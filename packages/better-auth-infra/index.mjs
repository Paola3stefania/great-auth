import { a as INFRA_KV_URL, i as INFRA_API_URL, n as createEmailSender, r as sendEmail, t as EMAIL_TEMPLATES } from "./email-BCLwDnnT.mjs";
import { createRequire } from "node:module";
import { APIError, generateId, logger, parseState } from "better-auth";
import { betterFetch, createFetch } from "@better-fetch/fetch";
import { APIError as APIError$1, createAuthEndpoint, createAuthMiddleware, requestPasswordReset, sendVerificationEmailFn, sessionMiddleware } from "better-auth/api";
import { createLocalJWKSet, jwtVerify } from "jose";
import { setSessionCookie } from "better-auth/cookies";
import crypto$1 from "crypto";
import "better-auth/crypto";
import "@better-auth/utils/base64";
import "better-auth/oauth2";
import "better-call";
import "@better-auth/utils/hash";
import "better-auth/types";
import { isValidPhoneNumber, parsePhoneNumberFromString } from "libphonenumber-js";

export * from "better-call"

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esmMin = (fn$1, res) => () => (fn$1 && (res = fn$1(fn$1 = 0)), res);
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __exportAll = (all$1, symbols) => {
	let target = {};
	for (var name$1 in all$1) {
		__defProp(target, name$1, {
			get: all$1[name$1],
			enumerable: true
		});
	}
	if (symbols) {
		__defProp(target, Symbol.toStringTag, { value: "Module" });
	}
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __toCommonJS = (mod) => __hasOwnProp.call(mod, "module.exports") ? mod["module.exports"] : __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region src/events/constants.ts
const EVENT_TYPES = {
	USER_CREATED: "user_created",
	USER_SIGNED_IN: "user_signed_in",
	USER_SIGNED_OUT: "user_signed_out",
	USER_SIGN_IN_FAILED: "user_sign_in_failed",
	PASSWORD_RESET_REQUESTED: "password_reset_requested",
	PASSWORD_RESET_COMPLETED: "password_reset_completed",
	PASSWORD_CHANGED: "password_changed",
	EMAIL_VERIFICATION_SENT: "email_verification_sent",
	EMAIL_VERIFIED: "email_verified",
	EMAIL_CHANGED: "email_changed",
	PROFILE_UPDATED: "profile_updated",
	PROFILE_IMAGE_UPDATED: "profile_image_updated",
	SESSION_CREATED: "session_created",
	SESSION_REVOKED: "session_revoked",
	ALL_SESSIONS_REVOKED: "all_sessions_revoked",
	TWO_FACTOR_ENABLED: "two_factor_enabled",
	TWO_FACTOR_DISABLED: "two_factor_disabled",
	TWO_FACTOR_VERIFIED: "two_factor_verified",
	ACCOUNT_LINKED: "account_linked",
	ACCOUNT_UNLINKED: "account_unlinked",
	USER_BANNED: "user_banned",
	USER_UNBANNED: "user_unbanned",
	USER_DELETED: "user_deleted",
	USER_IMPERSONATED: "user_impersonated",
	USER_IMPERSONATED_STOPPED: "user_impersonated_stopped"
};
const UNKNOWN_USER = "unknown";
const UNKNOWN_LOGIN = "unknown";
const routes = {
	SEND_VERIFICATION_EMAIL: "/send-verification-email",
	SIGN_IN: "/sign-in",
	SIGN_IN_EMAIL: "/sign-in/email",
	SIGN_IN_USERNAME: "/sign-in/username",
	SIGN_IN_EMAIL_OTP: "/sign-in/email-otp",
	SIGN_IN_SOCIAL: "/sign-in/social",
	SIGN_IN_ANONYMOUS: "/sign-in/anonymous",
	SIGN_IN_SOCIAL_CALLBACK: "/callback/:id",
	SIGN_IN_OAUTH_CALLBACK: "/oauth2/callback/:id",
	SIGN_OUT: "/sign-out",
	SIGN_UP: "/sign-up",
	SIGN_UP_EMAIL: "/sign-up/email",
	UPDATE_USER: "/update-user",
	CHANGE_EMAIL: "/change-email",
	VERIFY_EMAIL: "/verify-email",
	CHANGE_PASSWORD: "/change-password",
	SET_PASSWORD: "/set-password",
	RESET_PASSWORD: "/reset-password",
	REQUEST_PASSWORD_RESET: "/request-password-reset",
	REVOKE_ALL_SESSIONS: "/revoke-sessions",
	FORGET_PASSWORD: "/forget-password",
	SIGN_IN_PASSKEY: "/sign-in/passkey",
	PASSKEY_ADD: "/passkey/add-passkey",
	SIGN_IN_MAGIC_LINK: "/sign-in/magic-link",
	MAGIC_LINK_VERIFY: "/magic-link/verify",
	SIGN_IN_SSO: "/sign-in/sso",
	TWO_FACTOR_VERIFY_TOTP: "/two-factor/verify-totp",
	TWO_FACTOR_VERIFY_BACKUP: "/two-factor/verify-backup-code",
	TWO_FACTOR_VERIFY_OTP: "/two-factor/verify-otp",
	EMAIL_OTP_SEND: "/email-otp/send-verification-otp",
	PHONE_SEND_OTP: "/phone-number/send-otp",
	PHONE_VERIFY_OTP: "/phone-number/verify-phone-number",
	ORG_CREATE: "/organization/create",
	ORG_INVITE_MEMBER: "/organization/invite-member",
	API_KEY_CREATE: "/api-key/create",
	LINK_SOCIAL: "/link-social",
	DASH_ROUTE: "/dash",
	DASH_UPDATE_USER: "/dash/update-user",
	DASH_REVOKE_SESSIONS_ALL: "/dash/sessions/revoke-all",
	DASH_DELETE_SESSIONS: "/dash/delete-sessions",
	DASH_BAN_USER: "/dash/ban-user",
	DASH_UNBAN_USER: "/dash/unban-user",
	ADMIN_ROUTE: "/admin",
	ADMIN_REVOKE_USER_SESSIONS: "/admin/revoke-user-sessions",
	ADMIN_SET_PASSWORD: "/admin/set-user-password",
	ADMIN_BAN_USER: "/admin/ban-user",
	ADMIN_UNBAN_USER: "/admin/unban-user"
};
const ORGANIZATION_EVENT_TYPES = {
	ORGANIZATION_CREATED: "organization_created",
	ORGANIZATION_UPDATED: "organization_updated",
	ORGANIZATION_MEMBER_ADDED: "organization_member_added",
	ORGANIZATION_MEMBER_REMOVED: "organization_member_removed",
	ORGANIZATION_MEMBER_ROLE_UPDATED: "organization_member_role_updated",
	ORGANIZATION_MEMBER_INVITED: "organization_member_invited",
	ORGANIZATION_MEMBER_INVITE_CANCELED: "organization_member_invite_canceled",
	ORGANIZATION_MEMBER_INVITE_ACCEPTED: "organization_member_invite_accepted",
	ORGANIZATION_MEMBER_INVITE_REJECTED: "organization_member_invite_rejected",
	ORGANIZATION_TEAM_CREATED: "organization_team_created",
	ORGANIZATION_TEAM_UPDATED: "organization_team_updated",
	ORGANIZATION_TEAM_DELETED: "organization_team_deleted",
	ORGANIZATION_TEAM_MEMBER_ADDED: "organization_team_member_added",
	ORGANIZATION_TEAM_MEMBER_REMOVED: "organization_team_member_removed"
};

//#endregion
//#region src/events/core/events-user.ts
const initUserEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackUserSignedUp = (user, trigger, location) => {
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.USER_CREATED,
			eventDisplayName: `${user.name || user.email} signed up`,
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	const trackUserDeleted = (user, trigger, location) => {
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.USER_DELETED,
			eventDisplayName: "User deleted",
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	const trackUserProfileUpdated = (user, trigger, ctx, location) => {
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.PROFILE_UPDATED,
			eventDisplayName: "Profile updated",
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				updatedFields: Object.keys(ctx?.body || {}),
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	const trackUserProfileImageUpdated = (user, trigger, location) => {
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.PROFILE_IMAGE_UPDATED,
			eventDisplayName: "Profile image updated",
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	const trackUserBanned = (user, trigger, location) => {
		const reasonSuffix = user.banReason ? `: ${user.banReason}` : "";
		const expiresSuffix = user.banExpires ? ` (until ${user.banExpires.toISOString()})` : "";
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.USER_BANNED,
			eventDisplayName: `User banned${reasonSuffix}${expiresSuffix}`,
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				banned: user.banned,
				banReason: user.banReason,
				banExpires: user.banExpires,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	const trackUserUnBanned = (user, trigger, location) => {
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.USER_UNBANNED,
			eventDisplayName: "User unbanned",
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				banned: user.banned,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	const trackUserEmailVerified = (user, trigger, location) => {
		trackEvent({
			eventKey: user.id,
			eventType: EVENT_TYPES.EMAIL_VERIFIED,
			eventDisplayName: "Email verified",
			eventData: {
				userId: user.id,
				userEmail: user.email,
				userName: user.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			},
			ipAddress: location?.ipAddress,
			city: location?.city,
			country: location?.country,
			countryCode: location?.countryCode
		});
	};
	return {
		trackUserSignedUp,
		trackUserDeleted,
		trackUserProfileUpdated,
		trackUserProfileImageUpdated,
		trackUserBanned,
		trackUserUnBanned,
		trackUserEmailVerified
	};
};

//#endregion
//#region src/routes-matcher.ts
const stripQuery = (value) => value.split("?")[0] || value;
const escapeRegex$1 = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
const routeToRegex = (route) => {
	const pattern = escapeRegex$1(stripQuery(route)).replace(/\\\/:([^/]+)/g, "/[^/]+");
	return /* @__PURE__ */ new RegExp(`${pattern}(?:$|[/?])`);
};
const matchesAnyRoute = (path, routes$1) => {
	const cleanPath = stripQuery(path);
	return routes$1.some((route) => routeToRegex(route).test(cleanPath));
};

//#endregion
//#region src/events/login-methods.ts
const loginPaths = [
	routes.SIGN_IN_SOCIAL_CALLBACK,
	routes.SIGN_IN_OAUTH_CALLBACK,
	routes.SIGN_IN_EMAIL,
	routes.SIGN_IN_SOCIAL,
	routes.SIGN_IN_EMAIL_OTP,
	routes.SIGN_UP_EMAIL
];
const getLoginMethod = (ctx) => {
	if (matchesAnyRoute(ctx.path, loginPaths)) return ctx.params?.id ? ctx.params.id : ctx.path.split("/").pop();
	return null;
};

//#endregion
//#region src/events/utils.ts
function backgroundTask(task) {
	let result;
	try {
		result = task();
	} catch (error$47) {
		logger.debug("Error performing background operation: ", error$47);
		return;
	}
	Promise.resolve(result).catch((error$47) => {
		logger.debug("Error performing background operation: ", error$47);
	});
}

//#endregion
//#region src/events/core/adapter.ts
const getUserByEmail = async (email$2, ctx) => {
	let user;
	try {
		user = await ctx.context.adapter.findOne({
			model: "user",
			select: [
				"id",
				"name",
				"email"
			],
			where: [{
				field: "email",
				value: email$2
			}]
		});
	} catch (error$47) {
		logger.debug("Error fetching user info: ", error$47);
	}
	return user;
};
async function getUserById(userId, ctx) {
	let user;
	try {
		user = await ctx.context.adapter.findOne({
			model: "user",
			select: [
				"id",
				"name",
				"email"
			],
			where: [{
				field: "id",
				value: userId
			}]
		});
	} catch {}
	return user;
}
const getUserByIdToken = async (providerId, idToken, ctx) => {
	const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
	let user;
	if (provider) try {
		user = await provider.getUserInfo(idToken);
	} catch (error$47) {
		logger.debug("Error fetching user info: ", error$47);
	}
	return user;
};
const getUserByAuthorizationCode = async (providerId, ctx) => {
	let userInfo;
	const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
	if (provider) try {
		const codeVerifier = (await parseState(ctx)).codeVerifier;
		const { code, device_id } = ctx.query ?? {};
		const tokens = await provider.validateAuthorizationCode({
			code,
			codeVerifier,
			deviceId: device_id,
			redirectURI: `${ctx.context.baseURL}/callback/${provider.id}`
		});
		userInfo = await provider.getUserInfo({ ...tokens }).then((res) => res?.user);
	} catch (error$47) {
		logger.debug("Error fetching user info: ", error$47);
	}
	return userInfo;
};

//#endregion
//#region src/events/core/events-session.ts
const initSessionEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackUserSignedIn = (session, trigger, ctx, location) => {
		const track = async () => {
			const loginMethod = session.loginMethod ?? UNKNOWN_LOGIN;
			const user = await getUserById(session.userId, ctx);
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.USER_SIGNED_IN,
				eventDisplayName: `Signed in via ${loginMethod}`,
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					sessionId: session.id,
					loginMethod,
					userAgent: session.userAgent,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackUserSignedOut = (session, trigger, ctx, location) => {
		const track = async () => {
			const loginMethod = session.loginMethod ?? UNKNOWN_LOGIN;
			const user = await getUserById(session.userId, ctx);
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.USER_SIGNED_OUT,
				eventDisplayName: "User signed out",
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					sessionId: session.id,
					loginMethod,
					userAgent: session.userAgent,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackSessionRevoked = (session, trigger, ctx, location) => {
		const track = async () => {
			const loginMethod = session.loginMethod ?? UNKNOWN_LOGIN;
			const user = await getUserById(session.userId, ctx);
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.SESSION_REVOKED,
				eventDisplayName: "Session revoked",
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					sessionId: session.id,
					loginMethod,
					userAgent: session.userAgent,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackSessionRevokedAll = (session, trigger, ctx, location) => {
		const track = async () => {
			const user = await getUserById(session.userId, ctx);
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.ALL_SESSIONS_REVOKED,
				eventDisplayName: "All sessions revoked",
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				}
			});
		};
		backgroundTask(track);
	};
	const trackUserImpersonated = (session, trigger, ctx, location) => {
		const track = async () => {
			const loginMethod = session.loginMethod ?? UNKNOWN_LOGIN;
			const user = await getUserById(session.userId, ctx);
			const impersonator = session.impersonatedBy ? await getUserById(session.impersonatedBy, ctx) : null;
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.USER_IMPERSONATED,
				eventDisplayName: "User impersonated",
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					sessionId: session.id,
					loginMethod,
					userAgent: session.userAgent,
					impersonatedBy: impersonator?.name ?? impersonator?.email ?? session.impersonatedBy,
					impersonatedById: session.impersonatedBy,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackUserImpersonationStop = (session, trigger, ctx, location) => {
		const track = async () => {
			const loginMethod = session.loginMethod ?? UNKNOWN_LOGIN;
			const user = await getUserById(session.userId, ctx);
			const impersonator = session.impersonatedBy ? await getUserById(session.impersonatedBy, ctx) : null;
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.USER_IMPERSONATED_STOPPED,
				eventDisplayName: "User impersonation stopped",
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					sessionId: session.id,
					loginMethod,
					userAgent: session.userAgent,
					impersonatedBy: impersonator?.name ?? impersonator?.email ?? session.impersonatedBy,
					impersonatedById: session.impersonatedBy,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackSessionCreated = (session, trigger, ctx, location) => {
		const track = async () => {
			const loginMethod = session.loginMethod ?? UNKNOWN_LOGIN;
			const user = await getUserById(session.userId, ctx);
			trackEvent({
				eventKey: session.userId,
				eventType: EVENT_TYPES.SESSION_CREATED,
				eventDisplayName: "Session created",
				eventData: {
					userId: session.userId,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					sessionId: session.id,
					loginMethod,
					userAgent: session.userAgent,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackEmailVerificationSent = (session, user, trigger, ctx) => {
		trackEvent({
			eventKey: session.userId,
			eventType: EVENT_TYPES.EMAIL_VERIFICATION_SENT,
			eventDisplayName: "Verification email sent",
			eventData: {
				userId: session.userId,
				userName: user.name,
				userEmail: user.email,
				sessionId: session.id,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackEmailSignInAttempt = (ctx, trigger) => {
		const track = async () => {
			const user = await getUserByEmail(ctx.body.email, ctx);
			trackEvent({
				eventKey: user?.id ?? UNKNOWN_USER,
				eventType: EVENT_TYPES.USER_SIGN_IN_FAILED,
				eventDisplayName: "User sign-in attempt failed",
				eventData: {
					userId: user?.id ?? UNKNOWN_USER,
					nameName: user?.name ?? UNKNOWN_USER,
					userEmail: ctx.body.email,
					loginMethod: getLoginMethod(ctx),
					triggeredBy: user?.id ?? trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				}
			});
		};
		backgroundTask(track);
	};
	const trackSocialSignInAttempt = (ctx, trigger) => {
		const track = async () => {
			const user = await getUserByIdToken(ctx.body.provider, ctx.body.idToken, ctx);
			trackEvent({
				eventKey: user?.user.id.toString() ?? UNKNOWN_USER,
				eventType: EVENT_TYPES.USER_SIGN_IN_FAILED,
				eventDisplayName: "User sign-in attempt failed",
				eventData: {
					userId: user?.user.id.toString() ?? UNKNOWN_USER,
					userName: user?.user.name ?? UNKNOWN_USER,
					userEmail: user?.user.email ?? UNKNOWN_USER,
					loginMethod: getLoginMethod(ctx),
					triggeredBy: user?.user.id ?? trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				}
			});
		};
		backgroundTask(track);
	};
	const trackSocialSignInRedirectionAttempt = (ctx, trigger) => {
		const track = async () => {
			const user = await getUserByAuthorizationCode(ctx.body.provider, ctx);
			trackEvent({
				eventKey: user?.id.toString() ?? UNKNOWN_USER,
				eventType: EVENT_TYPES.USER_SIGN_IN_FAILED,
				eventDisplayName: "User sign-in attempt failed",
				eventData: {
					userId: user?.id.toString() ?? UNKNOWN_USER,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.id ?? UNKNOWN_USER,
					loginMethod: getLoginMethod(ctx),
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				}
			});
		};
		backgroundTask(track);
	};
	return {
		trackUserSignedIn,
		trackUserSignedOut,
		trackSessionCreated,
		trackSessionRevoked,
		trackSessionRevokedAll,
		trackUserImpersonated,
		trackUserImpersonationStop,
		trackEmailVerificationSent,
		trackEmailSignInAttempt,
		trackSocialSignInAttempt,
		trackSocialSignInRedirectionAttempt
	};
};

//#endregion
//#region src/events/core/events-account.ts
const initAccountEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackAccountLinking = (account, trigger, ctx, location) => {
		const track = async () => {
			const user = await getUserById(account.userId, ctx);
			trackEvent({
				eventKey: account.userId,
				eventType: EVENT_TYPES.ACCOUNT_LINKED,
				eventDisplayName: `Linked ${account.providerId} account`,
				eventData: {
					userId: account.userId,
					userEmail: user?.email ?? UNKNOWN_USER,
					userName: user?.name ?? UNKNOWN_USER,
					accountId: account.id,
					providerId: account.providerId,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackAccountUnlink = (account, trigger, ctx, location) => {
		const track = async () => {
			const user = await getUserById(account.userId, ctx);
			trackEvent({
				eventKey: account.userId,
				eventType: EVENT_TYPES.ACCOUNT_UNLINKED,
				eventDisplayName: `Unlinked ${account.providerId} account`,
				eventData: {
					userId: account.userId,
					userEmail: user?.email ?? UNKNOWN_USER,
					userName: user?.name ?? UNKNOWN_USER,
					accountId: account.id,
					providerId: account.providerId,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackAccountPasswordChange = (account, trigger, ctx, location) => {
		const track = async () => {
			const user = await getUserById(account.userId, ctx);
			trackEvent({
				eventKey: account.userId,
				eventType: EVENT_TYPES.PASSWORD_CHANGED,
				eventDisplayName: "Password changed",
				eventData: {
					userId: account.userId,
					userEmail: user?.email ?? UNKNOWN_USER,
					userName: user?.name ?? UNKNOWN_USER,
					accountId: account.id,
					providerId: account.providerId,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	return {
		trackAccountLinking,
		trackAccountUnlink,
		trackAccountPasswordChange
	};
};

//#endregion
//#region src/events/core/events-verification.ts
const initVerificationEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackPasswordResetRequest = (verification, trigger, ctx, location) => {
		const track = async () => {
			const user = await getUserById(verification.value, ctx);
			trackEvent({
				eventKey: verification.value,
				eventType: EVENT_TYPES.PASSWORD_RESET_REQUESTED,
				eventDisplayName: "Password reset requested",
				eventData: {
					userId: verification.value,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	const trackPasswordResetRequestCompletion = (verification, trigger, ctx, location) => {
		const track = async () => {
			const user = await getUserById(verification.value, ctx);
			trackEvent({
				eventKey: verification.value,
				eventType: EVENT_TYPES.PASSWORD_RESET_COMPLETED,
				eventDisplayName: "Password reset completed",
				eventData: {
					userId: verification.value,
					userName: user?.name ?? UNKNOWN_USER,
					userEmail: user?.email ?? UNKNOWN_USER,
					triggeredBy: trigger.triggeredBy,
					triggerContext: trigger.triggerContext
				},
				ipAddress: location?.ipAddress,
				city: location?.city,
				country: location?.country,
				countryCode: location?.countryCode
			});
		};
		backgroundTask(track);
	};
	return {
		trackPasswordResetRequest,
		trackPasswordResetRequestCompletion
	};
};

//#endregion
//#region src/events/triggers.ts
const getTriggerInfo = (ctx, userId, session) => {
	const sessionUserId = session?.userId ?? ctx.context.session?.session.userId ?? UNKNOWN_USER;
	return {
		triggeredBy: sessionUserId,
		triggerContext: sessionUserId === userId ? "user" : matchesAnyRoute(ctx.path, [routes.ADMIN_ROUTE]) ? "admin" : matchesAnyRoute(ctx.path, [routes.DASH_ROUTE]) ? "dashboard" : sessionUserId === UNKNOWN_USER ? "user" : "unknown"
	};
};
/**
* Get trigger info for organization hooks
* Since organization hooks don't have direct access to the auth context,
* we use the user parameter when available
*/
const getOrganizationTriggerInfo = (user) => {
	return {
		triggeredBy: user?.id ?? UNKNOWN_USER,
		triggerContext: "organization"
	};
};

//#endregion
//#region src/events/index.ts
const initTrackEvents = (options) => {
	const $fetch = createFetch({
		baseURL: options.apiUrl,
		headers: { "x-api-key": options.apiKey }
	});
	const trackEvent = (data) => {
		const track = async () => {
			try {
				await $fetch("/events/track", {
					method: "POST",
					body: {
						eventType: data.eventType,
						eventData: data.eventData,
						eventKey: data.eventKey,
						eventDisplayName: data.eventDisplayName || data.eventType,
						ipAddress: data.ipAddress ?? void 0,
						city: data.city ?? void 0,
						country: data.country ?? void 0,
						countryCode: data.countryCode ?? void 0
					}
				});
			} catch (e) {
				logger.debug("[Dash] Failed to track event:", e);
			}
		};
		track();
	};
	return { tracker: { trackEvent } };
};

//#endregion
//#region src/events/organization/events-organization.ts
const initOrganizationEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackOrganizationCreated = (organization, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_CREATED,
			eventDisplayName: "Organization Created",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationUpdated = (organization, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_UPDATED,
			eventDisplayName: "Organization Updated",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	return {
		trackOrganizationCreated,
		trackOrganizationUpdated
	};
};

//#endregion
//#region src/events/organization/events-invitation.ts
const initInvitationEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackOrganizationMemberInvited = (organization, invitation, inviter, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_INVITED,
			eventDisplayName: "User invited to organization",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				inviteeId: invitation.id,
				inviteeEmail: invitation.email,
				inviteeRole: invitation.role,
				inviteeTeamId: invitation.teamId,
				inviterId: inviter.id,
				inviterName: inviter.name,
				inviterEmail: inviter.email,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationMemberInviteAccepted = (organization, invitation, member, acceptedBy, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_INVITE_ACCEPTED,
			eventDisplayName: "User accepted invite organization invite",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				inviteeId: invitation.id,
				inviteeEmail: invitation.email,
				inviteeRole: invitation.role,
				inviteeTeamId: invitation.teamId,
				acceptedById: acceptedBy.id,
				acceptedByEmail: acceptedBy.email,
				acceptedByName: acceptedBy.name,
				memberId: member.id,
				memberRole: member.role,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationMemberInviteRejected = (organization, invitation, rejectedBy, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_INVITE_REJECTED,
			eventDisplayName: "User rejected organization invite",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				inviteeId: invitation.id,
				inviteeEmail: invitation.email,
				inviteeRole: invitation.role,
				inviteeTeamId: invitation.teamId,
				rejectedById: rejectedBy.id,
				rejectedByEmail: rejectedBy.email,
				rejectedByName: rejectedBy.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationMemberInviteCanceled = (organization, invitation, cancelledBy, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_INVITE_CANCELED,
			eventDisplayName: "Organization invite cancelled",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				inviteeId: invitation.id,
				inviteeEmail: invitation.email,
				inviteeRole: invitation.role,
				inviteeTeamId: invitation.teamId,
				cancelledById: cancelledBy.id,
				cancelledByName: cancelledBy.name,
				cancelledByEmail: cancelledBy.email,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	return {
		trackOrganizationMemberInvited,
		trackOrganizationMemberInviteAccepted,
		trackOrganizationMemberInviteCanceled,
		trackOrganizationMemberInviteRejected
	};
};

//#endregion
//#region src/events/organization/events-member.ts
const initMemberEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackOrganizationMemberAdded = (organization, member, user, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_ADDED,
			eventDisplayName: "Member added to organization",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				userId: member.userId,
				memberName: user.name,
				role: member.role,
				memberId: member.id,
				memberEmail: user.email,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationMemberRemoved = (organization, member, user, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_REMOVED,
			eventDisplayName: "Member removed from organization",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				userId: member.userId,
				memberName: user.name,
				role: member.role,
				memberId: member.id,
				memberEmail: user.email,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationMemberRoleUpdated = (organization, member, user, previousRole, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_MEMBER_ROLE_UPDATED,
			eventDisplayName: "Organization member role updated",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				userId: member.userId,
				memberName: user.name,
				newRole: member.role,
				oldRole: previousRole,
				memberId: member.id,
				memberEmail: user.email,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	return {
		trackOrganizationMemberAdded,
		trackOrganizationMemberRemoved,
		trackOrganizationMemberRoleUpdated
	};
};

//#endregion
//#region src/events/organization/events-team.ts
const initTeamEvents = (tracker) => {
	const { trackEvent } = tracker;
	const trackOrganizationTeamCreated = (organization, team, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_TEAM_CREATED,
			eventDisplayName: "Organization team created",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				teamId: team.id,
				teamName: team.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationTeamUpdated = (organization, team, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_TEAM_UPDATED,
			eventDisplayName: "Organization team updated",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				teamId: team.id,
				teamName: team.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationTeamDeleted = (organization, team, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_TEAM_DELETED,
			eventDisplayName: "Organization team deleted",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				teamId: team.id,
				teamName: team.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationTeamMemberAdded = (organization, team, user, teamMember, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_TEAM_MEMBER_ADDED,
			eventDisplayName: "User added to organization team",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				teamId: teamMember.teamId,
				teamName: team.name,
				userid: teamMember.userId,
				memberName: user.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	const trackOrganizationTeamMemberRemoved = (organization, team, user, teamMember, trigger) => {
		trackEvent({
			eventKey: organization.id,
			eventType: ORGANIZATION_EVENT_TYPES.ORGANIZATION_TEAM_MEMBER_REMOVED,
			eventDisplayName: "User removed from organization team",
			eventData: {
				organizationId: organization.id,
				organizationSlug: organization.slug,
				organizationName: organization.name,
				teamId: teamMember.teamId,
				teamName: team.name,
				userid: teamMember.userId,
				memberName: user.name,
				triggeredBy: trigger.triggeredBy,
				triggerContext: trigger.triggerContext
			}
		});
	};
	return {
		trackOrganizationTeamCreated,
		trackOrganizationTeamUpdated,
		trackOrganizationTeamDeleted,
		trackOrganizationTeamMemberAdded,
		trackOrganizationTeamMemberRemoved
	};
};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/core.js
/** A special constant with type `never` */
const NEVER = Object.freeze({ status: "aborted" });
function $constructor(name$1, initializer$2, params) {
	function init(inst, def) {
		if (!inst._zod) Object.defineProperty(inst, "_zod", {
			value: {
				def,
				constr: _,
				traits: /* @__PURE__ */ new Set()
			},
			enumerable: false
		});
		if (inst._zod.traits.has(name$1)) return;
		inst._zod.traits.add(name$1);
		initializer$2(inst, def);
		const proto = _.prototype;
		const keys = Object.keys(proto);
		for (let i = 0; i < keys.length; i++) {
			const k = keys[i];
			if (!(k in inst)) inst[k] = proto[k].bind(inst);
		}
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name$1 });
	function _(def) {
		var _a$1;
		const inst = params?.Parent ? new Definition() : this;
		init(inst, def);
		(_a$1 = inst._zod).deferred ?? (_a$1.deferred = []);
		for (const fn$1 of inst._zod.deferred) fn$1();
		return inst;
	}
	Object.defineProperty(_, "init", { value: init });
	Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name$1);
	} });
	Object.defineProperty(_, "name", { value: name$1 });
	return _;
}
const $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
var $ZodEncodeError = class extends Error {
	constructor(name$1) {
		super(`Encountered unidirectional transform during encode: ${name$1}`);
		this.name = "ZodEncodeError";
	}
};
const globalConfig = {};
function config(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/util.js
var util_exports = /* @__PURE__ */ __exportAll({
	BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
	Class: () => Class,
	NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
	aborted: () => aborted,
	allowsEval: () => allowsEval,
	assert: () => assert$2,
	assertEqual: () => assertEqual,
	assertIs: () => assertIs,
	assertNever: () => assertNever,
	assertNotEqual: () => assertNotEqual,
	assignProp: () => assignProp,
	base64ToUint8Array: () => base64ToUint8Array,
	base64urlToUint8Array: () => base64urlToUint8Array,
	cached: () => cached,
	captureStackTrace: () => captureStackTrace,
	cleanEnum: () => cleanEnum,
	cleanRegex: () => cleanRegex,
	clone: () => clone,
	cloneDef: () => cloneDef,
	createTransparentProxy: () => createTransparentProxy,
	defineLazy: () => defineLazy,
	esc: () => esc,
	escapeRegex: () => escapeRegex,
	extend: () => extend,
	finalizeIssue: () => finalizeIssue,
	floatSafeRemainder: () => floatSafeRemainder,
	getElementAtPath: () => getElementAtPath,
	getEnumValues: () => getEnumValues,
	getLengthableOrigin: () => getLengthableOrigin,
	getParsedType: () => getParsedType,
	getSizableOrigin: () => getSizableOrigin,
	hexToUint8Array: () => hexToUint8Array,
	isObject: () => isObject,
	isPlainObject: () => isPlainObject,
	issue: () => issue,
	joinValues: () => joinValues,
	jsonStringifyReplacer: () => jsonStringifyReplacer,
	merge: () => merge,
	mergeDefs: () => mergeDefs,
	normalizeParams: () => normalizeParams,
	nullish: () => nullish$1,
	numKeys: () => numKeys,
	objectClone: () => objectClone,
	omit: () => omit,
	optionalKeys: () => optionalKeys,
	parsedType: () => parsedType,
	partial: () => partial,
	pick: () => pick,
	prefixIssues: () => prefixIssues,
	primitiveTypes: () => primitiveTypes,
	promiseAllObject: () => promiseAllObject,
	propertyKeyTypes: () => propertyKeyTypes,
	randomString: () => randomString,
	required: () => required,
	safeExtend: () => safeExtend,
	shallowClone: () => shallowClone,
	slugify: () => slugify,
	stringifyPrimitive: () => stringifyPrimitive,
	uint8ArrayToBase64: () => uint8ArrayToBase64,
	uint8ArrayToBase64url: () => uint8ArrayToBase64url,
	uint8ArrayToHex: () => uint8ArrayToHex,
	unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
	return val;
}
function assertNotEqual(val) {
	return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
	throw new Error("Unexpected value in exhaustive check");
}
function assert$2(_) {}
function getEnumValues(entries) {
	const numericValues = Object.values(entries).filter((v) => typeof v === "number");
	return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function joinValues(array$1, separator = "|") {
	return array$1.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	return { get value() {
		{
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function nullish$1(input) {
	return input === null || input === void 0;
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepString = step.toString();
	let stepDecCount = (stepString.split(".")[1] || "").length;
	if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
		const match = stepString.match(/\d?e-(\d?)/);
		if (match?.[1]) stepDecCount = Number.parseInt(match[1]);
	}
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object$1, key, getter) {
	let value = void 0;
	Object.defineProperty(object$1, key, {
		get() {
			if (value === EVALUATING) return;
			if (value === void 0) {
				value = EVALUATING;
				value = getter();
			}
			return value;
		},
		set(v) {
			Object.defineProperty(object$1, key, { value: v });
		},
		configurable: true
	});
}
function objectClone(obj) {
	return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
	Object.defineProperty(target, prop, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function mergeDefs(...defs) {
	const mergedDescriptors = {};
	for (const def of defs) {
		const descriptors = Object.getOwnPropertyDescriptors(def);
		Object.assign(mergedDescriptors, descriptors);
	}
	return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
	return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
	if (!path) return obj;
	return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
	const keys = Object.keys(promisesObj);
	const promises = keys.map((key) => promisesObj[key]);
	return Promise.all(promises).then((results) => {
		const resolvedObj = {};
		for (let i = 0; i < keys.length; i++) resolvedObj[keys[i]] = results[i];
		return resolvedObj;
	});
}
function randomString(length = 10) {
	const chars = "abcdefghijklmnopqrstuvwxyz";
	let str = "";
	for (let i = 0; i < length; i++) str += chars[Math.floor(Math.random() * 26)];
	return str;
}
function esc(str) {
	return JSON.stringify(str);
}
function slugify(input) {
	return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
	return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
	try {
		new Function("");
		return true;
	} catch (_) {
		return false;
	}
});
function isPlainObject(o) {
	if (isObject(o) === false) return false;
	const ctor = o.constructor;
	if (ctor === void 0) return true;
	if (typeof ctor !== "function") return true;
	const prot = ctor.prototype;
	if (isObject(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
	return true;
}
function shallowClone(o) {
	if (isPlainObject(o)) return { ...o };
	if (Array.isArray(o)) return [...o];
	return o;
}
function numKeys(data) {
	let keyCount = 0;
	for (const key in data) if (Object.prototype.hasOwnProperty.call(data, key)) keyCount++;
	return keyCount;
}
const getParsedType = (data) => {
	const t = typeof data;
	switch (t) {
		case "undefined": return "undefined";
		case "string": return "string";
		case "number": return Number.isNaN(data) ? "nan" : "number";
		case "boolean": return "boolean";
		case "function": return "function";
		case "bigint": return "bigint";
		case "symbol": return "symbol";
		case "object":
			if (Array.isArray(data)) return "array";
			if (data === null) return "null";
			if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return "promise";
			if (typeof Map !== "undefined" && data instanceof Map) return "map";
			if (typeof Set !== "undefined" && data instanceof Set) return "set";
			if (typeof Date !== "undefined" && data instanceof Date) return "date";
			if (typeof File !== "undefined" && data instanceof File) return "file";
			return "object";
		default: throw new Error(`Unknown data type: ${t}`);
	}
};
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
const primitiveTypes = new Set([
	"string",
	"number",
	"bigint",
	"boolean",
	"symbol",
	"undefined"
]);
function escapeRegex(str) {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
	const cl = new inst._zod.constr(def ?? inst._zod.def);
	if (!def || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== void 0) {
		if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function createTransparentProxy(getter) {
	let target;
	return new Proxy({}, {
		get(_, prop, receiver) {
			target ?? (target = getter());
			return Reflect.get(target, prop, receiver);
		},
		set(_, prop, value, receiver) {
			target ?? (target = getter());
			return Reflect.set(target, prop, value, receiver);
		},
		has(_, prop) {
			target ?? (target = getter());
			return Reflect.has(target, prop);
		},
		deleteProperty(_, prop) {
			target ?? (target = getter());
			return Reflect.deleteProperty(target, prop);
		},
		ownKeys(_) {
			target ?? (target = getter());
			return Reflect.ownKeys(target);
		},
		getOwnPropertyDescriptor(_, prop) {
			target ?? (target = getter());
			return Reflect.getOwnPropertyDescriptor(target, prop);
		},
		defineProperty(_, prop, descriptor) {
			target ?? (target = getter());
			return Reflect.defineProperty(target, prop, descriptor);
		}
	});
}
function stringifyPrimitive(value) {
	if (typeof value === "bigint") return value.toString() + "n";
	if (typeof value === "string") return `"${value}"`;
	return `${value}`;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k) => {
		return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
const BIGINT_FORMAT_RANGES = {
	int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
	uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	if (checks && checks.length > 0) throw new Error(".pick() cannot be used on object schemas containing refinements");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = {};
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				newShape[key] = currDef.shape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function omit(schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	if (checks && checks.length > 0) throw new Error(".omit() cannot be used on object schemas containing refinements");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = { ...schema._zod.def.shape };
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				delete newShape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function extend(schema, shape) {
	if (!isPlainObject(shape)) throw new Error("Invalid input to extend: expected a plain object");
	const checks = schema._zod.def.checks;
	if (checks && checks.length > 0) {
		const existingShape = schema._zod.def.shape;
		for (const key in shape) if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
	}
	return clone(schema, mergeDefs(schema._zod.def, { get shape() {
		const _shape = {
			...schema._zod.def.shape,
			...shape
		};
		assignProp(this, "shape", _shape);
		return _shape;
	} }));
}
function safeExtend(schema, shape) {
	if (!isPlainObject(shape)) throw new Error("Invalid input to safeExtend: expected a plain object");
	return clone(schema, mergeDefs(schema._zod.def, { get shape() {
		const _shape = {
			...schema._zod.def.shape,
			...shape
		};
		assignProp(this, "shape", _shape);
		return _shape;
	} }));
}
function merge(a, b) {
	return clone(a, mergeDefs(a._zod.def, {
		get shape() {
			const _shape = {
				...a._zod.def.shape,
				...b._zod.def.shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		get catchall() {
			return b._zod.def.catchall;
		},
		checks: []
	}));
}
function partial(Class$1, schema, mask) {
	const checks = schema._zod.def.checks;
	if (checks && checks.length > 0) throw new Error(".partial() cannot be used on object schemas containing refinements");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) for (const key in mask) {
				if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				shape[key] = Class$1 ? new Class$1({
					type: "optional",
					innerType: oldShape[key]
				}) : oldShape[key];
			}
			else for (const key in oldShape) shape[key] = Class$1 ? new Class$1({
				type: "optional",
				innerType: oldShape[key]
			}) : oldShape[key];
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	}));
}
function required(Class$1, schema, mask) {
	return clone(schema, mergeDefs(schema._zod.def, { get shape() {
		const oldShape = schema._zod.def.shape;
		const shape = { ...oldShape };
		if (mask) for (const key in mask) {
			if (!(key in shape)) throw new Error(`Unrecognized key: "${key}"`);
			if (!mask[key]) continue;
			shape[key] = new Class$1({
				type: "nonoptional",
				innerType: oldShape[key]
			});
		}
		else for (const key in oldShape) shape[key] = new Class$1({
			type: "nonoptional",
			innerType: oldShape[key]
		});
		assignProp(this, "shape", shape);
		return shape;
	} }));
}
function aborted(x, startIndex = 0) {
	if (x.aborted === true) return true;
	for (let i = startIndex; i < x.issues.length; i++) if (x.issues[i]?.continue !== true) return true;
	return false;
}
function prefixIssues(path, issues) {
	return issues.map((iss) => {
		var _a$1;
		(_a$1 = iss).path ?? (_a$1.path = []);
		iss.path.unshift(path);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config$1) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? "Invalid input";
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) delete full.input;
	return full;
}
function getSizableOrigin(input) {
	if (input instanceof Set) return "set";
	if (input instanceof Map) return "map";
	if (input instanceof File) return "file";
	return "unknown";
}
function getLengthableOrigin(input) {
	if (Array.isArray(input)) return "array";
	if (typeof input === "string") return "string";
	return "unknown";
}
function parsedType(data) {
	const t = typeof data;
	switch (t) {
		case "number": return Number.isNaN(data) ? "nan" : "number";
		case "object": {
			if (data === null) return "null";
			if (Array.isArray(data)) return "array";
			const obj = data;
			if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) return obj.constructor.name;
		}
	}
	return t;
}
function issue(...args) {
	const [iss, input, inst] = args;
	if (typeof iss === "string") return {
		message: iss,
		code: "custom",
		input,
		inst
	};
	return { ...iss };
}
function cleanEnum(obj) {
	return Object.entries(obj).filter(([k, _]) => {
		return Number.isNaN(Number.parseInt(k, 10));
	}).map((el) => el[1]);
}
function base64ToUint8Array(base64$2) {
	const binaryString = atob(base64$2);
	const bytes = new Uint8Array(binaryString.length);
	for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
	return bytes;
}
function uint8ArrayToBase64(bytes) {
	let binaryString = "";
	for (let i = 0; i < bytes.length; i++) binaryString += String.fromCharCode(bytes[i]);
	return btoa(binaryString);
}
function base64urlToUint8Array(base64url$2) {
	const base64$2 = base64url$2.replace(/-/g, "+").replace(/_/g, "/");
	return base64ToUint8Array(base64$2 + "=".repeat((4 - base64$2.length % 4) % 4));
}
function uint8ArrayToBase64url(bytes) {
	return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex$2) {
	const cleanHex = hex$2.replace(/^0x/, "");
	if (cleanHex.length % 2 !== 0) throw new Error("Invalid hex string length");
	const bytes = new Uint8Array(cleanHex.length / 2);
	for (let i = 0; i < cleanHex.length; i += 2) bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
	return bytes;
}
function uint8ArrayToHex(bytes) {
	return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
	constructor(..._args) {}
};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/errors.js
const initializer$1 = (inst, def) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def,
		enumerable: false
	});
	inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error$47, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = {};
	const formErrors = [];
	for (const sub of error$47.issues) if (sub.path.length > 0) {
		fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
		fieldErrors[sub.path[0]].push(mapper(sub));
	} else formErrors.push(mapper(sub));
	return {
		formErrors,
		fieldErrors
	};
}
function formatError(error$47, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = { _errors: [] };
	const processError = (error$48) => {
		for (const issue$1 of error$48.issues) if (issue$1.code === "invalid_union" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }));
		else if (issue$1.code === "invalid_key") processError({ issues: issue$1.issues });
		else if (issue$1.code === "invalid_element") processError({ issues: issue$1.issues });
		else if (issue$1.path.length === 0) fieldErrors._errors.push(mapper(issue$1));
		else {
			let curr = fieldErrors;
			let i = 0;
			while (i < issue$1.path.length) {
				const el = issue$1.path[i];
				if (!(i === issue$1.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
				else {
					curr[el] = curr[el] || { _errors: [] };
					curr[el]._errors.push(mapper(issue$1));
				}
				curr = curr[el];
				i++;
			}
		}
	};
	processError(error$47);
	return fieldErrors;
}
function treeifyError(error$47, mapper = (issue$1) => issue$1.message) {
	const result = { errors: [] };
	const processError = (error$48, path = []) => {
		var _a$1, _b;
		for (const issue$1 of error$48.issues) if (issue$1.code === "invalid_union" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }, issue$1.path));
		else if (issue$1.code === "invalid_key") processError({ issues: issue$1.issues }, issue$1.path);
		else if (issue$1.code === "invalid_element") processError({ issues: issue$1.issues }, issue$1.path);
		else {
			const fullpath = [...path, ...issue$1.path];
			if (fullpath.length === 0) {
				result.errors.push(mapper(issue$1));
				continue;
			}
			let curr = result;
			let i = 0;
			while (i < fullpath.length) {
				const el = fullpath[i];
				const terminal = i === fullpath.length - 1;
				if (typeof el === "string") {
					curr.properties ?? (curr.properties = {});
					(_a$1 = curr.properties)[el] ?? (_a$1[el] = { errors: [] });
					curr = curr.properties[el];
				} else {
					curr.items ?? (curr.items = []);
					(_b = curr.items)[el] ?? (_b[el] = { errors: [] });
					curr = curr.items[el];
				}
				if (terminal) curr.errors.push(mapper(issue$1));
				i++;
			}
		}
	};
	processError(error$47);
	return result;
}
/** Format a ZodError as a human-readable string in the following form.
*
* From
*
* ```ts
* ZodError {
*   issues: [
*     {
*       expected: 'string',
*       code: 'invalid_type',
*       path: [ 'username' ],
*       message: 'Invalid input: expected string'
*     },
*     {
*       expected: 'number',
*       code: 'invalid_type',
*       path: [ 'favoriteNumbers', 1 ],
*       message: 'Invalid input: expected number'
*     }
*   ];
* }
* ```
*
* to
*
* ```
* username
*    Expected number, received string at "username
* favoriteNumbers[0]
*    Invalid input: expected number
* ```
*/
function toDotPath(_path) {
	const segs = [];
	const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
	for (const seg of path) if (typeof seg === "number") segs.push(`[${seg}]`);
	else if (typeof seg === "symbol") segs.push(`[${JSON.stringify(String(seg))}]`);
	else if (/[^\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);
	else {
		if (segs.length) segs.push(".");
		segs.push(seg);
	}
	return segs.join("");
}
function prettifyError(error$47) {
	const lines = [];
	const issues = [...error$47.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
	for (const issue$1 of issues) {
		lines.push(` ${issue$1.message}`);
		if (issue$1.path?.length) lines.push(`   at ${toDotPath(issue$1.path)}`);
	}
	return lines.join("\n");
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/parse.js
const _parse = (_Err) => (schema, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$2 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parse(_Err)(schema, value, ctx);
};
const encode$1 = /* @__PURE__ */ _encode($ZodRealError);
const _decode = (_Err) => (schema, value, _ctx) => {
	return _parse(_Err)(schema, value, _ctx);
};
const decode$1 = /* @__PURE__ */ _decode($ZodRealError);
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync$1 = /* @__PURE__ */ _encodeAsync($ZodRealError);
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync$1 = /* @__PURE__ */ _decodeAsync($ZodRealError);
const _safeEncode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode$1 = /* @__PURE__ */ _safeEncode($ZodRealError);
const _safeDecode = (_Err) => (schema, value, _ctx) => {
	return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode$1 = /* @__PURE__ */ _safeDecode($ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync$1 = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync$1 = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/regexes.js
var regexes_exports = /* @__PURE__ */ __exportAll({
	base64: () => base64$1,
	base64url: () => base64url$1,
	bigint: () => bigint$2,
	boolean: () => boolean$2,
	browserEmail: () => browserEmail,
	cidrv4: () => cidrv4$1,
	cidrv6: () => cidrv6$1,
	cuid: () => cuid$1,
	cuid2: () => cuid2$1,
	date: () => date$3,
	datetime: () => datetime$1,
	domain: () => domain,
	duration: () => duration$1,
	e164: () => e164$1,
	email: () => email$1,
	emoji: () => emoji$1,
	extendedDuration: () => extendedDuration,
	guid: () => guid$1,
	hex: () => hex$1,
	hostname: () => hostname$1,
	html5Email: () => html5Email,
	idnEmail: () => idnEmail,
	integer: () => integer,
	ipv4: () => ipv4$1,
	ipv6: () => ipv6$1,
	ksuid: () => ksuid$1,
	lowercase: () => lowercase,
	mac: () => mac$1,
	md5_base64: () => md5_base64,
	md5_base64url: () => md5_base64url,
	md5_hex: () => md5_hex,
	nanoid: () => nanoid$1,
	null: () => _null$2,
	number: () => number$2,
	rfc5322Email: () => rfc5322Email,
	sha1_base64: () => sha1_base64,
	sha1_base64url: () => sha1_base64url,
	sha1_hex: () => sha1_hex,
	sha256_base64: () => sha256_base64,
	sha256_base64url: () => sha256_base64url,
	sha256_hex: () => sha256_hex,
	sha384_base64: () => sha384_base64,
	sha384_base64url: () => sha384_base64url,
	sha384_hex: () => sha384_hex,
	sha512_base64: () => sha512_base64,
	sha512_base64url: () => sha512_base64url,
	sha512_hex: () => sha512_hex,
	string: () => string$2,
	time: () => time$1,
	ulid: () => ulid$1,
	undefined: () => _undefined$2,
	unicodeEmail: () => unicodeEmail,
	uppercase: () => uppercase,
	uuid: () => uuid$1,
	uuid4: () => uuid4,
	uuid6: () => uuid6,
	uuid7: () => uuid7,
	xid: () => xid$1
});
const cuid$1 = /^[cC][^\s-]{8,}$/;
const cuid2$1 = /^[0-9a-z]+$/;
const ulid$1 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid$1 = /^[0-9a-vA-V]{20}$/;
const ksuid$1 = /^[A-Za-z0-9]{27}$/;
const nanoid$1 = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */
const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid$1 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
*
* @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid$1 = (version$2) => {
	if (!version$2) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
	return /* @__PURE__ */ new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const uuid4 = /* @__PURE__ */ uuid$1(4);
const uuid6 = /* @__PURE__ */ uuid$1(6);
const uuid7 = /* @__PURE__ */ uuid$1(7);
/** Practical email validation */
const email$1 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */
const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/** The classic emailregex.com regex for RFC 5322-compliant emails */
const rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */
const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const idnEmail = unicodeEmail;
const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji$1() {
	return new RegExp(_emoji$1, "u");
}
const ipv4$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const mac$1 = (delimiter) => {
	const escapedDelim = escapeRegex(delimiter ?? ":");
	return /* @__PURE__ */ new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
const cidrv4$1 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url$1 = /^[A-Za-z0-9_-]*$/;
const hostname$1 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
const e164$1 = /^\+[1-9]\d{6,14}$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$3 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
	const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	return typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time$1(args) {
	return /* @__PURE__ */ new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
	const time$2 = timeSource({ precision: args.precision });
	const opts = ["Z"];
	if (args.local) opts.push("");
	if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
	const timeRegex = `${time$2}(?:${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$2 = (params) => {
	const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return /* @__PURE__ */ new RegExp(`^${regex}$`);
};
const bigint$2 = /^-?\d+n?$/;
const integer = /^-?\d+$/;
const number$2 = /^-?\d+(?:\.\d+)?$/;
const boolean$2 = /^(?:true|false)$/i;
const _null$2 = /^null$/i;
const _undefined$2 = /^undefined$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const hex$1 = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
	return /* @__PURE__ */ new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
	return /* @__PURE__ */ new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
const md5_hex = /^[0-9a-fA-F]{32}$/;
const md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
const md5_base64url = /* @__PURE__ */ fixedBase64url(22);
const sha1_hex = /^[0-9a-fA-F]{40}$/;
const sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
const sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
const sha256_hex = /^[0-9a-fA-F]{64}$/;
const sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
const sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
const sha384_hex = /^[0-9a-fA-F]{96}$/;
const sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
const sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
const sha512_hex = /^[0-9a-fA-F]{128}$/;
const sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
const sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/checks.js
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
	var _a$1;
	inst._zod ?? (inst._zod = {});
	inst._zod.def = def;
	(_a$1 = inst._zod).onattach ?? (_a$1.onattach = []);
});
const numericOriginMap = {
	number: "number",
	bigint: "bigint",
	object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
		if (def.value < curr) if (def.inclusive) bag.maximum = def.value;
		else bag.exclusiveMaximum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value <= def.value : payload.value < def.value) return;
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
		if (def.value > curr) if (def.inclusive) bag.minimum = def.value;
		else bag.exclusiveMinimum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value >= def.value : payload.value > def.value) return;
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		var _a$1;
		(_a$1 = inst$1._zod.bag).multipleOf ?? (_a$1.multipleOf = def.value);
	});
	inst._zod.check = (payload) => {
		if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
		if (typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0) return;
		payload.issues.push({
			origin: typeof payload.value,
			code: "not_multiple_of",
			divisor: def.value,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	def.format = def.format || "float64";
	const isInt = def.format?.includes("int");
	const origin = isInt ? "int" : "number";
	const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
		if (isInt) bag.pattern = integer;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (isInt) {
			if (!Number.isInteger(input)) {
				payload.issues.push({
					expected: origin,
					format: def.format,
					code: "invalid_type",
					continue: false,
					input,
					inst
				});
				return;
			}
			if (!Number.isSafeInteger(input)) {
				if (input > 0) payload.issues.push({
					input,
					code: "too_big",
					maximum: Number.MAX_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					inclusive: true,
					continue: !def.abort
				});
				else payload.issues.push({
					input,
					code: "too_small",
					minimum: Number.MIN_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					inclusive: true,
					continue: !def.abort
				});
				return;
			}
		}
		if (input < minimum) payload.issues.push({
			origin: "number",
			input,
			code: "too_small",
			minimum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
		if (input > maximum) payload.issues.push({
			origin: "number",
			input,
			code: "too_big",
			maximum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input < minimum) payload.issues.push({
			origin: "bigint",
			input,
			code: "too_small",
			minimum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
		if (input > maximum) payload.issues.push({
			origin: "bigint",
			input,
			code: "too_big",
			maximum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$1(val) && val.size !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.size <= def.maximum) return;
		payload.issues.push({
			origin: getSizableOrigin(input),
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$1(val) && val.size !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.size >= def.minimum) return;
		payload.issues.push({
			origin: getSizableOrigin(input),
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$1(val) && val.size !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def.size;
		bag.maximum = def.size;
		bag.size = def.size;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const size = input.size;
		if (size === def.size) return;
		const tooBig = size > def.size;
		payload.issues.push({
			origin: getSizableOrigin(input),
			...tooBig ? {
				code: "too_big",
				maximum: def.size
			} : {
				code: "too_small",
				minimum: def.size
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$1(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length <= def.maximum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$1(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length >= def.minimum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$1(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def.length;
		bag.maximum = def.length;
		bag.length = def.length;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length === def.length) return;
		const origin = getLengthableOrigin(input);
		const tooBig = length > def.length;
		payload.issues.push({
			origin,
			...tooBig ? {
				code: "too_big",
				maximum: def.length
			} : {
				code: "too_small",
				minimum: def.length
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
	var _a$1, _b;
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		if (def.pattern) {
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(def.pattern);
		}
	});
	if (def.pattern) (_a$1 = inst._zod).check ?? (_a$1.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			...def.pattern ? { pattern: def.pattern.toString() } : {},
			inst,
			continue: !def.abort
		});
	});
	else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "regex",
			input: payload.value,
			pattern: def.pattern.toString(),
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
	def.pattern ?? (def.pattern = lowercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
	def.pattern ?? (def.pattern = uppercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
	$ZodCheck.init(inst, def);
	const escapedRegex = escapeRegex(def.includes);
	const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
	def.pattern = pattern;
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.includes(def.includes, def.position)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "includes",
			includes: def.includes,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = /* @__PURE__ */ new RegExp(`^${escapeRegex(def.prefix)}.*`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.startsWith(def.prefix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "starts_with",
			prefix: def.prefix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = /* @__PURE__ */ new RegExp(`.*${escapeRegex(def.suffix)}$`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.endsWith(def.suffix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "ends_with",
			suffix: def.suffix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function handleCheckPropertyResult(result, payload, property) {
	if (result.issues.length) payload.issues.push(...prefixIssues(property, result.issues));
}
const $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		const result = def.schema._zod.run({
			value: payload.value[def.property],
			issues: []
		}, {});
		if (result instanceof Promise) return result.then((result$1) => handleCheckPropertyResult(result$1, payload, def.property));
		handleCheckPropertyResult(result, payload, def.property);
	};
});
const $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
	$ZodCheck.init(inst, def);
	const mimeSet = new Set(def.mime);
	inst._zod.onattach.push((inst$1) => {
		inst$1._zod.bag.mime = def.mime;
	});
	inst._zod.check = (payload) => {
		if (mimeSet.has(payload.value.type)) return;
		payload.issues.push({
			code: "invalid_value",
			values: def.mime,
			input: payload.value.type,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		payload.value = def.tx(payload.value);
	};
});

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/doc.js
var Doc = class {
	constructor(args = []) {
		this.content = [];
		this.indent = 0;
		if (this) this.args = args;
	}
	indented(fn$1) {
		this.indent += 1;
		fn$1(this);
		this.indent -= 1;
	}
	write(arg) {
		if (typeof arg === "function") {
			arg(this, { execution: "sync" });
			arg(this, { execution: "async" });
			return;
		}
		const lines = arg.split("\n").filter((x) => x);
		const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
		const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
		for (const line of dedented) this.content.push(line);
	}
	compile() {
		const F = Function;
		const args = this?.args;
		const lines = [...(this?.content ?? [``]).map((x) => `  ${x}`)];
		return new F(...args, lines.join("\n"));
	}
};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/versions.js
const version$1 = {
	major: 4,
	minor: 3,
	patch: 6
};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/schemas.js
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
	var _a$1;
	inst ?? (inst = {});
	inst._zod.def = def;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version$1;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
	for (const ch of checks) for (const fn$1 of ch._zod.onattach) fn$1(inst);
	if (checks.length === 0) {
		(_a$1 = inst._zod).deferred ?? (_a$1.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks$1, ctx) => {
			let isAborted = aborted(payload);
			let asyncResult;
			for (const ch of checks$1) {
				if (ch._zod.def.when) {
					if (!ch._zod.def.when(payload)) continue;
				} else if (isAborted) continue;
				const currLen = payload.issues.length;
				const _ = ch._zod.check(payload);
				if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
				if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
					await _;
					if (payload.issues.length === currLen) return;
					if (!isAborted) isAborted = aborted(payload, currLen);
				});
				else {
					if (payload.issues.length === currLen) continue;
					if (!isAborted) isAborted = aborted(payload, currLen);
				}
			}
			if (asyncResult) return asyncResult.then(() => {
				return payload;
			});
			return payload;
		};
		const handleCanaryResult = (canary, payload, ctx) => {
			if (aborted(canary)) {
				canary.aborted = true;
				return canary;
			}
			const checkResult = runChecks(payload, checks, ctx);
			if (checkResult instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return checkResult.then((checkResult$1) => inst._zod.parse(checkResult$1, ctx));
			}
			return inst._zod.parse(checkResult, ctx);
		};
		inst._zod.run = (payload, ctx) => {
			if (ctx.skipChecks) return inst._zod.parse(payload, ctx);
			if (ctx.direction === "backward") {
				const canary = inst._zod.parse({
					value: payload.value,
					issues: []
				}, {
					...ctx,
					skipChecks: true
				});
				if (canary instanceof Promise) return canary.then((canary$1) => {
					return handleCanaryResult(canary$1, payload, ctx);
				});
				return handleCanaryResult(canary, payload, ctx);
			}
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result$1) => runChecks(result$1, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	defineLazy(inst, "~standard", () => ({
		validate: (value) => {
			try {
				const r = safeParse$1(inst, value);
				return r.success ? { value: r.data } : { issues: r.error?.issues };
			} catch (_) {
				return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	}));
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$2(inst._zod.bag);
	inst._zod.parse = (payload, _) => {
		if (def.coerce) try {
			payload.value = String(payload.value);
		} catch (_$1) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	$ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
	def.pattern ?? (def.pattern = guid$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
	if (def.version) {
		const v = {
			v1: 1,
			v2: 2,
			v3: 3,
			v4: 4,
			v5: 5,
			v6: 6,
			v7: 7,
			v8: 8
		}[def.version];
		if (v === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
		def.pattern ?? (def.pattern = uuid$1(v));
	} else def.pattern ?? (def.pattern = uuid$1());
	$ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
	def.pattern ?? (def.pattern = email$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		try {
			const trimmed = payload.value.trim();
			const url$2 = new URL(trimmed);
			if (def.hostname) {
				def.hostname.lastIndex = 0;
				if (!def.hostname.test(url$2.hostname)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid hostname",
					pattern: def.hostname.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.protocol) {
				def.protocol.lastIndex = 0;
				if (!def.protocol.test(url$2.protocol.endsWith(":") ? url$2.protocol.slice(0, -1) : url$2.protocol)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid protocol",
					pattern: def.protocol.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.normalize) payload.value = url$2.href;
			else payload.value = trimmed;
			return;
		} catch (_) {
			payload.issues.push({
				code: "invalid_format",
				format: "url",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
	def.pattern ?? (def.pattern = emoji$1());
	$ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
	def.pattern ?? (def.pattern = nanoid$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
	def.pattern ?? (def.pattern = cuid$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
	def.pattern ?? (def.pattern = cuid2$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
	def.pattern ?? (def.pattern = ulid$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
	def.pattern ?? (def.pattern = xid$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
	def.pattern ?? (def.pattern = ksuid$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
	def.pattern ?? (def.pattern = datetime$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
	def.pattern ?? (def.pattern = date$3);
	$ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
	def.pattern ?? (def.pattern = time$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
	def.pattern ?? (def.pattern = duration$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
	def.pattern ?? (def.pattern = ipv4$1);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
	def.pattern ?? (def.pattern = ipv6$1);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv6`;
	inst._zod.check = (payload) => {
		try {
			new URL(`http://[${payload.value}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "ipv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
	def.pattern ?? (def.pattern = mac$1(def.delimiter));
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `mac`;
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv4$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv6$1);
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		const parts = payload.value.split("/");
		try {
			if (parts.length !== 2) throw new Error();
			const [address, prefix] = parts;
			if (!prefix) throw new Error();
			const prefixNum = Number(prefix);
			if (`${prefixNum}` !== prefix) throw new Error();
			if (prefixNum < 0 || prefixNum > 128) throw new Error();
			new URL(`http://[${address}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "cidrv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
function isValidBase64(data) {
	if (data === "") return true;
	if (data.length % 4 !== 0) return false;
	try {
		atob(data);
		return true;
	} catch {
		return false;
	}
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
	def.pattern ?? (def.pattern = base64$1);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64";
	inst._zod.check = (payload) => {
		if (isValidBase64(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function isValidBase64URL(data) {
	if (!base64url$1.test(data)) return false;
	const base64$2 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
	return isValidBase64(base64$2.padEnd(Math.ceil(base64$2.length / 4) * 4, "="));
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
	def.pattern ?? (def.pattern = base64url$1);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64url";
	inst._zod.check = (payload) => {
		if (isValidBase64URL(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64url",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
	def.pattern ?? (def.pattern = e164$1);
	$ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
	try {
		const tokensParts = token.split(".");
		if (tokensParts.length !== 3) return false;
		const [header] = tokensParts;
		if (!header) return false;
		const parsedHeader = JSON.parse(atob(header));
		if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
		if (!parsedHeader.alg) return false;
		if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
		return true;
	} catch {
		return false;
	}
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (isValidJWT(payload.value, def.alg)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "jwt",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (def.fn(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Number(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
	$ZodCheckNumberFormat.init(inst, def);
	$ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = boolean$2;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Boolean(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "boolean") return payload;
		payload.issues.push({
			expected: "boolean",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = bigint$2;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = BigInt(payload.value);
		} catch (_) {}
		if (typeof payload.value === "bigint") return payload;
		payload.issues.push({
			expected: "bigint",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
	$ZodCheckBigIntFormat.init(inst, def);
	$ZodBigInt.init(inst, def);
});
const $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "symbol") return payload;
		payload.issues.push({
			expected: "symbol",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = _undefined$2;
	inst._zod.values = new Set([void 0]);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "undefined") return payload;
		payload.issues.push({
			expected: "undefined",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = _null$2;
	inst._zod.values = new Set([null]);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (input === null) return payload;
		payload.issues.push({
			expected: "null",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		payload.issues.push({
			expected: "never",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "undefined") return payload;
		payload.issues.push({
			expected: "void",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = new Date(payload.value);
		} catch (_err) {}
		const input = payload.value;
		const isDate = input instanceof Date;
		if (isDate && !Number.isNaN(input.getTime())) return payload;
		payload.issues.push({
			expected: "date",
			code: "invalid_type",
			input,
			...isDate ? { received: "Invalid Date" } : {},
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index) {
	if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
	final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i = 0; i < input.length; i++) {
			const item = input[i];
			const result = def.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i)));
			else handleArrayResult(result, payload, i);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
	if (result.issues.length) {
		if (isOptionalOut && !(key in input)) return;
		final.issues.push(...prefixIssues(key, result.issues));
	}
	if (result.value === void 0) {
		if (key in input) final.value[key] = void 0;
	} else final.value[key] = result.value;
}
function normalizeDef(def) {
	const keys = Object.keys(def.shape);
	for (const k of keys) if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
	const okeys = optionalKeys(def.shape);
	return {
		...def,
		keys,
		keySet: new Set(keys),
		numKeys: keys.length,
		optionalKeys: new Set(okeys)
	};
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
	const unrecognized = [];
	const keySet = def.keySet;
	const _catchall = def.catchall._zod;
	const t = _catchall.def.type;
	const isOptionalOut = _catchall.optout === "optional";
	for (const key in input) {
		if (keySet.has(key)) continue;
		if (t === "never") {
			unrecognized.push(key);
			continue;
		}
		const r = _catchall.run({
			value: input[key],
			issues: []
		}, ctx);
		if (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input, isOptionalOut)));
		else handlePropertyResult(r, payload, key, input, isOptionalOut);
	}
	if (unrecognized.length) payload.issues.push({
		code: "unrecognized_keys",
		keys: unrecognized,
		input,
		inst
	});
	if (!proms.length) return payload;
	return Promise.all(proms).then(() => {
		return payload;
	});
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
	$ZodType.init(inst, def);
	if (!Object.getOwnPropertyDescriptor(def, "shape")?.get) {
		const sh = def.shape;
		Object.defineProperty(def, "shape", { get: () => {
			const newSh = { ...sh };
			Object.defineProperty(def, "shape", { value: newSh });
			return newSh;
		} });
	}
	const _normalized = cached(() => normalizeDef(def));
	defineLazy(inst._zod, "propValues", () => {
		const shape = def.shape;
		const propValues = {};
		for (const key in shape) {
			const field = shape[key]._zod;
			if (field.values) {
				propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
				for (const v of field.values) propValues[key].add(v);
			}
		}
		return propValues;
	});
	const isObject$1 = isObject;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = {};
		const proms = [];
		const shape = value.shape;
		for (const key of value.keys) {
			const el = shape[key];
			const isOptionalOut = el._zod.optout === "optional";
			const r = el._zod.run({
				value: input[key],
				issues: []
			}, ctx);
			if (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input, isOptionalOut)));
			else handlePropertyResult(r, payload, key, input, isOptionalOut);
		}
		if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
		return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	};
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
	$ZodObject.init(inst, def);
	const superParse = inst._zod.parse;
	const _normalized = cached(() => normalizeDef(def));
	const generateFastpass = (shape) => {
		const doc = new Doc([
			"shape",
			"payload",
			"ctx"
		]);
		const normalized = _normalized.value;
		const parseStr = (key) => {
			const k = esc(key);
			return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
		};
		doc.write(`const input = payload.value;`);
		const ids = Object.create(null);
		let counter = 0;
		for (const key of normalized.keys) ids[key] = `key_${counter++}`;
		doc.write(`const newResult = {};`);
		for (const key of normalized.keys) {
			const id = ids[key];
			const k = esc(key);
			const isOptionalOut = shape[key]?._zod?.optout === "optional";
			doc.write(`const ${id} = ${parseStr(key)};`);
			if (isOptionalOut) doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
			else doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
		}
		doc.write(`payload.value = newResult;`);
		doc.write(`return payload;`);
		const fn$1 = doc.compile();
		return (payload, ctx) => fn$1(shape, payload, ctx);
	};
	let fastpass;
	const isObject$1 = isObject;
	const jit = !globalConfig.jitless;
	const allowsEval$1 = allowsEval;
	const fastEnabled = jit && allowsEval$1.value;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
			if (!fastpass) fastpass = generateFastpass(def.shape);
			payload = fastpass(payload, ctx);
			if (!catchall) return payload;
			return handleCatchall([], input, payload, ctx, value, inst);
		}
		return superParse(payload, ctx);
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) if (result.issues.length === 0) {
		final.value = result.value;
		return final;
	}
	const nonaborted = results.filter((r) => !aborted(r));
	if (nonaborted.length === 1) {
		final.value = nonaborted[0].value;
		return nonaborted[0];
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "values", () => {
		if (def.options.every((o) => o._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def.options.every((o) => o._zod.pattern)) {
			const patterns = def.options.map((o) => o._zod.pattern);
			return /* @__PURE__ */ new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
	});
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) return first(payload, ctx);
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleUnionResults(results$1, payload, inst, ctx);
		});
	};
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
	const successes = results.filter((r) => r.issues.length === 0);
	if (successes.length === 1) {
		final.value = successes[0].value;
		return final;
	}
	if (successes.length === 0) final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	else final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: [],
		inclusive: false
	});
	return final;
}
const $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
	$ZodUnion.init(inst, def);
	def.inclusive = false;
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) return first(payload, ctx);
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else results.push(result);
		}
		if (!async) return handleExclusiveUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleExclusiveUnionResults(results$1, payload, inst, ctx);
		});
	};
});
const $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
	def.inclusive = false;
	$ZodUnion.init(inst, def);
	const _super = inst._zod.parse;
	defineLazy(inst._zod, "propValues", () => {
		const propValues = {};
		for (const option of def.options) {
			const pv = option._zod.propValues;
			if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
			for (const [k, v] of Object.entries(pv)) {
				if (!propValues[k]) propValues[k] = /* @__PURE__ */ new Set();
				for (const val of v) propValues[k].add(val);
			}
		}
		return propValues;
	});
	const disc = cached(() => {
		const opts = def.options;
		const map$1 = /* @__PURE__ */ new Map();
		for (const o of opts) {
			const values = o._zod.propValues?.[def.discriminator];
			if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
			for (const v of values) {
				if (map$1.has(v)) throw new Error(`Duplicate discriminator value "${String(v)}"`);
				map$1.set(v, o);
			}
		}
		return map$1;
	});
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isObject(input)) {
			payload.issues.push({
				code: "invalid_type",
				expected: "object",
				input,
				inst
			});
			return payload;
		}
		const opt = disc.value.get(input?.[def.discriminator]);
		if (opt) return opt._zod.run(payload, ctx);
		if (def.unionFallback) return _super(payload, ctx);
		payload.issues.push({
			code: "invalid_union",
			errors: [],
			note: "No matching discriminator",
			discriminator: def.discriminator,
			input,
			path: [def.discriminator],
			inst
		});
		return payload;
	};
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		const left = def.left._zod.run({
			value: input,
			issues: []
		}, ctx);
		const right = def.right._zod.run({
			value: input,
			issues: []
		}, ctx);
		if (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left$1, right$1]) => {
			return handleIntersectionResults(payload, left$1, right$1);
		});
		return handleIntersectionResults(payload, left, right);
	};
});
function mergeValues(a, b) {
	if (a === b) return {
		valid: true,
		data: a
	};
	if (a instanceof Date && b instanceof Date && +a === +b) return {
		valid: true,
		data: a
	};
	if (isPlainObject(a) && isPlainObject(b)) {
		const bKeys = Object.keys(b);
		const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
			};
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) return {
			valid: false,
			mergeErrorPath: []
		};
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
			};
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	}
	return {
		valid: false,
		mergeErrorPath: []
	};
}
function handleIntersectionResults(result, left, right) {
	const unrecKeys = /* @__PURE__ */ new Map();
	let unrecIssue;
	for (const iss of left.issues) if (iss.code === "unrecognized_keys") {
		unrecIssue ?? (unrecIssue = iss);
		for (const k of iss.keys) {
			if (!unrecKeys.has(k)) unrecKeys.set(k, {});
			unrecKeys.get(k).l = true;
		}
	} else result.issues.push(iss);
	for (const iss of right.issues) if (iss.code === "unrecognized_keys") for (const k of iss.keys) {
		if (!unrecKeys.has(k)) unrecKeys.set(k, {});
		unrecKeys.get(k).r = true;
	}
	else result.issues.push(iss);
	const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
	if (bothKeys.length && unrecIssue) result.issues.push({
		...unrecIssue,
		keys: bothKeys
	});
	if (aborted(result)) return result;
	const merged = mergeValues(left.value, right.value);
	if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
	result.value = merged.data;
	return result;
}
const $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
	$ZodType.init(inst, def);
	const items = def.items;
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				input,
				inst,
				expected: "tuple",
				code: "invalid_type"
			});
			return payload;
		}
		payload.value = [];
		const proms = [];
		const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
		const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
		if (!def.rest) {
			const tooBig = input.length > items.length;
			const tooSmall = input.length < optStart - 1;
			if (tooBig || tooSmall) {
				payload.issues.push({
					...tooBig ? {
						code: "too_big",
						maximum: items.length,
						inclusive: true
					} : {
						code: "too_small",
						minimum: items.length
					},
					input,
					inst,
					origin: "array"
				});
				return payload;
			}
		}
		let i = -1;
		for (const item of items) {
			i++;
			if (i >= input.length) {
				if (i >= optStart) continue;
			}
			const result = item._zod.run({
				value: input[i],
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleTupleResult(result$1, payload, i)));
			else handleTupleResult(result, payload, i);
		}
		if (def.rest) {
			const rest = input.slice(items.length);
			for (const el of rest) {
				i++;
				const result = def.rest._zod.run({
					value: el,
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => handleTupleResult(result$1, payload, i)));
				else handleTupleResult(result, payload, i);
			}
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleTupleResult(result, final, index) {
	if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
	final.value[index] = result.value;
}
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isPlainObject(input)) {
			payload.issues.push({
				expected: "record",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		const values = def.keyType._zod.values;
		if (values) {
			payload.value = {};
			const recordKeys = /* @__PURE__ */ new Set();
			for (const key of values) if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
				recordKeys.add(typeof key === "number" ? key.toString() : key);
				const result = def.valueType._zod.run({
					value: input[key],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => {
					if (result$1.issues.length) payload.issues.push(...prefixIssues(key, result$1.issues));
					payload.value[key] = result$1.value;
				}));
				else {
					if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
					payload.value[key] = result.value;
				}
			}
			let unrecognized;
			for (const key in input) if (!recordKeys.has(key)) {
				unrecognized = unrecognized ?? [];
				unrecognized.push(key);
			}
			if (unrecognized && unrecognized.length > 0) payload.issues.push({
				code: "unrecognized_keys",
				input,
				inst,
				keys: unrecognized
			});
		} else {
			payload.value = {};
			for (const key of Reflect.ownKeys(input)) {
				if (key === "__proto__") continue;
				let keyResult = def.keyType._zod.run({
					value: key,
					issues: []
				}, ctx);
				if (keyResult instanceof Promise) throw new Error("Async schemas not supported in object keys currently");
				if (typeof key === "string" && number$2.test(key) && keyResult.issues.length) {
					const retryResult = def.keyType._zod.run({
						value: Number(key),
						issues: []
					}, ctx);
					if (retryResult instanceof Promise) throw new Error("Async schemas not supported in object keys currently");
					if (retryResult.issues.length === 0) keyResult = retryResult;
				}
				if (keyResult.issues.length) {
					if (def.mode === "loose") payload.value[key] = input[key];
					else payload.issues.push({
						code: "invalid_key",
						origin: "record",
						issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
						input: key,
						path: [key],
						inst
					});
					continue;
				}
				const result = def.valueType._zod.run({
					value: input[key],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => {
					if (result$1.issues.length) payload.issues.push(...prefixIssues(key, result$1.issues));
					payload.value[keyResult.value] = result$1.value;
				}));
				else {
					if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
					payload.value[keyResult.value] = result.value;
				}
			}
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
const $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!(input instanceof Map)) {
			payload.issues.push({
				expected: "map",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		payload.value = /* @__PURE__ */ new Map();
		for (const [key, value] of input) {
			const keyResult = def.keyType._zod.run({
				value: key,
				issues: []
			}, ctx);
			const valueResult = def.valueType._zod.run({
				value,
				issues: []
			}, ctx);
			if (keyResult instanceof Promise || valueResult instanceof Promise) proms.push(Promise.all([keyResult, valueResult]).then(([keyResult$1, valueResult$1]) => {
				handleMapResult(keyResult$1, valueResult$1, payload, key, input, inst, ctx);
			}));
			else handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
	if (keyResult.issues.length) if (propertyKeyTypes.has(typeof key)) final.issues.push(...prefixIssues(key, keyResult.issues));
	else final.issues.push({
		code: "invalid_key",
		origin: "map",
		input,
		inst,
		issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
	});
	if (valueResult.issues.length) if (propertyKeyTypes.has(typeof key)) final.issues.push(...prefixIssues(key, valueResult.issues));
	else final.issues.push({
		origin: "map",
		code: "invalid_element",
		input,
		inst,
		key,
		issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
	});
	final.value.set(keyResult.value, valueResult.value);
}
const $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!(input instanceof Set)) {
			payload.issues.push({
				input,
				inst,
				expected: "set",
				code: "invalid_type"
			});
			return payload;
		}
		const proms = [];
		payload.value = /* @__PURE__ */ new Set();
		for (const item of input) {
			const result = def.valueType._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleSetResult(result$1, payload)));
			else handleSetResult(result, payload);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleSetResult(result, final) {
	if (result.issues.length) final.issues.push(...result.issues);
	final.value.add(result.value);
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
	$ZodType.init(inst, def);
	const values = getEnumValues(def.entries);
	const valuesSet = new Set(values);
	inst._zod.values = valuesSet;
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (valuesSet.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
	$ZodType.init(inst, def);
	if (def.values.length === 0) throw new Error("Cannot create literal schema with no valid values");
	const values = new Set(def.values);
	inst._zod.values = values;
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (values.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values: def.values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (input instanceof File) return payload;
		payload.issues.push({
			expected: "file",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		const _out = def.transform(payload.value, payload);
		if (ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output) => {
			payload.value = output;
			return payload;
		});
		if (_out instanceof Promise) throw new $ZodAsyncError();
		payload.value = _out;
		return payload;
	};
});
function handleOptionalResult(result, input) {
	if (result.issues.length && input === void 0) return {
		issues: [],
		value: void 0
	};
	return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def.innerType._zod.optin === "optional") {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((r) => handleOptionalResult(r, payload.value));
			return handleOptionalResult(result, payload.value);
		}
		if (payload.value === void 0) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
	inst._zod.parse = (payload, ctx) => {
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
	});
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === null) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) {
			payload.value = def.defaultValue;
			/**
			* $ZodDefault returns the default value immediately in forward direction.
			* It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
			return payload;
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleDefaultResult(result$1, def));
		return handleDefaultResult(result, def);
	};
});
function handleDefaultResult(payload, def) {
	if (payload.value === void 0) payload.value = def.defaultValue;
	return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) payload.value = def.defaultValue;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => {
		const v = def.innerType._zod.values;
		return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleNonOptionalResult(result$1, inst));
		return handleNonOptionalResult(result, inst);
	};
});
function handleNonOptionalResult(payload, inst) {
	if (!payload.issues.length && payload.value === void 0) payload.issues.push({
		code: "invalid_type",
		expected: "nonoptional",
		input: payload.value,
		inst
	});
	return payload;
}
const $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") throw new $ZodEncodeError("ZodSuccess");
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => {
			payload.value = result$1.issues.length === 0;
			return payload;
		});
		payload.value = result.issues.length === 0;
		return payload;
	};
});
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => {
			payload.value = result$1.value;
			if (result$1.issues.length) {
				payload.value = def.catchValue({
					...payload,
					error: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
					input: payload.value
				});
				payload.issues = [];
			}
			return payload;
		});
		payload.value = result.value;
		if (result.issues.length) {
			payload.value = def.catchValue({
				...payload,
				error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
				input: payload.value
			});
			payload.issues = [];
		}
		return payload;
	};
});
const $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
			payload.issues.push({
				input: payload.value,
				inst,
				expected: "nan",
				code: "invalid_type"
			});
			return payload;
		}
		return payload;
	};
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) return right.then((right$1) => handlePipeResult(right$1, def.in, ctx));
			return handlePipeResult(right, def.in, ctx);
		}
		const left = def.in._zod.run(payload, ctx);
		if (left instanceof Promise) return left.then((left$1) => handlePipeResult(left$1, def.out, ctx));
		return handlePipeResult(left, def.out, ctx);
	};
});
function handlePipeResult(left, next, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return next._zod.run({
		value: left.value,
		issues: left.issues
	}, ctx);
}
const $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		if ((ctx.direction || "forward") === "forward") {
			const left = def.in._zod.run(payload, ctx);
			if (left instanceof Promise) return left.then((left$1) => handleCodecAResult(left$1, def, ctx));
			return handleCodecAResult(left, def, ctx);
		} else {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) return right.then((right$1) => handleCodecAResult(right$1, def, ctx));
			return handleCodecAResult(right, def, ctx);
		}
	};
});
function handleCodecAResult(result, def, ctx) {
	if (result.issues.length) {
		result.aborted = true;
		return result;
	}
	if ((ctx.direction || "forward") === "forward") {
		const transformed = def.transform(result.value, result);
		if (transformed instanceof Promise) return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
		return handleCodecTxResult(result, transformed, def.out, ctx);
	} else {
		const transformed = def.reverseTransform(result.value, result);
		if (transformed instanceof Promise) return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
		return handleCodecTxResult(result, transformed, def.in, ctx);
	}
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return nextSchema._zod.run({
		value,
		issues: left.issues
	}, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
	defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then(handleReadonlyResult);
		return handleReadonlyResult(result);
	};
});
function handleReadonlyResult(payload) {
	payload.value = Object.freeze(payload.value);
	return payload;
}
const $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
	$ZodType.init(inst, def);
	const regexParts = [];
	for (const part of def.parts) if (typeof part === "object" && part !== null) {
		if (!part._zod.pattern) throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
		const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
		if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);
		const start = source.startsWith("^") ? 1 : 0;
		const end = source.endsWith("$") ? source.length - 1 : source.length;
		regexParts.push(source.slice(start, end));
	} else if (part === null || primitiveTypes.has(typeof part)) regexParts.push(escapeRegex(`${part}`));
	else throw new Error(`Invalid template literal part: ${part}`);
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^${regexParts.join("")}$`);
	inst._zod.parse = (payload, _ctx) => {
		if (typeof payload.value !== "string") {
			payload.issues.push({
				input: payload.value,
				inst,
				expected: "string",
				code: "invalid_type"
			});
			return payload;
		}
		inst._zod.pattern.lastIndex = 0;
		if (!inst._zod.pattern.test(payload.value)) {
			payload.issues.push({
				input: payload.value,
				inst,
				code: "invalid_format",
				format: def.format ?? "template_literal",
				pattern: inst._zod.pattern.source
			});
			return payload;
		}
		return payload;
	};
});
const $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
	$ZodType.init(inst, def);
	inst._def = def;
	inst._zod.def = def;
	inst.implement = (func) => {
		if (typeof func !== "function") throw new Error("implement() must be called with a function");
		return function(...args) {
			const parsedArgs = inst._def.input ? parse$2(inst._def.input, args) : args;
			const result = Reflect.apply(func, this, parsedArgs);
			if (inst._def.output) return parse$2(inst._def.output, result);
			return result;
		};
	};
	inst.implementAsync = (func) => {
		if (typeof func !== "function") throw new Error("implementAsync() must be called with a function");
		return async function(...args) {
			const parsedArgs = inst._def.input ? await parseAsync$1(inst._def.input, args) : args;
			const result = await Reflect.apply(func, this, parsedArgs);
			if (inst._def.output) return await parseAsync$1(inst._def.output, result);
			return result;
		};
	};
	inst._zod.parse = (payload, _ctx) => {
		if (typeof payload.value !== "function") {
			payload.issues.push({
				code: "invalid_type",
				expected: "function",
				input: payload.value,
				inst
			});
			return payload;
		}
		if (inst._def.output && inst._def.output._zod.def.type === "promise") payload.value = inst.implementAsync(payload.value);
		else payload.value = inst.implement(payload.value);
		return payload;
	};
	inst.input = (...args) => {
		const F = inst.constructor;
		if (Array.isArray(args[0])) return new F({
			type: "function",
			input: new $ZodTuple({
				type: "tuple",
				items: args[0],
				rest: args[1]
			}),
			output: inst._def.output
		});
		return new F({
			type: "function",
			input: args[0],
			output: inst._def.output
		});
	};
	inst.output = (output) => {
		const F = inst.constructor;
		return new F({
			type: "function",
			input: inst._def.input,
			output
		});
	};
	return inst;
});
const $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({
			value: inner,
			issues: []
		}, ctx));
	};
});
const $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "innerType", () => def.getter());
	defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
	defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
	defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
	defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
	inst._zod.parse = (payload, ctx) => {
		return inst._zod.innerType._zod.run(payload, ctx);
	};
});
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
	$ZodCheck.init(inst, def);
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _) => {
		return payload;
	};
	inst._zod.check = (payload) => {
		const input = payload.value;
		const r = def.fn(input);
		if (r instanceof Promise) return r.then((r$1) => handleRefineResult(r$1, payload, input, inst));
		handleRefineResult(r, payload, input, inst);
	};
});
function handleRefineResult(result, payload, input, inst) {
	if (!result) {
		const _iss = {
			code: "custom",
			input,
			inst,
			path: [...inst._zod.def.path ?? []],
			continue: !inst._zod.def.abort
		};
		if (inst._zod.def.params) _iss.params = inst._zod.def.params;
		payload.issues.push(issue(_iss));
	}
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ar.js
const error$46 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "   ISO",
		date: "  ISO",
		time: "  ISO",
		duration: "  ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: "   IPv4",
		cidrv6: "   IPv6",
		base64: "  base64-encoded",
		base64url: "  base64url-encoded",
		json_string: "   JSON",
		e164: "   E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `  :   instanceof ${issue$1.expected}    ${received}`;
				return `  :   ${expected}    ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  :   ${stringifyPrimitive(issue$1.values[0])}`;
				return `  :     : ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `   :    ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return `  :    ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `  :   ${issue$1.origin}   ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				return `  :   ${issue$1.origin}   ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `  :     "${issue$1.prefix}"`;
				if (_issue.format === "ends_with") return `  :     "${_issue.suffix}"`;
				if (_issue.format === "includes") return `  :    "${_issue.includes}"`;
				if (_issue.format === "regex") return `  :     ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}  `;
			}
			case "not_multiple_of": return `  :      ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, " ")}`;
			case "invalid_key": return `    ${issue$1.origin}`;
			case "invalid_union": return "  ";
			case "invalid_element": return `    ${issue$1.origin}`;
			default: return "  ";
		}
	};
};
function ar_default() {
	return { localeError: error$46() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/az.js
const error$45 = () => {
	const Sizable = {
		string: {
			unit: "simvol",
			verb: "olmaldr"
		},
		file: {
			unit: "bayt",
			verb: "olmaldr"
		},
		array: {
			unit: "element",
			verb: "olmaldr"
		},
		set: {
			unit: "element",
			verb: "olmaldr"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "email address",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datetime",
		date: "ISO date",
		time: "ISO time",
		duration: "ISO duration",
		ipv4: "IPv4 address",
		ipv6: "IPv6 address",
		cidrv4: "IPv4 range",
		cidrv6: "IPv6 range",
		base64: "base64-encoded string",
		base64url: "base64url-encoded string",
		json_string: "JSON string",
		e164: "E.164 number",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Yanl dyr: gzlniln instanceof ${issue$1.expected}, daxil olan ${received}`;
				return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Yanl dyr: gzlniln ${stringifyPrimitive(issue$1.values[0])}`;
				return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ox byk: gzlniln ${issue$1.origin ?? "dyr"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "element"}`;
				return `ox byk: gzlniln ${issue$1.origin ?? "dyr"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ox kiik: gzlniln ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `ox kiik: gzlniln ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
				if (_issue.format === "ends_with") return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
				if (_issue.format === "includes") return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
				if (_issue.format === "regex") return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
				return `Yanl ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Yanl dd: ${issue$1.divisor} il bln biln olmaldr`;
			case "unrecognized_keys": return `Tannmayan aar${issue$1.keys.length > 1 ? "lar" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} daxilind yanl aar`;
			case "invalid_union": return "Yanl dyr";
			case "invalid_element": return `${issue$1.origin} daxilind yanl dyr`;
			default: return `Yanl dyr`;
		}
	};
};
function az_default() {
	return { localeError: error$45() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
	const absCount = Math.abs(count);
	const lastDigit = absCount % 10;
	const lastTwoDigits = absCount % 100;
	if (lastTwoDigits >= 11 && lastTwoDigits <= 19) return many;
	if (lastDigit === 1) return one;
	if (lastDigit >= 2 && lastDigit <= 4) return few;
	return many;
}
const error$44 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		array: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		set: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		file: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "email ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "   base64",
		base64url: "   base64url",
		json_string: "JSON ",
		e164: " E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected},  ${received}`;
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const unit = getBelarusianPlural(Number(issue$1.maximum), sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return ` : ,  ${issue$1.origin ?? ""}  ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${unit}`;
				}
				return ` : ,  ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const unit = getBelarusianPlural(Number(issue$1.minimum), sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return ` : ,  ${issue$1.origin}  ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${unit}`;
				}
				return ` : ,  ${issue$1.origin}   ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :    "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :    ${issue$1.divisor}`;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return " ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function be_default() {
	return { localeError: error$44() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/bg.js
const error$43 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64- ",
		base64url: "base64url- ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected},  ${received}`;
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :     "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :     "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :    "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :     ${_issue.pattern}`;
				let invalid_adj = "";
				if (_issue.format === "emoji") invalid_adj = "";
				if (_issue.format === "datetime") invalid_adj = "";
				if (_issue.format === "date") invalid_adj = "";
				if (_issue.format === "time") invalid_adj = "";
				if (_issue.format === "duration") invalid_adj = "";
				return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :      ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return " ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function bg_default() {
	return { localeError: error$43() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ca.js
const error$42 = () => {
	const Sizable = {
		string: {
			unit: "carcters",
			verb: "contenir"
		},
		file: {
			unit: "bytes",
			verb: "contenir"
		},
		array: {
			unit: "elements",
			verb: "contenir"
		},
		set: {
			unit: "elements",
			verb: "contenir"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entrada",
		email: "adrea electrnica",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data i hora ISO",
		date: "data ISO",
		time: "hora ISO",
		duration: "durada ISO",
		ipv4: "adrea IPv4",
		ipv6: "adrea IPv6",
		cidrv4: "rang IPv4",
		cidrv6: "rang IPv6",
		base64: "cadena codificada en base64",
		base64url: "cadena codificada en base64url",
		json_string: "cadena JSON",
		e164: "nmero E.164",
		jwt: "JWT",
		template_literal: "entrada"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Tipus invlid: s'esperava instanceof ${issue$1.expected}, s'ha rebut ${received}`;
				return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Valor invlid: s'esperava ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opci invlida: s'esperava una de ${joinValues(issue$1.values, " o ")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "com a mxim" : "menys de";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Massa gran: s'esperava que ${issue$1.origin ?? "el valor"} contingus ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? "elements"}`;
				return `Massa gran: s'esperava que ${issue$1.origin ?? "el valor"} fos ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "com a mnim" : "ms de";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Massa petit: s'esperava que ${issue$1.origin} contingus ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Massa petit: s'esperava que ${issue$1.origin} fos ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Format invlid: ha d'incloure "${_issue.includes}"`;
				if (_issue.format === "regex") return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
				return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nmero invlid: ha de ser mltiple de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Clau${issue$1.keys.length > 1 ? "s" : ""} no reconeguda${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Clau invlida a ${issue$1.origin}`;
			case "invalid_union": return "Entrada invlida";
			case "invalid_element": return `Element invlid a ${issue$1.origin}`;
			default: return `Entrada invlida`;
		}
	};
};
function ca_default() {
	return { localeError: error$42() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/cs.js
const error$41 = () => {
	const Sizable = {
		string: {
			unit: "znak",
			verb: "mt"
		},
		file: {
			unit: "bajt",
			verb: "mt"
		},
		array: {
			unit: "prvk",
			verb: "mt"
		},
		set: {
			unit: "prvk",
			verb: "mt"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "regulrn vraz",
		email: "e-mailov adresa",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "datum a as ve formtu ISO",
		date: "datum ve formtu ISO",
		time: "as ve formtu ISO",
		duration: "doba trvn ISO",
		ipv4: "IPv4 adresa",
		ipv6: "IPv6 adresa",
		cidrv4: "rozsah IPv4",
		cidrv6: "rozsah IPv6",
		base64: "etzec zakdovan ve formtu base64",
		base64url: "etzec zakdovan ve formtu base64url",
		json_string: "etzec ve formtu JSON",
		e164: "slo E.164",
		jwt: "JWT",
		template_literal: "vstup"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "slo",
		string: "etzec",
		function: "funkce",
		array: "pole"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Neplatn vstup: oekvno instanceof ${issue$1.expected}, obdreno ${received}`;
				return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Neplatn vstup: oekvno ${stringifyPrimitive(issue$1.values[0])}`;
				return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Hodnota je pli velk: ${issue$1.origin ?? "hodnota"} mus mt ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "prvk"}`;
				return `Hodnota je pli velk: ${issue$1.origin ?? "hodnota"} mus bt ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Hodnota je pli mal: ${issue$1.origin ?? "hodnota"} mus mt ${adj}${issue$1.minimum.toString()} ${sizing.unit ?? "prvk"}`;
				return `Hodnota je pli mal: ${issue$1.origin ?? "hodnota"} mus bt ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
				if (_issue.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
				return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Neplatn slo: mus bt nsobkem ${issue$1.divisor}`;
			case "unrecognized_keys": return `Neznm kle: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Neplatn kl v ${issue$1.origin}`;
			case "invalid_union": return "Neplatn vstup";
			case "invalid_element": return `Neplatn hodnota v ${issue$1.origin}`;
			default: return `Neplatn vstup`;
		}
	};
};
function cs_default() {
	return { localeError: error$41() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/da.js
const error$40 = () => {
	const Sizable = {
		string: {
			unit: "tegn",
			verb: "havde"
		},
		file: {
			unit: "bytes",
			verb: "havde"
		},
		array: {
			unit: "elementer",
			verb: "indeholdt"
		},
		set: {
			unit: "elementer",
			verb: "indeholdt"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "e-mailadresse",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO dato- og klokkeslt",
		date: "ISO-dato",
		time: "ISO-klokkeslt",
		duration: "ISO-varighed",
		ipv4: "IPv4-omrde",
		ipv6: "IPv6-omrde",
		cidrv4: "IPv4-spektrum",
		cidrv6: "IPv6-spektrum",
		base64: "base64-kodet streng",
		base64url: "base64url-kodet streng",
		json_string: "JSON-streng",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		string: "streng",
		number: "tal",
		boolean: "boolean",
		array: "liste",
		object: "objekt",
		set: "st",
		file: "fil"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Ugyldigt input: forventede instanceof ${issue$1.expected}, fik ${received}`;
				return `Ugyldigt input: forventede ${expected}, fik ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ugyldigt valg: forventede en af flgende ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? "elementer"}`;
				return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				return `For lille: forventede ${origin} havde ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
				if (_issue.format === "regex") return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
				return `Ugyldig ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ugyldigt tal: skal vre deleligt med ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ugyldig ngle i ${issue$1.origin}`;
			case "invalid_union": return "Ugyldigt input: matcher ingen af de tilladte typer";
			case "invalid_element": return `Ugyldig vrdi i ${issue$1.origin}`;
			default: return `Ugyldigt input`;
		}
	};
};
function da_default() {
	return { localeError: error$40() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/de.js
const error$39 = () => {
	const Sizable = {
		string: {
			unit: "Zeichen",
			verb: "zu haben"
		},
		file: {
			unit: "Bytes",
			verb: "zu haben"
		},
		array: {
			unit: "Elemente",
			verb: "zu haben"
		},
		set: {
			unit: "Elemente",
			verb: "zu haben"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "Eingabe",
		email: "E-Mail-Adresse",
		url: "URL",
		emoji: "Emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-Datum und -Uhrzeit",
		date: "ISO-Datum",
		time: "ISO-Uhrzeit",
		duration: "ISO-Dauer",
		ipv4: "IPv4-Adresse",
		ipv6: "IPv6-Adresse",
		cidrv4: "IPv4-Bereich",
		cidrv6: "IPv6-Bereich",
		base64: "Base64-codierter String",
		base64url: "Base64-URL-codierter String",
		json_string: "JSON-String",
		e164: "E.164-Nummer",
		jwt: "JWT",
		template_literal: "Eingabe"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "Zahl",
		array: "Array"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Ungltige Eingabe: erwartet instanceof ${issue$1.expected}, erhalten ${received}`;
				return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ungltige Option: erwartet eine von ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Zu gro: erwartet, dass ${issue$1.origin ?? "Wert"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
				return `Zu gro: erwartet, dass ${issue$1.origin ?? "Wert"} ${adj}${issue$1.maximum.toString()} ist`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Zu klein: erwartet, dass ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit} hat`;
				return `Zu klein: erwartet, dass ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ist`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
				if (_issue.format === "ends_with") return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
				if (_issue.format === "includes") return `Ungltiger String: muss "${_issue.includes}" enthalten`;
				if (_issue.format === "regex") return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
				return `Ungltig: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ungltige Zahl: muss ein Vielfaches von ${issue$1.divisor} sein`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ungltiger Schlssel in ${issue$1.origin}`;
			case "invalid_union": return "Ungltige Eingabe";
			case "invalid_element": return `Ungltiger Wert in ${issue$1.origin}`;
			default: return `Ungltige Eingabe`;
		}
	};
};
function de_default() {
	return { localeError: error$39() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/en.js
const error$38 = () => {
	const Sizable = {
		string: {
			unit: "characters",
			verb: "to have"
		},
		file: {
			unit: "bytes",
			verb: "to have"
		},
		array: {
			unit: "items",
			verb: "to have"
		},
		set: {
			unit: "items",
			verb: "to have"
		},
		map: {
			unit: "entries",
			verb: "to have"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "email address",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datetime",
		date: "ISO date",
		time: "ISO time",
		duration: "ISO duration",
		ipv4: "IPv4 address",
		ipv6: "IPv6 address",
		mac: "MAC address",
		cidrv4: "IPv4 range",
		cidrv6: "IPv6 range",
		base64: "base64-encoded string",
		base64url: "base64url-encoded string",
		json_string: "JSON string",
		e164: "E.164 number",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				return `Invalid input: expected ${expected}, received ${TypeDictionary[receivedType] ?? receivedType}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue$1.values[0])}`;
				return `Invalid option: expected one of ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Too big: expected ${issue$1.origin ?? "value"} to have ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elements"}`;
				return `Too big: expected ${issue$1.origin ?? "value"} to be ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Too small: expected ${issue$1.origin} to have ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Too small: expected ${issue$1.origin} to be ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Invalid string: must start with "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Invalid string: must end with "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Invalid string: must include "${_issue.includes}"`;
				if (_issue.format === "regex") return `Invalid string: must match pattern ${_issue.pattern}`;
				return `Invalid ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Invalid number: must be a multiple of ${issue$1.divisor}`;
			case "unrecognized_keys": return `Unrecognized key${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Invalid key in ${issue$1.origin}`;
			case "invalid_union": return "Invalid input";
			case "invalid_element": return `Invalid value in ${issue$1.origin}`;
			default: return `Invalid input`;
		}
	};
};
function en_default() {
	return { localeError: error$38() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/eo.js
const error$37 = () => {
	const Sizable = {
		string: {
			unit: "karaktrojn",
			verb: "havi"
		},
		file: {
			unit: "bajtojn",
			verb: "havi"
		},
		array: {
			unit: "elementojn",
			verb: "havi"
		},
		set: {
			unit: "elementojn",
			verb: "havi"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "enigo",
		email: "retadreso",
		url: "URL",
		emoji: "emoio",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-datotempo",
		date: "ISO-dato",
		time: "ISO-tempo",
		duration: "ISO-daro",
		ipv4: "IPv4-adreso",
		ipv6: "IPv6-adreso",
		cidrv4: "IPv4-rango",
		cidrv6: "IPv6-rango",
		base64: "64-ume kodita karaktraro",
		base64url: "URL-64-ume kodita karaktraro",
		json_string: "JSON-karaktraro",
		e164: "E.164-nombro",
		jwt: "JWT",
		template_literal: "enigo"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nombro",
		array: "tabelo",
		null: "senvalora"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Nevalida enigo: atendiis instanceof ${issue$1.expected}, riceviis ${received}`;
				return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Nevalida enigo: atendiis ${stringifyPrimitive(issue$1.values[0])}`;
				return `Nevalida opcio: atendiis unu el ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Tro granda: atendiis ke ${issue$1.origin ?? "valoro"} havu ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
				return `Tro granda: atendiis ke ${issue$1.origin ?? "valoro"} havu ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Tro malgranda: atendiis ke ${issue$1.origin} havu ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Tro malgranda: atendiis ke ${issue$1.origin} estu ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
				if (_issue.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
				return `Nevalida ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nevalida nombro: devas esti oblo de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Nekonata${issue$1.keys.length > 1 ? "j" : ""} losilo${issue$1.keys.length > 1 ? "j" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Nevalida losilo en ${issue$1.origin}`;
			case "invalid_union": return "Nevalida enigo";
			case "invalid_element": return `Nevalida valoro en ${issue$1.origin}`;
			default: return `Nevalida enigo`;
		}
	};
};
function eo_default() {
	return { localeError: error$37() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/es.js
const error$36 = () => {
	const Sizable = {
		string: {
			unit: "caracteres",
			verb: "tener"
		},
		file: {
			unit: "bytes",
			verb: "tener"
		},
		array: {
			unit: "elementos",
			verb: "tener"
		},
		set: {
			unit: "elementos",
			verb: "tener"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entrada",
		email: "direccin de correo electrnico",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "fecha y hora ISO",
		date: "fecha ISO",
		time: "hora ISO",
		duration: "duracin ISO",
		ipv4: "direccin IPv4",
		ipv6: "direccin IPv6",
		cidrv4: "rango IPv4",
		cidrv6: "rango IPv6",
		base64: "cadena codificada en base64",
		base64url: "URL codificada en base64",
		json_string: "cadena JSON",
		e164: "nmero E.164",
		jwt: "JWT",
		template_literal: "entrada"
	};
	const TypeDictionary = {
		nan: "NaN",
		string: "texto",
		number: "nmero",
		boolean: "booleano",
		array: "arreglo",
		object: "objeto",
		set: "conjunto",
		file: "archivo",
		date: "fecha",
		bigint: "nmero grande",
		symbol: "smbolo",
		undefined: "indefinido",
		null: "nulo",
		function: "funcin",
		map: "mapa",
		record: "registro",
		tuple: "tupla",
		enum: "enumeracin",
		union: "unin",
		literal: "literal",
		promise: "promesa",
		void: "vaco",
		never: "nunca",
		unknown: "desconocido",
		any: "cualquiera"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Entrada invlida: se esperaba instanceof ${issue$1.expected}, recibido ${received}`;
				return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entrada invlida: se esperaba ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opcin invlida: se esperaba una de ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementos"}`;
				return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Cadena invlida: debe incluir "${_issue.includes}"`;
				if (_issue.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
				return `Invlido ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nmero invlido: debe ser mltiplo de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Llave${issue$1.keys.length > 1 ? "s" : ""} desconocida${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Llave invlida en ${TypeDictionary[issue$1.origin] ?? issue$1.origin}`;
			case "invalid_union": return "Entrada invlida";
			case "invalid_element": return `Valor invlido en ${TypeDictionary[issue$1.origin] ?? issue$1.origin}`;
			default: return `Entrada invlida`;
		}
	};
};
function es_default() {
	return { localeError: error$36() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/fa.js
const error$35 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "   ",
		date: " ",
		time: " ",
		duration: "  ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64-encoded ",
		base64url: "base64url-encoded ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected}  ${received}  `;
				return ` :  ${expected}  ${received}  `;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])} `;
				return ` :    ${joinValues(issue$1.values, "|")} `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""} `;
				return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit} `;
				return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :   "${_issue.prefix}"  `;
				if (_issue.format === "ends_with") return ` :   "${_issue.suffix}"  `;
				if (_issue.format === "includes") return ` :   "${_issue.includes}" `;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}   `;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} `;
			}
			case "not_multiple_of": return ` :   ${issue$1.divisor} `;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return ` `;
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function fa_default() {
	return { localeError: error$35() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/fi.js
const error$34 = () => {
	const Sizable = {
		string: {
			unit: "merkki",
			subject: "merkkijonon"
		},
		file: {
			unit: "tavua",
			subject: "tiedoston"
		},
		array: {
			unit: "alkiota",
			subject: "listan"
		},
		set: {
			unit: "alkiota",
			subject: "joukon"
		},
		number: {
			unit: "",
			subject: "luvun"
		},
		bigint: {
			unit: "",
			subject: "suuren kokonaisluvun"
		},
		int: {
			unit: "",
			subject: "kokonaisluvun"
		},
		date: {
			unit: "",
			subject: "pivmrn"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "snnllinen lauseke",
		email: "shkpostiosoite",
		url: "URL-osoite",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-aikaleima",
		date: "ISO-pivmr",
		time: "ISO-aika",
		duration: "ISO-kesto",
		ipv4: "IPv4-osoite",
		ipv6: "IPv6-osoite",
		cidrv4: "IPv4-alue",
		cidrv6: "IPv6-alue",
		base64: "base64-koodattu merkkijono",
		base64url: "base64url-koodattu merkkijono",
		json_string: "JSON-merkkijono",
		e164: "E.164-luku",
		jwt: "JWT",
		template_literal: "templaattimerkkijono"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Virheellinen tyyppi: odotettiin instanceof ${issue$1.expected}, oli ${received}`;
				return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue$1.values[0])}`;
				return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue$1.maximum.toString()} ${sizing.unit}`.trim();
				return `Liian suuri: arvon tytyy olla ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue$1.minimum.toString()} ${sizing.unit}`.trim();
				return `Liian pieni: arvon tytyy olla ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
				if (_issue.format === "regex") return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
				return `Virheellinen ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Virheellinen luku: tytyy olla luvun ${issue$1.divisor} monikerta`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return "Virheellinen avain tietueessa";
			case "invalid_union": return "Virheellinen unioni";
			case "invalid_element": return "Virheellinen arvo joukossa";
			default: return `Virheellinen syte`;
		}
	};
};
function fi_default() {
	return { localeError: error$34() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/fr.js
const error$33 = () => {
	const Sizable = {
		string: {
			unit: "caractres",
			verb: "avoir"
		},
		file: {
			unit: "octets",
			verb: "avoir"
		},
		array: {
			unit: "lments",
			verb: "avoir"
		},
		set: {
			unit: "lments",
			verb: "avoir"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entre",
		email: "adresse e-mail",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "date et heure ISO",
		date: "date ISO",
		time: "heure ISO",
		duration: "dure ISO",
		ipv4: "adresse IPv4",
		ipv6: "adresse IPv6",
		cidrv4: "plage IPv4",
		cidrv6: "plage IPv6",
		base64: "chane encode en base64",
		base64url: "chane encode en base64url",
		json_string: "chane JSON",
		e164: "numro E.164",
		jwt: "JWT",
		template_literal: "entre"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nombre",
		array: "tableau"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Entre invalide : instanceof ${issue$1.expected} attendu, ${received} reu`;
				return `Entre invalide : ${expected} attendu, ${received} reu`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entre invalide : ${stringifyPrimitive(issue$1.values[0])} attendu`;
				return `Option invalide : une valeur parmi ${joinValues(issue$1.values, "|")} attendue`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Trop grand : ${issue$1.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
				return `Trop grand : ${issue$1.origin ?? "valeur"} doit tre ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Trop petit : ${issue$1.origin} doit ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Trop petit : ${issue$1.origin} doit tre ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Chane invalide : doit commencer par "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Chane invalide : doit inclure "${_issue.includes}"`;
				if (_issue.format === "regex") return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} invalide`;
			}
			case "not_multiple_of": return `Nombre invalide : doit tre un multiple de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Cl${issue$1.keys.length > 1 ? "s" : ""} non reconnue${issue$1.keys.length > 1 ? "s" : ""} : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Cl invalide dans ${issue$1.origin}`;
			case "invalid_union": return "Entre invalide";
			case "invalid_element": return `Valeur invalide dans ${issue$1.origin}`;
			default: return `Entre invalide`;
		}
	};
};
function fr_default() {
	return { localeError: error$33() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/fr-CA.js
const error$32 = () => {
	const Sizable = {
		string: {
			unit: "caractres",
			verb: "avoir"
		},
		file: {
			unit: "octets",
			verb: "avoir"
		},
		array: {
			unit: "lments",
			verb: "avoir"
		},
		set: {
			unit: "lments",
			verb: "avoir"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entre",
		email: "adresse courriel",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "date-heure ISO",
		date: "date ISO",
		time: "heure ISO",
		duration: "dure ISO",
		ipv4: "adresse IPv4",
		ipv6: "adresse IPv6",
		cidrv4: "plage IPv4",
		cidrv6: "plage IPv6",
		base64: "chane encode en base64",
		base64url: "chane encode en base64url",
		json_string: "chane JSON",
		e164: "numro E.164",
		jwt: "JWT",
		template_literal: "entre"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Entre invalide : attendu instanceof ${issue$1.expected}, reu ${received}`;
				return `Entre invalide : attendu ${expected}, reu ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entre invalide : attendu ${stringifyPrimitive(issue$1.values[0])}`;
				return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Trop grand : attendu que ${issue$1.origin ?? "la valeur"} ait ${adj}${issue$1.maximum.toString()} ${sizing.unit}`;
				return `Trop grand : attendu que ${issue$1.origin ?? "la valeur"} soit ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Trop petit : attendu que ${issue$1.origin} ait ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Trop petit : attendu que ${issue$1.origin} soit ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Chane invalide : doit commencer par "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Chane invalide : doit inclure "${_issue.includes}"`;
				if (_issue.format === "regex") return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} invalide`;
			}
			case "not_multiple_of": return `Nombre invalide : doit tre un multiple de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Cl${issue$1.keys.length > 1 ? "s" : ""} non reconnue${issue$1.keys.length > 1 ? "s" : ""} : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Cl invalide dans ${issue$1.origin}`;
			case "invalid_union": return "Entre invalide";
			case "invalid_element": return `Valeur invalide dans ${issue$1.origin}`;
			default: return `Entre invalide`;
		}
	};
};
function fr_CA_default() {
	return { localeError: error$32() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/he.js
const error$31 = () => {
	const TypeNames = {
		string: {
			label: "",
			gender: "f"
		},
		number: {
			label: "",
			gender: "m"
		},
		boolean: {
			label: " ",
			gender: "m"
		},
		bigint: {
			label: "BigInt",
			gender: "m"
		},
		date: {
			label: "",
			gender: "m"
		},
		array: {
			label: "",
			gender: "m"
		},
		object: {
			label: "",
			gender: "m"
		},
		null: {
			label: "  (null)",
			gender: "m"
		},
		undefined: {
			label: "   (undefined)",
			gender: "m"
		},
		symbol: {
			label: " (Symbol)",
			gender: "m"
		},
		function: {
			label: "",
			gender: "f"
		},
		map: {
			label: " (Map)",
			gender: "f"
		},
		set: {
			label: " (Set)",
			gender: "f"
		},
		file: {
			label: "",
			gender: "m"
		},
		promise: {
			label: "Promise",
			gender: "m"
		},
		NaN: {
			label: "NaN",
			gender: "m"
		},
		unknown: {
			label: "  ",
			gender: "m"
		},
		value: {
			label: "",
			gender: "m"
		}
	};
	const Sizable = {
		string: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		file: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		array: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		set: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		number: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		}
	};
	const typeEntry = (t) => t ? TypeNames[t] : void 0;
	const typeLabel = (t) => {
		const e = typeEntry(t);
		if (e) return e.label;
		return t ?? TypeNames.unknown.label;
	};
	const withDefinite = (t) => `${typeLabel(t)}`;
	const verbFor = (t) => {
		return (typeEntry(t)?.gender ?? "m") === "f" ? " " : " ";
	};
	const getSizing = (origin) => {
		if (!origin) return null;
		return Sizable[origin] ?? null;
	};
	const FormatDictionary = {
		regex: {
			label: "",
			gender: "m"
		},
		email: {
			label: " ",
			gender: "f"
		},
		url: {
			label: " ",
			gender: "f"
		},
		emoji: {
			label: "'",
			gender: "m"
		},
		uuid: {
			label: "UUID",
			gender: "m"
		},
		nanoid: {
			label: "nanoid",
			gender: "m"
		},
		guid: {
			label: "GUID",
			gender: "m"
		},
		cuid: {
			label: "cuid",
			gender: "m"
		},
		cuid2: {
			label: "cuid2",
			gender: "m"
		},
		ulid: {
			label: "ULID",
			gender: "m"
		},
		xid: {
			label: "XID",
			gender: "m"
		},
		ksuid: {
			label: "KSUID",
			gender: "m"
		},
		datetime: {
			label: "  ISO",
			gender: "m"
		},
		date: {
			label: " ISO",
			gender: "m"
		},
		time: {
			label: " ISO",
			gender: "m"
		},
		duration: {
			label: "  ISO",
			gender: "m"
		},
		ipv4: {
			label: " IPv4",
			gender: "f"
		},
		ipv6: {
			label: " IPv6",
			gender: "f"
		},
		cidrv4: {
			label: " IPv4",
			gender: "m"
		},
		cidrv6: {
			label: " IPv6",
			gender: "m"
		},
		base64: {
			label: "  64",
			gender: "f"
		},
		base64url: {
			label: "  64  ",
			gender: "f"
		},
		json_string: {
			label: " JSON",
			gender: "f"
		},
		e164: {
			label: " E.164",
			gender: "m"
		},
		jwt: {
			label: "JWT",
			gender: "m"
		},
		ends_with: {
			label: "",
			gender: "m"
		},
		includes: {
			label: "",
			gender: "m"
		},
		lowercase: {
			label: "",
			gender: "m"
		},
		starts_with: {
			label: "",
			gender: "m"
		},
		uppercase: {
			label: "",
			gender: "m"
		}
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expectedKey = issue$1.expected;
				const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `  :   instanceof ${issue$1.expected},  ${received}`;
				return `  :   ${expected},  ${received}`;
			}
			case "invalid_value": {
				if (issue$1.values.length === 1) return `  :    ${stringifyPrimitive(issue$1.values[0])}`;
				const stringified = issue$1.values.map((v) => stringifyPrimitive(v));
				if (issue$1.values.length === 2) return `  :    ${stringified[0]}  ${stringified[1]}`;
				const lastValue = stringified[stringified.length - 1];
				return `  :    ${stringified.slice(0, -1).join(", ")}  ${lastValue}`;
			}
			case "too_big": {
				const sizing = getSizing(issue$1.origin);
				const subject = withDefinite(issue$1.origin ?? "value");
				if (issue$1.origin === "string") return `${sizing?.longLabel ?? ""} : ${subject}   ${issue$1.maximum.toString()} ${sizing?.unit ?? ""} ${issue$1.inclusive ? " " : " "}`.trim();
				if (issue$1.origin === "number") return ` : ${subject}   ${issue$1.inclusive ? `   -${issue$1.maximum}` : ` -${issue$1.maximum}`}`;
				if (issue$1.origin === "array" || issue$1.origin === "set") return ` : ${subject} ${issue$1.origin === "set" ? "" : ""}  ${issue$1.inclusive ? `${issue$1.maximum} ${sizing?.unit ?? ""}  ` : ` -${issue$1.maximum} ${sizing?.unit ?? ""}`}`.trim();
				const adj = issue$1.inclusive ? "<=" : "<";
				const be = verbFor(issue$1.origin ?? "value");
				if (sizing?.unit) return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue$1.maximum.toString()} ${sizing.unit}`;
				return `${sizing?.longLabel ?? ""} : ${subject} ${be} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const sizing = getSizing(issue$1.origin);
				const subject = withDefinite(issue$1.origin ?? "value");
				if (issue$1.origin === "string") return `${sizing?.shortLabel ?? ""} : ${subject}   ${issue$1.minimum.toString()} ${sizing?.unit ?? ""} ${issue$1.inclusive ? " " : ""}`.trim();
				if (issue$1.origin === "number") return ` : ${subject}   ${issue$1.inclusive ? `   -${issue$1.minimum}` : ` -${issue$1.minimum}`}`;
				if (issue$1.origin === "array" || issue$1.origin === "set") {
					const verb = issue$1.origin === "set" ? "" : "";
					if (issue$1.minimum === 1 && issue$1.inclusive) return ` : ${subject} ${verb}  ${issue$1.origin === "set" ? "  " : "  "}`;
					return ` : ${subject} ${verb}  ${issue$1.inclusive ? `${issue$1.minimum} ${sizing?.unit ?? ""}  ` : ` -${issue$1.minimum} ${sizing?.unit ?? ""}`}`.trim();
				}
				const adj = issue$1.inclusive ? ">=" : ">";
				const be = verbFor(issue$1.origin ?? "value");
				if (sizing?.unit) return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `${sizing?.shortLabel ?? ""} : ${subject} ${be} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `    "${_issue.suffix}"`;
				if (_issue.format === "includes") return `   "${_issue.includes}"`;
				if (_issue.format === "regex") return `    ${_issue.pattern}`;
				const nounEntry = FormatDictionary[_issue.format];
				return `${nounEntry?.label ?? _issue.format}  ${(nounEntry?.gender ?? "m") === "f" ? "" : ""}`;
			}
			case "not_multiple_of": return `  :     ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""}  ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   `;
			case "invalid_union": return "  ";
			case "invalid_element": return `   ${withDefinite(issue$1.origin ?? "array")}`;
			default: return `  `;
		}
	};
};
function he_default() {
	return { localeError: error$31() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/hu.js
const error$30 = () => {
	const Sizable = {
		string: {
			unit: "karakter",
			verb: "legyen"
		},
		file: {
			unit: "byte",
			verb: "legyen"
		},
		array: {
			unit: "elem",
			verb: "legyen"
		},
		set: {
			unit: "elem",
			verb: "legyen"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "bemenet",
		email: "email cm",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO idblyeg",
		date: "ISO dtum",
		time: "ISO id",
		duration: "ISO idintervallum",
		ipv4: "IPv4 cm",
		ipv6: "IPv6 cm",
		cidrv4: "IPv4 tartomny",
		cidrv6: "IPv6 tartomny",
		base64: "base64-kdolt string",
		base64url: "base64url-kdolt string",
		json_string: "JSON string",
		e164: "E.164 szm",
		jwt: "JWT",
		template_literal: "bemenet"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "szm",
		array: "tmb"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `rvnytelen bemenet: a vrt rtk instanceof ${issue$1.expected}, a kapott rtk ${received}`;
				return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue$1.values[0])}`;
				return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Tl nagy: ${issue$1.origin ?? "rtk"} mrete tl nagy ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elem"}`;
				return `Tl nagy: a bemeneti rtk ${issue$1.origin ?? "rtk"} tl nagy: ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Tl kicsi: a bemeneti rtk ${issue$1.origin} mrete tl kicsi ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Tl kicsi: a bemeneti rtk ${issue$1.origin} tl kicsi ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
				if (_issue.format === "ends_with") return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
				if (_issue.format === "includes") return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
				if (_issue.format === "regex") return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
				return `rvnytelen ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `rvnytelen szm: ${issue$1.divisor} tbbszrsnek kell lennie`;
			case "unrecognized_keys": return `Ismeretlen kulcs${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `rvnytelen kulcs ${issue$1.origin}`;
			case "invalid_union": return "rvnytelen bemenet";
			case "invalid_element": return `rvnytelen rtk: ${issue$1.origin}`;
			default: return `rvnytelen bemenet`;
		}
	};
};
function hu_default() {
	return { localeError: error$30() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
	return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
	if (!word) return "";
	const vowels = [
		"",
		"",
		"",
		"",
		"",
		"",
		""
	];
	const lastChar = word[word.length - 1];
	return word + (vowels.includes(lastChar) ? "" : "");
}
const error$29 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		},
		file: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		},
		array: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		},
		set: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: ". ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64  ",
		base64url: "base64url  ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `    instanceof ${issue$1.expected},   ${received}`;
				return `    ${expected},   ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `    ${stringifyPrimitive(issue$1.values[1])}`;
				return `      ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const unit = getArmenianPlural(Number(issue$1.maximum), sizing.unit.one, sizing.unit.many);
					return `    ,  ${withDefiniteArticle(issue$1.origin ?? "")}  ${adj}${issue$1.maximum.toString()} ${unit}`;
				}
				return `    ,  ${withDefiniteArticle(issue$1.origin ?? "")}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const unit = getArmenianPlural(Number(issue$1.minimum), sizing.unit.one, sizing.unit.many);
					return `    ,  ${withDefiniteArticle(issue$1.origin)}  ${adj}${issue$1.minimum.toString()} ${unit}`;
				}
				return `    ,  ${withDefiniteArticle(issue$1.origin)}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `     "${_issue.prefix}"-`;
				if (_issue.format === "ends_with") return `     "${_issue.suffix}"-`;
				if (_issue.format === "includes") return `     "${_issue.includes}"`;
				if (_issue.format === "regex") return `     ${_issue.pattern} `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `      ${issue$1.divisor}-`;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}. ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `  ${withDefiniteArticle(issue$1.origin)}-`;
			case "invalid_union": return " ";
			case "invalid_element": return `  ${withDefiniteArticle(issue$1.origin)}-`;
			default: return ` `;
		}
	};
};
function hy_default() {
	return { localeError: error$29() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/id.js
const error$28 = () => {
	const Sizable = {
		string: {
			unit: "karakter",
			verb: "memiliki"
		},
		file: {
			unit: "byte",
			verb: "memiliki"
		},
		array: {
			unit: "item",
			verb: "memiliki"
		},
		set: {
			unit: "item",
			verb: "memiliki"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "alamat email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "tanggal dan waktu format ISO",
		date: "tanggal format ISO",
		time: "jam format ISO",
		duration: "durasi format ISO",
		ipv4: "alamat IPv4",
		ipv6: "alamat IPv6",
		cidrv4: "rentang alamat IPv4",
		cidrv6: "rentang alamat IPv6",
		base64: "string dengan enkode base64",
		base64url: "string dengan enkode base64url",
		json_string: "string JSON",
		e164: "angka E.164",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Input tidak valid: diharapkan instanceof ${issue$1.expected}, diterima ${received}`;
				return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Input tidak valid: diharapkan ${stringifyPrimitive(issue$1.values[0])}`;
				return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Terlalu besar: diharapkan ${issue$1.origin ?? "value"} memiliki ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elemen"}`;
				return `Terlalu besar: diharapkan ${issue$1.origin ?? "value"} menjadi ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Terlalu kecil: diharapkan ${issue$1.origin} memiliki ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Terlalu kecil: diharapkan ${issue$1.origin} menjadi ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
				if (_issue.format === "includes") return `String tidak valid: harus menyertakan "${_issue.includes}"`;
				if (_issue.format === "regex") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} tidak valid`;
			}
			case "not_multiple_of": return `Angka tidak valid: harus kelipatan dari ${issue$1.divisor}`;
			case "unrecognized_keys": return `Kunci tidak dikenali ${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Kunci tidak valid di ${issue$1.origin}`;
			case "invalid_union": return "Input tidak valid";
			case "invalid_element": return `Nilai tidak valid di ${issue$1.origin}`;
			default: return `Input tidak valid`;
		}
	};
};
function id_default() {
	return { localeError: error$28() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/is.js
const error$27 = () => {
	const Sizable = {
		string: {
			unit: "stafi",
			verb: "a hafa"
		},
		file: {
			unit: "bti",
			verb: "a hafa"
		},
		array: {
			unit: "hluti",
			verb: "a hafa"
		},
		set: {
			unit: "hluti",
			verb: "a hafa"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "gildi",
		email: "netfang",
		url: "vefsl",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO dagsetning og tmi",
		date: "ISO dagsetning",
		time: "ISO tmi",
		duration: "ISO tmalengd",
		ipv4: "IPv4 address",
		ipv6: "IPv6 address",
		cidrv4: "IPv4 range",
		cidrv6: "IPv6 range",
		base64: "base64-encoded strengur",
		base64url: "base64url-encoded strengur",
		json_string: "JSON strengur",
		e164: "E.164 tlugildi",
		jwt: "JWT",
		template_literal: "gildi"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nmer",
		array: "fylki"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue$1.expected}`;
				return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue$1.values[0])}`;
				return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Of strt: gert er r fyrir a ${issue$1.origin ?? "gildi"} hafi ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "hluti"}`;
				return `Of strt: gert er r fyrir a ${issue$1.origin ?? "gildi"} s ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Of lti: gert er r fyrir a ${issue$1.origin} hafi ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Of lti: gert er r fyrir a ${issue$1.origin} s ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `gildur strengur: verur a enda  "${_issue.suffix}"`;
				if (_issue.format === "includes") return `gildur strengur: verur a innihalda "${_issue.includes}"`;
				if (_issue.format === "regex") return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
				return `Rangt ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Rng tala: verur a vera margfeldi af ${issue$1.divisor}`;
			case "unrecognized_keys": return `ekkt ${issue$1.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Rangur lykill  ${issue$1.origin}`;
			case "invalid_union": return "Rangt gildi";
			case "invalid_element": return `Rangt gildi  ${issue$1.origin}`;
			default: return `Rangt gildi`;
		}
	};
};
function is_default() {
	return { localeError: error$27() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/it.js
const error$26 = () => {
	const Sizable = {
		string: {
			unit: "caratteri",
			verb: "avere"
		},
		file: {
			unit: "byte",
			verb: "avere"
		},
		array: {
			unit: "elementi",
			verb: "avere"
		},
		set: {
			unit: "elementi",
			verb: "avere"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "indirizzo email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data e ora ISO",
		date: "data ISO",
		time: "ora ISO",
		duration: "durata ISO",
		ipv4: "indirizzo IPv4",
		ipv6: "indirizzo IPv6",
		cidrv4: "intervallo IPv4",
		cidrv6: "intervallo IPv6",
		base64: "stringa codificata in base64",
		base64url: "URL codificata in base64",
		json_string: "stringa JSON",
		e164: "numero E.164",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "numero",
		array: "vettore"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Input non valido: atteso instanceof ${issue$1.expected}, ricevuto ${received}`;
				return `Input non valido: atteso ${expected}, ricevuto ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Input non valido: atteso ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opzione non valida: atteso uno tra ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Troppo grande: ${issue$1.origin ?? "valore"} deve avere ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementi"}`;
				return `Troppo grande: ${issue$1.origin ?? "valore"} deve essere ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Troppo piccolo: ${issue$1.origin} deve avere ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Troppo piccolo: ${issue$1.origin} deve essere ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Stringa non valida: deve includere "${_issue.includes}"`;
				if (_issue.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
				return `Invalid ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Numero non valido: deve essere un multiplo di ${issue$1.divisor}`;
			case "unrecognized_keys": return `Chiav${issue$1.keys.length > 1 ? "i" : "e"} non riconosciut${issue$1.keys.length > 1 ? "e" : "a"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Chiave non valida in ${issue$1.origin}`;
			case "invalid_union": return "Input non valido";
			case "invalid_element": return `Valore non valido in ${issue$1.origin}`;
			default: return `Input non valido`;
		}
	};
};
function it_default() {
	return { localeError: error$26() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ja.js
const error$25 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO",
		date: "ISO",
		time: "ISO",
		duration: "ISO",
		ipv4: "IPv4",
		ipv6: "IPv6",
		cidrv4: "IPv4",
		cidrv6: "IPv6",
		base64: "base64",
		base64url: "base64url",
		json_string: "JSON",
		e164: "E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `: instanceof ${issue$1.expected}${received}`;
				return `: ${expected}${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `: ${stringifyPrimitive(issue$1.values[0])}`;
				return `: ${joinValues(issue$1.values, "")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin ?? ""}${issue$1.maximum.toString()}${sizing.unit ?? ""}${adj}`;
				return `: ${issue$1.origin ?? ""}${issue$1.maximum.toString()}${adj}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin}${issue$1.minimum.toString()}${sizing.unit}${adj}`;
				return `: ${issue$1.origin}${issue$1.minimum.toString()}${adj}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `: "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `: "${_issue.suffix}"`;
				if (_issue.format === "includes") return `: "${_issue.includes}"`;
				if (_issue.format === "regex") return `: ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `: ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, "")}`;
			case "invalid_key": return `${issue$1.origin}`;
			case "invalid_union": return "";
			case "invalid_element": return `${issue$1.origin}`;
			default: return ``;
		}
	};
};
function ja_default() {
	return { localeError: error$25() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ka.js
const error$24 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "- ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "-",
		date: "",
		time: "",
		duration: "",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64- ",
		base64url: "base64url- ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		string: "",
		boolean: "",
		function: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected},  ${received}`;
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :  - ${joinValues(issue$1.values, "|")}-`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :  ${issue$1.origin ?? ""} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit}`;
				return ` :  ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :  ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return ` :  ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :   "${_issue.prefix}"-`;
				if (_issue.format === "ends_with") return ` :   "${_issue.suffix}"-`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"-`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :   ${issue$1.divisor}- `;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `  ${issue$1.origin}-`;
			case "invalid_union": return " ";
			case "invalid_element": return `  ${issue$1.origin}-`;
			default: return ` `;
		}
	};
};
function ka_default() {
	return { localeError: error$24() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/km.js
const error$23 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "  ISO",
		date: " ISO",
		time: " ISO",
		duration: " ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: " IPv4",
		cidrv6: " IPv6",
		base64: " base64",
		base64url: " base64url",
		json_string: " JSON",
		e164: " E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: " (Array)",
		null: " (null)"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `  instanceof ${issue$1.expected}  ${received}`;
				return `  ${expected}  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  ${stringifyPrimitive(issue$1.values[0])}`;
				return `  ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `  ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return `  ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `  ${issue$1.origin} ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				return `  ${issue$1.origin} ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `  "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `  "${_issue.suffix}"`;
				if (_issue.format === "includes") return `  "${_issue.includes}"`;
				if (_issue.format === "regex") return `  ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `  ${issue$1.divisor}`;
			case "unrecognized_keys": return ` ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return ` ${issue$1.origin}`;
			case "invalid_union": return ``;
			case "invalid_element": return ` ${issue$1.origin}`;
			default: return ``;
		}
	};
};
function km_default() {
	return { localeError: error$23() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/kh.js
/** @deprecated Use `km` instead. */
function kh_default() {
	return km_default();
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ko.js
const error$22 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: "to have"
		},
		file: {
			unit: "",
			verb: "to have"
		},
		array: {
			unit: "",
			verb: "to have"
		},
		set: {
			unit: "",
			verb: "to have"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64  ",
		base64url: "base64url  ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :   instanceof ${issue$1.expected},   ${received}`;
				return ` :   ${expected},   ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}  `;
				return ` : ${joinValues(issue$1.values, " ")}   `;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "";
				const suffix = adj === "" ? " " : " ";
				const sizing = getSizing(issue$1.origin);
				const unit = sizing?.unit ?? "";
				if (sizing) return `${issue$1.origin ?? ""}  : ${issue$1.maximum.toString()}${unit} ${adj}${suffix}`;
				return `${issue$1.origin ?? ""}  : ${issue$1.maximum.toString()} ${adj}${suffix}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : "";
				const suffix = adj === "" ? " " : " ";
				const sizing = getSizing(issue$1.origin);
				const unit = sizing?.unit ?? "";
				if (sizing) return `${issue$1.origin ?? ""}  : ${issue$1.minimum.toString()}${unit} ${adj}${suffix}`;
				return `${issue$1.origin ?? ""}  : ${issue$1.minimum.toString()} ${adj}${suffix}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` : "${_issue.prefix}"()  `;
				if (_issue.format === "ends_with") return ` : "${_issue.suffix}"()  `;
				if (_issue.format === "includes") return ` : "${_issue.includes}"()  `;
				if (_issue.format === "regex") return ` :  ${_issue.pattern}   `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` : ${issue$1.divisor}  `;
			case "unrecognized_keys": return `   : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return ` : ${issue$1.origin}`;
			case "invalid_union": return ` `;
			case "invalid_element": return ` : ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function ko_default() {
	return { localeError: error$22() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/lt.js
const capitalizeFirstCharacter = (text) => {
	return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number$3) {
	const abs = Math.abs(number$3);
	const last = abs % 10;
	const last2 = abs % 100;
	if (last2 >= 11 && last2 <= 19 || last === 0) return "many";
	if (last === 1) return "one";
	return "few";
}
const error$21 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "simbolis",
				few: "simboliai",
				many: "simboli"
			},
			verb: {
				smaller: {
					inclusive: "turi bti ne ilgesn kaip",
					notInclusive: "turi bti trumpesn kaip"
				},
				bigger: {
					inclusive: "turi bti ne trumpesn kaip",
					notInclusive: "turi bti ilgesn kaip"
				}
			}
		},
		file: {
			unit: {
				one: "baitas",
				few: "baitai",
				many: "bait"
			},
			verb: {
				smaller: {
					inclusive: "turi bti ne didesnis kaip",
					notInclusive: "turi bti maesnis kaip"
				},
				bigger: {
					inclusive: "turi bti ne maesnis kaip",
					notInclusive: "turi bti didesnis kaip"
				}
			}
		},
		array: {
			unit: {
				one: "element",
				few: "elementus",
				many: "element"
			},
			verb: {
				smaller: {
					inclusive: "turi turti ne daugiau kaip",
					notInclusive: "turi turti maiau kaip"
				},
				bigger: {
					inclusive: "turi turti ne maiau kaip",
					notInclusive: "turi turti daugiau kaip"
				}
			}
		},
		set: {
			unit: {
				one: "element",
				few: "elementus",
				many: "element"
			},
			verb: {
				smaller: {
					inclusive: "turi turti ne daugiau kaip",
					notInclusive: "turi turti maiau kaip"
				},
				bigger: {
					inclusive: "turi turti ne maiau kaip",
					notInclusive: "turi turti daugiau kaip"
				}
			}
		}
	};
	function getSizing(origin, unitType, inclusive, targetShouldBe) {
		const result = Sizable[origin] ?? null;
		if (result === null) return result;
		return {
			unit: result.unit[unitType],
			verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
		};
	}
	const FormatDictionary = {
		regex: "vestis",
		email: "el. pato adresas",
		url: "URL",
		emoji: "jaustukas",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO data ir laikas",
		date: "ISO data",
		time: "ISO laikas",
		duration: "ISO trukm",
		ipv4: "IPv4 adresas",
		ipv6: "IPv6 adresas",
		cidrv4: "IPv4 tinklo prefiksas (CIDR)",
		cidrv6: "IPv6 tinklo prefiksas (CIDR)",
		base64: "base64 ukoduota eilut",
		base64url: "base64url ukoduota eilut",
		json_string: "JSON eilut",
		e164: "E.164 numeris",
		jwt: "JWT",
		template_literal: "vestis"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "skaiius",
		bigint: "sveikasis skaiius",
		string: "eilut",
		boolean: "login reikm",
		undefined: "neapibrta reikm",
		function: "funkcija",
		symbol: "simbolis",
		array: "masyvas",
		object: "objektas",
		null: "nulin reikm"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Gautas tipas ${received}, o tiktasi - instanceof ${issue$1.expected}`;
				return `Gautas tipas ${received}, o tiktasi - ${expected}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Privalo bti ${stringifyPrimitive(issue$1.values[0])}`;
				return `Privalo bti vienas i ${joinValues(issue$1.values, "|")} pasirinkim`;
			case "too_big": {
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				const sizing = getSizing(issue$1.origin, getUnitTypeFromNumber(Number(issue$1.maximum)), issue$1.inclusive ?? false, "smaller");
				if (sizing?.verb) return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} ${sizing.verb} ${issue$1.maximum.toString()} ${sizing.unit ?? "element"}`;
				const adj = issue$1.inclusive ? "ne didesnis kaip" : "maesnis kaip";
				return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} turi bti ${adj} ${issue$1.maximum.toString()} ${sizing?.unit}`;
			}
			case "too_small": {
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				const sizing = getSizing(issue$1.origin, getUnitTypeFromNumber(Number(issue$1.minimum)), issue$1.inclusive ?? false, "bigger");
				if (sizing?.verb) return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} ${sizing.verb} ${issue$1.minimum.toString()} ${sizing.unit ?? "element"}`;
				const adj = issue$1.inclusive ? "ne maesnis kaip" : "didesnis kaip";
				return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} turi bti ${adj} ${issue$1.minimum.toString()} ${sizing?.unit}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Eilut privalo prasidti "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Eilut privalo pasibaigti "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Eilut privalo traukti "${_issue.includes}"`;
				if (_issue.format === "regex") return `Eilut privalo atitikti ${_issue.pattern}`;
				return `Neteisingas ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Skaiius privalo bti ${issue$1.divisor} kartotinis.`;
			case "unrecognized_keys": return `Neatpaint${issue$1.keys.length > 1 ? "i" : "as"} rakt${issue$1.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return "Rastas klaidingas raktas";
			case "invalid_union": return "Klaidinga vestis";
			case "invalid_element": return `${capitalizeFirstCharacter(TypeDictionary[issue$1.origin] ?? issue$1.origin ?? issue$1.origin ?? "reikm")} turi klaiding vest`;
			default: return "Klaidinga vestis";
		}
	};
};
function lt_default() {
	return { localeError: error$21() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/mk.js
const error$20 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "  -",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64- ",
		base64url: "base64url- ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :   instanceof ${issue$1.expected},  ${received}`;
				return ` :   ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :     "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :     "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :    "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :      ${_issue.pattern}`;
				return `Invalid ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :      ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? " " : " "}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return " ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function mk_default() {
	return { localeError: error$20() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ms.js
const error$19 = () => {
	const Sizable = {
		string: {
			unit: "aksara",
			verb: "mempunyai"
		},
		file: {
			unit: "bait",
			verb: "mempunyai"
		},
		array: {
			unit: "elemen",
			verb: "mempunyai"
		},
		set: {
			unit: "elemen",
			verb: "mempunyai"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "alamat e-mel",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "tarikh masa ISO",
		date: "tarikh ISO",
		time: "masa ISO",
		duration: "tempoh ISO",
		ipv4: "alamat IPv4",
		ipv6: "alamat IPv6",
		cidrv4: "julat IPv4",
		cidrv6: "julat IPv6",
		base64: "string dikodkan base64",
		base64url: "string dikodkan base64url",
		json_string: "string JSON",
		e164: "nombor E.164",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nombor"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Input tidak sah: dijangka instanceof ${issue$1.expected}, diterima ${received}`;
				return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Input tidak sah: dijangka ${stringifyPrimitive(issue$1.values[0])}`;
				return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Terlalu besar: dijangka ${issue$1.origin ?? "nilai"} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elemen"}`;
				return `Terlalu besar: dijangka ${issue$1.origin ?? "nilai"} adalah ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Terlalu kecil: dijangka ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Terlalu kecil: dijangka ${issue$1.origin} adalah ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
				if (_issue.format === "includes") return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
				if (_issue.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} tidak sah`;
			}
			case "not_multiple_of": return `Nombor tidak sah: perlu gandaan ${issue$1.divisor}`;
			case "unrecognized_keys": return `Kunci tidak dikenali: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Kunci tidak sah dalam ${issue$1.origin}`;
			case "invalid_union": return "Input tidak sah";
			case "invalid_element": return `Nilai tidak sah dalam ${issue$1.origin}`;
			default: return `Input tidak sah`;
		}
	};
};
function ms_default() {
	return { localeError: error$19() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/nl.js
const error$18 = () => {
	const Sizable = {
		string: {
			unit: "tekens",
			verb: "heeft"
		},
		file: {
			unit: "bytes",
			verb: "heeft"
		},
		array: {
			unit: "elementen",
			verb: "heeft"
		},
		set: {
			unit: "elementen",
			verb: "heeft"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "invoer",
		email: "emailadres",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datum en tijd",
		date: "ISO datum",
		time: "ISO tijd",
		duration: "ISO duur",
		ipv4: "IPv4-adres",
		ipv6: "IPv6-adres",
		cidrv4: "IPv4-bereik",
		cidrv6: "IPv6-bereik",
		base64: "base64-gecodeerde tekst",
		base64url: "base64 URL-gecodeerde tekst",
		json_string: "JSON string",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "invoer"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "getal"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Ongeldige invoer: verwacht instanceof ${issue$1.expected}, ontving ${received}`;
				return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ongeldige optie: verwacht n van ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				const longName = issue$1.origin === "date" ? "laat" : issue$1.origin === "string" ? "lang" : "groot";
				if (sizing) return `Te ${longName}: verwacht dat ${issue$1.origin ?? "waarde"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
				return `Te ${longName}: verwacht dat ${issue$1.origin ?? "waarde"} ${adj}${issue$1.maximum.toString()} is`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				const shortName = issue$1.origin === "date" ? "vroeg" : issue$1.origin === "string" ? "kort" : "klein";
				if (sizing) return `Te ${shortName}: verwacht dat ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
				return `Te ${shortName}: verwacht dat ${issue$1.origin} ${adj}${issue$1.minimum.toString()} is`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
				if (_issue.format === "ends_with") return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
				if (_issue.format === "includes") return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
				if (_issue.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
				return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ongeldig getal: moet een veelvoud van ${issue$1.divisor} zijn`;
			case "unrecognized_keys": return `Onbekende key${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ongeldige key in ${issue$1.origin}`;
			case "invalid_union": return "Ongeldige invoer";
			case "invalid_element": return `Ongeldige waarde in ${issue$1.origin}`;
			default: return `Ongeldige invoer`;
		}
	};
};
function nl_default() {
	return { localeError: error$18() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/no.js
const error$17 = () => {
	const Sizable = {
		string: {
			unit: "tegn",
			verb: " ha"
		},
		file: {
			unit: "bytes",
			verb: " ha"
		},
		array: {
			unit: "elementer",
			verb: " inneholde"
		},
		set: {
			unit: "elementer",
			verb: " inneholde"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "e-postadresse",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO dato- og klokkeslett",
		date: "ISO-dato",
		time: "ISO-klokkeslett",
		duration: "ISO-varighet",
		ipv4: "IPv4-omrde",
		ipv6: "IPv6-omrde",
		cidrv4: "IPv4-spekter",
		cidrv6: "IPv6-spekter",
		base64: "base64-enkodet streng",
		base64url: "base64url-enkodet streng",
		json_string: "JSON-streng",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "tall",
		array: "liste"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Ugyldig input: forventet instanceof ${issue$1.expected}, fikk ${received}`;
				return `Ugyldig input: forventet ${expected}, fikk ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ugyldig verdi: forventet ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ugyldig valg: forventet en av ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `For stor(t): forventet ${issue$1.origin ?? "value"} til  ha ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementer"}`;
				return `For stor(t): forventet ${issue$1.origin ?? "value"} til  ha ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `For lite(n): forventet ${issue$1.origin} til  ha ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `For lite(n): forventet ${issue$1.origin} til  ha ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ugyldig streng: m starte med "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Ugyldig streng: m ende med "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Ugyldig streng: m inneholde "${_issue.includes}"`;
				if (_issue.format === "regex") return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
				return `Ugyldig ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ugyldig tall: m vre et multiplum av ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ugyldig nkkel i ${issue$1.origin}`;
			case "invalid_union": return "Ugyldig input";
			case "invalid_element": return `Ugyldig verdi i ${issue$1.origin}`;
			default: return `Ugyldig input`;
		}
	};
};
function no_default() {
	return { localeError: error$17() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ota.js
const error$16 = () => {
	const Sizable = {
		string: {
			unit: "harf",
			verb: "olmaldr"
		},
		file: {
			unit: "bayt",
			verb: "olmaldr"
		},
		array: {
			unit: "unsur",
			verb: "olmaldr"
		},
		set: {
			unit: "unsur",
			verb: "olmaldr"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "giren",
		email: "epostagh",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO hengm",
		date: "ISO tarihi",
		time: "ISO zaman",
		duration: "ISO mddeti",
		ipv4: "IPv4 nin",
		ipv6: "IPv6 nin",
		cidrv4: "IPv4 menzili",
		cidrv6: "IPv6 menzili",
		base64: "base64-ifreli metin",
		base64url: "base64url-ifreli metin",
		json_string: "JSON metin",
		e164: "E.164 says",
		jwt: "JWT",
		template_literal: "giren"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "numara",
		array: "saf",
		null: "gayb"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Fsit giren: umulan instanceof ${issue$1.expected}, alnan ${received}`;
				return `Fsit giren: umulan ${expected}, alnan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Fsit giren: umulan ${stringifyPrimitive(issue$1.values[0])}`;
				return `Fsit tercih: mteberler ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Fazla byk: ${issue$1.origin ?? "value"}, ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
				return `Fazla byk: ${issue$1.origin ?? "value"}, ${adj}${issue$1.maximum.toString()} olmalyd.`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Fazla kk: ${issue$1.origin}, ${adj}${issue$1.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
				return `Fazla kk: ${issue$1.origin}, ${adj}${issue$1.minimum.toString()} olmalyd.`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Fsit metin: "${_issue.prefix}" ile balamal.`;
				if (_issue.format === "ends_with") return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
				if (_issue.format === "includes") return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
				if (_issue.format === "regex") return `Fsit metin: ${_issue.pattern} nakna uymal.`;
				return `Fsit ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Fsit say: ${issue$1.divisor} kat olmalyd.`;
			case "unrecognized_keys": return `Tannmayan anahtar ${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} iin tannmayan anahtar var.`;
			case "invalid_union": return "Giren tannamad.";
			case "invalid_element": return `${issue$1.origin} iin tannmayan kymet var.`;
			default: return `Kymet tannamad.`;
		}
	};
};
function ota_default() {
	return { localeError: error$16() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ps.js
const error$15 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "  ",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "  ",
		date: "",
		time: "",
		duration: "",
		ipv4: " IPv4 ",
		ipv6: " IPv6 ",
		cidrv4: " IPv4 ",
		cidrv6: " IPv6 ",
		base64: "base64-encoded ",
		base64url: "base64url-encoded ",
		json_string: "JSON ",
		e164: " E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected} ,  ${received}  `;
				return ` :  ${expected} ,  ${received}  `;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])} `;
				return ` :    ${joinValues(issue$1.values, "|")}  `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""} `;
				return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit} `;
				return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :   "${_issue.prefix}"   `;
				if (_issue.format === "ends_with") return ` :   "${_issue.suffix}"    `;
				if (_issue.format === "includes") return ` :  "${_issue.includes}" `;
				if (_issue.format === "regex") return ` :   ${_issue.pattern}   `;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}  `;
			}
			case "not_multiple_of": return ` :   ${issue$1.divisor}  `;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin} `;
			case "invalid_union": return ` `;
			case "invalid_element": return `   ${issue$1.origin} `;
			default: return ` `;
		}
	};
};
function ps_default() {
	return { localeError: error$15() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/pl.js
const error$14 = () => {
	const Sizable = {
		string: {
			unit: "znakw",
			verb: "mie"
		},
		file: {
			unit: "bajtw",
			verb: "mie"
		},
		array: {
			unit: "elementw",
			verb: "mie"
		},
		set: {
			unit: "elementw",
			verb: "mie"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "wyraenie",
		email: "adres email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data i godzina w formacie ISO",
		date: "data w formacie ISO",
		time: "godzina w formacie ISO",
		duration: "czas trwania ISO",
		ipv4: "adres IPv4",
		ipv6: "adres IPv6",
		cidrv4: "zakres IPv4",
		cidrv6: "zakres IPv6",
		base64: "cig znakw zakodowany w formacie base64",
		base64url: "cig znakw zakodowany w formacie base64url",
		json_string: "cig znakw w formacie JSON",
		e164: "liczba E.164",
		jwt: "JWT",
		template_literal: "wejcie"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "liczba",
		array: "tablica"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue$1.expected}, otrzymano ${received}`;
				return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue$1.values[0])}`;
				return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Za dua warto: oczekiwano, e ${issue$1.origin ?? "warto"} bdzie mie ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementw"}`;
				return `Zbyt du(y/a/e): oczekiwano, e ${issue$1.origin ?? "warto"} bdzie wynosi ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Za maa warto: oczekiwano, e ${issue$1.origin ?? "warto"} bdzie mie ${adj}${issue$1.minimum.toString()} ${sizing.unit ?? "elementw"}`;
				return `Zbyt ma(y/a/e): oczekiwano, e ${issue$1.origin ?? "warto"} bdzie wynosi ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
				if (_issue.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
				return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nieprawidowa liczba: musi by wielokrotnoci ${issue$1.divisor}`;
			case "unrecognized_keys": return `Nierozpoznane klucze${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Nieprawidowy klucz w ${issue$1.origin}`;
			case "invalid_union": return "Nieprawidowe dane wejciowe";
			case "invalid_element": return `Nieprawidowa warto w ${issue$1.origin}`;
			default: return `Nieprawidowe dane wejciowe`;
		}
	};
};
function pl_default() {
	return { localeError: error$14() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/pt.js
const error$13 = () => {
	const Sizable = {
		string: {
			unit: "caracteres",
			verb: "ter"
		},
		file: {
			unit: "bytes",
			verb: "ter"
		},
		array: {
			unit: "itens",
			verb: "ter"
		},
		set: {
			unit: "itens",
			verb: "ter"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "padro",
		email: "endereo de e-mail",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data e hora ISO",
		date: "data ISO",
		time: "hora ISO",
		duration: "durao ISO",
		ipv4: "endereo IPv4",
		ipv6: "endereo IPv6",
		cidrv4: "faixa de IPv4",
		cidrv6: "faixa de IPv6",
		base64: "texto codificado em base64",
		base64url: "URL codificada em base64",
		json_string: "texto JSON",
		e164: "nmero E.164",
		jwt: "JWT",
		template_literal: "entrada"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nmero",
		null: "nulo"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Tipo invlido: esperado instanceof ${issue$1.expected}, recebido ${received}`;
				return `Tipo invlido: esperado ${expected}, recebido ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entrada invlida: esperado ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opo invlida: esperada uma das ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Muito grande: esperado que ${issue$1.origin ?? "valor"} tivesse ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementos"}`;
				return `Muito grande: esperado que ${issue$1.origin ?? "valor"} fosse ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Muito pequeno: esperado que ${issue$1.origin} tivesse ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Muito pequeno: esperado que ${issue$1.origin} fosse ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Texto invlido: deve comear com "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Texto invlido: deve terminar com "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Texto invlido: deve incluir "${_issue.includes}"`;
				if (_issue.format === "regex") return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} invlido`;
			}
			case "not_multiple_of": return `Nmero invlido: deve ser mltiplo de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Chave${issue$1.keys.length > 1 ? "s" : ""} desconhecida${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Chave invlida em ${issue$1.origin}`;
			case "invalid_union": return "Entrada invlida";
			case "invalid_element": return `Valor invlido em ${issue$1.origin}`;
			default: return `Campo invlido`;
		}
	};
};
function pt_default() {
	return { localeError: error$13() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
	const absCount = Math.abs(count);
	const lastDigit = absCount % 10;
	const lastTwoDigits = absCount % 100;
	if (lastTwoDigits >= 11 && lastTwoDigits <= 19) return many;
	if (lastDigit === 1) return one;
	if (lastDigit >= 2 && lastDigit <= 4) return few;
	return many;
}
const error$12 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		file: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		array: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		set: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "email ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "   base64",
		base64url: "   base64url",
		json_string: "JSON ",
		e164: " E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected},  ${received}`;
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const unit = getRussianPlural(Number(issue$1.maximum), sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return `  : ,  ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()} ${unit}`;
				}
				return `  : ,  ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const unit = getRussianPlural(Number(issue$1.minimum), sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return `  : ,  ${issue$1.origin}   ${adj}${issue$1.minimum.toString()} ${unit}`;
				}
				return `  : ,  ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :    "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :    ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return "  ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return `  `;
		}
	};
};
function ru_default() {
	return { localeError: error$12() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/sl.js
const error$11 = () => {
	const Sizable = {
		string: {
			unit: "znakov",
			verb: "imeti"
		},
		file: {
			unit: "bajtov",
			verb: "imeti"
		},
		array: {
			unit: "elementov",
			verb: "imeti"
		},
		set: {
			unit: "elementov",
			verb: "imeti"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "vnos",
		email: "e-potni naslov",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datum in as",
		date: "ISO datum",
		time: "ISO as",
		duration: "ISO trajanje",
		ipv4: "IPv4 naslov",
		ipv6: "IPv6 naslov",
		cidrv4: "obseg IPv4",
		cidrv6: "obseg IPv6",
		base64: "base64 kodiran niz",
		base64url: "base64url kodiran niz",
		json_string: "JSON niz",
		e164: "E.164 tevilka",
		jwt: "JWT",
		template_literal: "vnos"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "tevilo",
		array: "tabela"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Neveljaven vnos: priakovano instanceof ${issue$1.expected}, prejeto ${received}`;
				return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue$1.values[0])}`;
				return `Neveljavna monost: priakovano eno izmed ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Preveliko: priakovano, da bo ${issue$1.origin ?? "vrednost"} imelo ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementov"}`;
				return `Preveliko: priakovano, da bo ${issue$1.origin ?? "vrednost"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Premajhno: priakovano, da bo ${issue$1.origin} imelo ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Premajhno: priakovano, da bo ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
				if (_issue.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
				return `Neveljaven ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Neveljavno tevilo: mora biti vekratnik ${issue$1.divisor}`;
			case "unrecognized_keys": return `Neprepoznan${issue$1.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Neveljaven klju v ${issue$1.origin}`;
			case "invalid_union": return "Neveljaven vnos";
			case "invalid_element": return `Neveljavna vrednost v ${issue$1.origin}`;
			default: return "Neveljaven vnos";
		}
	};
};
function sl_default() {
	return { localeError: error$11() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/sv.js
const error$10 = () => {
	const Sizable = {
		string: {
			unit: "tecken",
			verb: "att ha"
		},
		file: {
			unit: "bytes",
			verb: "att ha"
		},
		array: {
			unit: "objekt",
			verb: "att innehlla"
		},
		set: {
			unit: "objekt",
			verb: "att innehlla"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "reguljrt uttryck",
		email: "e-postadress",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-datum och tid",
		date: "ISO-datum",
		time: "ISO-tid",
		duration: "ISO-varaktighet",
		ipv4: "IPv4-intervall",
		ipv6: "IPv6-intervall",
		cidrv4: "IPv4-spektrum",
		cidrv6: "IPv6-spektrum",
		base64: "base64-kodad strng",
		base64url: "base64url-kodad strng",
		json_string: "JSON-strng",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "mall-literal"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "antal",
		array: "lista"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Ogiltig inmatning: frvntat instanceof ${issue$1.expected}, fick ${received}`;
				return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ogiltigt val: frvntade en av ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Fr stor(t): frvntade ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "element"}`;
				return `Fr stor(t): frvntat ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Fr lite(t): frvntade ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Fr lite(t): frvntade ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
				if (_issue.format === "regex") return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
				return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ogiltigt tal: mste vara en multipel av ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ogiltig nyckel i ${issue$1.origin ?? "vrdet"}`;
			case "invalid_union": return "Ogiltig input";
			case "invalid_element": return `Ogiltigt vrde i ${issue$1.origin ?? "vrdet"}`;
			default: return `Ogiltig input`;
		}
	};
};
function sv_default() {
	return { localeError: error$10() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ta.js
const error$9 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO  ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO  ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64-encoded ",
		base64url: "base64url-encoded ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: "",
		null: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` :  instanceof ${issue$1.expected},  ${received}`;
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :  ${joinValues(issue$1.values, "|")}  `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :  ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}   `;
				return ` :  ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()}   `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :  ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}   `;
				return ` :  ${issue$1.origin} ${adj}${issue$1.minimum.toString()}   `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` : "${_issue.prefix}"   `;
				if (_issue.format === "ends_with") return ` : "${_issue.suffix}"   `;
				if (_issue.format === "includes") return ` : "${_issue.includes}"   `;
				if (_issue.format === "regex") return ` : ${_issue.pattern}   `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` : ${issue$1.divisor}    `;
			case "unrecognized_keys": return `  ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin}   `;
			case "invalid_union": return " ";
			case "invalid_element": return `${issue$1.origin}   `;
			default: return ` `;
		}
	};
};
function ta_default() {
	return { localeError: error$9() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/th.js
const error$8 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: " ISO",
		date: " ISO",
		time: " ISO",
		duration: " ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: " IP  IPv4",
		cidrv6: " IP  IPv6",
		base64: " Base64",
		base64url: " Base64  URL",
		json_string: " JSON",
		e164: " (E.164)",
		jwt: " JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: " (Array)",
		null: " (null)"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `:  instanceof ${issue$1.expected}  ${received}`;
				return `:  ${expected}  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `:  ${stringifyPrimitive(issue$1.values[0])}`;
				return `:  ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return `: ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin} ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				return `: ${issue$1.origin} ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `:  "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `:  "${_issue.suffix}"`;
				if (_issue.format === "includes") return `:  "${_issue.includes}" `;
				if (_issue.format === "regex") return `:  ${_issue.pattern}`;
				return `: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `:  ${issue$1.divisor} `;
			case "unrecognized_keys": return `: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return ` ${issue$1.origin}`;
			case "invalid_union": return ": ";
			case "invalid_element": return ` ${issue$1.origin}`;
			default: return ``;
		}
	};
};
function th_default() {
	return { localeError: error$8() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/tr.js
const error$7 = () => {
	const Sizable = {
		string: {
			unit: "karakter",
			verb: "olmal"
		},
		file: {
			unit: "bayt",
			verb: "olmal"
		},
		array: {
			unit: "e",
			verb: "olmal"
		},
		set: {
			unit: "e",
			verb: "olmal"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "girdi",
		email: "e-posta adresi",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO tarih ve saat",
		date: "ISO tarih",
		time: "ISO saat",
		duration: "ISO sre",
		ipv4: "IPv4 adresi",
		ipv6: "IPv6 adresi",
		cidrv4: "IPv4 aral",
		cidrv6: "IPv6 aral",
		base64: "base64 ile ifrelenmi metin",
		base64url: "base64url ile ifrelenmi metin",
		json_string: "JSON dizesi",
		e164: "E.164 says",
		jwt: "JWT",
		template_literal: "ablon dizesi"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Geersiz deer: beklenen instanceof ${issue$1.expected}, alnan ${received}`;
				return `Geersiz deer: beklenen ${expected}, alnan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Geersiz deer: beklenen ${stringifyPrimitive(issue$1.values[0])}`;
				return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ok byk: beklenen ${issue$1.origin ?? "deer"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "e"}`;
				return `ok byk: beklenen ${issue$1.origin ?? "deer"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ok kk: beklenen ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `ok kk: beklenen ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Geersiz metin: "${_issue.prefix}" ile balamal`;
				if (_issue.format === "ends_with") return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
				if (_issue.format === "includes") return `Geersiz metin: "${_issue.includes}" iermeli`;
				if (_issue.format === "regex") return `Geersiz metin: ${_issue.pattern} desenine uymal`;
				return `Geersiz ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Geersiz say: ${issue$1.divisor} ile tam blnebilmeli`;
			case "unrecognized_keys": return `Tannmayan anahtar${issue$1.keys.length > 1 ? "lar" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} iinde geersiz anahtar`;
			case "invalid_union": return "Geersiz deer";
			case "invalid_element": return `${issue$1.origin} iinde geersiz deer`;
			default: return `Geersiz deer`;
		}
	};
};
function tr_default() {
	return { localeError: error$7() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/uk.js
const error$6 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: " ",
		email: "  ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "   ISO",
		date: " ISO",
		time: " ISO",
		duration: " ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: " IPv4",
		cidrv6: " IPv6",
		base64: "   base64",
		base64url: "   base64url",
		json_string: " JSON",
		e164: " E.164",
		jwt: "JWT",
		template_literal: " "
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `  :  instanceof ${issue$1.expected},  ${received}`;
				return `  :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ,  ${issue$1.origin ?? ""} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` : ,  ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ,  ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return ` : ,  ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :    "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :    ${issue$1.divisor}`;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return "  ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return `  `;
		}
	};
};
function uk_default() {
	return { localeError: error$6() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ua.js
/** @deprecated Use `uk` instead. */
function ua_default() {
	return uk_default();
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/ur.js
const error$5 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: " ",
		email: "  ",
		url: "  ",
		emoji: "",
		uuid: "   ",
		uuidv4: "     4",
		uuidv6: "     6",
		nanoid: "  ",
		guid: "   ",
		cuid: "   ",
		cuid2: "    2",
		ulid: "   ",
		xid: "  ",
		ksuid: "    ",
		datetime: "    ",
		date: "   ",
		time: "   ",
		duration: "   ",
		ipv4: "   4 ",
		ipv6: "   6 ",
		cidrv4: "   4 ",
		cidrv6: "   6 ",
		base64: " 64   ",
		base64url: " 64      ",
		json_string: "    ",
		e164: " 164 ",
		jwt: "  ",
		template_literal: " "
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: "",
		null: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `  : instanceof ${issue$1.expected}   ${received}  `;
				return `  : ${expected}   ${received}  `;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  : ${stringifyPrimitive(issue$1.values[0])}  `;
				return ` : ${joinValues(issue$1.values, "|")}     `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}   `;
				return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}   `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit}   `;
				return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}   `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` : "${_issue.prefix}"    `;
				if (_issue.format === "ends_with") return ` : "${_issue.suffix}"    `;
				if (_issue.format === "includes") return ` : "${_issue.includes}"   `;
				if (_issue.format === "regex") return ` :  ${_issue.pattern}    `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` : ${issue$1.divisor}    `;
			case "unrecognized_keys": return `   ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, " ")}`;
			case "invalid_key": return `${issue$1.origin}   `;
			case "invalid_union": return "  ";
			case "invalid_element": return `${issue$1.origin}   `;
			default: return `  `;
		}
	};
};
function ur_default() {
	return { localeError: error$5() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/uz.js
const error$4 = () => {
	const Sizable = {
		string: {
			unit: "belgi",
			verb: "bolishi kerak"
		},
		file: {
			unit: "bayt",
			verb: "bolishi kerak"
		},
		array: {
			unit: "element",
			verb: "bolishi kerak"
		},
		set: {
			unit: "element",
			verb: "bolishi kerak"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "kirish",
		email: "elektron pochta manzili",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO sana va vaqti",
		date: "ISO sana",
		time: "ISO vaqt",
		duration: "ISO davomiylik",
		ipv4: "IPv4 manzil",
		ipv6: "IPv6 manzil",
		mac: "MAC manzil",
		cidrv4: "IPv4 diapazon",
		cidrv6: "IPv6 diapazon",
		base64: "base64 kodlangan satr",
		base64url: "base64url kodlangan satr",
		json_string: "JSON satr",
		e164: "E.164 raqam",
		jwt: "JWT",
		template_literal: "kirish"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "raqam",
		array: "massiv"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `Notogri kirish: kutilgan instanceof ${issue$1.expected}, qabul qilingan ${received}`;
				return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Notogri kirish: kutilgan ${stringifyPrimitive(issue$1.values[0])}`;
				return `Notogri variant: quyidagilardan biri kutilgan ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Juda katta: kutilgan ${issue$1.origin ?? "qiymat"} ${adj}${issue$1.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
				return `Juda katta: kutilgan ${issue$1.origin ?? "qiymat"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Juda kichik: kutilgan ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
				return `Juda kichik: kutilgan ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
				if (_issue.format === "ends_with") return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;
				if (_issue.format === "includes") return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;
				if (_issue.format === "regex") return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
				return `Notogri ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Notogri raqam: ${issue$1.divisor} ning karralisi bolishi kerak`;
			case "unrecognized_keys": return `Nomalum kalit${issue$1.keys.length > 1 ? "lar" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} dagi kalit notogri`;
			case "invalid_union": return "Notogri kirish";
			case "invalid_element": return `${issue$1.origin} da notogri qiymat`;
			default: return `Notogri kirish`;
		}
	};
};
function uz_default() {
	return { localeError: error$4() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/vi.js
const error$3 = () => {
	const Sizable = {
		string: {
			unit: "k t",
			verb: "c"
		},
		file: {
			unit: "byte",
			verb: "c"
		},
		array: {
			unit: "phn t",
			verb: "c"
		},
		set: {
			unit: "phn t",
			verb: "c"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "u vo",
		email: "a ch email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ngy gi ISO",
		date: "ngy ISO",
		time: "gi ISO",
		duration: "khong thi gian ISO",
		ipv4: "a ch IPv4",
		ipv6: "a ch IPv6",
		cidrv4: "di IPv4",
		cidrv6: "di IPv6",
		base64: "chui m ha base64",
		base64url: "chui m ha base64url",
		json_string: "chui JSON",
		e164: "s E.164",
		jwt: "JWT",
		template_literal: "u vo"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "s",
		array: "mng"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `u vo khng hp l: mong i instanceof ${issue$1.expected}, nhn c ${received}`;
				return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `u vo khng hp l: mong i ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Qu ln: mong i ${issue$1.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "phn t"}`;
				return `Qu ln: mong i ${issue$1.origin ?? "gi tr"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Qu nh: mong i ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `Qu nh: mong i ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
				if (_issue.format === "regex") return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} khng hp l`;
			}
			case "not_multiple_of": return `S khng hp l: phi l bi s ca ${issue$1.divisor}`;
			case "unrecognized_keys": return `Kha khng c nhn dng: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Kha khng hp l trong ${issue$1.origin}`;
			case "invalid_union": return "u vo khng hp l";
			case "invalid_element": return `Gi tr khng hp l trong ${issue$1.origin}`;
			default: return `u vo khng hp l`;
		}
	};
};
function vi_default() {
	return { localeError: error$3() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/zh-CN.js
const error$2 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO",
		date: "ISO",
		time: "ISO",
		duration: "ISO",
		ipv4: "IPv4",
		ipv6: "IPv6",
		cidrv4: "IPv4",
		cidrv6: "IPv6",
		base64: "base64",
		base64url: "base64url",
		json_string: "JSON",
		e164: "E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: "",
		null: "(null)"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` instanceof ${issue$1.expected} ${received}`;
				return ` ${expected} ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` ${stringifyPrimitive(issue$1.values[0])}`;
				return ` ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return ` ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` "${_issue.prefix}" `;
				if (_issue.format === "ends_with") return ` "${_issue.suffix}" `;
				if (_issue.format === "includes") return ` "${_issue.includes}"`;
				if (_issue.format === "regex") return ` ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` ${issue$1.divisor} `;
			case "unrecognized_keys": return `(key): ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} (key)`;
			case "invalid_union": return "";
			case "invalid_element": return `${issue$1.origin} (value)`;
			default: return ``;
		}
	};
};
function zh_CN_default() {
	return { localeError: error$2() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/zh-TW.js
const error$1 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64 ",
		base64url: "base64url ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return ` instanceof ${issue$1.expected} ${received}`;
				return ` ${expected} ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` ${stringifyPrimitive(issue$1.values[0])}`;
				return ` ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return ` ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` "${_issue.prefix}" `;
				if (_issue.format === "ends_with") return ` "${_issue.suffix}" `;
				if (_issue.format === "includes") return ` "${_issue.includes}"`;
				if (_issue.format === "regex") return ` ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` ${issue$1.divisor} `;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""}${joinValues(issue$1.keys, "")}`;
			case "invalid_key": return `${issue$1.origin} `;
			case "invalid_union": return "";
			case "invalid_element": return `${issue$1.origin} `;
			default: return ``;
		}
	};
};
function zh_TW_default() {
	return { localeError: error$1() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/yo.js
const error = () => {
	const Sizable = {
		string: {
			unit: "mi",
			verb: "n"
		},
		file: {
			unit: "bytes",
			verb: "n"
		},
		array: {
			unit: "nkan",
			verb: "n"
		},
		set: {
			unit: "nkan",
			verb: "n"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "r bwl",
		email: "drs ml",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "kk ISO",
		date: "j ISO",
		time: "kk ISO",
		duration: "kk t p ISO",
		ipv4: "drs IPv4",
		ipv6: "drs IPv6",
		cidrv4: "gbgb IPv4",
		cidrv6: "gbgb IPv6",
		base64: "r t a k n base64",
		base64url: "r base64url",
		json_string: "r JSON",
		e164: "nmb E.164",
		jwt: "JWT",
		template_literal: "r bwl"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nmb",
		array: "akop"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) return `bwl ae: a n lti fi instanceof ${issue$1.expected}, m a r ${received}`;
				return `bwl ae: a n lti fi ${expected}, m a r ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `bwl ae: a n lti fi ${stringifyPrimitive(issue$1.values[0])}`;
				return `yn ae: yan kan lra ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `T p j: a n lti j p ${issue$1.origin ?? "iye"} ${sizing.verb} ${adj}${issue$1.maximum} ${sizing.unit}`;
				return `T p j: a n lti j ${adj}${issue$1.maximum}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Kr ju: a n lti j p ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum} ${sizing.unit}`;
				return `Kr ju: a n lti j ${adj}${issue$1.minimum}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `r ae: gbd br pl "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `r ae: gbd par pl "${_issue.suffix}"`;
				if (_issue.format === "includes") return `r ae: gbd n "${_issue.includes}"`;
				if (_issue.format === "regex") return `r ae: gbd b pr mu ${_issue.pattern}`;
				return `Ae: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nmb ae: gbd j y ppn ti ${issue$1.divisor}`;
			case "unrecognized_keys": return `Btn m: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Btn ae nn ${issue$1.origin}`;
			case "invalid_union": return "bwl ae";
			case "invalid_element": return `Iye ae nn ${issue$1.origin}`;
			default: return "bwl ae";
		}
	};
};
function yo_default() {
	return { localeError: error() };
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/locales/index.js
var locales_exports = /* @__PURE__ */ __exportAll({
	ar: () => ar_default,
	az: () => az_default,
	be: () => be_default,
	bg: () => bg_default,
	ca: () => ca_default,
	cs: () => cs_default,
	da: () => da_default,
	de: () => de_default,
	en: () => en_default,
	eo: () => eo_default,
	es: () => es_default,
	fa: () => fa_default,
	fi: () => fi_default,
	fr: () => fr_default,
	frCA: () => fr_CA_default,
	he: () => he_default,
	hu: () => hu_default,
	hy: () => hy_default,
	id: () => id_default,
	is: () => is_default,
	it: () => it_default,
	ja: () => ja_default,
	ka: () => ka_default,
	kh: () => kh_default,
	km: () => km_default,
	ko: () => ko_default,
	lt: () => lt_default,
	mk: () => mk_default,
	ms: () => ms_default,
	nl: () => nl_default,
	no: () => no_default,
	ota: () => ota_default,
	pl: () => pl_default,
	ps: () => ps_default,
	pt: () => pt_default,
	ru: () => ru_default,
	sl: () => sl_default,
	sv: () => sv_default,
	ta: () => ta_default,
	th: () => th_default,
	tr: () => tr_default,
	ua: () => ua_default,
	uk: () => uk_default,
	ur: () => ur_default,
	uz: () => uz_default,
	vi: () => vi_default,
	yo: () => yo_default,
	zhCN: () => zh_CN_default,
	zhTW: () => zh_TW_default
});

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/registries.js
var _a;
const $output = Symbol("ZodOutput");
const $input = Symbol("ZodInput");
var $ZodRegistry = class {
	constructor() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
	}
	add(schema, ..._meta) {
		const meta$2 = _meta[0];
		this._map.set(schema, meta$2);
		if (meta$2 && typeof meta$2 === "object" && "id" in meta$2) this._idmap.set(meta$2.id, schema);
		return this;
	}
	clear() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
		return this;
	}
	remove(schema) {
		const meta$2 = this._map.get(schema);
		if (meta$2 && typeof meta$2 === "object" && "id" in meta$2) this._idmap.delete(meta$2.id);
		this._map.delete(schema);
		return this;
	}
	get(schema) {
		const p = schema._zod.parent;
		if (p) {
			const pm = { ...this.get(p) ?? {} };
			delete pm.id;
			const f = {
				...pm,
				...this._map.get(schema)
			};
			return Object.keys(f).length ? f : void 0;
		}
		return this._map.get(schema);
	}
	has(schema) {
		return this._map.has(schema);
	}
};
function registry() {
	return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/api.js
/* @__NO_SIDE_EFFECTS__ */
function _string(Class$1, params) {
	return new Class$1({
		type: "string",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedString(Class$1, params) {
	return new Class$1({
		type: "string",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _email(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "email",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _guid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "guid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv4(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v4",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv6(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v6",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv7(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v7",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _url(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _emoji(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "emoji",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nanoid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "nanoid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cuid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "cuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cuid2(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "cuid2",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ulid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "ulid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _xid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "xid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ksuid(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "ksuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ipv4(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "ipv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ipv6(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "ipv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _mac(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "mac",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cidrv4(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "cidrv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cidrv6(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "cidrv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _base64(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "base64",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _base64url(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "base64url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _e164(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "e164",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _jwt(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "jwt",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
const TimePrecision = {
	Any: null,
	Minute: -1,
	Second: 0,
	Millisecond: 3,
	Microsecond: 6
};
/* @__NO_SIDE_EFFECTS__ */
function _isoDateTime(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "datetime",
		check: "string_format",
		offset: false,
		local: false,
		precision: null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDate(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "date",
		check: "string_format",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoTime(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "time",
		check: "string_format",
		precision: null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDuration(Class$1, params) {
	return new Class$1({
		type: "string",
		format: "duration",
		check: "string_format",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _number(Class$1, params) {
	return new Class$1({
		type: "number",
		checks: [],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedNumber(Class$1, params) {
	return new Class$1({
		type: "number",
		coerce: true,
		checks: [],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int(Class$1, params) {
	return new Class$1({
		type: "number",
		check: "number_format",
		abort: false,
		format: "safeint",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _float32(Class$1, params) {
	return new Class$1({
		type: "number",
		check: "number_format",
		abort: false,
		format: "float32",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _float64(Class$1, params) {
	return new Class$1({
		type: "number",
		check: "number_format",
		abort: false,
		format: "float64",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int32(Class$1, params) {
	return new Class$1({
		type: "number",
		check: "number_format",
		abort: false,
		format: "int32",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uint32(Class$1, params) {
	return new Class$1({
		type: "number",
		check: "number_format",
		abort: false,
		format: "uint32",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _boolean(Class$1, params) {
	return new Class$1({
		type: "boolean",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedBoolean(Class$1, params) {
	return new Class$1({
		type: "boolean",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _bigint(Class$1, params) {
	return new Class$1({
		type: "bigint",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedBigint(Class$1, params) {
	return new Class$1({
		type: "bigint",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int64(Class$1, params) {
	return new Class$1({
		type: "bigint",
		check: "bigint_format",
		abort: false,
		format: "int64",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uint64(Class$1, params) {
	return new Class$1({
		type: "bigint",
		check: "bigint_format",
		abort: false,
		format: "uint64",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _symbol(Class$1, params) {
	return new Class$1({
		type: "symbol",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _undefined$1(Class$1, params) {
	return new Class$1({
		type: "undefined",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _null$1(Class$1, params) {
	return new Class$1({
		type: "null",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _any(Class$1) {
	return new Class$1({ type: "any" });
}
/* @__NO_SIDE_EFFECTS__ */
function _unknown(Class$1) {
	return new Class$1({ type: "unknown" });
}
/* @__NO_SIDE_EFFECTS__ */
function _never(Class$1, params) {
	return new Class$1({
		type: "never",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _void$1(Class$1, params) {
	return new Class$1({
		type: "void",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _date(Class$1, params) {
	return new Class$1({
		type: "date",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedDate(Class$1, params) {
	return new Class$1({
		type: "date",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nan(Class$1, params) {
	return new Class$1({
		type: "nan",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lt(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lte(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _gt(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _gte(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _positive(params) {
	return /* @__PURE__ */ _gt(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _negative(params) {
	return /* @__PURE__ */ _lt(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _nonpositive(params) {
	return /* @__PURE__ */ _lte(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _nonnegative(params) {
	return /* @__PURE__ */ _gte(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _multipleOf(value, params) {
	return new $ZodCheckMultipleOf({
		check: "multiple_of",
		...normalizeParams(params),
		value
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _maxSize(maximum, params) {
	return new $ZodCheckMaxSize({
		check: "max_size",
		...normalizeParams(params),
		maximum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _minSize(minimum, params) {
	return new $ZodCheckMinSize({
		check: "min_size",
		...normalizeParams(params),
		minimum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _size(size, params) {
	return new $ZodCheckSizeEquals({
		check: "size_equals",
		...normalizeParams(params),
		size
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _maxLength(maximum, params) {
	return new $ZodCheckMaxLength({
		check: "max_length",
		...normalizeParams(params),
		maximum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _minLength(minimum, params) {
	return new $ZodCheckMinLength({
		check: "min_length",
		...normalizeParams(params),
		minimum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _length(length, params) {
	return new $ZodCheckLengthEquals({
		check: "length_equals",
		...normalizeParams(params),
		length
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _regex(pattern, params) {
	return new $ZodCheckRegex({
		check: "string_format",
		format: "regex",
		...normalizeParams(params),
		pattern
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lowercase(params) {
	return new $ZodCheckLowerCase({
		check: "string_format",
		format: "lowercase",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uppercase(params) {
	return new $ZodCheckUpperCase({
		check: "string_format",
		format: "uppercase",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _includes(includes, params) {
	return new $ZodCheckIncludes({
		check: "string_format",
		format: "includes",
		...normalizeParams(params),
		includes
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _startsWith(prefix, params) {
	return new $ZodCheckStartsWith({
		check: "string_format",
		format: "starts_with",
		...normalizeParams(params),
		prefix
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _endsWith(suffix, params) {
	return new $ZodCheckEndsWith({
		check: "string_format",
		format: "ends_with",
		...normalizeParams(params),
		suffix
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _property(property, schema, params) {
	return new $ZodCheckProperty({
		check: "property",
		property,
		schema,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _mime(types, params) {
	return new $ZodCheckMimeType({
		check: "mime_type",
		mime: types,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _overwrite(tx) {
	return new $ZodCheckOverwrite({
		check: "overwrite",
		tx
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _normalize(form) {
	return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
/* @__NO_SIDE_EFFECTS__ */
function _trim() {
	return /* @__PURE__ */ _overwrite((input) => input.trim());
}
/* @__NO_SIDE_EFFECTS__ */
function _toLowerCase() {
	return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
/* @__NO_SIDE_EFFECTS__ */
function _toUpperCase() {
	return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
/* @__NO_SIDE_EFFECTS__ */
function _slugify() {
	return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
/* @__NO_SIDE_EFFECTS__ */
function _array(Class$1, element, params) {
	return new Class$1({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _union(Class$1, options, params) {
	return new Class$1({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
function _xor(Class$1, options, params) {
	return new Class$1({
		type: "union",
		options,
		inclusive: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _discriminatedUnion(Class$1, discriminator, options, params) {
	return new Class$1({
		type: "union",
		options,
		discriminator,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _intersection(Class$1, left, right) {
	return new Class$1({
		type: "intersection",
		left,
		right
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _tuple(Class$1, items, _paramsOrRest, _params) {
	const hasRest = _paramsOrRest instanceof $ZodType;
	const params = hasRest ? _params : _paramsOrRest;
	return new Class$1({
		type: "tuple",
		items,
		rest: hasRest ? _paramsOrRest : null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _record(Class$1, keyType, valueType, params) {
	return new Class$1({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _map(Class$1, keyType, valueType, params) {
	return new Class$1({
		type: "map",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _set(Class$1, valueType, params) {
	return new Class$1({
		type: "set",
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _enum$1(Class$1, values, params) {
	return new Class$1({
		type: "enum",
		entries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,
		...normalizeParams(params)
	});
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
*
* ```ts
* enum Colors { red, green, blue }
* z.enum(Colors);
* ```
*/
/* @__NO_SIDE_EFFECTS__ */
function _nativeEnum(Class$1, entries, params) {
	return new Class$1({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _literal(Class$1, value, params) {
	return new Class$1({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _file(Class$1, params) {
	return new Class$1({
		type: "file",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _transform(Class$1, fn$1) {
	return new Class$1({
		type: "transform",
		transform: fn$1
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _optional(Class$1, innerType) {
	return new Class$1({
		type: "optional",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nullable(Class$1, innerType) {
	return new Class$1({
		type: "nullable",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _default$1(Class$1, innerType, defaultValue) {
	return new Class$1({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nonoptional(Class$1, innerType, params) {
	return new Class$1({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _success(Class$1, innerType) {
	return new Class$1({
		type: "success",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _catch$1(Class$1, innerType, catchValue) {
	return new Class$1({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _pipe(Class$1, in_, out) {
	return new Class$1({
		type: "pipe",
		in: in_,
		out
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _readonly(Class$1, innerType) {
	return new Class$1({
		type: "readonly",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _templateLiteral(Class$1, parts, params) {
	return new Class$1({
		type: "template_literal",
		parts,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lazy(Class$1, getter) {
	return new Class$1({
		type: "lazy",
		getter
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _promise(Class$1, innerType) {
	return new Class$1({
		type: "promise",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _custom(Class$1, fn$1, _params) {
	const norm = normalizeParams(_params);
	norm.abort ?? (norm.abort = true);
	return new Class$1({
		type: "custom",
		check: "custom",
		fn: fn$1,
		...norm
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _refine(Class$1, fn$1, _params) {
	return new Class$1({
		type: "custom",
		check: "custom",
		fn: fn$1,
		...normalizeParams(_params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _superRefine(fn$1) {
	const ch = /* @__PURE__ */ _check((payload) => {
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = ch);
				_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
				payload.issues.push(issue(_issue));
			}
		};
		return fn$1(payload.value, payload);
	});
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function _check(fn$1, params) {
	const ch = new $ZodCheck({
		check: "custom",
		...normalizeParams(params)
	});
	ch._zod.check = fn$1;
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function describe$1(description) {
	const ch = new $ZodCheck({ check: "describe" });
	ch._zod.onattach = [(inst) => {
		const existing = globalRegistry.get(inst) ?? {};
		globalRegistry.add(inst, {
			...existing,
			description
		});
	}];
	ch._zod.check = () => {};
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function meta$1(metadata) {
	const ch = new $ZodCheck({ check: "meta" });
	ch._zod.onattach = [(inst) => {
		const existing = globalRegistry.get(inst) ?? {};
		globalRegistry.add(inst, {
			...existing,
			...metadata
		});
	}];
	ch._zod.check = () => {};
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function _stringbool(Classes, _params) {
	const params = normalizeParams(_params);
	let truthyArray = params.truthy ?? [
		"true",
		"1",
		"yes",
		"on",
		"y",
		"enabled"
	];
	let falsyArray = params.falsy ?? [
		"false",
		"0",
		"no",
		"off",
		"n",
		"disabled"
	];
	if (params.case !== "sensitive") {
		truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
		falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
	}
	const truthySet = new Set(truthyArray);
	const falsySet = new Set(falsyArray);
	const _Codec = Classes.Codec ?? $ZodCodec;
	const _Boolean = Classes.Boolean ?? $ZodBoolean;
	const codec$1 = new _Codec({
		type: "pipe",
		in: new (Classes.String ?? $ZodString)({
			type: "string",
			error: params.error
		}),
		out: new _Boolean({
			type: "boolean",
			error: params.error
		}),
		transform: ((input, payload) => {
			let data = input;
			if (params.case !== "sensitive") data = data.toLowerCase();
			if (truthySet.has(data)) return true;
			else if (falsySet.has(data)) return false;
			else {
				payload.issues.push({
					code: "invalid_value",
					expected: "stringbool",
					values: [...truthySet, ...falsySet],
					input: payload.value,
					inst: codec$1,
					continue: false
				});
				return {};
			}
		}),
		reverseTransform: ((input, _payload) => {
			if (input === true) return truthyArray[0] || "true";
			else return falsyArray[0] || "false";
		}),
		error: params.error
	});
	return codec$1;
}
/* @__NO_SIDE_EFFECTS__ */
function _stringFormat(Class$1, format, fnOrRegex, _params = {}) {
	const params = normalizeParams(_params);
	const def = {
		...normalizeParams(_params),
		check: "string_format",
		type: "string",
		format,
		fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
		...params
	};
	if (fnOrRegex instanceof RegExp) def.pattern = fnOrRegex;
	return new Class$1(def);
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
	let target = params?.target ?? "draft-2020-12";
	if (target === "draft-4") target = "draft-04";
	if (target === "draft-7") target = "draft-07";
	return {
		processors: params.processors ?? {},
		metadataRegistry: params?.metadata ?? globalRegistry,
		target,
		unrepresentable: params?.unrepresentable ?? "throw",
		override: params?.override ?? (() => {}),
		io: params?.io ?? "output",
		counter: 0,
		seen: /* @__PURE__ */ new Map(),
		cycles: params?.cycles ?? "ref",
		reused: params?.reused ?? "inline",
		external: params?.external ?? void 0
	};
}
function process$1(schema, ctx, _params = {
	path: [],
	schemaPath: []
}) {
	var _a$1;
	const def = schema._zod.def;
	const seen = ctx.seen.get(schema);
	if (seen) {
		seen.count++;
		if (_params.schemaPath.includes(schema)) seen.cycle = _params.path;
		return seen.schema;
	}
	const result = {
		schema: {},
		count: 1,
		cycle: void 0,
		path: _params.path
	};
	ctx.seen.set(schema, result);
	const overrideSchema = schema._zod.toJSONSchema?.();
	if (overrideSchema) result.schema = overrideSchema;
	else {
		const params = {
			..._params,
			schemaPath: [..._params.schemaPath, schema],
			path: _params.path
		};
		if (schema._zod.processJSONSchema) schema._zod.processJSONSchema(ctx, result.schema, params);
		else {
			const _json = result.schema;
			const processor = ctx.processors[def.type];
			if (!processor) throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
			processor(schema, ctx, _json, params);
		}
		const parent = schema._zod.parent;
		if (parent) {
			if (!result.ref) result.ref = parent;
			process$1(parent, ctx, params);
			ctx.seen.get(parent).isParent = true;
		}
	}
	const meta$2 = ctx.metadataRegistry.get(schema);
	if (meta$2) Object.assign(result.schema, meta$2);
	if (ctx.io === "input" && isTransforming(schema)) {
		delete result.schema.examples;
		delete result.schema.default;
	}
	if (ctx.io === "input" && result.schema._prefault) (_a$1 = result.schema).default ?? (_a$1.default = result.schema._prefault);
	delete result.schema._prefault;
	return ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
	const root = ctx.seen.get(schema);
	if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const idToSchema = /* @__PURE__ */ new Map();
	for (const entry of ctx.seen.entries()) {
		const id = ctx.metadataRegistry.get(entry[0])?.id;
		if (id) {
			const existing = idToSchema.get(id);
			if (existing && existing !== entry[0]) throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
			idToSchema.set(id, entry[0]);
		}
	}
	const makeURI = (entry) => {
		const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
		if (ctx.external) {
			const externalId = ctx.external.registry.get(entry[0])?.id;
			const uriGenerator = ctx.external.uri ?? ((id$1) => id$1);
			if (externalId) return { ref: uriGenerator(externalId) };
			const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
			entry[1].defId = id;
			return {
				defId: id,
				ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`
			};
		}
		if (entry[1] === root) return { ref: "#" };
		const defUriPrefix = `#/${defsSegment}/`;
		const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
		return {
			defId,
			ref: defUriPrefix + defId
		};
	};
	const extractToDef = (entry) => {
		if (entry[1].schema.$ref) return;
		const seen = entry[1];
		const { ref, defId } = makeURI(entry);
		seen.def = { ...seen.schema };
		if (defId) seen.defId = defId;
		const schema$1 = seen.schema;
		for (const key in schema$1) delete schema$1[key];
		schema$1.$ref = ref;
	};
	if (ctx.cycles === "throw") for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.cycle) throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
	}
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (schema === entry[0]) {
			extractToDef(entry);
			continue;
		}
		if (ctx.external) {
			const ext = ctx.external.registry.get(entry[0])?.id;
			if (schema !== entry[0] && ext) {
				extractToDef(entry);
				continue;
			}
		}
		if (ctx.metadataRegistry.get(entry[0])?.id) {
			extractToDef(entry);
			continue;
		}
		if (seen.cycle) {
			extractToDef(entry);
			continue;
		}
		if (seen.count > 1) {
			if (ctx.reused === "ref") {
				extractToDef(entry);
				continue;
			}
		}
	}
}
function finalize(ctx, schema) {
	const root = ctx.seen.get(schema);
	if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const flattenRef = (zodSchema) => {
		const seen = ctx.seen.get(zodSchema);
		if (seen.ref === null) return;
		const schema$1 = seen.def ?? seen.schema;
		const _cached = { ...schema$1 };
		const ref = seen.ref;
		seen.ref = null;
		if (ref) {
			flattenRef(ref);
			const refSeen = ctx.seen.get(ref);
			const refSchema = refSeen.schema;
			if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
				schema$1.allOf = schema$1.allOf ?? [];
				schema$1.allOf.push(refSchema);
			} else Object.assign(schema$1, refSchema);
			Object.assign(schema$1, _cached);
			if (zodSchema._zod.parent === ref) for (const key in schema$1) {
				if (key === "$ref" || key === "allOf") continue;
				if (!(key in _cached)) delete schema$1[key];
			}
			if (refSchema.$ref && refSeen.def) for (const key in schema$1) {
				if (key === "$ref" || key === "allOf") continue;
				if (key in refSeen.def && JSON.stringify(schema$1[key]) === JSON.stringify(refSeen.def[key])) delete schema$1[key];
			}
		}
		const parent = zodSchema._zod.parent;
		if (parent && parent !== ref) {
			flattenRef(parent);
			const parentSeen = ctx.seen.get(parent);
			if (parentSeen?.schema.$ref) {
				schema$1.$ref = parentSeen.schema.$ref;
				if (parentSeen.def) for (const key in schema$1) {
					if (key === "$ref" || key === "allOf") continue;
					if (key in parentSeen.def && JSON.stringify(schema$1[key]) === JSON.stringify(parentSeen.def[key])) delete schema$1[key];
				}
			}
		}
		ctx.override({
			zodSchema,
			jsonSchema: schema$1,
			path: seen.path ?? []
		});
	};
	for (const entry of [...ctx.seen.entries()].reverse()) flattenRef(entry[0]);
	const result = {};
	if (ctx.target === "draft-2020-12") result.$schema = "https://json-schema.org/draft/2020-12/schema";
	else if (ctx.target === "draft-07") result.$schema = "http://json-schema.org/draft-07/schema#";
	else if (ctx.target === "draft-04") result.$schema = "http://json-schema.org/draft-04/schema#";
	else if (ctx.target === "openapi-3.0") {}
	if (ctx.external?.uri) {
		const id = ctx.external.registry.get(schema)?.id;
		if (!id) throw new Error("Schema is missing an `id` property");
		result.$id = ctx.external.uri(id);
	}
	Object.assign(result, root.def ?? root.schema);
	const defs = ctx.external?.defs ?? {};
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.def && seen.defId) defs[seen.defId] = seen.def;
	}
	if (ctx.external) {} else if (Object.keys(defs).length > 0) if (ctx.target === "draft-2020-12") result.$defs = defs;
	else result.definitions = defs;
	try {
		const finalized = JSON.parse(JSON.stringify(result));
		Object.defineProperty(finalized, "~standard", {
			value: {
				...schema["~standard"],
				jsonSchema: {
					input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
					output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
				}
			},
			enumerable: false,
			writable: false
		});
		return finalized;
	} catch (_err) {
		throw new Error("Error converting schema to JSON.");
	}
}
function isTransforming(_schema, _ctx) {
	const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
	if (ctx.seen.has(_schema)) return false;
	ctx.seen.add(_schema);
	const def = _schema._zod.def;
	if (def.type === "transform") return true;
	if (def.type === "array") return isTransforming(def.element, ctx);
	if (def.type === "set") return isTransforming(def.valueType, ctx);
	if (def.type === "lazy") return isTransforming(def.getter(), ctx);
	if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") return isTransforming(def.innerType, ctx);
	if (def.type === "intersection") return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
	if (def.type === "record" || def.type === "map") return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
	if (def.type === "pipe") return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
	if (def.type === "object") {
		for (const key in def.shape) if (isTransforming(def.shape[key], ctx)) return true;
		return false;
	}
	if (def.type === "union") {
		for (const option of def.options) if (isTransforming(option, ctx)) return true;
		return false;
	}
	if (def.type === "tuple") {
		for (const item of def.items) if (isTransforming(item, ctx)) return true;
		if (def.rest && isTransforming(def.rest, ctx)) return true;
		return false;
	}
	return false;
}
/**
* Creates a toJSONSchema method for a schema instance.
* This encapsulates the logic of initializing context, processing, extracting defs, and finalizing.
*/
const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
	const ctx = initializeContext({
		...params,
		processors
	});
	process$1(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};
const createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
	const { libraryOptions, target } = params ?? {};
	const ctx = initializeContext({
		...libraryOptions ?? {},
		target,
		io,
		processors
	});
	process$1(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/json-schema-processors.js
const formatMap = {
	guid: "uuid",
	url: "uri",
	datetime: "date-time",
	json_string: "json-string",
	regex: ""
};
const stringProcessor = (schema, ctx, _json, _params) => {
	const json$1 = _json;
	json$1.type = "string";
	const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
	if (typeof minimum === "number") json$1.minLength = minimum;
	if (typeof maximum === "number") json$1.maxLength = maximum;
	if (format) {
		json$1.format = formatMap[format] ?? format;
		if (json$1.format === "") delete json$1.format;
		if (format === "time") delete json$1.format;
	}
	if (contentEncoding) json$1.contentEncoding = contentEncoding;
	if (patterns && patterns.size > 0) {
		const regexes = [...patterns];
		if (regexes.length === 1) json$1.pattern = regexes[0].source;
		else if (regexes.length > 1) json$1.allOf = [...regexes.map((regex) => ({
			...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
			pattern: regex.source
		}))];
	}
};
const numberProcessor = (schema, ctx, _json, _params) => {
	const json$1 = _json;
	const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
	if (typeof format === "string" && format.includes("int")) json$1.type = "integer";
	else json$1.type = "number";
	if (typeof exclusiveMinimum === "number") if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
		json$1.minimum = exclusiveMinimum;
		json$1.exclusiveMinimum = true;
	} else json$1.exclusiveMinimum = exclusiveMinimum;
	if (typeof minimum === "number") {
		json$1.minimum = minimum;
		if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") if (exclusiveMinimum >= minimum) delete json$1.minimum;
		else delete json$1.exclusiveMinimum;
	}
	if (typeof exclusiveMaximum === "number") if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
		json$1.maximum = exclusiveMaximum;
		json$1.exclusiveMaximum = true;
	} else json$1.exclusiveMaximum = exclusiveMaximum;
	if (typeof maximum === "number") {
		json$1.maximum = maximum;
		if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") if (exclusiveMaximum <= maximum) delete json$1.maximum;
		else delete json$1.exclusiveMaximum;
	}
	if (typeof multipleOf === "number") json$1.multipleOf = multipleOf;
};
const booleanProcessor = (_schema, _ctx, json$1, _params) => {
	json$1.type = "boolean";
};
const bigintProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("BigInt cannot be represented in JSON Schema");
};
const symbolProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Symbols cannot be represented in JSON Schema");
};
const nullProcessor = (_schema, ctx, json$1, _params) => {
	if (ctx.target === "openapi-3.0") {
		json$1.type = "string";
		json$1.nullable = true;
		json$1.enum = [null];
	} else json$1.type = "null";
};
const undefinedProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Undefined cannot be represented in JSON Schema");
};
const voidProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Void cannot be represented in JSON Schema");
};
const neverProcessor = (_schema, _ctx, json$1, _params) => {
	json$1.not = {};
};
const anyProcessor = (_schema, _ctx, _json, _params) => {};
const unknownProcessor = (_schema, _ctx, _json, _params) => {};
const dateProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Date cannot be represented in JSON Schema");
};
const enumProcessor = (schema, _ctx, json$1, _params) => {
	const def = schema._zod.def;
	const values = getEnumValues(def.entries);
	if (values.every((v) => typeof v === "number")) json$1.type = "number";
	if (values.every((v) => typeof v === "string")) json$1.type = "string";
	json$1.enum = values;
};
const literalProcessor = (schema, ctx, json$1, _params) => {
	const def = schema._zod.def;
	const vals = [];
	for (const val of def.values) if (val === void 0) {
		if (ctx.unrepresentable === "throw") throw new Error("Literal `undefined` cannot be represented in JSON Schema");
	} else if (typeof val === "bigint") if (ctx.unrepresentable === "throw") throw new Error("BigInt literals cannot be represented in JSON Schema");
	else vals.push(Number(val));
	else vals.push(val);
	if (vals.length === 0) {} else if (vals.length === 1) {
		const val = vals[0];
		json$1.type = val === null ? "null" : typeof val;
		if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") json$1.enum = [val];
		else json$1.const = val;
	} else {
		if (vals.every((v) => typeof v === "number")) json$1.type = "number";
		if (vals.every((v) => typeof v === "string")) json$1.type = "string";
		if (vals.every((v) => typeof v === "boolean")) json$1.type = "boolean";
		if (vals.every((v) => v === null)) json$1.type = "null";
		json$1.enum = vals;
	}
};
const nanProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("NaN cannot be represented in JSON Schema");
};
const templateLiteralProcessor = (schema, _ctx, json$1, _params) => {
	const _json = json$1;
	const pattern = schema._zod.pattern;
	if (!pattern) throw new Error("Pattern not found in template literal");
	_json.type = "string";
	_json.pattern = pattern.source;
};
const fileProcessor = (schema, _ctx, json$1, _params) => {
	const _json = json$1;
	const file$1 = {
		type: "string",
		format: "binary",
		contentEncoding: "binary"
	};
	const { minimum, maximum, mime } = schema._zod.bag;
	if (minimum !== void 0) file$1.minLength = minimum;
	if (maximum !== void 0) file$1.maxLength = maximum;
	if (mime) if (mime.length === 1) {
		file$1.contentMediaType = mime[0];
		Object.assign(_json, file$1);
	} else {
		Object.assign(_json, file$1);
		_json.anyOf = mime.map((m) => ({ contentMediaType: m }));
	}
	else Object.assign(_json, file$1);
};
const successProcessor = (_schema, _ctx, json$1, _params) => {
	json$1.type = "boolean";
};
const customProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Custom types cannot be represented in JSON Schema");
};
const functionProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Function types cannot be represented in JSON Schema");
};
const transformProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Transforms cannot be represented in JSON Schema");
};
const mapProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Map cannot be represented in JSON Schema");
};
const setProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Set cannot be represented in JSON Schema");
};
const arrayProcessor = (schema, ctx, _json, params) => {
	const json$1 = _json;
	const def = schema._zod.def;
	const { minimum, maximum } = schema._zod.bag;
	if (typeof minimum === "number") json$1.minItems = minimum;
	if (typeof maximum === "number") json$1.maxItems = maximum;
	json$1.type = "array";
	json$1.items = process$1(def.element, ctx, {
		...params,
		path: [...params.path, "items"]
	});
};
const objectProcessor = (schema, ctx, _json, params) => {
	const json$1 = _json;
	const def = schema._zod.def;
	json$1.type = "object";
	json$1.properties = {};
	const shape = def.shape;
	for (const key in shape) json$1.properties[key] = process$1(shape[key], ctx, {
		...params,
		path: [
			...params.path,
			"properties",
			key
		]
	});
	const allKeys = new Set(Object.keys(shape));
	const requiredKeys = new Set([...allKeys].filter((key) => {
		const v = def.shape[key]._zod;
		if (ctx.io === "input") return v.optin === void 0;
		else return v.optout === void 0;
	}));
	if (requiredKeys.size > 0) json$1.required = Array.from(requiredKeys);
	if (def.catchall?._zod.def.type === "never") json$1.additionalProperties = false;
	else if (!def.catchall) {
		if (ctx.io === "output") json$1.additionalProperties = false;
	} else if (def.catchall) json$1.additionalProperties = process$1(def.catchall, ctx, {
		...params,
		path: [...params.path, "additionalProperties"]
	});
};
const unionProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	const isExclusive = def.inclusive === false;
	const options = def.options.map((x, i) => process$1(x, ctx, {
		...params,
		path: [
			...params.path,
			isExclusive ? "oneOf" : "anyOf",
			i
		]
	}));
	if (isExclusive) json$1.oneOf = options;
	else json$1.anyOf = options;
};
const intersectionProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	const a = process$1(def.left, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			0
		]
	});
	const b = process$1(def.right, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			1
		]
	});
	const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
	json$1.allOf = [...isSimpleIntersection(a) ? a.allOf : [a], ...isSimpleIntersection(b) ? b.allOf : [b]];
};
const tupleProcessor = (schema, ctx, _json, params) => {
	const json$1 = _json;
	const def = schema._zod.def;
	json$1.type = "array";
	const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
	const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
	const prefixItems = def.items.map((x, i) => process$1(x, ctx, {
		...params,
		path: [
			...params.path,
			prefixPath,
			i
		]
	}));
	const rest = def.rest ? process$1(def.rest, ctx, {
		...params,
		path: [
			...params.path,
			restPath,
			...ctx.target === "openapi-3.0" ? [def.items.length] : []
		]
	}) : null;
	if (ctx.target === "draft-2020-12") {
		json$1.prefixItems = prefixItems;
		if (rest) json$1.items = rest;
	} else if (ctx.target === "openapi-3.0") {
		json$1.items = { anyOf: prefixItems };
		if (rest) json$1.items.anyOf.push(rest);
		json$1.minItems = prefixItems.length;
		if (!rest) json$1.maxItems = prefixItems.length;
	} else {
		json$1.items = prefixItems;
		if (rest) json$1.additionalItems = rest;
	}
	const { minimum, maximum } = schema._zod.bag;
	if (typeof minimum === "number") json$1.minItems = minimum;
	if (typeof maximum === "number") json$1.maxItems = maximum;
};
const recordProcessor = (schema, ctx, _json, params) => {
	const json$1 = _json;
	const def = schema._zod.def;
	json$1.type = "object";
	const keyType = def.keyType;
	const patterns = keyType._zod.bag?.patterns;
	if (def.mode === "loose" && patterns && patterns.size > 0) {
		const valueSchema = process$1(def.valueType, ctx, {
			...params,
			path: [
				...params.path,
				"patternProperties",
				"*"
			]
		});
		json$1.patternProperties = {};
		for (const pattern of patterns) json$1.patternProperties[pattern.source] = valueSchema;
	} else {
		if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") json$1.propertyNames = process$1(def.keyType, ctx, {
			...params,
			path: [...params.path, "propertyNames"]
		});
		json$1.additionalProperties = process$1(def.valueType, ctx, {
			...params,
			path: [...params.path, "additionalProperties"]
		});
	}
	const keyValues = keyType._zod.values;
	if (keyValues) {
		const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
		if (validKeyValues.length > 0) json$1.required = validKeyValues;
	}
};
const nullableProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	const inner = process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	if (ctx.target === "openapi-3.0") {
		seen.ref = def.innerType;
		json$1.nullable = true;
	} else json$1.anyOf = [inner, { type: "null" }];
};
const nonoptionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const defaultProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json$1.default = JSON.parse(JSON.stringify(def.defaultValue));
};
const prefaultProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	if (ctx.io === "input") json$1._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
const catchProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	let catchValue;
	try {
		catchValue = def.catchValue(void 0);
	} catch {
		throw new Error("Dynamic catch values are not supported in JSON Schema");
	}
	json$1.default = catchValue;
};
const pipeProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
	process$1(innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = innerType;
};
const readonlyProcessor = (schema, ctx, json$1, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json$1.readOnly = true;
};
const promiseProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const optionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$1(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const lazyProcessor = (schema, ctx, _json, params) => {
	const innerType = schema._zod.innerType;
	process$1(innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = innerType;
};
const allProcessors = {
	string: stringProcessor,
	number: numberProcessor,
	boolean: booleanProcessor,
	bigint: bigintProcessor,
	symbol: symbolProcessor,
	null: nullProcessor,
	undefined: undefinedProcessor,
	void: voidProcessor,
	never: neverProcessor,
	any: anyProcessor,
	unknown: unknownProcessor,
	date: dateProcessor,
	enum: enumProcessor,
	literal: literalProcessor,
	nan: nanProcessor,
	template_literal: templateLiteralProcessor,
	file: fileProcessor,
	success: successProcessor,
	custom: customProcessor,
	function: functionProcessor,
	transform: transformProcessor,
	map: mapProcessor,
	set: setProcessor,
	array: arrayProcessor,
	object: objectProcessor,
	union: unionProcessor,
	intersection: intersectionProcessor,
	tuple: tupleProcessor,
	record: recordProcessor,
	nullable: nullableProcessor,
	nonoptional: nonoptionalProcessor,
	default: defaultProcessor,
	prefault: prefaultProcessor,
	catch: catchProcessor,
	pipe: pipeProcessor,
	readonly: readonlyProcessor,
	promise: promiseProcessor,
	optional: optionalProcessor,
	lazy: lazyProcessor
};
function toJSONSchema(input, params) {
	if ("_idmap" in input) {
		const registry$1 = input;
		const ctx$1 = initializeContext({
			...params,
			processors: allProcessors
		});
		const defs = {};
		for (const entry of registry$1._idmap.entries()) {
			const [_, schema] = entry;
			process$1(schema, ctx$1);
		}
		const schemas = {};
		ctx$1.external = {
			registry: registry$1,
			uri: params?.uri,
			defs
		};
		for (const entry of registry$1._idmap.entries()) {
			const [key, schema] = entry;
			extractDefs(ctx$1, schema);
			schemas[key] = finalize(ctx$1, schema);
		}
		if (Object.keys(defs).length > 0) schemas.__shared = { [ctx$1.target === "draft-2020-12" ? "$defs" : "definitions"]: defs };
		return { schemas };
	}
	const ctx = initializeContext({
		...params,
		processors: allProcessors
	});
	process$1(input, ctx);
	extractDefs(ctx, input);
	return finalize(ctx, input);
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/json-schema-generator.js
/**
* Legacy class-based interface for JSON Schema generation.
* This class wraps the new functional implementation to provide backward compatibility.
*
* @deprecated Use the `toJSONSchema` function instead for new code.
*
* @example
* ```typescript
* // Legacy usage (still supported)
* const gen = new JSONSchemaGenerator({ target: "draft-07" });
* gen.process(schema);
* const result = gen.emit(schema);
*
* // Preferred modern usage
* const result = toJSONSchema(schema, { target: "draft-07" });
* ```
*/
var JSONSchemaGenerator = class {
	/** @deprecated Access via ctx instead */
	get metadataRegistry() {
		return this.ctx.metadataRegistry;
	}
	/** @deprecated Access via ctx instead */
	get target() {
		return this.ctx.target;
	}
	/** @deprecated Access via ctx instead */
	get unrepresentable() {
		return this.ctx.unrepresentable;
	}
	/** @deprecated Access via ctx instead */
	get override() {
		return this.ctx.override;
	}
	/** @deprecated Access via ctx instead */
	get io() {
		return this.ctx.io;
	}
	/** @deprecated Access via ctx instead */
	get counter() {
		return this.ctx.counter;
	}
	set counter(value) {
		this.ctx.counter = value;
	}
	/** @deprecated Access via ctx instead */
	get seen() {
		return this.ctx.seen;
	}
	constructor(params) {
		let normalizedTarget = params?.target ?? "draft-2020-12";
		if (normalizedTarget === "draft-4") normalizedTarget = "draft-04";
		if (normalizedTarget === "draft-7") normalizedTarget = "draft-07";
		this.ctx = initializeContext({
			processors: allProcessors,
			target: normalizedTarget,
			...params?.metadata && { metadata: params.metadata },
			...params?.unrepresentable && { unrepresentable: params.unrepresentable },
			...params?.override && { override: params.override },
			...params?.io && { io: params.io }
		});
	}
	/**
	* Process a schema to prepare it for JSON Schema generation.
	* This must be called before emit().
	*/
	process(schema, _params = {
		path: [],
		schemaPath: []
	}) {
		return process$1(schema, this.ctx, _params);
	}
	/**
	* Emit the final JSON Schema after processing.
	* Must call process() first.
	*/
	emit(schema, _params) {
		if (_params) {
			if (_params.cycles) this.ctx.cycles = _params.cycles;
			if (_params.reused) this.ctx.reused = _params.reused;
			if (_params.external) this.ctx.external = _params.external;
		}
		extractDefs(this.ctx, schema);
		const { "~standard": _, ...plainResult } = finalize(this.ctx, schema);
		return plainResult;
	}
};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/core/index.js
var core_exports = /* @__PURE__ */ __exportAll({
	$ZodAny: () => $ZodAny,
	$ZodArray: () => $ZodArray,
	$ZodAsyncError: () => $ZodAsyncError,
	$ZodBase64: () => $ZodBase64,
	$ZodBase64URL: () => $ZodBase64URL,
	$ZodBigInt: () => $ZodBigInt,
	$ZodBigIntFormat: () => $ZodBigIntFormat,
	$ZodBoolean: () => $ZodBoolean,
	$ZodCIDRv4: () => $ZodCIDRv4,
	$ZodCIDRv6: () => $ZodCIDRv6,
	$ZodCUID: () => $ZodCUID,
	$ZodCUID2: () => $ZodCUID2,
	$ZodCatch: () => $ZodCatch,
	$ZodCheck: () => $ZodCheck,
	$ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
	$ZodCheckEndsWith: () => $ZodCheckEndsWith,
	$ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
	$ZodCheckIncludes: () => $ZodCheckIncludes,
	$ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
	$ZodCheckLessThan: () => $ZodCheckLessThan,
	$ZodCheckLowerCase: () => $ZodCheckLowerCase,
	$ZodCheckMaxLength: () => $ZodCheckMaxLength,
	$ZodCheckMaxSize: () => $ZodCheckMaxSize,
	$ZodCheckMimeType: () => $ZodCheckMimeType,
	$ZodCheckMinLength: () => $ZodCheckMinLength,
	$ZodCheckMinSize: () => $ZodCheckMinSize,
	$ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
	$ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
	$ZodCheckOverwrite: () => $ZodCheckOverwrite,
	$ZodCheckProperty: () => $ZodCheckProperty,
	$ZodCheckRegex: () => $ZodCheckRegex,
	$ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
	$ZodCheckStartsWith: () => $ZodCheckStartsWith,
	$ZodCheckStringFormat: () => $ZodCheckStringFormat,
	$ZodCheckUpperCase: () => $ZodCheckUpperCase,
	$ZodCodec: () => $ZodCodec,
	$ZodCustom: () => $ZodCustom,
	$ZodCustomStringFormat: () => $ZodCustomStringFormat,
	$ZodDate: () => $ZodDate,
	$ZodDefault: () => $ZodDefault,
	$ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
	$ZodE164: () => $ZodE164,
	$ZodEmail: () => $ZodEmail,
	$ZodEmoji: () => $ZodEmoji,
	$ZodEncodeError: () => $ZodEncodeError,
	$ZodEnum: () => $ZodEnum,
	$ZodError: () => $ZodError,
	$ZodExactOptional: () => $ZodExactOptional,
	$ZodFile: () => $ZodFile,
	$ZodFunction: () => $ZodFunction,
	$ZodGUID: () => $ZodGUID,
	$ZodIPv4: () => $ZodIPv4,
	$ZodIPv6: () => $ZodIPv6,
	$ZodISODate: () => $ZodISODate,
	$ZodISODateTime: () => $ZodISODateTime,
	$ZodISODuration: () => $ZodISODuration,
	$ZodISOTime: () => $ZodISOTime,
	$ZodIntersection: () => $ZodIntersection,
	$ZodJWT: () => $ZodJWT,
	$ZodKSUID: () => $ZodKSUID,
	$ZodLazy: () => $ZodLazy,
	$ZodLiteral: () => $ZodLiteral,
	$ZodMAC: () => $ZodMAC,
	$ZodMap: () => $ZodMap,
	$ZodNaN: () => $ZodNaN,
	$ZodNanoID: () => $ZodNanoID,
	$ZodNever: () => $ZodNever,
	$ZodNonOptional: () => $ZodNonOptional,
	$ZodNull: () => $ZodNull,
	$ZodNullable: () => $ZodNullable,
	$ZodNumber: () => $ZodNumber,
	$ZodNumberFormat: () => $ZodNumberFormat,
	$ZodObject: () => $ZodObject,
	$ZodObjectJIT: () => $ZodObjectJIT,
	$ZodOptional: () => $ZodOptional,
	$ZodPipe: () => $ZodPipe,
	$ZodPrefault: () => $ZodPrefault,
	$ZodPromise: () => $ZodPromise,
	$ZodReadonly: () => $ZodReadonly,
	$ZodRealError: () => $ZodRealError,
	$ZodRecord: () => $ZodRecord,
	$ZodRegistry: () => $ZodRegistry,
	$ZodSet: () => $ZodSet,
	$ZodString: () => $ZodString,
	$ZodStringFormat: () => $ZodStringFormat,
	$ZodSuccess: () => $ZodSuccess,
	$ZodSymbol: () => $ZodSymbol,
	$ZodTemplateLiteral: () => $ZodTemplateLiteral,
	$ZodTransform: () => $ZodTransform,
	$ZodTuple: () => $ZodTuple,
	$ZodType: () => $ZodType,
	$ZodULID: () => $ZodULID,
	$ZodURL: () => $ZodURL,
	$ZodUUID: () => $ZodUUID,
	$ZodUndefined: () => $ZodUndefined,
	$ZodUnion: () => $ZodUnion,
	$ZodUnknown: () => $ZodUnknown,
	$ZodVoid: () => $ZodVoid,
	$ZodXID: () => $ZodXID,
	$ZodXor: () => $ZodXor,
	$brand: () => $brand,
	$constructor: () => $constructor,
	$input: () => $input,
	$output: () => $output,
	Doc: () => Doc,
	JSONSchema: () => json_schema_exports,
	JSONSchemaGenerator: () => JSONSchemaGenerator,
	NEVER: () => NEVER,
	TimePrecision: () => TimePrecision,
	_any: () => _any,
	_array: () => _array,
	_base64: () => _base64,
	_base64url: () => _base64url,
	_bigint: () => _bigint,
	_boolean: () => _boolean,
	_catch: () => _catch$1,
	_check: () => _check,
	_cidrv4: () => _cidrv4,
	_cidrv6: () => _cidrv6,
	_coercedBigint: () => _coercedBigint,
	_coercedBoolean: () => _coercedBoolean,
	_coercedDate: () => _coercedDate,
	_coercedNumber: () => _coercedNumber,
	_coercedString: () => _coercedString,
	_cuid: () => _cuid,
	_cuid2: () => _cuid2,
	_custom: () => _custom,
	_date: () => _date,
	_decode: () => _decode,
	_decodeAsync: () => _decodeAsync,
	_default: () => _default$1,
	_discriminatedUnion: () => _discriminatedUnion,
	_e164: () => _e164,
	_email: () => _email,
	_emoji: () => _emoji,
	_encode: () => _encode,
	_encodeAsync: () => _encodeAsync,
	_endsWith: () => _endsWith,
	_enum: () => _enum$1,
	_file: () => _file,
	_float32: () => _float32,
	_float64: () => _float64,
	_gt: () => _gt,
	_gte: () => _gte,
	_guid: () => _guid,
	_includes: () => _includes,
	_int: () => _int,
	_int32: () => _int32,
	_int64: () => _int64,
	_intersection: () => _intersection,
	_ipv4: () => _ipv4,
	_ipv6: () => _ipv6,
	_isoDate: () => _isoDate,
	_isoDateTime: () => _isoDateTime,
	_isoDuration: () => _isoDuration,
	_isoTime: () => _isoTime,
	_jwt: () => _jwt,
	_ksuid: () => _ksuid,
	_lazy: () => _lazy,
	_length: () => _length,
	_literal: () => _literal,
	_lowercase: () => _lowercase,
	_lt: () => _lt,
	_lte: () => _lte,
	_mac: () => _mac,
	_map: () => _map,
	_max: () => _lte,
	_maxLength: () => _maxLength,
	_maxSize: () => _maxSize,
	_mime: () => _mime,
	_min: () => _gte,
	_minLength: () => _minLength,
	_minSize: () => _minSize,
	_multipleOf: () => _multipleOf,
	_nan: () => _nan,
	_nanoid: () => _nanoid,
	_nativeEnum: () => _nativeEnum,
	_negative: () => _negative,
	_never: () => _never,
	_nonnegative: () => _nonnegative,
	_nonoptional: () => _nonoptional,
	_nonpositive: () => _nonpositive,
	_normalize: () => _normalize,
	_null: () => _null$1,
	_nullable: () => _nullable,
	_number: () => _number,
	_optional: () => _optional,
	_overwrite: () => _overwrite,
	_parse: () => _parse,
	_parseAsync: () => _parseAsync,
	_pipe: () => _pipe,
	_positive: () => _positive,
	_promise: () => _promise,
	_property: () => _property,
	_readonly: () => _readonly,
	_record: () => _record,
	_refine: () => _refine,
	_regex: () => _regex,
	_safeDecode: () => _safeDecode,
	_safeDecodeAsync: () => _safeDecodeAsync,
	_safeEncode: () => _safeEncode,
	_safeEncodeAsync: () => _safeEncodeAsync,
	_safeParse: () => _safeParse,
	_safeParseAsync: () => _safeParseAsync,
	_set: () => _set,
	_size: () => _size,
	_slugify: () => _slugify,
	_startsWith: () => _startsWith,
	_string: () => _string,
	_stringFormat: () => _stringFormat,
	_stringbool: () => _stringbool,
	_success: () => _success,
	_superRefine: () => _superRefine,
	_symbol: () => _symbol,
	_templateLiteral: () => _templateLiteral,
	_toLowerCase: () => _toLowerCase,
	_toUpperCase: () => _toUpperCase,
	_transform: () => _transform,
	_trim: () => _trim,
	_tuple: () => _tuple,
	_uint32: () => _uint32,
	_uint64: () => _uint64,
	_ulid: () => _ulid,
	_undefined: () => _undefined$1,
	_union: () => _union,
	_unknown: () => _unknown,
	_uppercase: () => _uppercase,
	_url: () => _url,
	_uuid: () => _uuid,
	_uuidv4: () => _uuidv4,
	_uuidv6: () => _uuidv6,
	_uuidv7: () => _uuidv7,
	_void: () => _void$1,
	_xid: () => _xid,
	_xor: () => _xor,
	clone: () => clone,
	config: () => config,
	createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
	createToJSONSchemaMethod: () => createToJSONSchemaMethod,
	decode: () => decode$1,
	decodeAsync: () => decodeAsync$1,
	describe: () => describe$1,
	encode: () => encode$1,
	encodeAsync: () => encodeAsync$1,
	extractDefs: () => extractDefs,
	finalize: () => finalize,
	flattenError: () => flattenError,
	formatError: () => formatError,
	globalConfig: () => globalConfig,
	globalRegistry: () => globalRegistry,
	initializeContext: () => initializeContext,
	isValidBase64: () => isValidBase64,
	isValidBase64URL: () => isValidBase64URL,
	isValidJWT: () => isValidJWT,
	locales: () => locales_exports,
	meta: () => meta$1,
	parse: () => parse$2,
	parseAsync: () => parseAsync$1,
	prettifyError: () => prettifyError,
	process: () => process$1,
	regexes: () => regexes_exports,
	registry: () => registry,
	safeDecode: () => safeDecode$1,
	safeDecodeAsync: () => safeDecodeAsync$1,
	safeEncode: () => safeEncode$1,
	safeEncodeAsync: () => safeEncodeAsync$1,
	safeParse: () => safeParse$1,
	safeParseAsync: () => safeParseAsync$1,
	toDotPath: () => toDotPath,
	toJSONSchema: () => toJSONSchema,
	treeifyError: () => treeifyError,
	util: () => util_exports,
	version: () => version$1
});

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/checks.js
var checks_exports = /* @__PURE__ */ __exportAll({
	endsWith: () => _endsWith,
	gt: () => _gt,
	gte: () => _gte,
	includes: () => _includes,
	length: () => _length,
	lowercase: () => _lowercase,
	lt: () => _lt,
	lte: () => _lte,
	maxLength: () => _maxLength,
	maxSize: () => _maxSize,
	mime: () => _mime,
	minLength: () => _minLength,
	minSize: () => _minSize,
	multipleOf: () => _multipleOf,
	negative: () => _negative,
	nonnegative: () => _nonnegative,
	nonpositive: () => _nonpositive,
	normalize: () => _normalize,
	overwrite: () => _overwrite,
	positive: () => _positive,
	property: () => _property,
	regex: () => _regex,
	size: () => _size,
	slugify: () => _slugify,
	startsWith: () => _startsWith,
	toLowerCase: () => _toLowerCase,
	toUpperCase: () => _toUpperCase,
	trim: () => _trim,
	uppercase: () => _uppercase
});

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/iso.js
var iso_exports = /* @__PURE__ */ __exportAll({
	ZodISODate: () => ZodISODate,
	ZodISODateTime: () => ZodISODateTime,
	ZodISODuration: () => ZodISODuration,
	ZodISOTime: () => ZodISOTime,
	date: () => date$2,
	datetime: () => datetime,
	duration: () => duration,
	time: () => time
});
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
	$ZodISODateTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function datetime(params) {
	return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
	$ZodISODate.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function date$2(params) {
	return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
	$ZodISOTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function time(params) {
	return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
	$ZodISODuration.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function duration(params) {
	return _isoDuration(ZodISODuration, params);
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/errors.js
const initializer = (inst, issues) => {
	$ZodError.init(inst, issues);
	inst.name = "ZodError";
	Object.defineProperties(inst, {
		format: { value: (mapper) => formatError(inst, mapper) },
		flatten: { value: (mapper) => flattenError(inst, mapper) },
		addIssue: { value: (issue$1) => {
			inst.issues.push(issue$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		addIssues: { value: (issues$1) => {
			inst.issues.push(...issues$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		isEmpty: { get() {
			return inst.issues.length === 0;
		} }
	});
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/parse.js
const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/schemas.js
var schemas_exports = /* @__PURE__ */ __exportAll({
	ZodAny: () => ZodAny,
	ZodArray: () => ZodArray,
	ZodBase64: () => ZodBase64,
	ZodBase64URL: () => ZodBase64URL,
	ZodBigInt: () => ZodBigInt,
	ZodBigIntFormat: () => ZodBigIntFormat,
	ZodBoolean: () => ZodBoolean,
	ZodCIDRv4: () => ZodCIDRv4,
	ZodCIDRv6: () => ZodCIDRv6,
	ZodCUID: () => ZodCUID,
	ZodCUID2: () => ZodCUID2,
	ZodCatch: () => ZodCatch,
	ZodCodec: () => ZodCodec,
	ZodCustom: () => ZodCustom,
	ZodCustomStringFormat: () => ZodCustomStringFormat,
	ZodDate: () => ZodDate,
	ZodDefault: () => ZodDefault,
	ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
	ZodE164: () => ZodE164,
	ZodEmail: () => ZodEmail,
	ZodEmoji: () => ZodEmoji,
	ZodEnum: () => ZodEnum,
	ZodExactOptional: () => ZodExactOptional,
	ZodFile: () => ZodFile,
	ZodFunction: () => ZodFunction,
	ZodGUID: () => ZodGUID,
	ZodIPv4: () => ZodIPv4,
	ZodIPv6: () => ZodIPv6,
	ZodIntersection: () => ZodIntersection,
	ZodJWT: () => ZodJWT,
	ZodKSUID: () => ZodKSUID,
	ZodLazy: () => ZodLazy,
	ZodLiteral: () => ZodLiteral,
	ZodMAC: () => ZodMAC,
	ZodMap: () => ZodMap,
	ZodNaN: () => ZodNaN,
	ZodNanoID: () => ZodNanoID,
	ZodNever: () => ZodNever,
	ZodNonOptional: () => ZodNonOptional,
	ZodNull: () => ZodNull,
	ZodNullable: () => ZodNullable,
	ZodNumber: () => ZodNumber,
	ZodNumberFormat: () => ZodNumberFormat,
	ZodObject: () => ZodObject,
	ZodOptional: () => ZodOptional,
	ZodPipe: () => ZodPipe,
	ZodPrefault: () => ZodPrefault,
	ZodPromise: () => ZodPromise,
	ZodReadonly: () => ZodReadonly,
	ZodRecord: () => ZodRecord,
	ZodSet: () => ZodSet,
	ZodString: () => ZodString,
	ZodStringFormat: () => ZodStringFormat,
	ZodSuccess: () => ZodSuccess,
	ZodSymbol: () => ZodSymbol,
	ZodTemplateLiteral: () => ZodTemplateLiteral,
	ZodTransform: () => ZodTransform,
	ZodTuple: () => ZodTuple,
	ZodType: () => ZodType,
	ZodULID: () => ZodULID,
	ZodURL: () => ZodURL,
	ZodUUID: () => ZodUUID,
	ZodUndefined: () => ZodUndefined,
	ZodUnion: () => ZodUnion,
	ZodUnknown: () => ZodUnknown,
	ZodVoid: () => ZodVoid,
	ZodXID: () => ZodXID,
	ZodXor: () => ZodXor,
	_ZodString: () => _ZodString,
	_default: () => _default,
	_function: () => _function,
	any: () => any,
	array: () => array,
	base64: () => base64,
	base64url: () => base64url,
	bigint: () => bigint$1,
	boolean: () => boolean$1,
	catch: () => _catch,
	check: () => check,
	cidrv4: () => cidrv4,
	cidrv6: () => cidrv6,
	codec: () => codec,
	cuid: () => cuid,
	cuid2: () => cuid2,
	custom: () => custom,
	date: () => date$1,
	describe: () => describe,
	discriminatedUnion: () => discriminatedUnion,
	e164: () => e164,
	email: () => email,
	emoji: () => emoji,
	enum: () => _enum,
	exactOptional: () => exactOptional,
	file: () => file,
	float32: () => float32,
	float64: () => float64,
	function: () => _function,
	guid: () => guid,
	hash: () => hash,
	hex: () => hex,
	hostname: () => hostname,
	httpUrl: () => httpUrl,
	instanceof: () => _instanceof,
	int: () => int,
	int32: () => int32,
	int64: () => int64,
	intersection: () => intersection,
	ipv4: () => ipv4,
	ipv6: () => ipv6,
	json: () => json,
	jwt: () => jwt,
	keyof: () => keyof,
	ksuid: () => ksuid,
	lazy: () => lazy,
	literal: () => literal,
	looseObject: () => looseObject,
	looseRecord: () => looseRecord,
	mac: () => mac,
	map: () => map,
	meta: () => meta,
	nan: () => nan,
	nanoid: () => nanoid,
	nativeEnum: () => nativeEnum,
	never: () => never,
	nonoptional: () => nonoptional,
	null: () => _null,
	nullable: () => nullable,
	nullish: () => nullish,
	number: () => number$1,
	object: () => object,
	optional: () => optional,
	partialRecord: () => partialRecord,
	pipe: () => pipe,
	prefault: () => prefault,
	preprocess: () => preprocess,
	promise: () => promise,
	readonly: () => readonly,
	record: () => record,
	refine: () => refine,
	set: () => set,
	strictObject: () => strictObject,
	string: () => string$1,
	stringFormat: () => stringFormat,
	stringbool: () => stringbool,
	success: () => success,
	superRefine: () => superRefine,
	symbol: () => symbol,
	templateLiteral: () => templateLiteral,
	transform: () => transform,
	tuple: () => tuple,
	uint32: () => uint32,
	uint64: () => uint64,
	ulid: () => ulid,
	undefined: () => _undefined,
	union: () => union,
	unknown: () => unknown,
	url: () => url$1,
	uuid: () => uuid,
	uuidv4: () => uuidv4,
	uuidv6: () => uuidv6,
	uuidv7: () => uuidv7,
	void: () => _void,
	xid: () => xid,
	xor: () => xor
});
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
	$ZodType.init(inst, def);
	Object.assign(inst["~standard"], { jsonSchema: {
		input: createStandardJSONSchemaMethod(inst, "input"),
		output: createStandardJSONSchemaMethod(inst, "output")
	} });
	inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
	inst.def = def;
	inst.type = def.type;
	Object.defineProperty(inst, "_def", { value: def });
	inst.check = (...checks) => {
		return inst.clone(mergeDefs(def, { checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
			check: ch,
			def: { check: "custom" },
			onattach: []
		} } : ch)] }), { parent: true });
	};
	inst.with = inst.check;
	inst.clone = (def$1, params) => clone(inst, def$1, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta$2) => {
		reg.add(inst, meta$2);
		return inst;
	});
	inst.parse = (data, params) => parse$1(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
	inst.spa = inst.safeParseAsync;
	inst.encode = (data, params) => encode(inst, data, params);
	inst.decode = (data, params) => decode(inst, data, params);
	inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
	inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
	inst.safeEncode = (data, params) => safeEncode(inst, data, params);
	inst.safeDecode = (data, params) => safeDecode(inst, data, params);
	inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
	inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
	inst.refine = (check$1, params) => inst.check(refine(check$1, params));
	inst.superRefine = (refinement) => inst.check(superRefine(refinement));
	inst.overwrite = (fn$1) => inst.check(_overwrite(fn$1));
	inst.optional = () => optional(inst);
	inst.exactOptional = () => exactOptional(inst);
	inst.nullable = () => nullable(inst);
	inst.nullish = () => optional(nullable(inst));
	inst.nonoptional = (params) => nonoptional(inst, params);
	inst.array = () => array(inst);
	inst.or = (arg) => union([inst, arg]);
	inst.and = (arg) => intersection(inst, arg);
	inst.transform = (tx) => pipe(inst, transform(tx));
	inst.default = (def$1) => _default(inst, def$1);
	inst.prefault = (def$1) => prefault(inst, def$1);
	inst.catch = (params) => _catch(inst, params);
	inst.pipe = (target) => pipe(inst, target);
	inst.readonly = () => readonly(inst);
	inst.describe = (description) => {
		const cl = inst.clone();
		globalRegistry.add(cl, { description });
		return cl;
	};
	Object.defineProperty(inst, "description", {
		get() {
			return globalRegistry.get(inst)?.description;
		},
		configurable: true
	});
	inst.meta = (...args) => {
		if (args.length === 0) return globalRegistry.get(inst);
		const cl = inst.clone();
		globalRegistry.add(cl, args[0]);
		return cl;
	};
	inst.isOptional = () => inst.safeParse(void 0).success;
	inst.isNullable = () => inst.safeParse(null).success;
	inst.apply = (fn$1) => fn$1(inst);
	return inst;
});
/** @internal */
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => stringProcessor(inst, ctx, json$1, params);
	const bag = inst._zod.bag;
	inst.format = bag.format ?? null;
	inst.minLength = bag.minimum ?? null;
	inst.maxLength = bag.maximum ?? null;
	inst.regex = (...args) => inst.check(_regex(...args));
	inst.includes = (...args) => inst.check(_includes(...args));
	inst.startsWith = (...args) => inst.check(_startsWith(...args));
	inst.endsWith = (...args) => inst.check(_endsWith(...args));
	inst.min = (...args) => inst.check(_minLength(...args));
	inst.max = (...args) => inst.check(_maxLength(...args));
	inst.length = (...args) => inst.check(_length(...args));
	inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
	inst.lowercase = (params) => inst.check(_lowercase(params));
	inst.uppercase = (params) => inst.check(_uppercase(params));
	inst.trim = () => inst.check(_trim());
	inst.normalize = (...args) => inst.check(_normalize(...args));
	inst.toLowerCase = () => inst.check(_toLowerCase());
	inst.toUpperCase = () => inst.check(_toUpperCase());
	inst.slugify = () => inst.check(_slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	_ZodString.init(inst, def);
	inst.email = (params) => inst.check(_email(ZodEmail, params));
	inst.url = (params) => inst.check(_url(ZodURL, params));
	inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
	inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
	inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
	inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
	inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
	inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
	inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
	inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
	inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
	inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
	inst.xid = (params) => inst.check(_xid(ZodXID, params));
	inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
	inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
	inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
	inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
	inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
	inst.e164 = (params) => inst.check(_e164(ZodE164, params));
	inst.datetime = (params) => inst.check(datetime(params));
	inst.date = (params) => inst.check(date$2(params));
	inst.time = (params) => inst.check(time(params));
	inst.duration = (params) => inst.check(duration(params));
});
function string$1(params) {
	return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	_ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
	$ZodEmail.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function email(params) {
	return _email(ZodEmail, params);
}
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
	$ZodGUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function guid(params) {
	return _guid(ZodGUID, params);
}
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
	$ZodUUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function uuid(params) {
	return _uuid(ZodUUID, params);
}
function uuidv4(params) {
	return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
	return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
	return _uuidv7(ZodUUID, params);
}
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
	$ZodURL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function url$1(params) {
	return _url(ZodURL, params);
}
function httpUrl(params) {
	return _url(ZodURL, {
		protocol: /^https?$/,
		hostname: domain,
		...normalizeParams(params)
	});
}
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
	$ZodEmoji.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function emoji(params) {
	return _emoji(ZodEmoji, params);
}
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
	$ZodNanoID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function nanoid(params) {
	return _nanoid(ZodNanoID, params);
}
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
	$ZodCUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cuid(params) {
	return _cuid(ZodCUID, params);
}
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
	$ZodCUID2.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cuid2(params) {
	return _cuid2(ZodCUID2, params);
}
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
	$ZodULID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ulid(params) {
	return _ulid(ZodULID, params);
}
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
	$ZodXID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function xid(params) {
	return _xid(ZodXID, params);
}
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
	$ZodKSUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ksuid(params) {
	return _ksuid(ZodKSUID, params);
}
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
	$ZodIPv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ipv4(params) {
	return _ipv4(ZodIPv4, params);
}
const ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
	$ZodMAC.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function mac(params) {
	return _mac(ZodMAC, params);
}
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
	$ZodIPv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ipv6(params) {
	return _ipv6(ZodIPv6, params);
}
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
	$ZodCIDRv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cidrv4(params) {
	return _cidrv4(ZodCIDRv4, params);
}
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
	$ZodCIDRv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cidrv6(params) {
	return _cidrv6(ZodCIDRv6, params);
}
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
	$ZodBase64.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function base64(params) {
	return _base64(ZodBase64, params);
}
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
	$ZodBase64URL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function base64url(params) {
	return _base64url(ZodBase64URL, params);
}
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
	$ZodE164.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function e164(params) {
	return _e164(ZodE164, params);
}
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
	$ZodJWT.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function jwt(params) {
	return _jwt(ZodJWT, params);
}
const ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
	$ZodCustomStringFormat.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
	return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname(_params) {
	return _stringFormat(ZodCustomStringFormat, "hostname", hostname$1, _params);
}
function hex(_params) {
	return _stringFormat(ZodCustomStringFormat, "hex", hex$1, _params);
}
function hash(alg, params) {
	const format = `${alg}_${params?.enc ?? "hex"}`;
	const regex = regexes_exports[format];
	if (!regex) throw new Error(`Unrecognized hash format: ${format}`);
	return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => numberProcessor(inst, ctx, json$1, params);
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.int = (params) => inst.check(int(params));
	inst.safe = (params) => inst.check(int(params));
	inst.positive = (params) => inst.check(_gt(0, params));
	inst.nonnegative = (params) => inst.check(_gte(0, params));
	inst.negative = (params) => inst.check(_lt(0, params));
	inst.nonpositive = (params) => inst.check(_lte(0, params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	inst.step = (value, params) => inst.check(_multipleOf(value, params));
	inst.finite = () => inst;
	const bag = inst._zod.bag;
	inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
	inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
	inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
	inst.isFinite = true;
	inst.format = bag.format ?? null;
});
function number$1(params) {
	return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
	$ZodNumberFormat.init(inst, def);
	ZodNumber.init(inst, def);
});
function int(params) {
	return _int(ZodNumberFormat, params);
}
function float32(params) {
	return _float32(ZodNumberFormat, params);
}
function float64(params) {
	return _float64(ZodNumberFormat, params);
}
function int32(params) {
	return _int32(ZodNumberFormat, params);
}
function uint32(params) {
	return _uint32(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
	$ZodBoolean.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => booleanProcessor(inst, ctx, json$1, params);
});
function boolean$1(params) {
	return _boolean(ZodBoolean, params);
}
const ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
	$ZodBigInt.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => bigintProcessor(inst, ctx, json$1, params);
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.positive = (params) => inst.check(_gt(BigInt(0), params));
	inst.negative = (params) => inst.check(_lt(BigInt(0), params));
	inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
	inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	const bag = inst._zod.bag;
	inst.minValue = bag.minimum ?? null;
	inst.maxValue = bag.maximum ?? null;
	inst.format = bag.format ?? null;
});
function bigint$1(params) {
	return _bigint(ZodBigInt, params);
}
const ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
	$ZodBigIntFormat.init(inst, def);
	ZodBigInt.init(inst, def);
});
function int64(params) {
	return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
	return _uint64(ZodBigIntFormat, params);
}
const ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
	$ZodSymbol.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => symbolProcessor(inst, ctx, json$1, params);
});
function symbol(params) {
	return _symbol(ZodSymbol, params);
}
const ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
	$ZodUndefined.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => undefinedProcessor(inst, ctx, json$1, params);
});
function _undefined(params) {
	return _undefined$1(ZodUndefined, params);
}
const ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
	$ZodNull.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => nullProcessor(inst, ctx, json$1, params);
});
function _null(params) {
	return _null$1(ZodNull, params);
}
const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
	$ZodAny.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => anyProcessor(inst, ctx, json$1, params);
});
function any() {
	return _any(ZodAny);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => unknownProcessor(inst, ctx, json$1, params);
});
function unknown() {
	return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
	$ZodNever.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => neverProcessor(inst, ctx, json$1, params);
});
function never(params) {
	return _never(ZodNever, params);
}
const ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
	$ZodVoid.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => voidProcessor(inst, ctx, json$1, params);
});
function _void(params) {
	return _void$1(ZodVoid, params);
}
const ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
	$ZodDate.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => dateProcessor(inst, ctx, json$1, params);
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	const c = inst._zod.bag;
	inst.minDate = c.minimum ? new Date(c.minimum) : null;
	inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date$1(params) {
	return _date(ZodDate, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => arrayProcessor(inst, ctx, json$1, params);
	inst.element = def.element;
	inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
	inst.nonempty = (params) => inst.check(_minLength(1, params));
	inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
	inst.length = (len, params) => inst.check(_length(len, params));
	inst.unwrap = () => inst.element;
});
function array(element, params) {
	return _array(ZodArray, element, params);
}
function keyof(schema) {
	const shape = schema._zod.def.shape;
	return _enum(Object.keys(shape));
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
	$ZodObjectJIT.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => objectProcessor(inst, ctx, json$1, params);
	defineLazy(inst, "shape", () => {
		return def.shape;
	});
	inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
	inst.catchall = (catchall) => inst.clone({
		...inst._zod.def,
		catchall
	});
	inst.passthrough = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.loose = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.strict = () => inst.clone({
		...inst._zod.def,
		catchall: never()
	});
	inst.strip = () => inst.clone({
		...inst._zod.def,
		catchall: void 0
	});
	inst.extend = (incoming) => {
		return extend(inst, incoming);
	};
	inst.safeExtend = (incoming) => {
		return safeExtend(inst, incoming);
	};
	inst.merge = (other) => merge(inst, other);
	inst.pick = (mask) => pick(inst, mask);
	inst.omit = (mask) => omit(inst, mask);
	inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
	inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
	return new ZodObject({
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	});
}
function strictObject(shape, params) {
	return new ZodObject({
		type: "object",
		shape,
		catchall: never(),
		...normalizeParams(params)
	});
}
function looseObject(shape, params) {
	return new ZodObject({
		type: "object",
		shape,
		catchall: unknown(),
		...normalizeParams(params)
	});
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => unionProcessor(inst, ctx, json$1, params);
	inst.options = def.options;
});
function union(options, params) {
	return new ZodUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
	ZodUnion.init(inst, def);
	$ZodXor.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => unionProcessor(inst, ctx, json$1, params);
	inst.options = def.options;
});
/** Creates an exclusive union (XOR) where exactly one option must match.
* Unlike regular unions that succeed when any option matches, xor fails if
* zero or more than one option matches the input. */
function xor(options, params) {
	return new ZodXor({
		type: "union",
		options,
		inclusive: false,
		...normalizeParams(params)
	});
}
const ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
	ZodUnion.init(inst, def);
	$ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
	return new ZodDiscriminatedUnion({
		type: "union",
		options,
		discriminator,
		...normalizeParams(params)
	});
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
	$ZodIntersection.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => intersectionProcessor(inst, ctx, json$1, params);
});
function intersection(left, right) {
	return new ZodIntersection({
		type: "intersection",
		left,
		right
	});
}
const ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
	$ZodTuple.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => tupleProcessor(inst, ctx, json$1, params);
	inst.rest = (rest) => inst.clone({
		...inst._zod.def,
		rest
	});
});
function tuple(items, _paramsOrRest, _params) {
	const hasRest = _paramsOrRest instanceof $ZodType;
	const params = hasRest ? _params : _paramsOrRest;
	return new ZodTuple({
		type: "tuple",
		items,
		rest: hasRest ? _paramsOrRest : null,
		...normalizeParams(params)
	});
}
const ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
	$ZodRecord.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => recordProcessor(inst, ctx, json$1, params);
	inst.keyType = def.keyType;
	inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
	return new ZodRecord({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
function partialRecord(keyType, valueType, params) {
	const k = clone(keyType);
	k._zod.values = void 0;
	return new ZodRecord({
		type: "record",
		keyType: k,
		valueType,
		...normalizeParams(params)
	});
}
function looseRecord(keyType, valueType, params) {
	return new ZodRecord({
		type: "record",
		keyType,
		valueType,
		mode: "loose",
		...normalizeParams(params)
	});
}
const ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
	$ZodMap.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => mapProcessor(inst, ctx, json$1, params);
	inst.keyType = def.keyType;
	inst.valueType = def.valueType;
	inst.min = (...args) => inst.check(_minSize(...args));
	inst.nonempty = (params) => inst.check(_minSize(1, params));
	inst.max = (...args) => inst.check(_maxSize(...args));
	inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
	return new ZodMap({
		type: "map",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
const ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
	$ZodSet.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => setProcessor(inst, ctx, json$1, params);
	inst.min = (...args) => inst.check(_minSize(...args));
	inst.nonempty = (params) => inst.check(_minSize(1, params));
	inst.max = (...args) => inst.check(_maxSize(...args));
	inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
	return new ZodSet({
		type: "set",
		valueType,
		...normalizeParams(params)
	});
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
	$ZodEnum.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => enumProcessor(inst, ctx, json$1, params);
	inst.enum = def.entries;
	inst.options = Object.values(def.entries);
	const keys = new Set(Object.keys(def.entries));
	inst.extract = (values, params) => {
		const newEntries = {};
		for (const value of values) if (keys.has(value)) newEntries[value] = def.entries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
	inst.exclude = (values, params) => {
		const newEntries = { ...def.entries };
		for (const value of values) if (keys.has(value)) delete newEntries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
});
function _enum(values, params) {
	return new ZodEnum({
		type: "enum",
		entries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,
		...normalizeParams(params)
	});
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
*
* ```ts
* enum Colors { red, green, blue }
* z.enum(Colors);
* ```
*/
function nativeEnum(entries, params) {
	return new ZodEnum({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
	$ZodLiteral.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => literalProcessor(inst, ctx, json$1, params);
	inst.values = new Set(def.values);
	Object.defineProperty(inst, "value", { get() {
		if (def.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
		return def.values[0];
	} });
});
function literal(value, params) {
	return new ZodLiteral({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
const ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
	$ZodFile.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => fileProcessor(inst, ctx, json$1, params);
	inst.min = (size, params) => inst.check(_minSize(size, params));
	inst.max = (size, params) => inst.check(_maxSize(size, params));
	inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
	return _file(ZodFile, params);
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
	$ZodTransform.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => transformProcessor(inst, ctx, json$1, params);
	inst._zod.parse = (payload, _ctx) => {
		if (_ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = inst);
				payload.issues.push(issue(_issue));
			}
		};
		const output = def.transform(payload.value, payload);
		if (output instanceof Promise) return output.then((output$1) => {
			payload.value = output$1;
			return payload;
		});
		payload.value = output;
		return payload;
	};
});
function transform(fn$1) {
	return new ZodTransform({
		type: "transform",
		transform: fn$1
	});
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => optionalProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
	return new ZodOptional({
		type: "optional",
		innerType
	});
}
const ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
	$ZodExactOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => optionalProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
	return new ZodExactOptional({
		type: "optional",
		innerType
	});
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
	$ZodNullable.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => nullableProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
	return new ZodNullable({
		type: "nullable",
		innerType
	});
}
function nullish(innerType) {
	return optional(nullable(innerType));
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
	$ZodDefault.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => defaultProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
	return new ZodDefault({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
	$ZodPrefault.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => prefaultProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
	return new ZodPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
	$ZodNonOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => nonoptionalProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
	return new ZodNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
	$ZodSuccess.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => successProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
	return new ZodSuccess({
		type: "success",
		innerType
	});
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
	$ZodCatch.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => catchProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
	return new ZodCatch({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
	$ZodNaN.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => nanProcessor(inst, ctx, json$1, params);
});
function nan(params) {
	return _nan(ZodNaN, params);
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
	$ZodPipe.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => pipeProcessor(inst, ctx, json$1, params);
	inst.in = def.in;
	inst.out = def.out;
});
function pipe(in_, out) {
	return new ZodPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
	ZodPipe.init(inst, def);
	$ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
	return new ZodCodec({
		type: "pipe",
		in: in_,
		out,
		transform: params.decode,
		reverseTransform: params.encode
	});
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
	$ZodReadonly.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => readonlyProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
	return new ZodReadonly({
		type: "readonly",
		innerType
	});
}
const ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
	$ZodTemplateLiteral.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => templateLiteralProcessor(inst, ctx, json$1, params);
});
function templateLiteral(parts, params) {
	return new ZodTemplateLiteral({
		type: "template_literal",
		parts,
		...normalizeParams(params)
	});
}
const ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
	$ZodLazy.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => lazyProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
	return new ZodLazy({
		type: "lazy",
		getter
	});
}
const ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
	$ZodPromise.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => promiseProcessor(inst, ctx, json$1, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
	return new ZodPromise({
		type: "promise",
		innerType
	});
}
const ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
	$ZodFunction.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => functionProcessor(inst, ctx, json$1, params);
});
function _function(params) {
	return new ZodFunction({
		type: "function",
		input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
		output: params?.output ?? unknown()
	});
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
	$ZodCustom.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$1, params) => customProcessor(inst, ctx, json$1, params);
});
function check(fn$1) {
	const ch = new $ZodCheck({ check: "custom" });
	ch._zod.check = fn$1;
	return ch;
}
function custom(fn$1, _params) {
	return _custom(ZodCustom, fn$1 ?? (() => true), _params);
}
function refine(fn$1, _params = {}) {
	return _refine(ZodCustom, fn$1, _params);
}
function superRefine(fn$1) {
	return _superRefine(fn$1);
}
const describe = describe$1;
const meta = meta$1;
function _instanceof(cls, params = {}) {
	const inst = new ZodCustom({
		type: "custom",
		check: "custom",
		fn: (data) => data instanceof cls,
		abort: true,
		...normalizeParams(params)
	});
	inst._zod.bag.Class = cls;
	inst._zod.check = (payload) => {
		if (!(payload.value instanceof cls)) payload.issues.push({
			code: "invalid_type",
			expected: cls.name,
			input: payload.value,
			inst,
			path: [...inst._zod.def.path ?? []]
		});
	};
	return inst;
}
const stringbool = (...args) => _stringbool({
	Codec: ZodCodec,
	Boolean: ZodBoolean,
	String: ZodString
}, ...args);
function json(params) {
	const jsonSchema = lazy(() => {
		return union([
			string$1(params),
			number$1(),
			boolean$1(),
			_null(),
			array(jsonSchema),
			record(string$1(), jsonSchema)
		]);
	});
	return jsonSchema;
}
function preprocess(fn$1, schema) {
	return pipe(transform(fn$1), schema);
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/compat.js
/** @deprecated Use the raw string literal codes instead, e.g. "invalid_type". */
const ZodIssueCode = {
	invalid_type: "invalid_type",
	too_big: "too_big",
	too_small: "too_small",
	invalid_format: "invalid_format",
	not_multiple_of: "not_multiple_of",
	unrecognized_keys: "unrecognized_keys",
	invalid_union: "invalid_union",
	invalid_key: "invalid_key",
	invalid_element: "invalid_element",
	invalid_value: "invalid_value",
	custom: "custom"
};
/** @deprecated Use `z.config(params)` instead. */
function setErrorMap(map$1) {
	config({ customError: map$1 });
}
/** @deprecated Use `z.config()` instead. */
function getErrorMap() {
	return config().customError;
}
/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$1) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/from-json-schema.js
const z = {
	...schemas_exports,
	...checks_exports,
	iso: iso_exports
};
const RECOGNIZED_KEYS = new Set([
	"$schema",
	"$ref",
	"$defs",
	"definitions",
	"$id",
	"id",
	"$comment",
	"$anchor",
	"$vocabulary",
	"$dynamicRef",
	"$dynamicAnchor",
	"type",
	"enum",
	"const",
	"anyOf",
	"oneOf",
	"allOf",
	"not",
	"properties",
	"required",
	"additionalProperties",
	"patternProperties",
	"propertyNames",
	"minProperties",
	"maxProperties",
	"items",
	"prefixItems",
	"additionalItems",
	"minItems",
	"maxItems",
	"uniqueItems",
	"contains",
	"minContains",
	"maxContains",
	"minLength",
	"maxLength",
	"pattern",
	"format",
	"minimum",
	"maximum",
	"exclusiveMinimum",
	"exclusiveMaximum",
	"multipleOf",
	"description",
	"default",
	"contentEncoding",
	"contentMediaType",
	"contentSchema",
	"unevaluatedItems",
	"unevaluatedProperties",
	"if",
	"then",
	"else",
	"dependentSchemas",
	"dependentRequired",
	"nullable",
	"readOnly"
]);
function detectVersion(schema, defaultTarget) {
	const $schema = schema.$schema;
	if ($schema === "https://json-schema.org/draft/2020-12/schema") return "draft-2020-12";
	if ($schema === "http://json-schema.org/draft-07/schema#") return "draft-7";
	if ($schema === "http://json-schema.org/draft-04/schema#") return "draft-4";
	return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
	if (!ref.startsWith("#")) throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
	const path = ref.slice(1).split("/").filter(Boolean);
	if (path.length === 0) return ctx.rootSchema;
	const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
	if (path[0] === defsKey) {
		const key = path[1];
		if (!key || !ctx.defs[key]) throw new Error(`Reference not found: ${ref}`);
		return ctx.defs[key];
	}
	throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
	if (schema.not !== void 0) {
		if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) return z.never();
		throw new Error("not is not supported in Zod (except { not: {} } for never)");
	}
	if (schema.unevaluatedItems !== void 0) throw new Error("unevaluatedItems is not supported");
	if (schema.unevaluatedProperties !== void 0) throw new Error("unevaluatedProperties is not supported");
	if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) throw new Error("Conditional schemas (if/then/else) are not supported");
	if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) throw new Error("dependentSchemas and dependentRequired are not supported");
	if (schema.$ref) {
		const refPath = schema.$ref;
		if (ctx.refs.has(refPath)) return ctx.refs.get(refPath);
		if (ctx.processing.has(refPath)) return z.lazy(() => {
			if (!ctx.refs.has(refPath)) throw new Error(`Circular reference not resolved: ${refPath}`);
			return ctx.refs.get(refPath);
		});
		ctx.processing.add(refPath);
		const zodSchema$1 = convertSchema(resolveRef(refPath, ctx), ctx);
		ctx.refs.set(refPath, zodSchema$1);
		ctx.processing.delete(refPath);
		return zodSchema$1;
	}
	if (schema.enum !== void 0) {
		const enumValues = schema.enum;
		if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) return z.null();
		if (enumValues.length === 0) return z.never();
		if (enumValues.length === 1) return z.literal(enumValues[0]);
		if (enumValues.every((v) => typeof v === "string")) return z.enum(enumValues);
		const literalSchemas = enumValues.map((v) => z.literal(v));
		if (literalSchemas.length < 2) return literalSchemas[0];
		return z.union([
			literalSchemas[0],
			literalSchemas[1],
			...literalSchemas.slice(2)
		]);
	}
	if (schema.const !== void 0) return z.literal(schema.const);
	const type = schema.type;
	if (Array.isArray(type)) {
		const typeSchemas = type.map((t) => {
			return convertBaseSchema({
				...schema,
				type: t
			}, ctx);
		});
		if (typeSchemas.length === 0) return z.never();
		if (typeSchemas.length === 1) return typeSchemas[0];
		return z.union(typeSchemas);
	}
	if (!type) return z.any();
	let zodSchema;
	switch (type) {
		case "string": {
			let stringSchema = z.string();
			if (schema.format) {
				const format = schema.format;
				if (format === "email") stringSchema = stringSchema.check(z.email());
				else if (format === "uri" || format === "uri-reference") stringSchema = stringSchema.check(z.url());
				else if (format === "uuid" || format === "guid") stringSchema = stringSchema.check(z.uuid());
				else if (format === "date-time") stringSchema = stringSchema.check(z.iso.datetime());
				else if (format === "date") stringSchema = stringSchema.check(z.iso.date());
				else if (format === "time") stringSchema = stringSchema.check(z.iso.time());
				else if (format === "duration") stringSchema = stringSchema.check(z.iso.duration());
				else if (format === "ipv4") stringSchema = stringSchema.check(z.ipv4());
				else if (format === "ipv6") stringSchema = stringSchema.check(z.ipv6());
				else if (format === "mac") stringSchema = stringSchema.check(z.mac());
				else if (format === "cidr") stringSchema = stringSchema.check(z.cidrv4());
				else if (format === "cidr-v6") stringSchema = stringSchema.check(z.cidrv6());
				else if (format === "base64") stringSchema = stringSchema.check(z.base64());
				else if (format === "base64url") stringSchema = stringSchema.check(z.base64url());
				else if (format === "e164") stringSchema = stringSchema.check(z.e164());
				else if (format === "jwt") stringSchema = stringSchema.check(z.jwt());
				else if (format === "emoji") stringSchema = stringSchema.check(z.emoji());
				else if (format === "nanoid") stringSchema = stringSchema.check(z.nanoid());
				else if (format === "cuid") stringSchema = stringSchema.check(z.cuid());
				else if (format === "cuid2") stringSchema = stringSchema.check(z.cuid2());
				else if (format === "ulid") stringSchema = stringSchema.check(z.ulid());
				else if (format === "xid") stringSchema = stringSchema.check(z.xid());
				else if (format === "ksuid") stringSchema = stringSchema.check(z.ksuid());
			}
			if (typeof schema.minLength === "number") stringSchema = stringSchema.min(schema.minLength);
			if (typeof schema.maxLength === "number") stringSchema = stringSchema.max(schema.maxLength);
			if (schema.pattern) stringSchema = stringSchema.regex(new RegExp(schema.pattern));
			zodSchema = stringSchema;
			break;
		}
		case "number":
		case "integer": {
			let numberSchema = type === "integer" ? z.number().int() : z.number();
			if (typeof schema.minimum === "number") numberSchema = numberSchema.min(schema.minimum);
			if (typeof schema.maximum === "number") numberSchema = numberSchema.max(schema.maximum);
			if (typeof schema.exclusiveMinimum === "number") numberSchema = numberSchema.gt(schema.exclusiveMinimum);
			else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") numberSchema = numberSchema.gt(schema.minimum);
			if (typeof schema.exclusiveMaximum === "number") numberSchema = numberSchema.lt(schema.exclusiveMaximum);
			else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") numberSchema = numberSchema.lt(schema.maximum);
			if (typeof schema.multipleOf === "number") numberSchema = numberSchema.multipleOf(schema.multipleOf);
			zodSchema = numberSchema;
			break;
		}
		case "boolean":
			zodSchema = z.boolean();
			break;
		case "null":
			zodSchema = z.null();
			break;
		case "object": {
			const shape = {};
			const properties = schema.properties || {};
			const requiredSet = new Set(schema.required || []);
			for (const [key, propSchema] of Object.entries(properties)) {
				const propZodSchema = convertSchema(propSchema, ctx);
				shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
			}
			if (schema.propertyNames) {
				const keySchema = convertSchema(schema.propertyNames, ctx);
				const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
				if (Object.keys(shape).length === 0) {
					zodSchema = z.record(keySchema, valueSchema);
					break;
				}
				const objectSchema$1 = z.object(shape).passthrough();
				const recordSchema = z.looseRecord(keySchema, valueSchema);
				zodSchema = z.intersection(objectSchema$1, recordSchema);
				break;
			}
			if (schema.patternProperties) {
				const patternProps = schema.patternProperties;
				const patternKeys = Object.keys(patternProps);
				const looseRecords = [];
				for (const pattern of patternKeys) {
					const patternValue = convertSchema(patternProps[pattern], ctx);
					const keySchema = z.string().regex(new RegExp(pattern));
					looseRecords.push(z.looseRecord(keySchema, patternValue));
				}
				const schemasToIntersect = [];
				if (Object.keys(shape).length > 0) schemasToIntersect.push(z.object(shape).passthrough());
				schemasToIntersect.push(...looseRecords);
				if (schemasToIntersect.length === 0) zodSchema = z.object({}).passthrough();
				else if (schemasToIntersect.length === 1) zodSchema = schemasToIntersect[0];
				else {
					let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
					for (let i = 2; i < schemasToIntersect.length; i++) result = z.intersection(result, schemasToIntersect[i]);
					zodSchema = result;
				}
				break;
			}
			const objectSchema = z.object(shape);
			if (schema.additionalProperties === false) zodSchema = objectSchema.strict();
			else if (typeof schema.additionalProperties === "object") zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
			else zodSchema = objectSchema.passthrough();
			break;
		}
		case "array": {
			const prefixItems = schema.prefixItems;
			const items = schema.items;
			if (prefixItems && Array.isArray(prefixItems)) {
				const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
				const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
				if (rest) zodSchema = z.tuple(tupleItems).rest(rest);
				else zodSchema = z.tuple(tupleItems);
				if (typeof schema.minItems === "number") zodSchema = zodSchema.check(z.minLength(schema.minItems));
				if (typeof schema.maxItems === "number") zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
			} else if (Array.isArray(items)) {
				const tupleItems = items.map((item) => convertSchema(item, ctx));
				const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
				if (rest) zodSchema = z.tuple(tupleItems).rest(rest);
				else zodSchema = z.tuple(tupleItems);
				if (typeof schema.minItems === "number") zodSchema = zodSchema.check(z.minLength(schema.minItems));
				if (typeof schema.maxItems === "number") zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
			} else if (items !== void 0) {
				const element = convertSchema(items, ctx);
				let arraySchema = z.array(element);
				if (typeof schema.minItems === "number") arraySchema = arraySchema.min(schema.minItems);
				if (typeof schema.maxItems === "number") arraySchema = arraySchema.max(schema.maxItems);
				zodSchema = arraySchema;
			} else zodSchema = z.array(z.any());
			break;
		}
		default: throw new Error(`Unsupported type: ${type}`);
	}
	if (schema.description) zodSchema = zodSchema.describe(schema.description);
	if (schema.default !== void 0) zodSchema = zodSchema.default(schema.default);
	return zodSchema;
}
function convertSchema(schema, ctx) {
	if (typeof schema === "boolean") return schema ? z.any() : z.never();
	let baseSchema = convertBaseSchema(schema, ctx);
	const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
	if (schema.anyOf && Array.isArray(schema.anyOf)) {
		const options = schema.anyOf.map((s) => convertSchema(s, ctx));
		const anyOfUnion = z.union(options);
		baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
	}
	if (schema.oneOf && Array.isArray(schema.oneOf)) {
		const options = schema.oneOf.map((s) => convertSchema(s, ctx));
		const oneOfUnion = z.xor(options);
		baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
	}
	if (schema.allOf && Array.isArray(schema.allOf)) if (schema.allOf.length === 0) baseSchema = hasExplicitType ? baseSchema : z.any();
	else {
		let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
		const startIdx = hasExplicitType ? 0 : 1;
		for (let i = startIdx; i < schema.allOf.length; i++) result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
		baseSchema = result;
	}
	if (schema.nullable === true && ctx.version === "openapi-3.0") baseSchema = z.nullable(baseSchema);
	if (schema.readOnly === true) baseSchema = z.readonly(baseSchema);
	const extraMeta = {};
	for (const key of [
		"$id",
		"id",
		"$comment",
		"$anchor",
		"$vocabulary",
		"$dynamicRef",
		"$dynamicAnchor"
	]) if (key in schema) extraMeta[key] = schema[key];
	for (const key of [
		"contentEncoding",
		"contentMediaType",
		"contentSchema"
	]) if (key in schema) extraMeta[key] = schema[key];
	for (const key of Object.keys(schema)) if (!RECOGNIZED_KEYS.has(key)) extraMeta[key] = schema[key];
	if (Object.keys(extraMeta).length > 0) ctx.registry.add(baseSchema, extraMeta);
	return baseSchema;
}
/**
* Converts a JSON Schema to a Zod schema. This function should be considered semi-experimental. It's behavior is liable to change. */
function fromJSONSchema(schema, params) {
	if (typeof schema === "boolean") return schema ? z.any() : z.never();
	return convertSchema(schema, {
		version: detectVersion(schema, params?.defaultTarget),
		defs: schema.$defs || schema.definitions || {},
		refs: /* @__PURE__ */ new Map(),
		processing: /* @__PURE__ */ new Set(),
		rootSchema: schema,
		registry: params?.registry ?? globalRegistry
	});
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/coerce.js
var coerce_exports = /* @__PURE__ */ __exportAll({
	bigint: () => bigint,
	boolean: () => boolean,
	date: () => date,
	number: () => number,
	string: () => string
});
function string(params) {
	return _coercedString(ZodString, params);
}
function number(params) {
	return _coercedNumber(ZodNumber, params);
}
function boolean(params) {
	return _coercedBoolean(ZodBoolean, params);
}
function bigint(params) {
	return _coercedBigint(ZodBigInt, params);
}
function date(params) {
	return _coercedDate(ZodDate, params);
}

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/external.js
var external_exports = /* @__PURE__ */ __exportAll({
	$brand: () => $brand,
	$input: () => $input,
	$output: () => $output,
	NEVER: () => NEVER,
	TimePrecision: () => TimePrecision,
	ZodAny: () => ZodAny,
	ZodArray: () => ZodArray,
	ZodBase64: () => ZodBase64,
	ZodBase64URL: () => ZodBase64URL,
	ZodBigInt: () => ZodBigInt,
	ZodBigIntFormat: () => ZodBigIntFormat,
	ZodBoolean: () => ZodBoolean,
	ZodCIDRv4: () => ZodCIDRv4,
	ZodCIDRv6: () => ZodCIDRv6,
	ZodCUID: () => ZodCUID,
	ZodCUID2: () => ZodCUID2,
	ZodCatch: () => ZodCatch,
	ZodCodec: () => ZodCodec,
	ZodCustom: () => ZodCustom,
	ZodCustomStringFormat: () => ZodCustomStringFormat,
	ZodDate: () => ZodDate,
	ZodDefault: () => ZodDefault,
	ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
	ZodE164: () => ZodE164,
	ZodEmail: () => ZodEmail,
	ZodEmoji: () => ZodEmoji,
	ZodEnum: () => ZodEnum,
	ZodError: () => ZodError,
	ZodExactOptional: () => ZodExactOptional,
	ZodFile: () => ZodFile,
	ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
	ZodFunction: () => ZodFunction,
	ZodGUID: () => ZodGUID,
	ZodIPv4: () => ZodIPv4,
	ZodIPv6: () => ZodIPv6,
	ZodISODate: () => ZodISODate,
	ZodISODateTime: () => ZodISODateTime,
	ZodISODuration: () => ZodISODuration,
	ZodISOTime: () => ZodISOTime,
	ZodIntersection: () => ZodIntersection,
	ZodIssueCode: () => ZodIssueCode,
	ZodJWT: () => ZodJWT,
	ZodKSUID: () => ZodKSUID,
	ZodLazy: () => ZodLazy,
	ZodLiteral: () => ZodLiteral,
	ZodMAC: () => ZodMAC,
	ZodMap: () => ZodMap,
	ZodNaN: () => ZodNaN,
	ZodNanoID: () => ZodNanoID,
	ZodNever: () => ZodNever,
	ZodNonOptional: () => ZodNonOptional,
	ZodNull: () => ZodNull,
	ZodNullable: () => ZodNullable,
	ZodNumber: () => ZodNumber,
	ZodNumberFormat: () => ZodNumberFormat,
	ZodObject: () => ZodObject,
	ZodOptional: () => ZodOptional,
	ZodPipe: () => ZodPipe,
	ZodPrefault: () => ZodPrefault,
	ZodPromise: () => ZodPromise,
	ZodReadonly: () => ZodReadonly,
	ZodRealError: () => ZodRealError,
	ZodRecord: () => ZodRecord,
	ZodSet: () => ZodSet,
	ZodString: () => ZodString,
	ZodStringFormat: () => ZodStringFormat,
	ZodSuccess: () => ZodSuccess,
	ZodSymbol: () => ZodSymbol,
	ZodTemplateLiteral: () => ZodTemplateLiteral,
	ZodTransform: () => ZodTransform,
	ZodTuple: () => ZodTuple,
	ZodType: () => ZodType,
	ZodULID: () => ZodULID,
	ZodURL: () => ZodURL,
	ZodUUID: () => ZodUUID,
	ZodUndefined: () => ZodUndefined,
	ZodUnion: () => ZodUnion,
	ZodUnknown: () => ZodUnknown,
	ZodVoid: () => ZodVoid,
	ZodXID: () => ZodXID,
	ZodXor: () => ZodXor,
	_ZodString: () => _ZodString,
	_default: () => _default,
	_function: () => _function,
	any: () => any,
	array: () => array,
	base64: () => base64,
	base64url: () => base64url,
	bigint: () => bigint$1,
	boolean: () => boolean$1,
	catch: () => _catch,
	check: () => check,
	cidrv4: () => cidrv4,
	cidrv6: () => cidrv6,
	clone: () => clone,
	codec: () => codec,
	coerce: () => coerce_exports,
	config: () => config,
	core: () => core_exports,
	cuid: () => cuid,
	cuid2: () => cuid2,
	custom: () => custom,
	date: () => date$1,
	decode: () => decode,
	decodeAsync: () => decodeAsync,
	describe: () => describe,
	discriminatedUnion: () => discriminatedUnion,
	e164: () => e164,
	email: () => email,
	emoji: () => emoji,
	encode: () => encode,
	encodeAsync: () => encodeAsync,
	endsWith: () => _endsWith,
	enum: () => _enum,
	exactOptional: () => exactOptional,
	file: () => file,
	flattenError: () => flattenError,
	float32: () => float32,
	float64: () => float64,
	formatError: () => formatError,
	fromJSONSchema: () => fromJSONSchema,
	function: () => _function,
	getErrorMap: () => getErrorMap,
	globalRegistry: () => globalRegistry,
	gt: () => _gt,
	gte: () => _gte,
	guid: () => guid,
	hash: () => hash,
	hex: () => hex,
	hostname: () => hostname,
	httpUrl: () => httpUrl,
	includes: () => _includes,
	instanceof: () => _instanceof,
	int: () => int,
	int32: () => int32,
	int64: () => int64,
	intersection: () => intersection,
	ipv4: () => ipv4,
	ipv6: () => ipv6,
	iso: () => iso_exports,
	json: () => json,
	jwt: () => jwt,
	keyof: () => keyof,
	ksuid: () => ksuid,
	lazy: () => lazy,
	length: () => _length,
	literal: () => literal,
	locales: () => locales_exports,
	looseObject: () => looseObject,
	looseRecord: () => looseRecord,
	lowercase: () => _lowercase,
	lt: () => _lt,
	lte: () => _lte,
	mac: () => mac,
	map: () => map,
	maxLength: () => _maxLength,
	maxSize: () => _maxSize,
	meta: () => meta,
	mime: () => _mime,
	minLength: () => _minLength,
	minSize: () => _minSize,
	multipleOf: () => _multipleOf,
	nan: () => nan,
	nanoid: () => nanoid,
	nativeEnum: () => nativeEnum,
	negative: () => _negative,
	never: () => never,
	nonnegative: () => _nonnegative,
	nonoptional: () => nonoptional,
	nonpositive: () => _nonpositive,
	normalize: () => _normalize,
	null: () => _null,
	nullable: () => nullable,
	nullish: () => nullish,
	number: () => number$1,
	object: () => object,
	optional: () => optional,
	overwrite: () => _overwrite,
	parse: () => parse$1,
	parseAsync: () => parseAsync,
	partialRecord: () => partialRecord,
	pipe: () => pipe,
	positive: () => _positive,
	prefault: () => prefault,
	preprocess: () => preprocess,
	prettifyError: () => prettifyError,
	promise: () => promise,
	property: () => _property,
	readonly: () => readonly,
	record: () => record,
	refine: () => refine,
	regex: () => _regex,
	regexes: () => regexes_exports,
	registry: () => registry,
	safeDecode: () => safeDecode,
	safeDecodeAsync: () => safeDecodeAsync,
	safeEncode: () => safeEncode,
	safeEncodeAsync: () => safeEncodeAsync,
	safeParse: () => safeParse,
	safeParseAsync: () => safeParseAsync,
	set: () => set,
	setErrorMap: () => setErrorMap,
	size: () => _size,
	slugify: () => _slugify,
	startsWith: () => _startsWith,
	strictObject: () => strictObject,
	string: () => string$1,
	stringFormat: () => stringFormat,
	stringbool: () => stringbool,
	success: () => success,
	superRefine: () => superRefine,
	symbol: () => symbol,
	templateLiteral: () => templateLiteral,
	toJSONSchema: () => toJSONSchema,
	toLowerCase: () => _toLowerCase,
	toUpperCase: () => _toUpperCase,
	transform: () => transform,
	treeifyError: () => treeifyError,
	trim: () => _trim,
	tuple: () => tuple,
	uint32: () => uint32,
	uint64: () => uint64,
	ulid: () => ulid,
	undefined: () => _undefined,
	union: () => union,
	unknown: () => unknown,
	uppercase: () => _uppercase,
	url: () => url$1,
	util: () => util_exports,
	uuid: () => uuid,
	uuidv4: () => uuidv4,
	uuidv6: () => uuidv6,
	uuidv7: () => uuidv7,
	void: () => _void,
	xid: () => xid,
	xor: () => xor
});
config(en_default());

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/index.js
var zod_default = external_exports;

//#endregion
//#region src/jwt.ts
/**
* Skip JTI check for JWTs issued within this many seconds.
* This is safe because replay attacks require time for interception.
* A freshly issued token is almost certainly legitimate.
*/
const JTI_CHECK_GRACE_PERIOD_SECONDS = 30;
async function getJWKs(apiUrl) {
	const jwks = await betterFetch(`${apiUrl}/api/auth/jwks`);
	if (!jwks.data) throw new APIError$1("UNAUTHORIZED", { message: "Invalid API key" });
	return createLocalJWKSet(jwks.data);
}
/**
* Check if JWT is recently issued and can skip JTI verification.
* JWTs issued within the grace period are trusted without JTI check
* since replay attacks need time for interception and replay.
*/
function isRecentlyIssued(payload) {
	if (!payload.iat) return false;
	const issuedAt = payload.iat * 1e3;
	return Date.now() - issuedAt < JTI_CHECK_GRACE_PERIOD_SECONDS * 1e3;
}
const jwtMiddleware = (options, schema, getJWT) => createAuthMiddleware(async (ctx) => {
	const jwsFromHeader = getJWT ? await getJWT(ctx) : ctx.headers?.get("Authorization")?.split(" ")[1];
	if (!jwsFromHeader) throw ctx.error("UNAUTHORIZED", { message: "Invalid API key" });
	const { payload } = await jwtVerify(jwsFromHeader, await getJWKs(options.apiUrl), { maxTokenAge: "5m" }).catch(() => {
		throw ctx.error("UNAUTHORIZED", { message: "Invalid API key" });
	});
	if (!isRecentlyIssued(payload)) {
		if (!(await betterFetch("/api/auth/check-jti", {
			baseURL: options.apiUrl,
			method: "POST",
			body: {
				jti: payload.jti,
				expiresAt: payload.exp
			}
		})).data?.valid) throw ctx.error("UNAUTHORIZED", { message: "Invalid API key" });
	}
	if (schema) {
		const parsed = schema.safeParse(payload);
		if (!parsed.success) throw ctx.error("UNAUTHORIZED", { message: "Invalid API key" });
		return { payload: parsed.data };
	}
	return { payload };
});

//#endregion
//#region src/routes/users.ts
const getUsers = (options) => {
	return createAuthEndpoint("/dash/list-users", {
		method: "GET",
		use: [jwtMiddleware(options)],
		query: zod_default.object({
			limit: zod_default.number().or(zod_default.string().transform(Number)).optional(),
			offset: zod_default.number().or(zod_default.string().transform(Number)).optional(),
			sortBy: zod_default.string().optional(),
			sortOrder: zod_default.enum(["asc", "desc"]).optional(),
			where: zod_default.string().transform((val) => {
				if (!val) return [];
				return JSON.parse(val);
			}).optional(),
			countWhere: zod_default.string().transform((val) => {
				if (!val) return [];
				return JSON.parse(val);
			}).optional()
		}).optional()
	}, async (ctx) => {
		const activityTrackingEnabled = !!options.activityTracking?.enabled;
		const userQuery = ctx.context.adapter.findMany({
			model: "user",
			limit: ctx.query?.limit || 10,
			offset: ctx.query?.offset ? ctx.query.offset : 0,
			sortBy: {
				field: ctx.query?.sortBy || "createdAt",
				direction: ctx.query?.sortOrder || "desc"
			},
			where: ctx.query?.where
		});
		const totalQuery = ctx.context.adapter.count({
			model: "user",
			where: ctx.query?.countWhere
		});
		const onlineUsersQuery = activityTrackingEnabled ? ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "lastActiveAt",
				value: /* @__PURE__ */ new Date(Date.now() - 1e3 * 60 * 2),
				operator: "gte"
			}]
		}) : Promise.resolve(0);
		const [users, total, onlineUsers] = await Promise.all([
			userQuery,
			totalQuery,
			onlineUsersQuery
		]);
		const hasAdminPlugin = ctx.context.options.plugins?.some((p) => p.id === "admin");
		return {
			users: users.map((user) => {
				const u = user;
				return {
					...u,
					banned: hasAdminPlugin ? u.banned ?? false : false,
					banReason: hasAdminPlugin ? u.banReason ?? null : null,
					banExpires: hasAdminPlugin ? u.banExpires ?? null : null
				};
			}),
			total,
			offset: ctx.query?.offset || 0,
			limit: ctx.query?.limit || 10,
			onlineUsers,
			activityTrackingEnabled
		};
	});
};
const getOnlineUsersCount = (options) => {
	return createAuthEndpoint("/dash/online-users-count", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		if (!options.activityTracking?.enabled) return { onlineUsers: 0 };
		return { onlineUsers: await ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "lastActiveAt",
				value: /* @__PURE__ */ new Date(Date.now() - 1e3 * 60 * 2),
				operator: "gte"
			}]
		}) };
	});
};
const deleteUser = (options) => {
	return createAuthEndpoint("/dash/delete-user", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
	}, async (ctx) => {
		try {
			await ctx.context.adapter.delete({
				model: "user",
				where: [{
					field: "id",
					value: ctx.context.payload.userId
				}]
			});
		} catch (e) {
			logger.error(e);
			throw ctx.error("INTERNAL_SERVER_ERROR", { message: "Internal server error" });
		}
	});
};
const impersonateUser = (options) => {
	return createAuthEndpoint("/dash/impersonate-user", {
		method: "GET",
		query: zod_default.object({ impersonation_token: zod_default.string() }),
		use: [jwtMiddleware(options, zod_default.object({
			userId: zod_default.string(),
			redirectUrl: zod_default.string().url(),
			impersonatedBy: zod_default.string().optional()
		}), async (ctx) => {
			return ctx.query.impersonation_token;
		})]
	}, async (ctx) => {
		const { userId, redirectUrl, impersonatedBy } = ctx.context.payload;
		if (!(userId && redirectUrl)) throw ctx.error("BAD_REQUEST", { message: "Invalid token" });
		const session = await ctx.context.internalAdapter.createSession(userId, true, {
			expiresAt: new Date(Date.now() + 1e3 * 60 * 10),
			impersonatedBy: impersonatedBy || void 0
		});
		const user = await ctx.context.internalAdapter.findUserById(userId);
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		await setSessionCookie(ctx, {
			session,
			user
		}, true);
		throw ctx.redirect(redirectUrl);
	});
};
const createUser = (options) => {
	return createAuthEndpoint("/dash/create-user", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({
			organizationId: zod_default.string().optional(),
			organizationRole: zod_default.string().optional()
		}))],
		body: zod_default.object({
			name: zod_default.string(),
			email: zod_default.string().email(),
			image: zod_default.string().optional(),
			password: zod_default.string().optional(),
			generatePassword: zod_default.boolean().optional(),
			emailVerified: zod_default.boolean().optional(),
			sendVerificationEmail: zod_default.boolean().optional(),
			sendOrganizationInvite: zod_default.boolean().optional(),
			organizationRole: zod_default.string().optional(),
			organizationId: zod_default.string().optional()
		}).passthrough()
	}, async (ctx) => {
		const userData = ctx.body;
		if (await ctx.context.internalAdapter.findUserByEmail(userData.email)) throw new APIError("BAD_REQUEST", { message: "User with this email already exist" });
		let password = null;
		if (userData.generatePassword && !userData.password) password = generateId(12);
		else if (userData.password && userData.password.trim() !== "") password = userData.password;
		const user = await ctx.context.internalAdapter.createUser({
			...userData,
			emailVerified: userData.emailVerified,
			createdAt: /* @__PURE__ */ new Date(),
			updatedAt: /* @__PURE__ */ new Date()
		});
		if (password) await ctx.context.internalAdapter.createAccount({
			userId: user.id,
			providerId: "credential",
			accountId: user.id,
			password: await ctx.context.password.hash(password)
		});
		if (userData.sendVerificationEmail && !userData.emailVerified) {
			if (ctx.context.options.emailVerification?.sendVerificationEmail) await sendVerificationEmailFn(ctx, user);
		}
		const organizationId = ctx.context.payload?.organizationId || userData.organizationId;
		const organizationRole = ctx.context.payload?.organizationRole || userData.organizationRole;
		if (organizationId) {
			const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
			if (organizationPlugin) {
				const orgOptions = organizationPlugin?.options || {};
				const role = organizationRole || orgOptions.defaultRole || "member";
				const organization = await ctx.context.adapter.findOne({
					model: "organization",
					where: [{
						field: "id",
						value: organizationId
					}]
				});
				if (organization) {
					let memberData = {
						organizationId,
						userId: user.id,
						role,
						createdAt: /* @__PURE__ */ new Date()
					};
					if (orgOptions?.organizationHooks?.beforeAddMember) {
						const response = await orgOptions.organizationHooks.beforeAddMember({
							member: memberData,
							user,
							organization
						});
						if (response && typeof response === "object" && "data" in response) memberData = {
							...memberData,
							...response.data
						};
					}
					const member = await ctx.context.adapter.create({
						model: "member",
						data: memberData
					});
					if (orgOptions?.organizationHooks?.afterAddMember) await orgOptions.organizationHooks.afterAddMember({
						member,
						user,
						organization
					});
				}
			}
		}
		return user;
	});
};
const setPassword = (options) => {
	return createAuthEndpoint("/dash/set-password", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))],
		body: zod_default.object({ password: zod_default.string().min(8) })
	}, async (ctx) => {
		const { userId } = ctx.context.payload;
		const { password } = ctx.body;
		if (!userId) throw new APIError("FORBIDDEN", { message: "Invalid payload" });
		const hashed = await ctx.context.password.hash(password);
		const credential = (await ctx.context.internalAdapter.findAccounts(userId)).find((a) => a.providerId === "credential");
		if (credential) await ctx.context.internalAdapter.updateAccount(credential.id, {
			password: hashed,
			updatedAt: /* @__PURE__ */ new Date()
		});
		else await ctx.context.internalAdapter.createAccount({
			userId,
			providerId: "credential",
			accountId: userId,
			password: hashed
		});
		return { success: true };
	});
};
const unlinkAccount = (options) => {
	return createAuthEndpoint("/dash/unlink-account", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))],
		body: zod_default.object({
			providerId: zod_default.string(),
			accountId: zod_default.string().optional()
		})
	}, async (ctx) => {
		const { userId } = ctx.context.payload;
		const { providerId, accountId } = ctx.body;
		if (!userId) throw new APIError("BAD_REQUEST", { message: "Invalid payload" });
		const accounts = await ctx.context.internalAdapter.findAccounts(userId);
		const allowUnlinkingAll = ctx.context.options.account?.accountLinking?.allowUnlinkingAll ?? false;
		if (accounts.length === 1 && !allowUnlinkingAll) throw new APIError("BAD_REQUEST", { message: "Cannot unlink the last account. This would lock the user out." });
		const accountToUnlink = accounts.find((account) => accountId ? account.accountId === accountId && account.providerId === providerId : account.providerId === providerId);
		if (!accountToUnlink) throw new APIError("NOT_FOUND", { message: "Account not found" });
		await ctx.context.internalAdapter.deleteAccount(accountToUnlink.id);
		return { success: true };
	});
};
const getUserDetails = (options) => {
	return createAuthEndpoint("/dash/user", {
		method: "GET",
		use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
	}, async (ctx) => {
		const { userId } = ctx.context.payload;
		const hasAdminPlugin = ctx.context.options.plugins?.some((p) => p.id === "admin");
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: userId
			}],
			join: {
				account: true,
				session: true
			}
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		const activityTrackingEnabled = !!options.activityTracking?.enabled;
		let sessions = user.session || [];
		let lastActiveAt = null;
		if (activityTrackingEnabled) {
			lastActiveAt = user.lastActiveAt;
			let shouldUpdateLastActiveAt = false;
			if (sessions.length > 0) {
				const mostRecentSession = [...sessions].sort((a, b) => {
					const aTime = new Date(a.updatedAt || a.createdAt).getTime();
					return new Date(b.updatedAt || b.createdAt).getTime() - aTime;
				})[0];
				if (!lastActiveAt && mostRecentSession) {
					lastActiveAt = new Date(mostRecentSession.updatedAt || mostRecentSession.createdAt);
					shouldUpdateLastActiveAt = true;
				}
			}
			if (shouldUpdateLastActiveAt && lastActiveAt) try {
				await ctx.context.internalAdapter.updateUser(userId, {
					lastActiveAt,
					updatedAt: /* @__PURE__ */ new Date()
				});
			} catch (error$47) {
				ctx.context.logger.error("Failed to update user lastActiveAt:", error$47);
			}
		}
		return {
			...user,
			lastActiveAt,
			banned: hasAdminPlugin ? user.banned ?? false : false,
			banReason: hasAdminPlugin ? user.banReason ?? null : null,
			banExpires: hasAdminPlugin ? user.banExpires ?? null : null
		};
	});
};
const getUserOrganizations = (options) => {
	return createAuthEndpoint("/dash/user-organizations", {
		method: "GET",
		use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
	}, async (ctx) => {
		const { userId } = ctx.context.payload;
		const isOrgEnabled = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!isOrgEnabled) return { organizations: [] };
		const member = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "userId",
				value: userId
			}]
		});
		if (member.length === 0) return { organizations: [] };
		const organizations = await ctx.context.adapter.findMany({
			model: "organization",
			where: [{
				field: "id",
				value: member.map((m) => m.organizationId),
				operator: "in"
			}]
		});
		const isTeamEnabled = isOrgEnabled.options?.teams?.enabled;
		const teamMembers = isTeamEnabled ? await ctx.context.adapter.findMany({
			model: "teamMember",
			where: [{
				field: "userId",
				value: userId
			}]
		}).catch((e) => {
			ctx.context.logger.error(e);
			return [];
		}) : [];
		const teams = isTeamEnabled && teamMembers.length > 0 ? await ctx.context.adapter.findMany({
			model: "team",
			where: [{
				field: "id",
				value: teamMembers.map((tm) => tm.teamId),
				operator: "in"
			}]
		}) : [];
		return { organizations: organizations.map((organization) => ({
			id: organization.id,
			name: organization.name,
			logo: organization.logo,
			createdAt: organization.createdAt,
			slug: organization.slug,
			role: member.find((m) => m.organizationId === organization.id)?.role,
			teams: teams.filter((team) => team.organizationId === organization.id)
		})) };
	});
};
const updateUser = (options) => createAuthEndpoint("/dash/update-user", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))],
	body: zod_default.object({
		name: zod_default.string().optional(),
		email: zod_default.string().email().optional(),
		image: zod_default.string().optional(),
		emailVerified: zod_default.boolean().optional()
	}).passthrough()
}, async (ctx) => {
	const updateData = ctx.body;
	const userId = ctx.context.payload?.userId;
	if (!userId) throw new APIError("FORBIDDEN", { message: "Invalid payload" });
	const filteredData = Object.fromEntries(Object.entries(updateData).filter(([_, value]) => value !== void 0));
	if (Object.keys(filteredData).length === 0) throw new APIError("BAD_REQUEST", { message: "No valid fields to update" });
	const user = await ctx.context.internalAdapter.updateUser(userId, {
		...filteredData,
		updatedAt: /* @__PURE__ */ new Date()
	});
	if (!user) throw new APIError("NOT_FOUND", { message: "User not found" });
	return user;
});
async function countUniqueActiveUsers(adapter, where) {
	const sessions = await adapter.findMany({
		model: "session",
		where
	});
	return new Set(sessions.map((s) => s.userId)).size;
}
const getUserStats = (options) => createAuthEndpoint("/dash/user-stats", {
	method: "GET",
	use: [jwtMiddleware(options)]
}, async (ctx) => {
	const now = /* @__PURE__ */ new Date();
	const oneDayAgo = /* @__PURE__ */ new Date(now.getTime() - 1440 * 60 * 1e3);
	const twoDaysAgo = /* @__PURE__ */ new Date(now.getTime() - 2880 * 60 * 1e3);
	const oneWeekAgo = /* @__PURE__ */ new Date(now.getTime() - 10080 * 60 * 1e3);
	const twoWeeksAgo = /* @__PURE__ */ new Date(now.getTime() - 336 * 60 * 60 * 1e3);
	const oneMonthAgo = /* @__PURE__ */ new Date(now.getTime() - 720 * 60 * 60 * 1e3);
	const twoMonthsAgo = /* @__PURE__ */ new Date(now.getTime() - 1440 * 60 * 60 * 1e3);
	const [dailyCount, previousDailyCount, weeklyCount, previousWeeklyCount, monthlyCount, previousMonthlyCount, totalCount, dailyActiveCount, previousDailyActiveCount, weeklyActiveCount, previousWeeklyActiveCount, monthlyActiveCount, previousMonthlyActiveCount] = await Promise.all([
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: oneDayAgo
			}]
		}),
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: twoDaysAgo
			}, {
				field: "createdAt",
				operator: "lt",
				value: oneDayAgo
			}]
		}),
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: oneWeekAgo
			}]
		}),
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: twoWeeksAgo
			}, {
				field: "createdAt",
				operator: "lt",
				value: oneWeekAgo
			}]
		}),
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: oneMonthAgo
			}]
		}),
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: twoMonthsAgo
			}, {
				field: "createdAt",
				operator: "lt",
				value: oneMonthAgo
			}]
		}),
		ctx.context.adapter.count({ model: "user" }),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gte",
			value: oneDayAgo
		}]),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gte",
			value: twoDaysAgo
		}, {
			field: "updatedAt",
			operator: "lt",
			value: oneDayAgo
		}]),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gte",
			value: oneWeekAgo
		}]),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gte",
			value: twoWeeksAgo
		}, {
			field: "updatedAt",
			operator: "lt",
			value: oneWeekAgo
		}]),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gte",
			value: oneMonthAgo
		}]),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gte",
			value: twoMonthsAgo
		}, {
			field: "updatedAt",
			operator: "lt",
			value: oneMonthAgo
		}])
	]);
	const calculatePercentage = (current, previous) => {
		if (previous === 0) return current > 0 ? 100 : 0;
		return (current - previous) / previous * 100;
	};
	return {
		daily: {
			signUps: dailyCount,
			percentage: calculatePercentage(dailyCount, previousDailyCount)
		},
		weekly: {
			signUps: weeklyCount,
			percentage: calculatePercentage(weeklyCount, previousWeeklyCount)
		},
		monthly: {
			signUps: monthlyCount,
			percentage: calculatePercentage(monthlyCount, previousMonthlyCount)
		},
		total: totalCount,
		activeUsers: {
			daily: {
				active: dailyActiveCount,
				percentage: calculatePercentage(dailyActiveCount, previousDailyActiveCount)
			},
			weekly: {
				active: weeklyActiveCount,
				percentage: calculatePercentage(weeklyActiveCount, previousWeeklyActiveCount)
			},
			monthly: {
				active: monthlyActiveCount,
				percentage: calculatePercentage(monthlyActiveCount, previousMonthlyActiveCount)
			}
		}
	};
});
const getUserGraphData = (options) => createAuthEndpoint("/dash/user-graph-data", {
	method: "GET",
	use: [jwtMiddleware(options)],
	query: zod_default.object({ period: zod_default.enum([
		"daily",
		"weekly",
		"monthly"
	]).default("daily") })
}, async (ctx) => {
	const { period } = ctx.query;
	const now = /* @__PURE__ */ new Date();
	const intervals = period === "daily" ? 7 : period === "weekly" ? 8 : 6;
	const msPerInterval = period === "daily" ? 1440 * 60 * 1e3 : period === "weekly" ? 10080 * 60 * 1e3 : 720 * 60 * 60 * 1e3;
	const intervalData = [];
	for (let i = intervals - 1; i >= 0; i--) {
		const endDate = new Date(now.getTime() - i * msPerInterval);
		const startDate = new Date(endDate.getTime() - msPerInterval);
		let label;
		if (period === "daily") label = endDate.toLocaleDateString("en-US", { weekday: "short" });
		else if (period === "weekly") label = endDate.toLocaleDateString("en-US", {
			month: "short",
			day: "numeric"
		});
		else label = endDate.toLocaleDateString("en-US", { month: "short" });
		intervalData.push({
			startDate,
			endDate,
			label
		});
	}
	const allQueries = intervalData.flatMap((interval) => [
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "lte",
				value: interval.endDate
			}]
		}),
		ctx.context.adapter.count({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gt",
				value: interval.startDate
			}, {
				field: "createdAt",
				operator: "lte",
				value: interval.endDate
			}]
		}),
		countUniqueActiveUsers(ctx.context.adapter, [{
			field: "updatedAt",
			operator: "gt",
			value: interval.startDate
		}, {
			field: "updatedAt",
			operator: "lte",
			value: interval.endDate
		}])
	]);
	const results = await Promise.all(allQueries);
	return {
		data: intervalData.map((interval, idx) => ({
			date: typeof interval.endDate === "object" ? interval.endDate : interval.endDate,
			label: interval.label,
			totalUsers: results[idx * 3] ?? 0,
			newUsers: results[idx * 3 + 1] ?? 0,
			activeUsers: results[idx * 3 + 2] ?? 0
		})),
		period
	};
});
const getUserRetentionData = (options) => createAuthEndpoint("/dash/user-retention-data", {
	method: "GET",
	use: [jwtMiddleware(options)],
	query: zod_default.object({ period: zod_default.enum([
		"daily",
		"weekly",
		"monthly"
	]).default("weekly") })
}, async (ctx) => {
	/**
	* Professional cohort retention (calendar-aligned, UTC):
	*
	* D-N retention:
	*   users created during Day(-N) who are active during "today"
	*
	* W-N retention:
	*   users created during Week(-N) who are active during "this week"
	*
	* M-N retention:
	*   users created during Month(-N) who are active during "this month"
	*
	* Active is determined by session activity (session.updatedAt in the active window).
	*/
	const { period } = ctx.query;
	const now = /* @__PURE__ */ new Date();
	const startOfUtcDay = (d) => new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
	const startOfUtcMonth = (d) => new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
	const startOfUtcWeek = (d) => {
		const day = d.getUTCDay();
		const diff = day === 0 ? -6 : 1 - day;
		const monday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
		monday.setUTCDate(monday.getUTCDate() + diff);
		return monday;
	};
	const addUtcDays = (d, days) => {
		const nd = new Date(d);
		nd.setUTCDate(nd.getUTCDate() + days);
		return nd;
	};
	const addUtcMonths = (d, months) => {
		const nd = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
		nd.setUTCMonth(nd.getUTCMonth() + months);
		return nd;
	};
	const horizons = period === "daily" ? 7 : period === "weekly" ? 8 : 6;
	const activeStart = period === "daily" ? startOfUtcDay(now) : period === "weekly" ? startOfUtcWeek(now) : startOfUtcMonth(now);
	const activeEnd = period === "daily" ? addUtcDays(activeStart, 1) : period === "weekly" ? addUtcDays(activeStart, 7) : addUtcMonths(activeStart, 1);
	const prefix = period === "daily" ? "D" : period === "weekly" ? "W" : "M";
	const data = [];
	for (let n = 1; n <= horizons; n++) {
		const cohortStart = period === "daily" ? addUtcDays(activeStart, -n) : period === "weekly" ? addUtcDays(activeStart, -7 * n) : addUtcMonths(activeStart, -n);
		const cohortEnd = period === "daily" ? addUtcDays(cohortStart, 1) : period === "weekly" ? addUtcDays(cohortStart, 7) : addUtcMonths(cohortStart, 1);
		const cohortUsers = await ctx.context.adapter.findMany({
			model: "user",
			where: [{
				field: "createdAt",
				operator: "gte",
				value: cohortStart
			}, {
				field: "createdAt",
				operator: "lt",
				value: cohortEnd
			}]
		});
		const cohortSize = cohortUsers.length;
		if (cohortSize === 0) {
			data.push({
				n,
				label: `${prefix}${n}`,
				cohortStart: cohortStart.toISOString(),
				cohortEnd: cohortEnd.toISOString(),
				activeStart: activeStart.toISOString(),
				activeEnd: activeEnd.toISOString(),
				cohortSize: 0,
				retained: 0,
				retentionRate: 0
			});
			continue;
		}
		const cohortUserIds = cohortUsers.map((u) => u.id);
		const sessionsInActiveWindow = await ctx.context.adapter.findMany({
			model: "session",
			where: [
				{
					field: "userId",
					operator: "in",
					value: cohortUserIds
				},
				{
					field: "updatedAt",
					operator: "gte",
					value: activeStart
				},
				{
					field: "updatedAt",
					operator: "lt",
					value: activeEnd
				}
			]
		}).catch(() => []);
		const retained = new Set(sessionsInActiveWindow.map((s) => s.userId)).size;
		const retentionRate = cohortSize > 0 ? Math.round(retained / cohortSize * 100 * 10) / 10 : 0;
		data.push({
			n,
			label: `${prefix}${n}`,
			cohortStart: cohortStart.toISOString(),
			cohortEnd: cohortEnd.toISOString(),
			activeStart: activeStart.toISOString(),
			activeEnd: activeEnd.toISOString(),
			cohortSize,
			retained,
			retentionRate
		});
	}
	return {
		data,
		period
	};
});
const banUser = (options) => createAuthEndpoint("/dash/ban-user", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))],
	body: zod_default.object({
		banReason: zod_default.string().optional(),
		banExpires: zod_default.number().optional()
	})
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const { banReason, banExpires } = ctx.body;
	if (!await ctx.context.internalAdapter.findUserById(userId)) throw new APIError("NOT_FOUND", { message: "User not found" });
	await ctx.context.internalAdapter.updateUser(userId, {
		banned: true,
		banReason: banReason || null,
		banExpires: banExpires ? new Date(banExpires) : null,
		updatedAt: /* @__PURE__ */ new Date()
	});
	const sessions = await ctx.context.adapter.findMany({
		model: "session",
		where: [{
			field: "userId",
			value: userId
		}]
	});
	for (const session of sessions) await ctx.context.adapter.delete({
		model: "session",
		where: [{
			field: "id",
			value: session.id
		}]
	});
	return { success: true };
});
const unbanUser = (options) => createAuthEndpoint("/dash/unban-user", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	if (!await ctx.context.internalAdapter.findUserById(userId)) throw new APIError("NOT_FOUND", { message: "User not found" });
	await ctx.context.internalAdapter.updateUser(userId, {
		banned: false,
		banReason: null,
		banExpires: null,
		updatedAt: /* @__PURE__ */ new Date()
	});
	return { success: true };
});
const sendVerificationEmail = (options) => createAuthEndpoint("/dash/send-verification-email", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))],
	body: zod_default.object({ callbackUrl: zod_default.string().url() })
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const { callbackUrl } = ctx.body;
	const user = await ctx.context.internalAdapter.findUserById(userId);
	if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
	if (user.emailVerified) throw ctx.error("BAD_REQUEST", { message: "Email is already verified" });
	if (!ctx.context.options.emailVerification?.sendVerificationEmail) throw ctx.error("BAD_REQUEST", { message: "Email verification is not enabled" });
	await sendVerificationEmailFn({
		...ctx,
		body: {
			...ctx.body,
			callbackURL: callbackUrl
		}
	}, user);
	return { success: true };
});
const sendResetPasswordEmail = (options) => createAuthEndpoint("/dash/send-reset-password-email", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))],
	body: zod_default.object({ callbackUrl: zod_default.string().url() })
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const user = await ctx.context.internalAdapter.findUserById(userId);
	if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
	ctx.body.redirectTo = ctx.body.callbackUrl;
	ctx.body.email = user.email;
	return await requestPasswordReset(ctx);
});
const getUserMapData = (options) => createAuthEndpoint("/dash/user-map-data", {
	method: "GET",
	use: [jwtMiddleware(options)]
}, async (ctx) => {
	const sessions = await ctx.context.adapter.findMany({
		model: "session",
		limit: 1e4
	});
	const countryMap = /* @__PURE__ */ new Map();
	const cityMap = /* @__PURE__ */ new Map();
	const userCountrySeen = /* @__PURE__ */ new Set();
	for (const session of sessions) {
		if (!session.country || !session.userId) continue;
		const userCountryKey = `${session.userId}:${session.country}`;
		if (userCountrySeen.has(userCountryKey)) continue;
		userCountrySeen.add(userCountryKey);
		countryMap.set(session.country, (countryMap.get(session.country) || 0) + 1);
		if (session.city) {
			const cityKey = `${session.city}:${session.country}`;
			const existing = cityMap.get(cityKey);
			if (existing) existing.count++;
			else cityMap.set(cityKey, {
				city: session.city,
				country: session.country,
				count: 1
			});
		}
	}
	return {
		countries: Array.from(countryMap.entries()).map(([country, count]) => ({
			country_code: country,
			country_name: country,
			user_count: count
		})).sort((a, b) => b.user_count - a.user_count),
		cities: Array.from(cityMap.values()).map((c) => ({
			city: c.city,
			country: c.country,
			country_code: c.country,
			user_count: c.count
		})).sort((a, b) => b.user_count - a.user_count).slice(0, 100),
		total: userCountrySeen.size
	};
});
const enableTwoFactor = (options) => createAuthEndpoint("/dash/enable-two-factor", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const twoFactorPlugin = ctx.context.options.plugins?.find((p) => p.id === "two-factor");
	if (!twoFactorPlugin) throw new APIError("BAD_REQUEST", { message: "Two-factor authentication plugin is not enabled" });
	if (await ctx.context.adapter.findOne({
		model: "twoFactor",
		where: [{
			field: "userId",
			value: userId
		}]
	})) throw new APIError("BAD_REQUEST", { message: "Two-factor authentication is already enabled for this user" });
	const { generateRandomString, symmetricEncrypt } = await import("better-auth/crypto");
	const secret = generateRandomString(32, "A-Z");
	const backupCodeAmount = 10;
	const backupCodeLength = 10;
	const backupCodes = [];
	for (let i = 0; i < backupCodeAmount; i++) backupCodes.push(generateId(backupCodeLength).toUpperCase());
	const encryptedSecret = await symmetricEncrypt({
		key: ctx.context.secret,
		data: secret
	});
	const encryptedBackupCodes = await symmetricEncrypt({
		key: ctx.context.secret,
		data: JSON.stringify(backupCodes)
	});
	await ctx.context.adapter.create({
		model: "twoFactor",
		data: {
			id: generateId(32),
			userId,
			secret: encryptedSecret,
			backupCodes: encryptedBackupCodes
		}
	});
	await ctx.context.internalAdapter.updateUser(userId, {
		twoFactorEnabled: true,
		updatedAt: /* @__PURE__ */ new Date()
	});
	const user = await ctx.context.internalAdapter.findUserById(userId);
	const issuer = twoFactorPlugin.options?.issuer || ctx.context.appName || "BetterAuth";
	return {
		success: true,
		totpURI: `otpauth://totp/${encodeURIComponent(issuer)}:${encodeURIComponent(user?.email || userId)}?secret=${secret}&issuer=${encodeURIComponent(issuer)}&algorithm=SHA1&digits=6&period=30`,
		secret,
		backupCodes
	};
});
const viewTwoFactorTotpUri = (options) => createAuthEndpoint("/dash/view-two-factor-totp-uri", {
	method: "POST",
	metadata: { scope: "http" },
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const twoFactorPlugin = ctx.context.options.plugins?.find((p) => p.id === "two-factor");
	if (!twoFactorPlugin) throw new APIError("BAD_REQUEST", { message: "Two-factor authentication plugin is not enabled" });
	const twoFactorRecord = await ctx.context.adapter.findOne({
		model: "twoFactor",
		where: [{
			field: "userId",
			value: userId
		}]
	});
	if (!twoFactorRecord) throw new APIError("NOT_FOUND", { message: "Two-factor authentication not set up for this user" });
	let secret = twoFactorRecord.secret;
	try {
		const { symmetricDecrypt } = await import("better-auth/crypto");
		secret = await symmetricDecrypt({
			key: ctx.context.secret,
			data: twoFactorRecord.secret
		});
	} catch {}
	const user = await ctx.context.internalAdapter.findUserById(userId);
	const issuer = twoFactorPlugin.options?.issuer || ctx.context.appName || "BetterAuth";
	return {
		totpURI: `otpauth://totp/${encodeURIComponent(issuer)}:${encodeURIComponent(user?.email || userId)}?secret=${secret}&issuer=${encodeURIComponent(issuer)}&algorithm=SHA1&digits=6&period=30`,
		secret
	};
});
const viewBackupCodes = (options) => createAuthEndpoint("/dash/view-backup-codes", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const twoFactorRecord = await ctx.context.adapter.findOne({
		model: "twoFactor",
		where: [{
			field: "userId",
			value: userId
		}]
	});
	if (!twoFactorRecord) throw new APIError("NOT_FOUND", { message: "Two-factor authentication not set up for this user" });
	let backupCodes;
	try {
		backupCodes = JSON.parse(twoFactorRecord.backupCodes);
	} catch {
		try {
			const { symmetricDecrypt } = await import("better-auth/crypto");
			const decrypted = await symmetricDecrypt({
				key: ctx.context.secret,
				data: twoFactorRecord.backupCodes
			});
			backupCodes = JSON.parse(decrypted);
		} catch {
			throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to decrypt backup codes" });
		}
	}
	return { backupCodes };
});
const disableTwoFactor = (options) => createAuthEndpoint("/dash/disable-two-factor", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	if (!ctx.context.options.plugins?.find((p) => p.id === "two-factor")) throw new APIError("BAD_REQUEST", { message: "Two-factor authentication is not enabled" });
	await ctx.context.adapter.delete({
		model: "twoFactor",
		where: [{
			field: "userId",
			value: userId
		}]
	});
	await ctx.context.internalAdapter.updateUser(userId, {
		twoFactorEnabled: false,
		updatedAt: /* @__PURE__ */ new Date()
	});
	return { success: true };
});
const generateBackupCodes = (options) => createAuthEndpoint("/dash/generate-backup-codes", {
	method: "POST",
	use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
}, async (ctx) => {
	const { userId } = ctx.context.payload;
	const twoFactorRecord = await ctx.context.adapter.findOne({
		model: "twoFactor",
		where: [{
			field: "userId",
			value: userId
		}]
	});
	if (!twoFactorRecord) throw new APIError("NOT_FOUND", { message: "Two-factor authentication not set up for this user" });
	const backupCodeAmount = 10;
	const backupCodeLength = 10;
	const newBackupCodes = [];
	for (let i = 0; i < backupCodeAmount; i++) newBackupCodes.push(generateId(backupCodeLength).toUpperCase());
	const { symmetricEncrypt } = await import("better-auth/crypto");
	const encryptedCodes = await symmetricEncrypt({
		key: ctx.context.secret,
		data: JSON.stringify(newBackupCodes)
	});
	await ctx.context.adapter.update({
		model: "twoFactor",
		where: [{
			field: "id",
			value: twoFactorRecord.id
		}],
		update: { backupCodes: encryptedCodes }
	});
	return { backupCodes: newBackupCodes };
});

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/util.js
const nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
nameStartChar + "";
const nameRegexp = "[" + nameStartChar + "][:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*";
const regexName = /* @__PURE__ */ new RegExp("^" + nameRegexp + "$");
function getAllMatches(string$3, regex) {
	const matches = [];
	let match = regex.exec(string$3);
	while (match) {
		const allmatches = [];
		allmatches.startIndex = regex.lastIndex - match[0].length;
		const len = match.length;
		for (let index = 0; index < len; index++) allmatches.push(match[index]);
		matches.push(allmatches);
		match = regex.exec(string$3);
	}
	return matches;
}
const isName = function(string$3) {
	const match = regexName.exec(string$3);
	return !(match === null || typeof match === "undefined");
};
function isExist(v) {
	return typeof v !== "undefined";
}

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/validator.js
const defaultOptions$1 = {
	allowBooleanAttributes: false,
	unpairedTags: []
};
function validate$1(xmlData, options) {
	options = Object.assign({}, defaultOptions$1, options);
	const tags = [];
	let tagFound = false;
	let reachedRoot = false;
	if (xmlData[0] === "") xmlData = xmlData.substr(1);
	for (let i = 0; i < xmlData.length; i++) if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
		i += 2;
		i = readPI(xmlData, i);
		if (i.err) return i;
	} else if (xmlData[i] === "<") {
		let tagStartPos = i;
		i++;
		if (xmlData[i] === "!") {
			i = readCommentAndCDATA(xmlData, i);
			continue;
		} else {
			let closingTag = false;
			if (xmlData[i] === "/") {
				closingTag = true;
				i++;
			}
			let tagName = "";
			for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) tagName += xmlData[i];
			tagName = tagName.trim();
			if (tagName[tagName.length - 1] === "/") {
				tagName = tagName.substring(0, tagName.length - 1);
				i--;
			}
			if (!validateTagName(tagName)) {
				let msg;
				if (tagName.trim().length === 0) msg = "Invalid space after '<'.";
				else msg = "Tag '" + tagName + "' is an invalid name.";
				return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
			}
			const result = readAttributeStr(xmlData, i);
			if (result === false) return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
			let attrStr = result.value;
			i = result.index;
			if (attrStr[attrStr.length - 1] === "/") {
				const attrStrStart = i - attrStr.length;
				attrStr = attrStr.substring(0, attrStr.length - 1);
				const isValid = validateAttributeString(attrStr, options);
				if (isValid === true) tagFound = true;
				else return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
			} else if (closingTag) if (!result.tagClosed) return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
			else if (attrStr.trim().length > 0) return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
			else if (tags.length === 0) return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
			else {
				const otg = tags.pop();
				if (tagName !== otg.tagName) {
					let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
					return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
				}
				if (tags.length == 0) reachedRoot = true;
			}
			else {
				const isValid = validateAttributeString(attrStr, options);
				if (isValid !== true) return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
				if (reachedRoot === true) return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
				else if (options.unpairedTags.indexOf(tagName) !== -1) {} else tags.push({
					tagName,
					tagStartPos
				});
				tagFound = true;
			}
			for (i++; i < xmlData.length; i++) if (xmlData[i] === "<") if (xmlData[i + 1] === "!") {
				i++;
				i = readCommentAndCDATA(xmlData, i);
				continue;
			} else if (xmlData[i + 1] === "?") {
				i = readPI(xmlData, ++i);
				if (i.err) return i;
			} else break;
			else if (xmlData[i] === "&") {
				const afterAmp = validateAmpersand(xmlData, i);
				if (afterAmp == -1) return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
				i = afterAmp;
			} else if (reachedRoot === true && !isWhiteSpace(xmlData[i])) return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
			if (xmlData[i] === "<") i--;
		}
	} else {
		if (isWhiteSpace(xmlData[i])) continue;
		return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
	}
	if (!tagFound) return getErrorObject("InvalidXml", "Start tag expected.", 1);
	else if (tags.length == 1) return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
	else if (tags.length > 0) return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
		line: 1,
		col: 1
	});
	return true;
}
function isWhiteSpace(char) {
	return char === " " || char === "	" || char === "\n" || char === "\r";
}
/**
* Read Processing insstructions and skip
* @param {*} xmlData
* @param {*} i
*/
function readPI(xmlData, i) {
	const start = i;
	for (; i < xmlData.length; i++) if (xmlData[i] == "?" || xmlData[i] == " ") {
		const tagname = xmlData.substr(start, i - start);
		if (i > 5 && tagname === "xml") return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
		else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
			i++;
			break;
		} else continue;
	}
	return i;
}
function readCommentAndCDATA(xmlData, i) {
	if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
		for (i += 3; i < xmlData.length; i++) if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
			i += 2;
			break;
		}
	} else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
		let angleBracketsCount = 1;
		for (i += 8; i < xmlData.length; i++) if (xmlData[i] === "<") angleBracketsCount++;
		else if (xmlData[i] === ">") {
			angleBracketsCount--;
			if (angleBracketsCount === 0) break;
		}
	} else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
		for (i += 8; i < xmlData.length; i++) if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
			i += 2;
			break;
		}
	}
	return i;
}
const doubleQuote = "\"";
const singleQuote = "'";
/**
* Keep reading xmlData until '<' is found outside the attribute value.
* @param {string} xmlData
* @param {number} i
*/
function readAttributeStr(xmlData, i) {
	let attrStr = "";
	let startChar = "";
	let tagClosed = false;
	for (; i < xmlData.length; i++) {
		if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) if (startChar === "") startChar = xmlData[i];
		else if (startChar !== xmlData[i]) {} else startChar = "";
		else if (xmlData[i] === ">") {
			if (startChar === "") {
				tagClosed = true;
				break;
			}
		}
		attrStr += xmlData[i];
	}
	if (startChar !== "") return false;
	return {
		value: attrStr,
		index: i,
		tagClosed
	};
}
/**
* Select all the attributes whether valid or invalid.
*/
const validAttrStrRegxp = new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?", "g");
function validateAttributeString(attrStr, options) {
	const matches = getAllMatches(attrStr, validAttrStrRegxp);
	const attrNames = {};
	for (let i = 0; i < matches.length; i++) {
		if (matches[i][1].length === 0) return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
		else if (matches[i][3] !== void 0 && matches[i][4] === void 0) return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
		else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
		const attrName = matches[i][2];
		if (!validateAttrName(attrName)) return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
		if (!attrNames.hasOwnProperty(attrName)) attrNames[attrName] = 1;
		else return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
	}
	return true;
}
function validateNumberAmpersand(xmlData, i) {
	let re = /\d/;
	if (xmlData[i] === "x") {
		i++;
		re = /[\da-fA-F]/;
	}
	for (; i < xmlData.length; i++) {
		if (xmlData[i] === ";") return i;
		if (!xmlData[i].match(re)) break;
	}
	return -1;
}
function validateAmpersand(xmlData, i) {
	i++;
	if (xmlData[i] === ";") return -1;
	if (xmlData[i] === "#") {
		i++;
		return validateNumberAmpersand(xmlData, i);
	}
	let count = 0;
	for (; i < xmlData.length; i++, count++) {
		if (xmlData[i].match(/\w/) && count < 20) continue;
		if (xmlData[i] === ";") break;
		return -1;
	}
	return i;
}
function getErrorObject(code, message, lineNumber) {
	return { err: {
		code,
		msg: message,
		line: lineNumber.line || lineNumber,
		col: lineNumber.col
	} };
}
function validateAttrName(attrName) {
	return isName(attrName);
}
function validateTagName(tagname) {
	return isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
	const lines = xmlData.substring(0, index).split(/\r?\n/);
	return {
		line: lines.length,
		col: lines[lines.length - 1].length + 1
	};
}
function getPositionFromMatch(match) {
	return match.startIndex + match[1].length;
}

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
const defaultOptions = {
	preserveOrder: false,
	attributeNamePrefix: "@_",
	attributesGroupName: false,
	textNodeName: "#text",
	ignoreAttributes: true,
	removeNSPrefix: false,
	allowBooleanAttributes: false,
	parseTagValue: true,
	parseAttributeValue: false,
	trimValues: true,
	cdataPropName: false,
	numberParseOptions: {
		hex: true,
		leadingZeros: true,
		eNotation: true
	},
	tagValueProcessor: function(tagName, val) {
		return val;
	},
	attributeValueProcessor: function(attrName, val) {
		return val;
	},
	stopNodes: [],
	alwaysCreateTextNode: false,
	isArray: () => false,
	commentPropName: false,
	unpairedTags: [],
	processEntities: true,
	htmlEntities: false,
	ignoreDeclaration: false,
	ignorePiTags: false,
	transformTagName: false,
	transformAttributeName: false,
	updateTag: function(tagName, jPath, attrs) {
		return tagName;
	},
	captureMetaData: false
};
const buildOptions = function(options) {
	return Object.assign({}, defaultOptions, options);
};

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
let METADATA_SYMBOL$1;
if (typeof Symbol !== "function") METADATA_SYMBOL$1 = "@@xmlMetadata";
else METADATA_SYMBOL$1 = Symbol("XML Node Metadata");
var XmlNode = class {
	constructor(tagname) {
		this.tagname = tagname;
		this.child = [];
		this[":@"] = {};
	}
	add(key, val) {
		if (key === "__proto__") key = "#__proto__";
		this.child.push({ [key]: val });
	}
	addChild(node, startIndex) {
		if (node.tagname === "__proto__") node.tagname = "#__proto__";
		if (node[":@"] && Object.keys(node[":@"]).length > 0) this.child.push({
			[node.tagname]: node.child,
			[":@"]: node[":@"]
		});
		else this.child.push({ [node.tagname]: node.child });
		if (startIndex !== void 0) this.child[this.child.length - 1][METADATA_SYMBOL$1] = { startIndex };
	}
	/** symbol used for metadata */
	static getMetaDataSymbol() {
		return METADATA_SYMBOL$1;
	}
};

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var DocTypeReader = class {
	constructor(processEntities) {
		this.suppressValidationErr = !processEntities;
	}
	readDocType(xmlData, i) {
		const entities = {};
		if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
			i = i + 9;
			let angleBracketsCount = 1;
			let hasBody = false, comment = false;
			let exp = "";
			for (; i < xmlData.length; i++) if (xmlData[i] === "<" && !comment) {
				if (hasBody && hasSeq(xmlData, "!ENTITY", i)) {
					i += 7;
					let entityName, val;
					[entityName, val, i] = this.readEntityExp(xmlData, i + 1, this.suppressValidationErr);
					if (val.indexOf("&") === -1) {
						const escaped = entityName.replace(/[.\-+*:]/g, "\\.");
						entities[entityName] = {
							regx: RegExp(`&${escaped};`, "g"),
							val
						};
					}
				} else if (hasBody && hasSeq(xmlData, "!ELEMENT", i)) {
					i += 8;
					const { index } = this.readElementExp(xmlData, i + 1);
					i = index;
				} else if (hasBody && hasSeq(xmlData, "!ATTLIST", i)) i += 8;
				else if (hasBody && hasSeq(xmlData, "!NOTATION", i)) {
					i += 9;
					const { index } = this.readNotationExp(xmlData, i + 1, this.suppressValidationErr);
					i = index;
				} else if (hasSeq(xmlData, "!--", i)) comment = true;
				else throw new Error(`Invalid DOCTYPE`);
				angleBracketsCount++;
				exp = "";
			} else if (xmlData[i] === ">") {
				if (comment) {
					if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
						comment = false;
						angleBracketsCount--;
					}
				} else angleBracketsCount--;
				if (angleBracketsCount === 0) break;
			} else if (xmlData[i] === "[") hasBody = true;
			else exp += xmlData[i];
			if (angleBracketsCount !== 0) throw new Error(`Unclosed DOCTYPE`);
		} else throw new Error(`Invalid Tag instead of DOCTYPE`);
		return {
			entities,
			i
		};
	}
	readEntityExp(xmlData, i) {
		i = skipWhitespace(xmlData, i);
		let entityName = "";
		while (i < xmlData.length && !/\s/.test(xmlData[i]) && xmlData[i] !== "\"" && xmlData[i] !== "'") {
			entityName += xmlData[i];
			i++;
		}
		validateEntityName(entityName);
		i = skipWhitespace(xmlData, i);
		if (!this.suppressValidationErr) {
			if (xmlData.substring(i, i + 6).toUpperCase() === "SYSTEM") throw new Error("External entities are not supported");
			else if (xmlData[i] === "%") throw new Error("Parameter entities are not supported");
		}
		let entityValue = "";
		[i, entityValue] = this.readIdentifierVal(xmlData, i, "entity");
		i--;
		return [
			entityName,
			entityValue,
			i
		];
	}
	readNotationExp(xmlData, i) {
		i = skipWhitespace(xmlData, i);
		let notationName = "";
		while (i < xmlData.length && !/\s/.test(xmlData[i])) {
			notationName += xmlData[i];
			i++;
		}
		!this.suppressValidationErr && validateEntityName(notationName);
		i = skipWhitespace(xmlData, i);
		const identifierType = xmlData.substring(i, i + 6).toUpperCase();
		if (!this.suppressValidationErr && identifierType !== "SYSTEM" && identifierType !== "PUBLIC") throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
		i += identifierType.length;
		i = skipWhitespace(xmlData, i);
		let publicIdentifier = null;
		let systemIdentifier = null;
		if (identifierType === "PUBLIC") {
			[i, publicIdentifier] = this.readIdentifierVal(xmlData, i, "publicIdentifier");
			i = skipWhitespace(xmlData, i);
			if (xmlData[i] === "\"" || xmlData[i] === "'") [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, "systemIdentifier");
		} else if (identifierType === "SYSTEM") {
			[i, systemIdentifier] = this.readIdentifierVal(xmlData, i, "systemIdentifier");
			if (!this.suppressValidationErr && !systemIdentifier) throw new Error("Missing mandatory system identifier for SYSTEM notation");
		}
		return {
			notationName,
			publicIdentifier,
			systemIdentifier,
			index: --i
		};
	}
	readIdentifierVal(xmlData, i, type) {
		let identifierVal = "";
		const startChar = xmlData[i];
		if (startChar !== "\"" && startChar !== "'") throw new Error(`Expected quoted string, found "${startChar}"`);
		i++;
		while (i < xmlData.length && xmlData[i] !== startChar) {
			identifierVal += xmlData[i];
			i++;
		}
		if (xmlData[i] !== startChar) throw new Error(`Unterminated ${type} value`);
		i++;
		return [i, identifierVal];
	}
	readElementExp(xmlData, i) {
		i = skipWhitespace(xmlData, i);
		let elementName = "";
		while (i < xmlData.length && !/\s/.test(xmlData[i])) {
			elementName += xmlData[i];
			i++;
		}
		if (!this.suppressValidationErr && !isName(elementName)) throw new Error(`Invalid element name: "${elementName}"`);
		i = skipWhitespace(xmlData, i);
		let contentModel = "";
		if (xmlData[i] === "E" && hasSeq(xmlData, "MPTY", i)) i += 4;
		else if (xmlData[i] === "A" && hasSeq(xmlData, "NY", i)) i += 2;
		else if (xmlData[i] === "(") {
			i++;
			while (i < xmlData.length && xmlData[i] !== ")") {
				contentModel += xmlData[i];
				i++;
			}
			if (xmlData[i] !== ")") throw new Error("Unterminated content model");
		} else if (!this.suppressValidationErr) throw new Error(`Invalid Element Expression, found "${xmlData[i]}"`);
		return {
			elementName,
			contentModel: contentModel.trim(),
			index: i
		};
	}
	readAttlistExp(xmlData, i) {
		i = skipWhitespace(xmlData, i);
		let elementName = "";
		while (i < xmlData.length && !/\s/.test(xmlData[i])) {
			elementName += xmlData[i];
			i++;
		}
		validateEntityName(elementName);
		i = skipWhitespace(xmlData, i);
		let attributeName = "";
		while (i < xmlData.length && !/\s/.test(xmlData[i])) {
			attributeName += xmlData[i];
			i++;
		}
		if (!validateEntityName(attributeName)) throw new Error(`Invalid attribute name: "${attributeName}"`);
		i = skipWhitespace(xmlData, i);
		let attributeType = "";
		if (xmlData.substring(i, i + 8).toUpperCase() === "NOTATION") {
			attributeType = "NOTATION";
			i += 8;
			i = skipWhitespace(xmlData, i);
			if (xmlData[i] !== "(") throw new Error(`Expected '(', found "${xmlData[i]}"`);
			i++;
			let allowedNotations = [];
			while (i < xmlData.length && xmlData[i] !== ")") {
				let notation = "";
				while (i < xmlData.length && xmlData[i] !== "|" && xmlData[i] !== ")") {
					notation += xmlData[i];
					i++;
				}
				notation = notation.trim();
				if (!validateEntityName(notation)) throw new Error(`Invalid notation name: "${notation}"`);
				allowedNotations.push(notation);
				if (xmlData[i] === "|") {
					i++;
					i = skipWhitespace(xmlData, i);
				}
			}
			if (xmlData[i] !== ")") throw new Error("Unterminated list of notations");
			i++;
			attributeType += " (" + allowedNotations.join("|") + ")";
		} else {
			while (i < xmlData.length && !/\s/.test(xmlData[i])) {
				attributeType += xmlData[i];
				i++;
			}
			if (!this.suppressValidationErr && ![
				"CDATA",
				"ID",
				"IDREF",
				"IDREFS",
				"ENTITY",
				"ENTITIES",
				"NMTOKEN",
				"NMTOKENS"
			].includes(attributeType.toUpperCase())) throw new Error(`Invalid attribute type: "${attributeType}"`);
		}
		i = skipWhitespace(xmlData, i);
		let defaultValue = "";
		if (xmlData.substring(i, i + 8).toUpperCase() === "#REQUIRED") {
			defaultValue = "#REQUIRED";
			i += 8;
		} else if (xmlData.substring(i, i + 7).toUpperCase() === "#IMPLIED") {
			defaultValue = "#IMPLIED";
			i += 7;
		} else [i, defaultValue] = this.readIdentifierVal(xmlData, i, "ATTLIST");
		return {
			elementName,
			attributeName,
			attributeType,
			defaultValue,
			index: i
		};
	}
};
const skipWhitespace = (data, index) => {
	while (index < data.length && /\s/.test(data[index])) index++;
	return index;
};
function hasSeq(data, seq, i) {
	for (let j = 0; j < seq.length; j++) if (seq[j] !== data[i + j + 1]) return false;
	return true;
}
function validateEntityName(name$1) {
	if (isName(name$1)) return name$1;
	else throw new Error(`Invalid entity name ${name$1}`);
}

//#endregion
//#region ../../node_modules/.bun/strnum@2.1.2/node_modules/strnum/strnum.js
const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
const consider = {
	hex: true,
	leadingZeros: true,
	decimalPoint: ".",
	eNotation: true
};
function toNumber(str, options = {}) {
	options = Object.assign({}, consider, options);
	if (!str || typeof str !== "string") return str;
	let trimmedStr = str.trim();
	if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
	else if (str === "0") return 0;
	else if (options.hex && hexRegex.test(trimmedStr)) return parse_int(trimmedStr, 16);
	else if (trimmedStr.includes("e") || trimmedStr.includes("E")) return resolveEnotation(str, trimmedStr, options);
	else {
		const match = numRegex.exec(trimmedStr);
		if (match) {
			const sign = match[1] || "";
			const leadingZeros = match[2];
			let numTrimmedByZeros = trimZeros(match[3]);
			const decimalAdjacentToLeadingZeros = sign ? str[leadingZeros.length + 1] === "." : str[leadingZeros.length] === ".";
			if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) return str;
			else {
				const num = Number(trimmedStr);
				const parsedStr = String(num);
				if (num === 0) return num;
				if (parsedStr.search(/[eE]/) !== -1) if (options.eNotation) return num;
				else return str;
				else if (trimmedStr.indexOf(".") !== -1) if (parsedStr === "0") return num;
				else if (parsedStr === numTrimmedByZeros) return num;
				else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;
				else return str;
				let n = leadingZeros ? numTrimmedByZeros : trimmedStr;
				if (leadingZeros) return n === parsedStr || sign + n === parsedStr ? num : str;
				else return n === parsedStr || n === sign + parsedStr ? num : str;
			}
		} else return str;
	}
}
const eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function resolveEnotation(str, trimmedStr, options) {
	if (!options.eNotation) return str;
	const notation = trimmedStr.match(eNotationRegx);
	if (notation) {
		let sign = notation[1] || "";
		const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
		const leadingZeros = notation[2];
		const eAdjacentToLeadingZeros = sign ? str[leadingZeros.length + 1] === eChar : str[leadingZeros.length] === eChar;
		if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;
		else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) return Number(trimmedStr);
		else if (options.leadingZeros && !eAdjacentToLeadingZeros) {
			trimmedStr = (notation[1] || "") + notation[3];
			return Number(trimmedStr);
		} else return str;
	} else return str;
}
/**
* 
* @param {string} numStr without leading zeros
* @returns 
*/
function trimZeros(numStr) {
	if (numStr && numStr.indexOf(".") !== -1) {
		numStr = numStr.replace(/0+$/, "");
		if (numStr === ".") numStr = "0";
		else if (numStr[0] === ".") numStr = "0" + numStr;
		else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
		return numStr;
	}
	return numStr;
}
function parse_int(numStr, base) {
	if (parseInt) return parseInt(numStr, base);
	else if (Number.parseInt) return Number.parseInt(numStr, base);
	else if (window && window.parseInt) return window.parseInt(numStr, base);
	else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/ignoreAttributes.js
function getIgnoreAttributesFn(ignoreAttributes) {
	if (typeof ignoreAttributes === "function") return ignoreAttributes;
	if (Array.isArray(ignoreAttributes)) return (attrName) => {
		for (const pattern of ignoreAttributes) {
			if (typeof pattern === "string" && attrName === pattern) return true;
			if (pattern instanceof RegExp && pattern.test(attrName)) return true;
		}
	};
	return () => false;
}

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var OrderedObjParser = class {
	constructor(options) {
		this.options = options;
		this.currentNode = null;
		this.tagsNodeStack = [];
		this.docTypeEntities = {};
		this.lastEntities = {
			"apos": {
				regex: /&(apos|#39|#x27);/g,
				val: "'"
			},
			"gt": {
				regex: /&(gt|#62|#x3E);/g,
				val: ">"
			},
			"lt": {
				regex: /&(lt|#60|#x3C);/g,
				val: "<"
			},
			"quot": {
				regex: /&(quot|#34|#x22);/g,
				val: "\""
			}
		};
		this.ampEntity = {
			regex: /&(amp|#38|#x26);/g,
			val: "&"
		};
		this.htmlEntities = {
			"space": {
				regex: /&(nbsp|#160);/g,
				val: " "
			},
			"cent": {
				regex: /&(cent|#162);/g,
				val: ""
			},
			"pound": {
				regex: /&(pound|#163);/g,
				val: ""
			},
			"yen": {
				regex: /&(yen|#165);/g,
				val: ""
			},
			"euro": {
				regex: /&(euro|#8364);/g,
				val: ""
			},
			"copyright": {
				regex: /&(copy|#169);/g,
				val: ""
			},
			"reg": {
				regex: /&(reg|#174);/g,
				val: ""
			},
			"inr": {
				regex: /&(inr|#8377);/g,
				val: ""
			},
			"num_dec": {
				regex: /&#([0-9]{1,7});/g,
				val: (_, str) => fromCodePoint(str, 10, "&#")
			},
			"num_hex": {
				regex: /&#x([0-9a-fA-F]{1,6});/g,
				val: (_, str) => fromCodePoint(str, 16, "&#x")
			}
		};
		this.addExternalEntities = addExternalEntities;
		this.parseXml = parseXml;
		this.parseTextData = parseTextData;
		this.resolveNameSpace = resolveNameSpace;
		this.buildAttributesMap = buildAttributesMap;
		this.isItStopNode = isItStopNode;
		this.replaceEntitiesValue = replaceEntitiesValue;
		this.readStopNodeData = readStopNodeData;
		this.saveTextToParentTag = saveTextToParentTag;
		this.addChild = addChild;
		this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
		if (this.options.stopNodes && this.options.stopNodes.length > 0) {
			this.stopNodesExact = /* @__PURE__ */ new Set();
			this.stopNodesWildcard = /* @__PURE__ */ new Set();
			for (let i = 0; i < this.options.stopNodes.length; i++) {
				const stopNodeExp = this.options.stopNodes[i];
				if (typeof stopNodeExp !== "string") continue;
				if (stopNodeExp.startsWith("*.")) this.stopNodesWildcard.add(stopNodeExp.substring(2));
				else this.stopNodesExact.add(stopNodeExp);
			}
		}
	}
};
function addExternalEntities(externalEntities) {
	const entKeys = Object.keys(externalEntities);
	for (let i = 0; i < entKeys.length; i++) {
		const ent = entKeys[i];
		const escaped = ent.replace(/[.\-+*:]/g, "\\.");
		this.lastEntities[ent] = {
			regex: new RegExp("&" + escaped + ";", "g"),
			val: externalEntities[ent]
		};
	}
}
/**
* @param {string} val
* @param {string} tagName
* @param {string} jPath
* @param {boolean} dontTrim
* @param {boolean} hasAttributes
* @param {boolean} isLeafNode
* @param {boolean} escapeEntities
*/
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
	if (val !== void 0) {
		if (this.options.trimValues && !dontTrim) val = val.trim();
		if (val.length > 0) {
			if (!escapeEntities) val = this.replaceEntitiesValue(val);
			const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
			if (newval === null || newval === void 0) return val;
			else if (typeof newval !== typeof val || newval !== val) return newval;
			else if (this.options.trimValues) return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
			else if (val.trim() === val) return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
			else return val;
		}
	}
}
function resolveNameSpace(tagname) {
	if (this.options.removeNSPrefix) {
		const tags = tagname.split(":");
		const prefix = tagname.charAt(0) === "/" ? "/" : "";
		if (tags[0] === "xmlns") return "";
		if (tags.length === 2) tagname = prefix + tags[1];
	}
	return tagname;
}
const attrsRegx = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
function buildAttributesMap(attrStr, jPath) {
	if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
		const matches = getAllMatches(attrStr, attrsRegx);
		const len = matches.length;
		const attrs = {};
		for (let i = 0; i < len; i++) {
			const attrName = this.resolveNameSpace(matches[i][1]);
			if (this.ignoreAttributesFn(attrName, jPath)) continue;
			let oldVal = matches[i][4];
			let aName = this.options.attributeNamePrefix + attrName;
			if (attrName.length) {
				if (this.options.transformAttributeName) aName = this.options.transformAttributeName(aName);
				if (aName === "__proto__") aName = "#__proto__";
				if (oldVal !== void 0) {
					if (this.options.trimValues) oldVal = oldVal.trim();
					oldVal = this.replaceEntitiesValue(oldVal);
					const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
					if (newVal === null || newVal === void 0) attrs[aName] = oldVal;
					else if (typeof newVal !== typeof oldVal || newVal !== oldVal) attrs[aName] = newVal;
					else attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
				} else if (this.options.allowBooleanAttributes) attrs[aName] = true;
			}
		}
		if (!Object.keys(attrs).length) return;
		if (this.options.attributesGroupName) {
			const attrCollection = {};
			attrCollection[this.options.attributesGroupName] = attrs;
			return attrCollection;
		}
		return attrs;
	}
}
const parseXml = function(xmlData) {
	xmlData = xmlData.replace(/\r\n?/g, "\n");
	const xmlObj = new XmlNode("!xml");
	let currentNode = xmlObj;
	let textData = "";
	let jPath = "";
	const docTypeReader = new DocTypeReader(this.options.processEntities);
	for (let i = 0; i < xmlData.length; i++) if (xmlData[i] === "<") if (xmlData[i + 1] === "/") {
		const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
		let tagName = xmlData.substring(i + 2, closeIndex).trim();
		if (this.options.removeNSPrefix) {
			const colonIndex = tagName.indexOf(":");
			if (colonIndex !== -1) tagName = tagName.substr(colonIndex + 1);
		}
		if (this.options.transformTagName) tagName = this.options.transformTagName(tagName);
		if (currentNode) textData = this.saveTextToParentTag(textData, currentNode, jPath);
		const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
		if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
		let propIndex = 0;
		if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
			propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
			this.tagsNodeStack.pop();
		} else propIndex = jPath.lastIndexOf(".");
		jPath = jPath.substring(0, propIndex);
		currentNode = this.tagsNodeStack.pop();
		textData = "";
		i = closeIndex;
	} else if (xmlData[i + 1] === "?") {
		let tagData = readTagExp(xmlData, i, false, "?>");
		if (!tagData) throw new Error("Pi Tag is not closed.");
		textData = this.saveTextToParentTag(textData, currentNode, jPath);
		if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {} else {
			const childNode = new XmlNode(tagData.tagName);
			childNode.add(this.options.textNodeName, "");
			if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
			this.addChild(currentNode, childNode, jPath, i);
		}
		i = tagData.closeIndex + 1;
	} else if (xmlData.substr(i + 1, 3) === "!--") {
		const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
		if (this.options.commentPropName) {
			const comment = xmlData.substring(i + 4, endIndex - 2);
			textData = this.saveTextToParentTag(textData, currentNode, jPath);
			currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
		}
		i = endIndex;
	} else if (xmlData.substr(i + 1, 2) === "!D") {
		const result = docTypeReader.readDocType(xmlData, i);
		this.docTypeEntities = result.entities;
		i = result.i;
	} else if (xmlData.substr(i + 1, 2) === "![") {
		const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
		const tagExp = xmlData.substring(i + 9, closeIndex);
		textData = this.saveTextToParentTag(textData, currentNode, jPath);
		let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
		if (val == void 0) val = "";
		if (this.options.cdataPropName) currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
		else currentNode.add(this.options.textNodeName, val);
		i = closeIndex + 2;
	} else {
		let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
		let tagName = result.tagName;
		const rawTagName = result.rawTagName;
		let tagExp = result.tagExp;
		let attrExpPresent = result.attrExpPresent;
		let closeIndex = result.closeIndex;
		if (this.options.transformTagName) {
			const newTagName = this.options.transformTagName(tagName);
			if (tagExp === tagName) tagExp = newTagName;
			tagName = newTagName;
		}
		if (currentNode && textData) {
			if (currentNode.tagname !== "!xml") textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
		}
		const lastTag = currentNode;
		if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
			currentNode = this.tagsNodeStack.pop();
			jPath = jPath.substring(0, jPath.lastIndexOf("."));
		}
		if (tagName !== xmlObj.tagname) jPath += jPath ? "." + tagName : tagName;
		const startIndex = i;
		if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, jPath, tagName)) {
			let tagContent = "";
			if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
				if (tagName[tagName.length - 1] === "/") {
					tagName = tagName.substr(0, tagName.length - 1);
					jPath = jPath.substr(0, jPath.length - 1);
					tagExp = tagName;
				} else tagExp = tagExp.substr(0, tagExp.length - 1);
				i = result.closeIndex;
			} else if (this.options.unpairedTags.indexOf(tagName) !== -1) i = result.closeIndex;
			else {
				const result$1 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
				if (!result$1) throw new Error(`Unexpected end of ${rawTagName}`);
				i = result$1.i;
				tagContent = result$1.tagContent;
			}
			const childNode = new XmlNode(tagName);
			if (tagName !== tagExp && attrExpPresent) childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
			if (tagContent) tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
			jPath = jPath.substr(0, jPath.lastIndexOf("."));
			childNode.add(this.options.textNodeName, tagContent);
			this.addChild(currentNode, childNode, jPath, startIndex);
		} else {
			if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
				if (tagName[tagName.length - 1] === "/") {
					tagName = tagName.substr(0, tagName.length - 1);
					jPath = jPath.substr(0, jPath.length - 1);
					tagExp = tagName;
				} else tagExp = tagExp.substr(0, tagExp.length - 1);
				if (this.options.transformTagName) {
					const newTagName = this.options.transformTagName(tagName);
					if (tagExp === tagName) tagExp = newTagName;
					tagName = newTagName;
				}
				const childNode = new XmlNode(tagName);
				if (tagName !== tagExp && attrExpPresent) childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
				this.addChild(currentNode, childNode, jPath, startIndex);
				jPath = jPath.substr(0, jPath.lastIndexOf("."));
			} else {
				const childNode = new XmlNode(tagName);
				this.tagsNodeStack.push(currentNode);
				if (tagName !== tagExp && attrExpPresent) childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
				this.addChild(currentNode, childNode, jPath, startIndex);
				currentNode = childNode;
			}
			textData = "";
			i = closeIndex;
		}
	}
	else textData += xmlData[i];
	return xmlObj.child;
};
function addChild(currentNode, childNode, jPath, startIndex) {
	if (!this.options.captureMetaData) startIndex = void 0;
	const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
	if (result === false) {} else if (typeof result === "string") {
		childNode.tagname = result;
		currentNode.addChild(childNode, startIndex);
	} else currentNode.addChild(childNode, startIndex);
}
const replaceEntitiesValue = function(val) {
	if (this.options.processEntities) {
		for (let entityName in this.docTypeEntities) {
			const entity = this.docTypeEntities[entityName];
			val = val.replace(entity.regx, entity.val);
		}
		for (let entityName in this.lastEntities) {
			const entity = this.lastEntities[entityName];
			val = val.replace(entity.regex, entity.val);
		}
		if (this.options.htmlEntities) for (let entityName in this.htmlEntities) {
			const entity = this.htmlEntities[entityName];
			val = val.replace(entity.regex, entity.val);
		}
		val = val.replace(this.ampEntity.regex, this.ampEntity.val);
	}
	return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
	if (textData) {
		if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
		textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
		if (textData !== void 0 && textData !== "") currentNode.add(this.options.textNodeName, textData);
		textData = "";
	}
	return textData;
}
/**
* @param {Set} stopNodesExact
* @param {Set} stopNodesWildcard
* @param {string} jPath
* @param {string} currentTagName
*/
function isItStopNode(stopNodesExact, stopNodesWildcard, jPath, currentTagName) {
	if (stopNodesWildcard && stopNodesWildcard.has(currentTagName)) return true;
	if (stopNodesExact && stopNodesExact.has(jPath)) return true;
	return false;
}
/**
* Returns the tag Expression and where it is ending handling single-double quotes situation
* @param {string} xmlData 
* @param {number} i starting index
* @returns 
*/
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
	let attrBoundary;
	let tagExp = "";
	for (let index = i; index < xmlData.length; index++) {
		let ch = xmlData[index];
		if (attrBoundary) {
			if (ch === attrBoundary) attrBoundary = "";
		} else if (ch === "\"" || ch === "'") attrBoundary = ch;
		else if (ch === closingChar[0]) if (closingChar[1]) {
			if (xmlData[index + 1] === closingChar[1]) return {
				data: tagExp,
				index
			};
		} else return {
			data: tagExp,
			index
		};
		else if (ch === "	") ch = " ";
		tagExp += ch;
	}
}
function findClosingIndex(xmlData, str, i, errMsg) {
	const closingIndex = xmlData.indexOf(str, i);
	if (closingIndex === -1) throw new Error(errMsg);
	else return closingIndex + str.length - 1;
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
	const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
	if (!result) return;
	let tagExp = result.data;
	const closeIndex = result.index;
	const separatorIndex = tagExp.search(/\s/);
	let tagName = tagExp;
	let attrExpPresent = true;
	if (separatorIndex !== -1) {
		tagName = tagExp.substring(0, separatorIndex);
		tagExp = tagExp.substring(separatorIndex + 1).trimStart();
	}
	const rawTagName = tagName;
	if (removeNSPrefix) {
		const colonIndex = tagName.indexOf(":");
		if (colonIndex !== -1) {
			tagName = tagName.substr(colonIndex + 1);
			attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
		}
	}
	return {
		tagName,
		tagExp,
		closeIndex,
		attrExpPresent,
		rawTagName
	};
}
/**
* find paired tag for a stop node
* @param {string} xmlData 
* @param {string} tagName 
* @param {number} i 
*/
function readStopNodeData(xmlData, tagName, i) {
	const startIndex = i;
	let openTagCount = 1;
	for (; i < xmlData.length; i++) if (xmlData[i] === "<") if (xmlData[i + 1] === "/") {
		const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
		if (xmlData.substring(i + 2, closeIndex).trim() === tagName) {
			openTagCount--;
			if (openTagCount === 0) return {
				tagContent: xmlData.substring(startIndex, i),
				i: closeIndex
			};
		}
		i = closeIndex;
	} else if (xmlData[i + 1] === "?") i = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
	else if (xmlData.substr(i + 1, 3) === "!--") i = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
	else if (xmlData.substr(i + 1, 2) === "![") i = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
	else {
		const tagData = readTagExp(xmlData, i, ">");
		if (tagData) {
			if ((tagData && tagData.tagName) === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") openTagCount++;
			i = tagData.closeIndex;
		}
	}
}
function parseValue(val, shouldParse, options) {
	if (shouldParse && typeof val === "string") {
		const newval = val.trim();
		if (newval === "true") return true;
		else if (newval === "false") return false;
		else return toNumber(val, options);
	} else if (isExist(val)) return val;
	else return "";
}
function fromCodePoint(str, base, prefix) {
	const codePoint = Number.parseInt(str, base);
	if (codePoint >= 0 && codePoint <= 1114111) return String.fromCodePoint(codePoint);
	else return prefix + str + ";";
}

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/xmlparser/node2json.js
const METADATA_SYMBOL = XmlNode.getMetaDataSymbol();
/**
* 
* @param {array} node 
* @param {any} options 
* @returns 
*/
function prettify(node, options) {
	return compress(node, options);
}
/**
* 
* @param {array} arr 
* @param {object} options 
* @param {string} jPath 
* @returns object
*/
function compress(arr, options, jPath) {
	let text;
	const compressedObj = {};
	for (let i = 0; i < arr.length; i++) {
		const tagObj = arr[i];
		const property = propName(tagObj);
		let newJpath = "";
		if (jPath === void 0) newJpath = property;
		else newJpath = jPath + "." + property;
		if (property === options.textNodeName) if (text === void 0) text = tagObj[property];
		else text += "" + tagObj[property];
		else if (property === void 0) continue;
		else if (tagObj[property]) {
			let val = compress(tagObj[property], options, newJpath);
			const isLeaf = isLeafTag(val, options);
			if (tagObj[METADATA_SYMBOL] !== void 0) val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL];
			if (tagObj[":@"]) assignAttributes(val, tagObj[":@"], newJpath, options);
			else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) val = val[options.textNodeName];
			else if (Object.keys(val).length === 0) if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
			else val = "";
			if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
				if (!Array.isArray(compressedObj[property])) compressedObj[property] = [compressedObj[property]];
				compressedObj[property].push(val);
			} else if (options.isArray(property, newJpath, isLeaf)) compressedObj[property] = [val];
			else compressedObj[property] = val;
		}
	}
	if (typeof text === "string") {
		if (text.length > 0) compressedObj[options.textNodeName] = text;
	} else if (text !== void 0) compressedObj[options.textNodeName] = text;
	return compressedObj;
}
function propName(obj) {
	const keys = Object.keys(obj);
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		if (key !== ":@") return key;
	}
}
function assignAttributes(obj, attrMap, jpath, options) {
	if (attrMap) {
		const keys = Object.keys(attrMap);
		const len = keys.length;
		for (let i = 0; i < len; i++) {
			const atrrName = keys[i];
			if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) obj[atrrName] = [attrMap[atrrName]];
			else obj[atrrName] = attrMap[atrrName];
		}
	}
}
function isLeafTag(obj, options) {
	const { textNodeName } = options;
	const propCount = Object.keys(obj).length;
	if (propCount === 0) return true;
	if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) return true;
	return false;
}

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var XMLParser = class {
	constructor(options) {
		this.externalEntities = {};
		this.options = buildOptions(options);
	}
	/**
	* Parse XML dats to JS object 
	* @param {string|Uint8Array} xmlData 
	* @param {boolean|Object} validationOption 
	*/
	parse(xmlData, validationOption) {
		if (typeof xmlData !== "string" && xmlData.toString) xmlData = xmlData.toString();
		else if (typeof xmlData !== "string") throw new Error("XML data is accepted in String or Bytes[] form.");
		if (validationOption) {
			if (validationOption === true) validationOption = {};
			const result = validate$1(xmlData, validationOption);
			if (result !== true) throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
		}
		const orderedObjParser = new OrderedObjParser(this.options);
		orderedObjParser.addExternalEntities(this.externalEntities);
		const orderedResult = orderedObjParser.parseXml(xmlData);
		if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
		else return prettify(orderedResult, this.options);
	}
	/**
	* Add Entity which is not by default supported by this library
	* @param {string} key 
	* @param {string} value 
	*/
	addEntity(key, value) {
		if (value.indexOf("&") !== -1) throw new Error("Entity value can't have '&'");
		else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
		else if (value === "&") throw new Error("An entity with value '&' is not permitted");
		else this.externalEntities[key] = value;
	}
	/**
	* Returns a Symbol that can be used to access the metadata
	* property on a node.
	* 
	* If Symbol is not available in the environment, an ordinary property is used
	* and the name of the property is here returned.
	* 
	* The XMLMetaData property is only present when `captureMetaData`
	* is true in the options.
	*/
	static getMetaDataSymbol() {
		return XmlNode.getMetaDataSymbol();
	}
};

//#endregion
//#region ../../node_modules/.bun/fast-xml-parser@5.3.5/node_modules/fast-xml-parser/src/fxp.js
const XMLValidator = { validate: validate$1 };

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/forge.js
var require_forge = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2016 Digital Bazaar, Inc.
	*/
	module.exports = { options: { usePureJavaScript: false } };
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/baseN.js
var require_baseN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Base-N/Base-X encoding/decoding functions.
	*
	* Original implementation from base-x:
	* https://github.com/cryptocoinjs/base-x
	*
	* Which is MIT licensed:
	*
	* The MIT License (MIT)
	*
	* Copyright base-x contributors (c) 2016
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to deal
	* in the Software without restriction, including without limitation the rights
	* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	* DEALINGS IN THE SOFTWARE.
	*/
	var api = {};
	module.exports = api;
	var _reverseAlphabets = {};
	/**
	* BaseN-encodes a Uint8Array using the given alphabet.
	*
	* @param input the Uint8Array to encode.
	* @param maxline the maximum number of encoded characters per line to use,
	*          defaults to none.
	*
	* @return the baseN-encoded output string.
	*/
	api.encode = function(input, alphabet, maxline) {
		if (typeof alphabet !== "string") throw new TypeError("\"alphabet\" must be a string.");
		if (maxline !== void 0 && typeof maxline !== "number") throw new TypeError("\"maxline\" must be a number.");
		var output = "";
		if (!(input instanceof Uint8Array)) output = _encodeWithByteBuffer(input, alphabet);
		else {
			var i = 0;
			var base = alphabet.length;
			var first = alphabet.charAt(0);
			var digits = [0];
			for (i = 0; i < input.length; ++i) {
				for (var j = 0, carry = input[i]; j < digits.length; ++j) {
					carry += digits[j] << 8;
					digits[j] = carry % base;
					carry = carry / base | 0;
				}
				while (carry > 0) {
					digits.push(carry % base);
					carry = carry / base | 0;
				}
			}
			for (i = 0; input[i] === 0 && i < input.length - 1; ++i) output += first;
			for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
		}
		if (maxline) {
			var regex = new RegExp(".{1," + maxline + "}", "g");
			output = output.match(regex).join("\r\n");
		}
		return output;
	};
	/**
	* Decodes a baseN-encoded (using the given alphabet) string to a
	* Uint8Array.
	*
	* @param input the baseN-encoded input string.
	*
	* @return the Uint8Array.
	*/
	api.decode = function(input, alphabet) {
		if (typeof input !== "string") throw new TypeError("\"input\" must be a string.");
		if (typeof alphabet !== "string") throw new TypeError("\"alphabet\" must be a string.");
		var table = _reverseAlphabets[alphabet];
		if (!table) {
			table = _reverseAlphabets[alphabet] = [];
			for (var i = 0; i < alphabet.length; ++i) table[alphabet.charCodeAt(i)] = i;
		}
		input = input.replace(/\s/g, "");
		var base = alphabet.length;
		var first = alphabet.charAt(0);
		var bytes = [0];
		for (var i = 0; i < input.length; i++) {
			var value = table[input.charCodeAt(i)];
			if (value === void 0) return;
			for (var j = 0, carry = value; j < bytes.length; ++j) {
				carry += bytes[j] * base;
				bytes[j] = carry & 255;
				carry >>= 8;
			}
			while (carry > 0) {
				bytes.push(carry & 255);
				carry >>= 8;
			}
		}
		for (var k = 0; input[k] === first && k < input.length - 1; ++k) bytes.push(0);
		if (typeof Buffer !== "undefined") return Buffer.from(bytes.reverse());
		return new Uint8Array(bytes.reverse());
	};
	function _encodeWithByteBuffer(input, alphabet) {
		var i = 0;
		var base = alphabet.length;
		var first = alphabet.charAt(0);
		var digits = [0];
		for (i = 0; i < input.length(); ++i) {
			for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
				carry += digits[j] << 8;
				digits[j] = carry % base;
				carry = carry / base | 0;
			}
			while (carry > 0) {
				digits.push(carry % base);
				carry = carry / base | 0;
			}
		}
		var output = "";
		for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) output += first;
		for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
		return output;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/util.js
var require_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Utility functions for web applications.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2018 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	var baseN = require_baseN();
	var util = module.exports = forge.util = forge.util || {};
	(function() {
		if (typeof process !== "undefined" && process.nextTick && !process.browser) {
			util.nextTick = process.nextTick;
			if (typeof setImmediate === "function") util.setImmediate = setImmediate;
			else util.setImmediate = util.nextTick;
			return;
		}
		if (typeof setImmediate === "function") {
			util.setImmediate = function() {
				return setImmediate.apply(void 0, arguments);
			};
			util.nextTick = function(callback$1) {
				return setImmediate(callback$1);
			};
			return;
		}
		util.setImmediate = function(callback$1) {
			setTimeout(callback$1, 0);
		};
		if (typeof window !== "undefined" && typeof window.postMessage === "function") {
			var msg = "forge.setImmediate";
			var callbacks = [];
			util.setImmediate = function(callback$1) {
				callbacks.push(callback$1);
				if (callbacks.length === 1) window.postMessage(msg, "*");
			};
			function handler(event) {
				if (event.source === window && event.data === msg) {
					event.stopPropagation();
					var copy = callbacks.slice();
					callbacks.length = 0;
					copy.forEach(function(callback$1) {
						callback$1();
					});
				}
			}
			window.addEventListener("message", handler, true);
		}
		if (typeof MutationObserver !== "undefined") {
			var now = Date.now();
			var attr = true;
			var div = document.createElement("div");
			var callbacks = [];
			new MutationObserver(function() {
				var copy = callbacks.slice();
				callbacks.length = 0;
				copy.forEach(function(callback$1) {
					callback$1();
				});
			}).observe(div, { attributes: true });
			var oldSetImmediate = util.setImmediate;
			util.setImmediate = function(callback$1) {
				if (Date.now() - now > 15) {
					now = Date.now();
					oldSetImmediate(callback$1);
				} else {
					callbacks.push(callback$1);
					if (callbacks.length === 1) div.setAttribute("a", attr = !attr);
				}
			};
		}
		util.nextTick = util.setImmediate;
	})();
	util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
	util.globalScope = (function() {
		if (util.isNodejs) return global;
		return typeof self === "undefined" ? window : self;
	})();
	util.isArray = Array.isArray || function(x) {
		return Object.prototype.toString.call(x) === "[object Array]";
	};
	util.isArrayBuffer = function(x) {
		return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
	};
	util.isArrayBufferView = function(x) {
		return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
	};
	/**
	* Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
	* algorithms where bit manipulation, JavaScript limitations, and/or algorithm
	* design only allow for byte operations of a limited size.
	*
	* @param n number of bits.
	*
	* Throw Error if n invalid.
	*/
	function _checkBitsParam(n) {
		if (!(n === 8 || n === 16 || n === 24 || n === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
	}
	util.ByteBuffer = ByteStringBuffer;
	/** Buffer w/BinaryString backing */
	/**
	* Constructor for a binary string backed byte buffer.
	*
	* @param [b] the bytes to wrap (either encoded as string, one byte per
	*          character, or as an ArrayBuffer or Typed Array).
	*/
	function ByteStringBuffer(b) {
		this.data = "";
		this.read = 0;
		if (typeof b === "string") this.data = b;
		else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) if (typeof Buffer !== "undefined" && b instanceof Buffer) this.data = b.toString("binary");
		else {
			var arr = new Uint8Array(b);
			try {
				this.data = String.fromCharCode.apply(null, arr);
			} catch (e) {
				for (var i = 0; i < arr.length; ++i) this.putByte(arr[i]);
			}
		}
		else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
			this.data = b.data;
			this.read = b.read;
		}
		this._constructedStringLength = 0;
	}
	util.ByteStringBuffer = ByteStringBuffer;
	var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
	util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
		this._constructedStringLength += x;
		if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
			this.data.substr(0, 1);
			this._constructedStringLength = 0;
		}
	};
	/**
	* Gets the number of bytes in this buffer.
	*
	* @return the number of bytes in this buffer.
	*/
	util.ByteStringBuffer.prototype.length = function() {
		return this.data.length - this.read;
	};
	/**
	* Gets whether or not this buffer is empty.
	*
	* @return true if this buffer is empty, false if not.
	*/
	util.ByteStringBuffer.prototype.isEmpty = function() {
		return this.length() <= 0;
	};
	/**
	* Puts a byte in this buffer.
	*
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putByte = function(b) {
		return this.putBytes(String.fromCharCode(b));
	};
	/**
	* Puts a byte in this buffer N times.
	*
	* @param b the byte to put.
	* @param n the number of bytes of value b to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
		b = String.fromCharCode(b);
		var d = this.data;
		while (n > 0) {
			if (n & 1) d += b;
			n >>>= 1;
			if (n > 0) b += b;
		}
		this.data = d;
		this._optimizeConstructedString(n);
		return this;
	};
	/**
	* Puts bytes in this buffer.
	*
	* @param bytes the bytes (as a binary encoded string) to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putBytes = function(bytes) {
		this.data += bytes;
		this._optimizeConstructedString(bytes.length);
		return this;
	};
	/**
	* Puts a UTF-16 encoded string into this buffer.
	*
	* @param str the string to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putString = function(str) {
		return this.putBytes(util.encodeUtf8(str));
	};
	/**
	* Puts a 16-bit integer in this buffer in big-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt16 = function(i) {
		return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
	};
	/**
	* Puts a 24-bit integer in this buffer in big-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt24 = function(i) {
		return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
	};
	/**
	* Puts a 32-bit integer in this buffer in big-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt32 = function(i) {
		return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
	};
	/**
	* Puts a 16-bit integer in this buffer in little-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt16Le = function(i) {
		return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
	};
	/**
	* Puts a 24-bit integer in this buffer in little-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt24Le = function(i) {
		return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
	};
	/**
	* Puts a 32-bit integer in this buffer in little-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt32Le = function(i) {
		return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
	};
	/**
	* Puts an n-bit integer in this buffer in big-endian order.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt = function(i, n) {
		_checkBitsParam(n);
		var bytes = "";
		do {
			n -= 8;
			bytes += String.fromCharCode(i >> n & 255);
		} while (n > 0);
		return this.putBytes(bytes);
	};
	/**
	* Puts a signed n-bit integer in this buffer in big-endian order. Two's
	* complement representation is used.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
		if (i < 0) i += 2 << n - 1;
		return this.putInt(i, n);
	};
	/**
	* Puts the given buffer into this buffer.
	*
	* @param buffer the buffer to put into this one.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putBuffer = function(buffer$1) {
		return this.putBytes(buffer$1.getBytes());
	};
	/**
	* Gets a byte from this buffer and advances the read pointer by 1.
	*
	* @return the byte.
	*/
	util.ByteStringBuffer.prototype.getByte = function() {
		return this.data.charCodeAt(this.read++);
	};
	/**
	* Gets a uint16 from this buffer in big-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.ByteStringBuffer.prototype.getInt16 = function() {
		var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in big-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.ByteStringBuffer.prototype.getInt24 = function() {
		var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in big-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.ByteStringBuffer.prototype.getInt32 = function() {
		var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
		this.read += 4;
		return rval;
	};
	/**
	* Gets a uint16 from this buffer in little-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.ByteStringBuffer.prototype.getInt16Le = function() {
		var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in little-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.ByteStringBuffer.prototype.getInt24Le = function() {
		var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in little-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.ByteStringBuffer.prototype.getInt32Le = function() {
		var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
		this.read += 4;
		return rval;
	};
	/**
	* Gets an n-bit integer from this buffer in big-endian order and advances the
	* read pointer by ceil(n/8).
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.ByteStringBuffer.prototype.getInt = function(n) {
		_checkBitsParam(n);
		var rval = 0;
		do {
			rval = (rval << 8) + this.data.charCodeAt(this.read++);
			n -= 8;
		} while (n > 0);
		return rval;
	};
	/**
	* Gets a signed n-bit integer from this buffer in big-endian order, using
	* two's complement, and advances the read pointer by n/8.
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.ByteStringBuffer.prototype.getSignedInt = function(n) {
		var x = this.getInt(n);
		var max = 2 << n - 2;
		if (x >= max) x -= max << 1;
		return x;
	};
	/**
	* Reads bytes out as a binary encoded string and clears them from the
	* buffer. Note that the resulting string is binary encoded (in node.js this
	* encoding is referred to as `binary`, it is *not* `utf8`).
	*
	* @param count the number of bytes to read, undefined or null for all.
	*
	* @return a binary encoded string of bytes.
	*/
	util.ByteStringBuffer.prototype.getBytes = function(count) {
		var rval;
		if (count) {
			count = Math.min(this.length(), count);
			rval = this.data.slice(this.read, this.read + count);
			this.read += count;
		} else if (count === 0) rval = "";
		else {
			rval = this.read === 0 ? this.data : this.data.slice(this.read);
			this.clear();
		}
		return rval;
	};
	/**
	* Gets a binary encoded string of the bytes from this buffer without
	* modifying the read pointer.
	*
	* @param count the number of bytes to get, omit to get all.
	*
	* @return a string full of binary encoded characters.
	*/
	util.ByteStringBuffer.prototype.bytes = function(count) {
		return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
	};
	/**
	* Gets a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	*
	* @return the byte.
	*/
	util.ByteStringBuffer.prototype.at = function(i) {
		return this.data.charCodeAt(this.read + i);
	};
	/**
	* Puts a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.setAt = function(i, b) {
		this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
		return this;
	};
	/**
	* Gets the last byte without modifying the read pointer.
	*
	* @return the last byte.
	*/
	util.ByteStringBuffer.prototype.last = function() {
		return this.data.charCodeAt(this.data.length - 1);
	};
	/**
	* Creates a copy of this buffer.
	*
	* @return the copy.
	*/
	util.ByteStringBuffer.prototype.copy = function() {
		var c = util.createBuffer(this.data);
		c.read = this.read;
		return c;
	};
	/**
	* Compacts this buffer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.compact = function() {
		if (this.read > 0) {
			this.data = this.data.slice(this.read);
			this.read = 0;
		}
		return this;
	};
	/**
	* Clears this buffer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.clear = function() {
		this.data = "";
		this.read = 0;
		return this;
	};
	/**
	* Shortens this buffer by trimming bytes off of the end of this buffer.
	*
	* @param count the number of bytes to trim off.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.truncate = function(count) {
		var len = Math.max(0, this.length() - count);
		this.data = this.data.substr(this.read, len);
		this.read = 0;
		return this;
	};
	/**
	* Converts this buffer to a hexadecimal string.
	*
	* @return a hexadecimal string.
	*/
	util.ByteStringBuffer.prototype.toHex = function() {
		var rval = "";
		for (var i = this.read; i < this.data.length; ++i) {
			var b = this.data.charCodeAt(i);
			if (b < 16) rval += "0";
			rval += b.toString(16);
		}
		return rval;
	};
	/**
	* Converts this buffer to a UTF-16 string (standard JavaScript string).
	*
	* @return a UTF-16 string.
	*/
	util.ByteStringBuffer.prototype.toString = function() {
		return util.decodeUtf8(this.bytes());
	};
	/** End Buffer w/BinaryString backing */
	/** Buffer w/UInt8Array backing */
	/**
	* FIXME: Experimental. Do not use yet.
	*
	* Constructor for an ArrayBuffer-backed byte buffer.
	*
	* The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
	* TypedArray.
	*
	* If a string is given, its encoding should be provided as an option,
	* otherwise it will default to 'binary'. A 'binary' string is encoded such
	* that each character is one byte in length and size.
	*
	* If an ArrayBuffer, DataView, or TypedArray is given, it will be used
	* *directly* without any copying. Note that, if a write to the buffer requires
	* more space, the buffer will allocate a new backing ArrayBuffer to
	* accommodate. The starting read and write offsets for the buffer may be
	* given as options.
	*
	* @param [b] the initial bytes for this buffer.
	* @param options the options to use:
	*          [readOffset] the starting read offset to use (default: 0).
	*          [writeOffset] the starting write offset to use (default: the
	*            length of the first parameter).
	*          [growSize] the minimum amount, in bytes, to grow the buffer by to
	*            accommodate writes (default: 1024).
	*          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
	*            first parameter, if it is a string (default: 'binary').
	*/
	function DataBuffer(b, options) {
		options = options || {};
		this.read = options.readOffset || 0;
		this.growSize = options.growSize || 1024;
		var isArrayBuffer = util.isArrayBuffer(b);
		var isArrayBufferView = util.isArrayBufferView(b);
		if (isArrayBuffer || isArrayBufferView) {
			if (isArrayBuffer) this.data = new DataView(b);
			else this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
			this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
			return;
		}
		this.data = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(0));
		this.write = 0;
		if (b !== null && b !== void 0) this.putBytes(b);
		if ("writeOffset" in options) this.write = options.writeOffset;
	}
	util.DataBuffer = DataBuffer;
	/**
	* Gets the number of bytes in this buffer.
	*
	* @return the number of bytes in this buffer.
	*/
	util.DataBuffer.prototype.length = function() {
		return this.write - this.read;
	};
	/**
	* Gets whether or not this buffer is empty.
	*
	* @return true if this buffer is empty, false if not.
	*/
	util.DataBuffer.prototype.isEmpty = function() {
		return this.length() <= 0;
	};
	/**
	* Ensures this buffer has enough empty space to accommodate the given number
	* of bytes. An optional parameter may be given that indicates a minimum
	* amount to grow the buffer if necessary. If the parameter is not given,
	* the buffer will be grown by some previously-specified default amount
	* or heuristic.
	*
	* @param amount the number of bytes to accommodate.
	* @param [growSize] the minimum amount, in bytes, to grow the buffer by if
	*          necessary.
	*/
	util.DataBuffer.prototype.accommodate = function(amount, growSize) {
		if (this.length() >= amount) return this;
		growSize = Math.max(growSize || this.growSize, amount);
		var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
		var dst = new Uint8Array(this.length() + growSize);
		dst.set(src);
		this.data = new DataView(dst.buffer);
		return this;
	};
	/**
	* Puts a byte in this buffer.
	*
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putByte = function(b) {
		this.accommodate(1);
		this.data.setUint8(this.write++, b);
		return this;
	};
	/**
	* Puts a byte in this buffer N times.
	*
	* @param b the byte to put.
	* @param n the number of bytes of value b to put.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.fillWithByte = function(b, n) {
		this.accommodate(n);
		for (var i = 0; i < n; ++i) this.data.setUint8(b);
		return this;
	};
	/**
	* Puts bytes in this buffer. The bytes may be given as a string, an
	* ArrayBuffer, a DataView, or a TypedArray.
	*
	* @param bytes the bytes to put.
	* @param [encoding] the encoding for the first parameter ('binary', 'utf8',
	*          'utf16', 'hex'), if it is a string (default: 'binary').
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
		if (util.isArrayBufferView(bytes)) {
			var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
			var len = src.byteLength - src.byteOffset;
			this.accommodate(len);
			var dst = new Uint8Array(this.data.buffer, this.write);
			dst.set(src);
			this.write += len;
			return this;
		}
		if (util.isArrayBuffer(bytes)) {
			var src = new Uint8Array(bytes);
			this.accommodate(src.byteLength);
			var dst = new Uint8Array(this.data.buffer);
			dst.set(src, this.write);
			this.write += src.byteLength;
			return this;
		}
		if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
			var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
			this.accommodate(src.byteLength);
			var dst = new Uint8Array(bytes.data.byteLength, this.write);
			dst.set(src);
			this.write += src.byteLength;
			return this;
		}
		if (bytes instanceof util.ByteStringBuffer) {
			bytes = bytes.data;
			encoding = "binary";
		}
		encoding = encoding || "binary";
		if (typeof bytes === "string") {
			var view;
			if (encoding === "hex") {
				this.accommodate(Math.ceil(bytes.length / 2));
				view = new Uint8Array(this.data.buffer, this.write);
				this.write += util.binary.hex.decode(bytes, view, this.write);
				return this;
			}
			if (encoding === "base64") {
				this.accommodate(Math.ceil(bytes.length / 4) * 3);
				view = new Uint8Array(this.data.buffer, this.write);
				this.write += util.binary.base64.decode(bytes, view, this.write);
				return this;
			}
			if (encoding === "utf8") {
				bytes = util.encodeUtf8(bytes);
				encoding = "binary";
			}
			if (encoding === "binary" || encoding === "raw") {
				this.accommodate(bytes.length);
				view = new Uint8Array(this.data.buffer, this.write);
				this.write += util.binary.raw.decode(view);
				return this;
			}
			if (encoding === "utf16") {
				this.accommodate(bytes.length * 2);
				view = new Uint16Array(this.data.buffer, this.write);
				this.write += util.text.utf16.encode(view);
				return this;
			}
			throw new Error("Invalid encoding: " + encoding);
		}
		throw Error("Invalid parameter: " + bytes);
	};
	/**
	* Puts the given buffer into this buffer.
	*
	* @param buffer the buffer to put into this one.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putBuffer = function(buffer$1) {
		this.putBytes(buffer$1);
		buffer$1.clear();
		return this;
	};
	/**
	* Puts a string into this buffer.
	*
	* @param str the string to put.
	* @param [encoding] the encoding for the string (default: 'utf16').
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putString = function(str) {
		return this.putBytes(str, "utf16");
	};
	/**
	* Puts a 16-bit integer in this buffer in big-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt16 = function(i) {
		this.accommodate(2);
		this.data.setInt16(this.write, i);
		this.write += 2;
		return this;
	};
	/**
	* Puts a 24-bit integer in this buffer in big-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt24 = function(i) {
		this.accommodate(3);
		this.data.setInt16(this.write, i >> 8 & 65535);
		this.data.setInt8(this.write, i >> 16 & 255);
		this.write += 3;
		return this;
	};
	/**
	* Puts a 32-bit integer in this buffer in big-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt32 = function(i) {
		this.accommodate(4);
		this.data.setInt32(this.write, i);
		this.write += 4;
		return this;
	};
	/**
	* Puts a 16-bit integer in this buffer in little-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt16Le = function(i) {
		this.accommodate(2);
		this.data.setInt16(this.write, i, true);
		this.write += 2;
		return this;
	};
	/**
	* Puts a 24-bit integer in this buffer in little-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt24Le = function(i) {
		this.accommodate(3);
		this.data.setInt8(this.write, i >> 16 & 255);
		this.data.setInt16(this.write, i >> 8 & 65535, true);
		this.write += 3;
		return this;
	};
	/**
	* Puts a 32-bit integer in this buffer in little-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt32Le = function(i) {
		this.accommodate(4);
		this.data.setInt32(this.write, i, true);
		this.write += 4;
		return this;
	};
	/**
	* Puts an n-bit integer in this buffer in big-endian order.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt = function(i, n) {
		_checkBitsParam(n);
		this.accommodate(n / 8);
		do {
			n -= 8;
			this.data.setInt8(this.write++, i >> n & 255);
		} while (n > 0);
		return this;
	};
	/**
	* Puts a signed n-bit integer in this buffer in big-endian order. Two's
	* complement representation is used.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putSignedInt = function(i, n) {
		_checkBitsParam(n);
		this.accommodate(n / 8);
		if (i < 0) i += 2 << n - 1;
		return this.putInt(i, n);
	};
	/**
	* Gets a byte from this buffer and advances the read pointer by 1.
	*
	* @return the byte.
	*/
	util.DataBuffer.prototype.getByte = function() {
		return this.data.getInt8(this.read++);
	};
	/**
	* Gets a uint16 from this buffer in big-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.DataBuffer.prototype.getInt16 = function() {
		var rval = this.data.getInt16(this.read);
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in big-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.DataBuffer.prototype.getInt24 = function() {
		var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in big-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.DataBuffer.prototype.getInt32 = function() {
		var rval = this.data.getInt32(this.read);
		this.read += 4;
		return rval;
	};
	/**
	* Gets a uint16 from this buffer in little-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.DataBuffer.prototype.getInt16Le = function() {
		var rval = this.data.getInt16(this.read, true);
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in little-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.DataBuffer.prototype.getInt24Le = function() {
		var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in little-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.DataBuffer.prototype.getInt32Le = function() {
		var rval = this.data.getInt32(this.read, true);
		this.read += 4;
		return rval;
	};
	/**
	* Gets an n-bit integer from this buffer in big-endian order and advances the
	* read pointer by n/8.
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.DataBuffer.prototype.getInt = function(n) {
		_checkBitsParam(n);
		var rval = 0;
		do {
			rval = (rval << 8) + this.data.getInt8(this.read++);
			n -= 8;
		} while (n > 0);
		return rval;
	};
	/**
	* Gets a signed n-bit integer from this buffer in big-endian order, using
	* two's complement, and advances the read pointer by n/8.
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.DataBuffer.prototype.getSignedInt = function(n) {
		var x = this.getInt(n);
		var max = 2 << n - 2;
		if (x >= max) x -= max << 1;
		return x;
	};
	/**
	* Reads bytes out as a binary encoded string and clears them from the
	* buffer.
	*
	* @param count the number of bytes to read, undefined or null for all.
	*
	* @return a binary encoded string of bytes.
	*/
	util.DataBuffer.prototype.getBytes = function(count) {
		var rval;
		if (count) {
			count = Math.min(this.length(), count);
			rval = this.data.slice(this.read, this.read + count);
			this.read += count;
		} else if (count === 0) rval = "";
		else {
			rval = this.read === 0 ? this.data : this.data.slice(this.read);
			this.clear();
		}
		return rval;
	};
	/**
	* Gets a binary encoded string of the bytes from this buffer without
	* modifying the read pointer.
	*
	* @param count the number of bytes to get, omit to get all.
	*
	* @return a string full of binary encoded characters.
	*/
	util.DataBuffer.prototype.bytes = function(count) {
		return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
	};
	/**
	* Gets a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	*
	* @return the byte.
	*/
	util.DataBuffer.prototype.at = function(i) {
		return this.data.getUint8(this.read + i);
	};
	/**
	* Puts a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.setAt = function(i, b) {
		this.data.setUint8(i, b);
		return this;
	};
	/**
	* Gets the last byte without modifying the read pointer.
	*
	* @return the last byte.
	*/
	util.DataBuffer.prototype.last = function() {
		return this.data.getUint8(this.write - 1);
	};
	/**
	* Creates a copy of this buffer.
	*
	* @return the copy.
	*/
	util.DataBuffer.prototype.copy = function() {
		return new util.DataBuffer(this);
	};
	/**
	* Compacts this buffer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.compact = function() {
		if (this.read > 0) {
			var src = new Uint8Array(this.data.buffer, this.read);
			var dst = new Uint8Array(src.byteLength);
			dst.set(src);
			this.data = new DataView(dst);
			this.write -= this.read;
			this.read = 0;
		}
		return this;
	};
	/**
	* Clears this buffer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.clear = function() {
		this.data = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(0));
		this.read = this.write = 0;
		return this;
	};
	/**
	* Shortens this buffer by trimming bytes off of the end of this buffer.
	*
	* @param count the number of bytes to trim off.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.truncate = function(count) {
		this.write = Math.max(0, this.length() - count);
		this.read = Math.min(this.read, this.write);
		return this;
	};
	/**
	* Converts this buffer to a hexadecimal string.
	*
	* @return a hexadecimal string.
	*/
	util.DataBuffer.prototype.toHex = function() {
		var rval = "";
		for (var i = this.read; i < this.data.byteLength; ++i) {
			var b = this.data.getUint8(i);
			if (b < 16) rval += "0";
			rval += b.toString(16);
		}
		return rval;
	};
	/**
	* Converts this buffer to a string, using the given encoding. If no
	* encoding is given, 'utf8' (UTF-8) is used.
	*
	* @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
	*          'base64' (default: 'utf8').
	*
	* @return a string representation of the bytes in this buffer.
	*/
	util.DataBuffer.prototype.toString = function(encoding) {
		var view = new Uint8Array(this.data, this.read, this.length());
		encoding = encoding || "utf8";
		if (encoding === "binary" || encoding === "raw") return util.binary.raw.encode(view);
		if (encoding === "hex") return util.binary.hex.encode(view);
		if (encoding === "base64") return util.binary.base64.encode(view);
		if (encoding === "utf8") return util.text.utf8.decode(view);
		if (encoding === "utf16") return util.text.utf16.decode(view);
		throw new Error("Invalid encoding: " + encoding);
	};
	/** End Buffer w/UInt8Array backing */
	/**
	* Creates a buffer that stores bytes. A value may be given to populate the
	* buffer with data. This value can either be string of encoded bytes or a
	* regular string of characters. When passing a string of binary encoded
	* bytes, the encoding `raw` should be given. This is also the default. When
	* passing a string of characters, the encoding `utf8` should be given.
	*
	* @param [input] a string with encoded bytes to store in the buffer.
	* @param [encoding] (default: 'raw', other: 'utf8').
	*/
	util.createBuffer = function(input, encoding) {
		encoding = encoding || "raw";
		if (input !== void 0 && encoding === "utf8") input = util.encodeUtf8(input);
		return new util.ByteBuffer(input);
	};
	/**
	* Fills a string with a particular value. If you want the string to be a byte
	* string, pass in String.fromCharCode(theByte).
	*
	* @param c the character to fill the string with, use String.fromCharCode
	*          to fill the string with a byte value.
	* @param n the number of characters of value c to fill with.
	*
	* @return the filled string.
	*/
	util.fillString = function(c, n) {
		var s = "";
		while (n > 0) {
			if (n & 1) s += c;
			n >>>= 1;
			if (n > 0) c += c;
		}
		return s;
	};
	/**
	* Performs a per byte XOR between two byte strings and returns the result as a
	* string of bytes.
	*
	* @param s1 first string of bytes.
	* @param s2 second string of bytes.
	* @param n the number of bytes to XOR.
	*
	* @return the XOR'd result.
	*/
	util.xorBytes = function(s1, s2, n) {
		var s3 = "";
		var b = "";
		var t = "";
		var i = 0;
		var c = 0;
		for (; n > 0; --n, ++i) {
			b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
			if (c >= 10) {
				s3 += t;
				t = "";
				c = 0;
			}
			t += String.fromCharCode(b);
			++c;
		}
		s3 += t;
		return s3;
	};
	/**
	* Converts a hex string into a 'binary' encoded string of bytes.
	*
	* @param hex the hexadecimal string to convert.
	*
	* @return the binary-encoded string of bytes.
	*/
	util.hexToBytes = function(hex$2) {
		var rval = "";
		var i = 0;
		if (hex$2.length & true) {
			i = 1;
			rval += String.fromCharCode(parseInt(hex$2[0], 16));
		}
		for (; i < hex$2.length; i += 2) rval += String.fromCharCode(parseInt(hex$2.substr(i, 2), 16));
		return rval;
	};
	/**
	* Converts a 'binary' encoded string of bytes to hex.
	*
	* @param bytes the byte string to convert.
	*
	* @return the string of hexadecimal characters.
	*/
	util.bytesToHex = function(bytes) {
		return util.createBuffer(bytes).toHex();
	};
	/**
	* Converts an 32-bit integer to 4-big-endian byte string.
	*
	* @param i the integer.
	*
	* @return the byte string.
	*/
	util.int32ToBytes = function(i) {
		return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
	};
	var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var _base64Idx = [
		62,
		-1,
		-1,
		-1,
		63,
		52,
		53,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		-1,
		-1,
		-1,
		64,
		-1,
		-1,
		-1,
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		20,
		21,
		22,
		23,
		24,
		25,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		26,
		27,
		28,
		29,
		30,
		31,
		32,
		33,
		34,
		35,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		43,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51
	];
	var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
	/**
	* Base64 encodes a 'binary' encoded string of bytes.
	*
	* @param input the binary encoded string of bytes to base64-encode.
	* @param maxline the maximum number of encoded characters per line to use,
	*          defaults to none.
	*
	* @return the base64-encoded output.
	*/
	util.encode64 = function(input, maxline) {
		var line = "";
		var output = "";
		var chr1, chr2, chr3;
		var i = 0;
		while (i < input.length) {
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);
			line += _base64.charAt(chr1 >> 2);
			line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
			if (isNaN(chr2)) line += "==";
			else {
				line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
				line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
			}
			if (maxline && line.length > maxline) {
				output += line.substr(0, maxline) + "\r\n";
				line = line.substr(maxline);
			}
		}
		output += line;
		return output;
	};
	/**
	* Base64 decodes a string into a 'binary' encoded string of bytes.
	*
	* @param input the base64-encoded input.
	*
	* @return the binary encoded string.
	*/
	util.decode64 = function(input) {
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
		var output = "";
		var enc1, enc2, enc3, enc4;
		var i = 0;
		while (i < input.length) {
			enc1 = _base64Idx[input.charCodeAt(i++) - 43];
			enc2 = _base64Idx[input.charCodeAt(i++) - 43];
			enc3 = _base64Idx[input.charCodeAt(i++) - 43];
			enc4 = _base64Idx[input.charCodeAt(i++) - 43];
			output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
			if (enc3 !== 64) {
				output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
				if (enc4 !== 64) output += String.fromCharCode((enc3 & 3) << 6 | enc4);
			}
		}
		return output;
	};
	/**
	* Encodes the given string of characters (a standard JavaScript
	* string) as a binary encoded string where the bytes represent
	* a UTF-8 encoded string of characters. Non-ASCII characters will be
	* encoded as multiple bytes according to UTF-8.
	*
	* @param str a standard string of characters to encode.
	*
	* @return the binary encoded string.
	*/
	util.encodeUtf8 = function(str) {
		return unescape(encodeURIComponent(str));
	};
	/**
	* Decodes a binary encoded string that contains bytes that
	* represent a UTF-8 encoded string of characters -- into a
	* string of characters (a standard JavaScript string).
	*
	* @param str the binary encoded string to decode.
	*
	* @return the resulting standard string of characters.
	*/
	util.decodeUtf8 = function(str) {
		return decodeURIComponent(escape(str));
	};
	util.binary = {
		raw: {},
		hex: {},
		base64: {},
		base58: {},
		baseN: {
			encode: baseN.encode,
			decode: baseN.decode
		}
	};
	/**
	* Encodes a Uint8Array as a binary-encoded string. This encoding uses
	* a value between 0 and 255 for each character.
	*
	* @param bytes the Uint8Array to encode.
	*
	* @return the binary-encoded string.
	*/
	util.binary.raw.encode = function(bytes) {
		return String.fromCharCode.apply(null, bytes);
	};
	/**
	* Decodes a binary-encoded string to a Uint8Array. This encoding uses
	* a value between 0 and 255 for each character.
	*
	* @param str the binary-encoded string to decode.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.binary.raw.decode = function(str, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(str.length);
		offset = offset || 0;
		var j = offset;
		for (var i = 0; i < str.length; ++i) out[j++] = str.charCodeAt(i);
		return output ? j - offset : out;
	};
	/**
	* Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
	* ByteBuffer as a string of hexadecimal characters.
	*
	* @param bytes the bytes to convert.
	*
	* @return the string of hexadecimal characters.
	*/
	util.binary.hex.encode = util.bytesToHex;
	/**
	* Decodes a hex-encoded string to a Uint8Array.
	*
	* @param hex the hexadecimal string to convert.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.binary.hex.decode = function(hex$2, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(Math.ceil(hex$2.length / 2));
		offset = offset || 0;
		var i = 0, j = offset;
		if (hex$2.length & 1) {
			i = 1;
			out[j++] = parseInt(hex$2[0], 16);
		}
		for (; i < hex$2.length; i += 2) out[j++] = parseInt(hex$2.substr(i, 2), 16);
		return output ? j - offset : out;
	};
	/**
	* Base64-encodes a Uint8Array.
	*
	* @param input the Uint8Array to encode.
	* @param maxline the maximum number of encoded characters per line to use,
	*          defaults to none.
	*
	* @return the base64-encoded output string.
	*/
	util.binary.base64.encode = function(input, maxline) {
		var line = "";
		var output = "";
		var chr1, chr2, chr3;
		var i = 0;
		while (i < input.byteLength) {
			chr1 = input[i++];
			chr2 = input[i++];
			chr3 = input[i++];
			line += _base64.charAt(chr1 >> 2);
			line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
			if (isNaN(chr2)) line += "==";
			else {
				line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
				line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
			}
			if (maxline && line.length > maxline) {
				output += line.substr(0, maxline) + "\r\n";
				line = line.substr(maxline);
			}
		}
		output += line;
		return output;
	};
	/**
	* Decodes a base64-encoded string to a Uint8Array.
	*
	* @param input the base64-encoded input string.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.binary.base64.decode = function(input, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(Math.ceil(input.length / 4) * 3);
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
		offset = offset || 0;
		var enc1, enc2, enc3, enc4;
		var i = 0, j = offset;
		while (i < input.length) {
			enc1 = _base64Idx[input.charCodeAt(i++) - 43];
			enc2 = _base64Idx[input.charCodeAt(i++) - 43];
			enc3 = _base64Idx[input.charCodeAt(i++) - 43];
			enc4 = _base64Idx[input.charCodeAt(i++) - 43];
			out[j++] = enc1 << 2 | enc2 >> 4;
			if (enc3 !== 64) {
				out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
				if (enc4 !== 64) out[j++] = (enc3 & 3) << 6 | enc4;
			}
		}
		return output ? j - offset : out.subarray(0, j);
	};
	util.binary.base58.encode = function(input, maxline) {
		return util.binary.baseN.encode(input, _base58, maxline);
	};
	util.binary.base58.decode = function(input, maxline) {
		return util.binary.baseN.decode(input, _base58, maxline);
	};
	util.text = {
		utf8: {},
		utf16: {}
	};
	/**
	* Encodes the given string as UTF-8 in a Uint8Array.
	*
	* @param str the string to encode.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.text.utf8.encode = function(str, output, offset) {
		str = util.encodeUtf8(str);
		var out = output;
		if (!out) out = new Uint8Array(str.length);
		offset = offset || 0;
		var j = offset;
		for (var i = 0; i < str.length; ++i) out[j++] = str.charCodeAt(i);
		return output ? j - offset : out;
	};
	/**
	* Decodes the UTF-8 contents from a Uint8Array.
	*
	* @param bytes the Uint8Array to decode.
	*
	* @return the resulting string.
	*/
	util.text.utf8.decode = function(bytes) {
		return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
	};
	/**
	* Encodes the given string as UTF-16 in a Uint8Array.
	*
	* @param str the string to encode.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.text.utf16.encode = function(str, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(str.length * 2);
		var view = new Uint16Array(out.buffer);
		offset = offset || 0;
		var j = offset;
		var k = offset;
		for (var i = 0; i < str.length; ++i) {
			view[k++] = str.charCodeAt(i);
			j += 2;
		}
		return output ? j - offset : out;
	};
	/**
	* Decodes the UTF-16 contents from a Uint8Array.
	*
	* @param bytes the Uint8Array to decode.
	*
	* @return the resulting string.
	*/
	util.text.utf16.decode = function(bytes) {
		return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
	};
	/**
	* Deflates the given data using a flash interface.
	*
	* @param api the flash interface.
	* @param bytes the data.
	* @param raw true to return only raw deflate data, false to include zlib
	*          header and trailer.
	*
	* @return the deflated data as a string.
	*/
	util.deflate = function(api, bytes, raw) {
		bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
		if (raw) {
			var start = 2;
			if (bytes.charCodeAt(1) & 32) start = 6;
			bytes = bytes.substring(start, bytes.length - 4);
		}
		return bytes;
	};
	/**
	* Inflates the given data using a flash interface.
	*
	* @param api the flash interface.
	* @param bytes the data.
	* @param raw true if the incoming data has no zlib header or trailer and is
	*          raw DEFLATE data.
	*
	* @return the inflated data as a string, null on error.
	*/
	util.inflate = function(api, bytes, raw) {
		var rval = api.inflate(util.encode64(bytes)).rval;
		return rval === null ? null : util.decode64(rval);
	};
	/**
	* Sets a storage object.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param obj the storage object, null to remove.
	*/
	var _setStorageObject = function(api, id, obj) {
		if (!api) throw new Error("WebStorage not available.");
		var rval;
		if (obj === null) rval = api.removeItem(id);
		else {
			obj = util.encode64(JSON.stringify(obj));
			rval = api.setItem(id, obj);
		}
		if (typeof rval !== "undefined" && rval.rval !== true) {
			var error$47 = new Error(rval.error.message);
			error$47.id = rval.error.id;
			error$47.name = rval.error.name;
			throw error$47;
		}
	};
	/**
	* Gets a storage object.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	*
	* @return the storage object entry or null if none exists.
	*/
	var _getStorageObject = function(api, id) {
		if (!api) throw new Error("WebStorage not available.");
		var rval = api.getItem(id);
		if (api.init) if (rval.rval === null) {
			if (rval.error) {
				var error$47 = new Error(rval.error.message);
				error$47.id = rval.error.id;
				error$47.name = rval.error.name;
				throw error$47;
			}
			rval = null;
		} else rval = rval.rval;
		if (rval !== null) rval = JSON.parse(util.decode64(rval));
		return rval;
	};
	/**
	* Stores an item in local storage.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param data the data for the item (any javascript object/primitive).
	*/
	var _setItem = function(api, id, key, data) {
		var obj = _getStorageObject(api, id);
		if (obj === null) obj = {};
		obj[key] = data;
		_setStorageObject(api, id, obj);
	};
	/**
	* Gets an item from local storage.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	*
	* @return the item.
	*/
	var _getItem = function(api, id, key) {
		var rval = _getStorageObject(api, id);
		if (rval !== null) rval = key in rval ? rval[key] : null;
		return rval;
	};
	/**
	* Removes an item from local storage.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	*/
	var _removeItem = function(api, id, key) {
		var obj = _getStorageObject(api, id);
		if (obj !== null && key in obj) {
			delete obj[key];
			var empty = true;
			for (var prop in obj) {
				empty = false;
				break;
			}
			if (empty) obj = null;
			_setStorageObject(api, id, obj);
		}
	};
	/**
	* Clears the local disk storage identified by the given ID.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	*/
	var _clearItems = function(api, id) {
		_setStorageObject(api, id, null);
	};
	/**
	* Calls a storage function.
	*
	* @param func the function to call.
	* @param args the arguments for the function.
	* @param location the location argument.
	*
	* @return the return value from the function.
	*/
	var _callStorageFunction = function(func, args, location) {
		var rval = null;
		if (typeof location === "undefined") location = ["web", "flash"];
		var type;
		var done = false;
		var exception = null;
		for (var idx in location) {
			type = location[idx];
			try {
				if (type === "flash" || type === "both") {
					if (args[0] === null) throw new Error("Flash local storage not available.");
					rval = func.apply(this, args);
					done = type === "flash";
				}
				if (type === "web" || type === "both") {
					args[0] = localStorage;
					rval = func.apply(this, args);
					done = true;
				}
			} catch (ex) {
				exception = ex;
			}
			if (done) break;
		}
		if (!done) throw exception;
		return rval;
	};
	/**
	* Stores an item on local disk.
	*
	* The available types of local storage include 'flash', 'web', and 'both'.
	*
	* The type 'flash' refers to flash local storage (SharedObject). In order
	* to use flash local storage, the 'api' parameter must be valid. The type
	* 'web' refers to WebStorage, if supported by the browser. The type 'both'
	* refers to storing using both 'flash' and 'web', not just one or the
	* other.
	*
	* The location array should list the storage types to use in order of
	* preference:
	*
	* ['flash']: flash only storage
	* ['web']: web only storage
	* ['both']: try to store in both
	* ['flash','web']: store in flash first, but if not available, 'web'
	* ['web','flash']: store in web first, but if not available, 'flash'
	*
	* The location array defaults to: ['web', 'flash']
	*
	* @param api the flash interface, null to use only WebStorage.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param data the data for the item (any javascript object/primitive).
	* @param location an array with the preferred types of storage to use.
	*/
	util.setItem = function(api, id, key, data, location) {
		_callStorageFunction(_setItem, arguments, location);
	};
	/**
	* Gets an item on local disk.
	*
	* Set setItem() for details on storage types.
	*
	* @param api the flash interface, null to use only WebStorage.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param location an array with the preferred types of storage to use.
	*
	* @return the item.
	*/
	util.getItem = function(api, id, key, location) {
		return _callStorageFunction(_getItem, arguments, location);
	};
	/**
	* Removes an item on local disk.
	*
	* Set setItem() for details on storage types.
	*
	* @param api the flash interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param location an array with the preferred types of storage to use.
	*/
	util.removeItem = function(api, id, key, location) {
		_callStorageFunction(_removeItem, arguments, location);
	};
	/**
	* Clears the local disk storage identified by the given ID.
	*
	* Set setItem() for details on storage types.
	*
	* @param api the flash interface if flash is available.
	* @param id the storage ID to use.
	* @param location an array with the preferred types of storage to use.
	*/
	util.clearItems = function(api, id, location) {
		_callStorageFunction(_clearItems, arguments, location);
	};
	/**
	* Check if an object is empty.
	*
	* Taken from:
	* http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
	*
	* @param object the object to check.
	*/
	util.isEmpty = function(obj) {
		for (var prop in obj) if (obj.hasOwnProperty(prop)) return false;
		return true;
	};
	/**
	* Format with simple printf-style interpolation.
	*
	* %%: literal '%'
	* %s,%o: convert next argument into a string.
	*
	* @param format the string to format.
	* @param ... arguments to interpolate into the format string.
	*/
	util.format = function(format) {
		var re = /%./g;
		var match;
		var part;
		var argi = 0;
		var parts = [];
		var last = 0;
		while (match = re.exec(format)) {
			part = format.substring(last, re.lastIndex - 2);
			if (part.length > 0) parts.push(part);
			last = re.lastIndex;
			var code = match[0][1];
			switch (code) {
				case "s":
				case "o":
					if (argi < arguments.length) parts.push(arguments[argi++ + 1]);
					else parts.push("<?>");
					break;
				case "%":
					parts.push("%");
					break;
				default: parts.push("<%" + code + "?>");
			}
		}
		parts.push(format.substring(last));
		return parts.join("");
	};
	/**
	* Formats a number.
	*
	* http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
	*/
	util.formatNumber = function(number$3, decimals, dec_point, thousands_sep) {
		var n = number$3, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
		var d = dec_point === void 0 ? "," : dec_point;
		var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
		var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
		var j = i.length > 3 ? i.length % 3 : 0;
		return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
	};
	/**
	* Formats a byte size.
	*
	* http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
	*/
	util.formatSize = function(size) {
		if (size >= 1073741824) size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
		else if (size >= 1048576) size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
		else if (size >= 1024) size = util.formatNumber(size / 1024, 0) + " KiB";
		else size = util.formatNumber(size, 0) + " bytes";
		return size;
	};
	/**
	* Converts an IPv4 or IPv6 string representation into bytes (in network order).
	*
	* @param ip the IPv4 or IPv6 address to convert.
	*
	* @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
	*         be parsed.
	*/
	util.bytesFromIP = function(ip) {
		if (ip.indexOf(".") !== -1) return util.bytesFromIPv4(ip);
		if (ip.indexOf(":") !== -1) return util.bytesFromIPv6(ip);
		return null;
	};
	/**
	* Converts an IPv4 string representation into bytes (in network order).
	*
	* @param ip the IPv4 address to convert.
	*
	* @return the 4-byte address or null if the address can't be parsed.
	*/
	util.bytesFromIPv4 = function(ip) {
		ip = ip.split(".");
		if (ip.length !== 4) return null;
		var b = util.createBuffer();
		for (var i = 0; i < ip.length; ++i) {
			var num = parseInt(ip[i], 10);
			if (isNaN(num)) return null;
			b.putByte(num);
		}
		return b.getBytes();
	};
	/**
	* Converts an IPv6 string representation into bytes (in network order).
	*
	* @param ip the IPv6 address to convert.
	*
	* @return the 16-byte address or null if the address can't be parsed.
	*/
	util.bytesFromIPv6 = function(ip) {
		var blanks = 0;
		ip = ip.split(":").filter(function(e) {
			if (e.length === 0) ++blanks;
			return true;
		});
		var zeros = (8 - ip.length + blanks) * 2;
		var b = util.createBuffer();
		for (var i = 0; i < 8; ++i) {
			if (!ip[i] || ip[i].length === 0) {
				b.fillWithByte(0, zeros);
				zeros = 0;
				continue;
			}
			var bytes = util.hexToBytes(ip[i]);
			if (bytes.length < 2) b.putByte(0);
			b.putBytes(bytes);
		}
		return b.getBytes();
	};
	/**
	* Converts 4-bytes into an IPv4 string representation or 16-bytes into
	* an IPv6 string representation. The bytes must be in network order.
	*
	* @param bytes the bytes to convert.
	*
	* @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
	*         respectively, are given, otherwise null.
	*/
	util.bytesToIP = function(bytes) {
		if (bytes.length === 4) return util.bytesToIPv4(bytes);
		if (bytes.length === 16) return util.bytesToIPv6(bytes);
		return null;
	};
	/**
	* Converts 4-bytes into an IPv4 string representation. The bytes must be
	* in network order.
	*
	* @param bytes the bytes to convert.
	*
	* @return the IPv4 string representation or null for an invalid # of bytes.
	*/
	util.bytesToIPv4 = function(bytes) {
		if (bytes.length !== 4) return null;
		var ip = [];
		for (var i = 0; i < bytes.length; ++i) ip.push(bytes.charCodeAt(i));
		return ip.join(".");
	};
	/**
	* Converts 16-bytes into an IPv16 string representation. The bytes must be
	* in network order.
	*
	* @param bytes the bytes to convert.
	*
	* @return the IPv16 string representation or null for an invalid # of bytes.
	*/
	util.bytesToIPv6 = function(bytes) {
		if (bytes.length !== 16) return null;
		var ip = [];
		var zeroGroups = [];
		var zeroMaxGroup = 0;
		for (var i = 0; i < bytes.length; i += 2) {
			var hex$2 = util.bytesToHex(bytes[i] + bytes[i + 1]);
			while (hex$2[0] === "0" && hex$2 !== "0") hex$2 = hex$2.substr(1);
			if (hex$2 === "0") {
				var last = zeroGroups[zeroGroups.length - 1];
				var idx = ip.length;
				if (!last || idx !== last.end + 1) zeroGroups.push({
					start: idx,
					end: idx
				});
				else {
					last.end = idx;
					if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) zeroMaxGroup = zeroGroups.length - 1;
				}
			}
			ip.push(hex$2);
		}
		if (zeroGroups.length > 0) {
			var group = zeroGroups[zeroMaxGroup];
			if (group.end - group.start > 0) {
				ip.splice(group.start, group.end - group.start + 1, "");
				if (group.start === 0) ip.unshift("");
				if (group.end === 7) ip.push("");
			}
		}
		return ip.join(":");
	};
	/**
	* Estimates the number of processes that can be run concurrently. If
	* creating Web Workers, keep in mind that the main JavaScript process needs
	* its own core.
	*
	* @param options the options to use:
	*          update true to force an update (not use the cached value).
	* @param callback(err, max) called once the operation completes.
	*/
	util.estimateCores = function(options, callback$1) {
		if (typeof options === "function") {
			callback$1 = options;
			options = {};
		}
		options = options || {};
		if ("cores" in util && !options.update) return callback$1(null, util.cores);
		if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
			util.cores = navigator.hardwareConcurrency;
			return callback$1(null, util.cores);
		}
		if (typeof Worker === "undefined") {
			util.cores = 1;
			return callback$1(null, util.cores);
		}
		if (typeof Blob === "undefined") {
			util.cores = 2;
			return callback$1(null, util.cores);
		}
		var blobUrl = URL.createObjectURL(new Blob([
			"(",
			function() {
				self.addEventListener("message", function(e) {
					var st = Date.now();
					var et = st + 4;
					while (Date.now() < et);
					self.postMessage({
						st,
						et
					});
				});
			}.toString(),
			")()"
		], { type: "application/javascript" }));
		sample([], 5, 16);
		function sample(max, samples, numWorkers) {
			if (samples === 0) {
				var avg = Math.floor(max.reduce(function(avg$1, x) {
					return avg$1 + x;
				}, 0) / max.length);
				util.cores = Math.max(1, avg);
				URL.revokeObjectURL(blobUrl);
				return callback$1(null, util.cores);
			}
			map$1(numWorkers, function(err, results) {
				max.push(reduce(numWorkers, results));
				sample(max, samples - 1, numWorkers);
			});
		}
		function map$1(numWorkers, callback$2) {
			var workers = [];
			var results = [];
			for (var i = 0; i < numWorkers; ++i) {
				var worker = new Worker(blobUrl);
				worker.addEventListener("message", function(e) {
					results.push(e.data);
					if (results.length === numWorkers) {
						for (var i$1 = 0; i$1 < numWorkers; ++i$1) workers[i$1].terminate();
						callback$2(null, results);
					}
				});
				workers.push(worker);
			}
			for (var i = 0; i < numWorkers; ++i) workers[i].postMessage(i);
		}
		function reduce(numWorkers, results) {
			var overlaps = [];
			for (var n = 0; n < numWorkers; ++n) {
				var r1 = results[n];
				var overlap = overlaps[n] = [];
				for (var i = 0; i < numWorkers; ++i) {
					if (n === i) continue;
					var r2 = results[i];
					if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) overlap.push(i);
				}
			}
			return overlaps.reduce(function(max, overlap$1) {
				return Math.max(max, overlap$1.length);
			}, 0);
		}
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/cipher.js
var require_cipher = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Cipher base API.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	module.exports = forge.cipher = forge.cipher || {};
	forge.cipher.algorithms = forge.cipher.algorithms || {};
	/**
	* Creates a cipher object that can be used to encrypt data using the given
	* algorithm and key. The algorithm may be provided as a string value for a
	* previously registered algorithm or it may be given as a cipher algorithm
	* API object.
	*
	* @param algorithm the algorithm to use, either a string or an algorithm API
	*          object.
	* @param key the key to use, as a binary-encoded string of bytes or a
	*          byte buffer.
	*
	* @return the cipher.
	*/
	forge.cipher.createCipher = function(algorithm, key) {
		var api = algorithm;
		if (typeof api === "string") {
			api = forge.cipher.getAlgorithm(api);
			if (api) api = api();
		}
		if (!api) throw new Error("Unsupported algorithm: " + algorithm);
		return new forge.cipher.BlockCipher({
			algorithm: api,
			key,
			decrypt: false
		});
	};
	/**
	* Creates a decipher object that can be used to decrypt data using the given
	* algorithm and key. The algorithm may be provided as a string value for a
	* previously registered algorithm or it may be given as a cipher algorithm
	* API object.
	*
	* @param algorithm the algorithm to use, either a string or an algorithm API
	*          object.
	* @param key the key to use, as a binary-encoded string of bytes or a
	*          byte buffer.
	*
	* @return the cipher.
	*/
	forge.cipher.createDecipher = function(algorithm, key) {
		var api = algorithm;
		if (typeof api === "string") {
			api = forge.cipher.getAlgorithm(api);
			if (api) api = api();
		}
		if (!api) throw new Error("Unsupported algorithm: " + algorithm);
		return new forge.cipher.BlockCipher({
			algorithm: api,
			key,
			decrypt: true
		});
	};
	/**
	* Registers an algorithm by name. If the name was already registered, the
	* algorithm API object will be overwritten.
	*
	* @param name the name of the algorithm.
	* @param algorithm the algorithm API object.
	*/
	forge.cipher.registerAlgorithm = function(name$1, algorithm) {
		name$1 = name$1.toUpperCase();
		forge.cipher.algorithms[name$1] = algorithm;
	};
	/**
	* Gets a registered algorithm by name.
	*
	* @param name the name of the algorithm.
	*
	* @return the algorithm, if found, null if not.
	*/
	forge.cipher.getAlgorithm = function(name$1) {
		name$1 = name$1.toUpperCase();
		if (name$1 in forge.cipher.algorithms) return forge.cipher.algorithms[name$1];
		return null;
	};
	var BlockCipher = forge.cipher.BlockCipher = function(options) {
		this.algorithm = options.algorithm;
		this.mode = this.algorithm.mode;
		this.blockSize = this.mode.blockSize;
		this._finish = false;
		this._input = null;
		this.output = null;
		this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
		this._decrypt = options.decrypt;
		this.algorithm.initialize(options);
	};
	/**
	* Starts or restarts the encryption or decryption process, whichever
	* was previously configured.
	*
	* For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
	* of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
	* bytes, then it must be Nb (16) bytes in length. If the IV is given in as
	* 32-bit integers, then it must be 4 integers long.
	*
	* Note: an IV is not required or used in ECB mode.
	*
	* For GCM-mode, the IV must be given as a binary-encoded string of bytes or
	* a byte buffer. The number of bytes should be 12 (96 bits) as recommended
	* by NIST SP-800-38D but another length may be given.
	*
	* @param options the options to use:
	*          iv the initialization vector to use as a binary-encoded string of
	*            bytes, null to reuse the last ciphered block from a previous
	*            update() (this "residue" method is for legacy support only).
	*          additionalData additional authentication data as a binary-encoded
	*            string of bytes, for 'GCM' mode, (default: none).
	*          tagLength desired length of authentication tag, in bits, for
	*            'GCM' mode (0-128, default: 128).
	*          tag the authentication tag to check if decrypting, as a
	*             binary-encoded string of bytes.
	*          output the output the buffer to write to, null to create one.
	*/
	BlockCipher.prototype.start = function(options) {
		options = options || {};
		var opts = {};
		for (var key in options) opts[key] = options[key];
		opts.decrypt = this._decrypt;
		this._finish = false;
		this._input = forge.util.createBuffer();
		this.output = options.output || forge.util.createBuffer();
		this.mode.start(opts);
	};
	/**
	* Updates the next block according to the cipher mode.
	*
	* @param input the buffer to read from.
	*/
	BlockCipher.prototype.update = function(input) {
		if (input) this._input.putBuffer(input);
		while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish);
		this._input.compact();
	};
	/**
	* Finishes encrypting or decrypting.
	*
	* @param pad a padding function to use in CBC mode, null for default,
	*          signature(blockSize, buffer, decrypt).
	*
	* @return true if successful, false on error.
	*/
	BlockCipher.prototype.finish = function(pad) {
		if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
			this.mode.pad = function(input) {
				return pad(this.blockSize, input, false);
			};
			this.mode.unpad = function(output) {
				return pad(this.blockSize, output, true);
			};
		}
		var options = {};
		options.decrypt = this._decrypt;
		options.overflow = this._input.length() % this.blockSize;
		if (!this._decrypt && this.mode.pad) {
			if (!this.mode.pad(this._input, options)) return false;
		}
		this._finish = true;
		this.update();
		if (this._decrypt && this.mode.unpad) {
			if (!this.mode.unpad(this.output, options)) return false;
		}
		if (this.mode.afterFinish) {
			if (!this.mode.afterFinish(this.output, options)) return false;
		}
		return true;
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Supported cipher modes.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	forge.cipher = forge.cipher || {};
	var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
	/** Electronic codebook (ECB) (Don't use this; it's not secure) **/
	modes.ecb = function(options) {
		options = options || {};
		this.name = "ECB";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = new Array(this._ints);
		this._outBlock = new Array(this._ints);
	};
	modes.ecb.prototype.start = function(options) {};
	modes.ecb.prototype.encrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
		this.cipher.encrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
	};
	modes.ecb.prototype.decrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
		this.cipher.decrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
	};
	modes.ecb.prototype.pad = function(input, options) {
		var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
		input.fillWithByte(padding, padding);
		return true;
	};
	modes.ecb.prototype.unpad = function(output, options) {
		if (options.overflow > 0) return false;
		var len = output.length();
		var count = output.at(len - 1);
		if (count > this.blockSize << 2) return false;
		output.truncate(count);
		return true;
	};
	/** Cipher-block Chaining (CBC) **/
	modes.cbc = function(options) {
		options = options || {};
		this.name = "CBC";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = new Array(this._ints);
		this._outBlock = new Array(this._ints);
	};
	modes.cbc.prototype.start = function(options) {
		if (options.iv === null) {
			if (!this._prev) throw new Error("Invalid IV parameter.");
			this._iv = this._prev.slice(0);
		} else if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		else {
			this._iv = transformIV(options.iv, this.blockSize);
			this._prev = this._iv.slice(0);
		}
	};
	modes.cbc.prototype.encrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._prev[i] ^ input.getInt32();
		this.cipher.encrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
		this._prev = this._outBlock;
	};
	modes.cbc.prototype.decrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
		this.cipher.decrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._prev[i] ^ this._outBlock[i]);
		this._prev = this._inBlock.slice(0);
	};
	modes.cbc.prototype.pad = function(input, options) {
		var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
		input.fillWithByte(padding, padding);
		return true;
	};
	modes.cbc.prototype.unpad = function(output, options) {
		if (options.overflow > 0) return false;
		var len = output.length();
		var count = output.at(len - 1);
		if (count > this.blockSize << 2) return false;
		output.truncate(count);
		return true;
	};
	/** Cipher feedback (CFB) **/
	modes.cfb = function(options) {
		options = options || {};
		this.name = "CFB";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = null;
		this._outBlock = new Array(this._ints);
		this._partialBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
	};
	modes.cfb.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		this._iv = transformIV(options.iv, this.blockSize);
		this._inBlock = this._iv.slice(0);
		this._partialBytes = 0;
	};
	modes.cfb.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) {
				this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
				output.putInt32(this._inBlock[i]);
			}
			return;
		}
		var partialBytes = (this.blockSize - inputLength) % this.blockSize;
		if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
		this._partialOutput.clear();
		for (var i = 0; i < this._ints; ++i) {
			this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
			this._partialOutput.putInt32(this._partialBlock[i]);
		}
		if (partialBytes > 0) input.read -= this.blockSize;
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
		if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
		if (partialBytes > 0 && !finish) {
			output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
			this._partialBytes = partialBytes;
			return true;
		}
		output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
		this._partialBytes = 0;
	};
	modes.cfb.prototype.decrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) {
				this._inBlock[i] = input.getInt32();
				output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
			}
			return;
		}
		var partialBytes = (this.blockSize - inputLength) % this.blockSize;
		if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
		this._partialOutput.clear();
		for (var i = 0; i < this._ints; ++i) {
			this._partialBlock[i] = input.getInt32();
			this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
		}
		if (partialBytes > 0) input.read -= this.blockSize;
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
		if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
		if (partialBytes > 0 && !finish) {
			output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
			this._partialBytes = partialBytes;
			return true;
		}
		output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
		this._partialBytes = 0;
	};
	/** Output feedback (OFB) **/
	modes.ofb = function(options) {
		options = options || {};
		this.name = "OFB";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = null;
		this._outBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
	};
	modes.ofb.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		this._iv = transformIV(options.iv, this.blockSize);
		this._inBlock = this._iv.slice(0);
		this._partialBytes = 0;
	};
	modes.ofb.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (input.length() === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) {
				output.putInt32(input.getInt32() ^ this._outBlock[i]);
				this._inBlock[i] = this._outBlock[i];
			}
			return;
		}
		var partialBytes = (this.blockSize - inputLength) % this.blockSize;
		if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
		this._partialOutput.clear();
		for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
		if (partialBytes > 0) input.read -= this.blockSize;
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i];
		if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
		if (partialBytes > 0 && !finish) {
			output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
			this._partialBytes = partialBytes;
			return true;
		}
		output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
		this._partialBytes = 0;
	};
	modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
	/** Counter (CTR) **/
	modes.ctr = function(options) {
		options = options || {};
		this.name = "CTR";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = null;
		this._outBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
	};
	modes.ctr.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		this._iv = transformIV(options.iv, this.blockSize);
		this._inBlock = this._iv.slice(0);
		this._partialBytes = 0;
	};
	modes.ctr.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) for (var i = 0; i < this._ints; ++i) output.putInt32(input.getInt32() ^ this._outBlock[i]);
		else {
			var partialBytes = (this.blockSize - inputLength) % this.blockSize;
			if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
			this._partialOutput.clear();
			for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
			if (partialBytes > 0) input.read -= this.blockSize;
			if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
			if (partialBytes > 0 && !finish) {
				output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
				this._partialBytes = partialBytes;
				return true;
			}
			output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
			this._partialBytes = 0;
		}
		inc32(this._inBlock);
	};
	modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
	/** Galois/Counter Mode (GCM) **/
	modes.gcm = function(options) {
		options = options || {};
		this.name = "GCM";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = new Array(this._ints);
		this._outBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
		this._R = 3774873600;
	};
	modes.gcm.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		var iv = forge.util.createBuffer(options.iv);
		this._cipherLength = 0;
		var additionalData;
		if ("additionalData" in options) additionalData = forge.util.createBuffer(options.additionalData);
		else additionalData = forge.util.createBuffer();
		if ("tagLength" in options) this._tagLength = options.tagLength;
		else this._tagLength = 128;
		this._tag = null;
		if (options.decrypt) {
			this._tag = forge.util.createBuffer(options.tag).getBytes();
			if (this._tag.length !== this._tagLength / 8) throw new Error("Authentication tag does not match tag length.");
		}
		this._hashBlock = new Array(this._ints);
		this.tag = null;
		this._hashSubkey = new Array(this._ints);
		this.cipher.encrypt([
			0,
			0,
			0,
			0
		], this._hashSubkey);
		this.componentBits = 4;
		this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
		var ivLength = iv.length();
		if (ivLength === 12) this._j0 = [
			iv.getInt32(),
			iv.getInt32(),
			iv.getInt32(),
			1
		];
		else {
			this._j0 = [
				0,
				0,
				0,
				0
			];
			while (iv.length() > 0) this._j0 = this.ghash(this._hashSubkey, this._j0, [
				iv.getInt32(),
				iv.getInt32(),
				iv.getInt32(),
				iv.getInt32()
			]);
			this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
		}
		this._inBlock = this._j0.slice(0);
		inc32(this._inBlock);
		this._partialBytes = 0;
		additionalData = forge.util.createBuffer(additionalData);
		this._aDataLength = from64To32(additionalData.length() * 8);
		var overflow = additionalData.length() % this.blockSize;
		if (overflow) additionalData.fillWithByte(0, this.blockSize - overflow);
		this._s = [
			0,
			0,
			0,
			0
		];
		while (additionalData.length() > 0) this._s = this.ghash(this._hashSubkey, this._s, [
			additionalData.getInt32(),
			additionalData.getInt32(),
			additionalData.getInt32(),
			additionalData.getInt32()
		]);
	};
	modes.gcm.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i] ^= input.getInt32());
			this._cipherLength += this.blockSize;
		} else {
			var partialBytes = (this.blockSize - inputLength) % this.blockSize;
			if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
			this._partialOutput.clear();
			for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
			if (partialBytes <= 0 || finish) {
				if (finish) {
					var overflow = inputLength % this.blockSize;
					this._cipherLength += overflow;
					this._partialOutput.truncate(this.blockSize - overflow);
				} else this._cipherLength += this.blockSize;
				for (var i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32();
				this._partialOutput.read -= this.blockSize;
			}
			if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
			if (partialBytes > 0 && !finish) {
				input.read -= this.blockSize;
				output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
				this._partialBytes = partialBytes;
				return true;
			}
			output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
			this._partialBytes = 0;
		}
		this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
		inc32(this._inBlock);
	};
	modes.gcm.prototype.decrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength < this.blockSize && !(finish && inputLength > 0)) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		inc32(this._inBlock);
		this._hashBlock[0] = input.getInt32();
		this._hashBlock[1] = input.getInt32();
		this._hashBlock[2] = input.getInt32();
		this._hashBlock[3] = input.getInt32();
		this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
		if (inputLength < this.blockSize) this._cipherLength += inputLength % this.blockSize;
		else this._cipherLength += this.blockSize;
	};
	modes.gcm.prototype.afterFinish = function(output, options) {
		var rval = true;
		if (options.decrypt && options.overflow) output.truncate(this.blockSize - options.overflow);
		this.tag = forge.util.createBuffer();
		var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
		this._s = this.ghash(this._hashSubkey, this._s, lengths);
		var tag = [];
		this.cipher.encrypt(this._j0, tag);
		for (var i = 0; i < this._ints; ++i) this.tag.putInt32(this._s[i] ^ tag[i]);
		this.tag.truncate(this.tag.length() % (this._tagLength / 8));
		if (options.decrypt && this.tag.bytes() !== this._tag) rval = false;
		return rval;
	};
	/**
	* See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
	* field multiplication. The field, GF(2^128), is defined by the polynomial:
	*
	* x^128 + x^7 + x^2 + x + 1
	*
	* Which is represented in little-endian binary form as: 11100001 (0xe1). When
	* the value of a coefficient is 1, a bit is set. The value R, is the
	* concatenation of this value and 120 zero bits, yielding a 128-bit value
	* which matches the block size.
	*
	* This function will multiply two elements (vectors of bytes), X and Y, in
	* the field GF(2^128). The result is initialized to zero. For each bit of
	* X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
	* by the current value of Y. For each bit, the value of Y will be raised by
	* a power of x (multiplied by the polynomial x). This can be achieved by
	* shifting Y once to the right. If the current value of Y, prior to being
	* multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
	* Otherwise, we must divide by R after shifting to find the remainder.
	*
	* @param x the first block to multiply by the second.
	* @param y the second block to multiply by the first.
	*
	* @return the block result of the multiplication.
	*/
	modes.gcm.prototype.multiply = function(x, y) {
		var z_i = [
			0,
			0,
			0,
			0
		];
		var v_i = y.slice(0);
		for (var i = 0; i < 128; ++i) {
			if (x[i / 32 | 0] & 1 << 31 - i % 32) {
				z_i[0] ^= v_i[0];
				z_i[1] ^= v_i[1];
				z_i[2] ^= v_i[2];
				z_i[3] ^= v_i[3];
			}
			this.pow(v_i, v_i);
		}
		return z_i;
	};
	modes.gcm.prototype.pow = function(x, out) {
		var lsb = x[3] & 1;
		for (var i = 3; i > 0; --i) out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
		out[0] = x[0] >>> 1;
		if (lsb) out[0] ^= this._R;
	};
	modes.gcm.prototype.tableMultiply = function(x) {
		var z$1 = [
			0,
			0,
			0,
			0
		];
		for (var i = 0; i < 32; ++i) {
			var x_i = x[i / 8 | 0] >>> (7 - i % 8) * 4 & 15;
			var ah = this._m[i][x_i];
			z$1[0] ^= ah[0];
			z$1[1] ^= ah[1];
			z$1[2] ^= ah[2];
			z$1[3] ^= ah[3];
		}
		return z$1;
	};
	/**
	* A continuing version of the GHASH algorithm that operates on a single
	* block. The hash block, last hash value (Ym) and the new block to hash
	* are given.
	*
	* @param h the hash block.
	* @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
	* @param x the block to hash.
	*
	* @return the hashed value (Ym).
	*/
	modes.gcm.prototype.ghash = function(h, y, x) {
		y[0] ^= x[0];
		y[1] ^= x[1];
		y[2] ^= x[2];
		y[3] ^= x[3];
		return this.tableMultiply(y);
	};
	/**
	* Precomputes a table for multiplying against the hash subkey. This
	* mechanism provides a substantial speed increase over multiplication
	* performed without a table. The table-based multiplication this table is
	* for solves X * H by multiplying each component of X by H and then
	* composing the results together using XOR.
	*
	* This function can be used to generate tables with different bit sizes
	* for the components, however, this implementation assumes there are
	* 32 components of X (which is a 16 byte vector), therefore each component
	* takes 4-bits (so the table is constructed with bits=4).
	*
	* @param h the hash subkey.
	* @param bits the bit size for a component.
	*/
	modes.gcm.prototype.generateHashTable = function(h, bits) {
		var multiplier = 8 / bits;
		var perInt = 4 * multiplier;
		var size = 16 * multiplier;
		var m = new Array(size);
		for (var i = 0; i < size; ++i) {
			var tmp = [
				0,
				0,
				0,
				0
			];
			var idx = i / perInt | 0;
			var shft = (perInt - 1 - i % perInt) * bits;
			tmp[idx] = 1 << bits - 1 << shft;
			m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
		}
		return m;
	};
	/**
	* Generates a table for multiplying against the hash subkey for one
	* particular component (out of all possible component values).
	*
	* @param mid the pre-multiplied value for the middle key of the table.
	* @param bits the bit size for a component.
	*/
	modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
		var size = 1 << bits;
		var half = size >>> 1;
		var m = new Array(size);
		m[half] = mid.slice(0);
		var i = half >>> 1;
		while (i > 0) {
			this.pow(m[2 * i], m[i] = []);
			i >>= 1;
		}
		i = 2;
		while (i < half) {
			for (var j = 1; j < i; ++j) {
				var m_i = m[i];
				var m_j = m[j];
				m[i + j] = [
					m_i[0] ^ m_j[0],
					m_i[1] ^ m_j[1],
					m_i[2] ^ m_j[2],
					m_i[3] ^ m_j[3]
				];
			}
			i *= 2;
		}
		m[0] = [
			0,
			0,
			0,
			0
		];
		for (i = half + 1; i < size; ++i) {
			var c = m[i ^ half];
			m[i] = [
				mid[0] ^ c[0],
				mid[1] ^ c[1],
				mid[2] ^ c[2],
				mid[3] ^ c[3]
			];
		}
		return m;
	};
	/** Utility functions */
	function transformIV(iv, blockSize) {
		if (typeof iv === "string") iv = forge.util.createBuffer(iv);
		if (forge.util.isArray(iv) && iv.length > 4) {
			var tmp = iv;
			iv = forge.util.createBuffer();
			for (var i = 0; i < tmp.length; ++i) iv.putByte(tmp[i]);
		}
		if (iv.length() < blockSize) throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
		if (!forge.util.isArray(iv)) {
			var ints = [];
			var blocks = blockSize / 4;
			for (var i = 0; i < blocks; ++i) ints.push(iv.getInt32());
			iv = ints;
		}
		return iv;
	}
	function inc32(block) {
		block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
	}
	function from64To32(num) {
		return [num / 4294967296 | 0, num & 4294967295];
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/aes.js
var require_aes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Advanced Encryption Standard (AES) implementation.
	*
	* This implementation is based on the public domain library 'jscrypto' which
	* was written by:
	*
	* Emily Stark (estark@stanford.edu)
	* Mike Hamburg (mhamburg@stanford.edu)
	* Dan Boneh (dabo@cs.stanford.edu)
	*
	* Parts of this code are based on the OpenSSL implementation of AES:
	* http://www.openssl.org
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_cipher();
	require_cipherModes();
	require_util();
	module.exports = forge.aes = forge.aes || {};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('AES-<mode>', key);
	* cipher.start({iv: iv});
	*
	* Creates an AES cipher object to encrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as a string of bytes, an array of bytes,
	* a byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.startEncrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: false,
			mode
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('AES-<mode>', key);
	*
	* Creates an AES cipher object to encrypt data using the given symmetric key.
	*
	* The key may be given as a string of bytes, an array of bytes, a
	* byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.createEncryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: false,
			mode
		});
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('AES-<mode>', key);
	* decipher.start({iv: iv});
	*
	* Creates an AES cipher object to decrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as a string of bytes, an array of bytes,
	* a byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.startDecrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: true,
			mode
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('AES-<mode>', key);
	*
	* Creates an AES cipher object to decrypt data using the given symmetric key.
	*
	* The key may be given as a string of bytes, an array of bytes, a
	* byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.createDecryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: true,
			mode
		});
	};
	/**
	* Creates a new AES cipher algorithm object.
	*
	* @param name the name of the algorithm.
	* @param mode the mode factory function.
	*
	* @return the AES algorithm object.
	*/
	forge.aes.Algorithm = function(name$1, mode) {
		if (!init) initialize();
		var self$1 = this;
		self$1.name = name$1;
		self$1.mode = new mode({
			blockSize: 16,
			cipher: {
				encrypt: function(inBlock, outBlock) {
					return _updateBlock(self$1._w, inBlock, outBlock, false);
				},
				decrypt: function(inBlock, outBlock) {
					return _updateBlock(self$1._w, inBlock, outBlock, true);
				}
			}
		});
		self$1._init = false;
	};
	/**
	* Initializes this AES algorithm by expanding its key.
	*
	* @param options the options to use.
	*          key the key to use with this algorithm.
	*          decrypt true if the algorithm should be initialized for decryption,
	*            false for encryption.
	*/
	forge.aes.Algorithm.prototype.initialize = function(options) {
		if (this._init) return;
		var key = options.key;
		var tmp;
		if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) key = forge.util.createBuffer(key);
		else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
			tmp = key;
			key = forge.util.createBuffer();
			for (var i = 0; i < tmp.length; ++i) key.putByte(tmp[i]);
		}
		if (!forge.util.isArray(key)) {
			tmp = key;
			key = [];
			var len = tmp.length();
			if (len === 16 || len === 24 || len === 32) {
				len = len >>> 2;
				for (var i = 0; i < len; ++i) key.push(tmp.getInt32());
			}
		}
		if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) throw new Error("Invalid key parameter.");
		var mode = this.mode.name;
		var encryptOp = [
			"CFB",
			"OFB",
			"CTR",
			"GCM"
		].indexOf(mode) !== -1;
		this._w = _expandKey(key, options.decrypt && !encryptOp);
		this._init = true;
	};
	/**
	* Expands a key. Typically only used for testing.
	*
	* @param key the symmetric key to expand, as an array of 32-bit words.
	* @param decrypt true to expand for decryption, false for encryption.
	*
	* @return the expanded key.
	*/
	forge.aes._expandKey = function(key, decrypt) {
		if (!init) initialize();
		return _expandKey(key, decrypt);
	};
	/**
	* Updates a single block. Typically only used for testing.
	*
	* @param w the expanded key to use.
	* @param input an array of block-size 32-bit words.
	* @param output an array of block-size 32-bit words.
	* @param decrypt true to decrypt, false to encrypt.
	*/
	forge.aes._updateBlock = _updateBlock;
	/** Register AES algorithms **/
	registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
	registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
	registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
	registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
	registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
	registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
	function registerAlgorithm(name$1, mode) {
		var factory = function() {
			return new forge.aes.Algorithm(name$1, mode);
		};
		forge.cipher.registerAlgorithm(name$1, factory);
	}
	/** AES implementation **/
	var init = false;
	var Nb = 4;
	var sbox;
	var isbox;
	var rcon;
	var mix;
	var imix;
	/**
	* Performs initialization, ie: precomputes tables to optimize for speed.
	*
	* One way to understand how AES works is to imagine that 'addition' and
	* 'multiplication' are interfaces that require certain mathematical
	* properties to hold true (ie: they are associative) but they might have
	* different implementations and produce different kinds of results ...
	* provided that their mathematical properties remain true. AES defines
	* its own methods of addition and multiplication but keeps some important
	* properties the same, ie: associativity and distributivity. The
	* explanation below tries to shed some light on how AES defines addition
	* and multiplication of bytes and 32-bit words in order to perform its
	* encryption and decryption algorithms.
	*
	* The basics:
	*
	* The AES algorithm views bytes as binary representations of polynomials
	* that have either 1 or 0 as the coefficients. It defines the addition
	* or subtraction of two bytes as the XOR operation. It also defines the
	* multiplication of two bytes as a finite field referred to as GF(2^8)
	* (Note: 'GF' means "Galois Field" which is a field that contains a finite
	* number of elements so GF(2^8) has 256 elements).
	*
	* This means that any two bytes can be represented as binary polynomials;
	* when they multiplied together and modularly reduced by an irreducible
	* polynomial of the 8th degree, the results are the field GF(2^8). The
	* specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
	* This multiplication is associative with 0x01 as the identity:
	*
	* (b * 0x01 = GF(b, 0x01) = b).
	*
	* The operation GF(b, 0x02) can be performed at the byte level by left
	* shifting b once and then XOR'ing it (to perform the modular reduction)
	* with 0x11b if b is >= 128. Repeated application of the multiplication
	* of 0x02 can be used to implement the multiplication of any two bytes.
	*
	* For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
	* be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
	* factors can each be multiplied by 0x57 and then added together. To do
	* the multiplication, values for 0x57 multiplied by each of these 3 factors
	* can be precomputed and stored in a table. To add them, the values from
	* the table are XOR'd together.
	*
	* AES also defines addition and multiplication of words, that is 4-byte
	* numbers represented as polynomials of 3 degrees where the coefficients
	* are the values of the bytes.
	*
	* The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
	*
	* Addition is performed by XOR'ing like powers of x. Multiplication
	* is performed in two steps, the first is an algebraic expansion as
	* you would do normally (where addition is XOR). But the result is
	* a polynomial larger than 3 degrees and thus it cannot fit in a word. So
	* next the result is modularly reduced by an AES-specific polynomial of
	* degree 4 which will always produce a polynomial of less than 4 degrees
	* such that it will fit in a word. In AES, this polynomial is x^4 + 1.
	*
	* The modular product of two polynomials 'a' and 'b' is thus:
	*
	* d(x) = d3x^3 + d2x^2 + d1x + d0
	* with
	* d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
	* d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
	* d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
	* d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
	*
	* As a matrix:
	*
	* [d0] = [a0 a3 a2 a1][b0]
	* [d1]   [a1 a0 a3 a2][b1]
	* [d2]   [a2 a1 a0 a3][b2]
	* [d3]   [a3 a2 a1 a0][b3]
	*
	* Special polynomials defined by AES (0x02 == {02}):
	* a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
	* a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
	*
	* These polynomials are used in the MixColumns() and InverseMixColumns()
	* operations, respectively, to cause each element in the state to affect
	* the output (referred to as diffusing).
	*
	* RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
	* polynomial x3.
	*
	* The ShiftRows() method modifies the last 3 rows in the state (where
	* the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
	* The 1st byte in the second row is moved to the end of the row. The 1st
	* and 2nd bytes in the third row are moved to the end of the row. The 1st,
	* 2nd, and 3rd bytes are moved in the fourth row.
	*
	* More details on how AES arithmetic works:
	*
	* In the polynomial representation of binary numbers, XOR performs addition
	* and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
	* corresponds with the multiplication of polynomials modulo an irreducible
	* polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
	* polynomial 'a' with polynomial 'b' and then do a modular reduction by
	* an AES-specific irreducible polynomial of degree 8.
	*
	* A polynomial is irreducible if its only divisors are one and itself. For
	* the AES algorithm, this irreducible polynomial is:
	*
	* m(x) = x^8 + x^4 + x^3 + x + 1,
	*
	* or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
	* 100011011 = 283 = 0x11b.
	*
	* For example, GF(0x57, 0x83) = 0xc1 because
	*
	* 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
	* 0x85 = 131 = 10000101 = x^7 + x + 1
	*
	* (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
	* =  x^13 + x^11 + x^9 + x^8 + x^7 +
	*    x^7 + x^5 + x^3 + x^2 + x +
	*    x^6 + x^4 + x^2 + x + 1
	* =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
	*    y modulo (x^8 + x^4 + x^3 + x + 1)
	* =  x^7 + x^6 + 1.
	*
	* The modular reduction by m(x) guarantees the result will be a binary
	* polynomial of less than degree 8, so that it can fit in a byte.
	*
	* The operation to multiply a binary polynomial b with x (the polynomial
	* x in binary representation is 00000010) is:
	*
	* b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
	*
	* To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
	* most significant bit is 0 in b) then the result is already reduced. If
	* it is 1, then we can reduce it by subtracting m(x) via an XOR.
	*
	* It follows that multiplication by x (00000010 or 0x02) can be implemented
	* by performing a left shift followed by a conditional bitwise XOR with
	* 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
	* higher powers of x can be implemented by repeated application of xtime().
	*
	* By adding intermediate results, multiplication by any constant can be
	* implemented. For instance:
	*
	* GF(0x57, 0x13) = 0xfe because:
	*
	* xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
	*
	* Note: We XOR with 0x11b instead of 0x1b because in javascript our
	* datatype for b can be larger than 1 byte, so a left shift will not
	* automatically eliminate bits that overflow a byte ... by XOR'ing the
	* overflow bit with 1 (the extra one from 0x11b) we zero it out.
	*
	* GF(0x57, 0x02) = xtime(0x57) = 0xae
	* GF(0x57, 0x04) = xtime(0xae) = 0x47
	* GF(0x57, 0x08) = xtime(0x47) = 0x8e
	* GF(0x57, 0x10) = xtime(0x8e) = 0x07
	*
	* GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
	*
	* And by the distributive property (since XOR is addition and GF() is
	* multiplication):
	*
	* = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
	* = 0x57 ^ 0xae ^ 0x07
	* = 0xfe.
	*/
	function initialize() {
		init = true;
		rcon = [
			0,
			1,
			2,
			4,
			8,
			16,
			32,
			64,
			128,
			27,
			54
		];
		var xtime = new Array(256);
		for (var i = 0; i < 128; ++i) {
			xtime[i] = i << 1;
			xtime[i + 128] = i + 128 << 1 ^ 283;
		}
		sbox = new Array(256);
		isbox = new Array(256);
		mix = new Array(4);
		imix = new Array(4);
		for (var i = 0; i < 4; ++i) {
			mix[i] = new Array(256);
			imix[i] = new Array(256);
		}
		var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
		for (var i = 0; i < 256; ++i) {
			sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
			sx = sx >> 8 ^ sx & 255 ^ 99;
			sbox[e] = sx;
			isbox[sx] = e;
			sx2 = xtime[sx];
			e2 = xtime[e];
			e4 = xtime[e2];
			e8 = xtime[e4];
			me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
			ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
			for (var n = 0; n < 4; ++n) {
				mix[n][e] = me;
				imix[n][sx] = ime;
				me = me << 24 | me >>> 8;
				ime = ime << 24 | ime >>> 8;
			}
			if (e === 0) e = ei = 1;
			else {
				e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
				ei ^= xtime[xtime[ei]];
			}
		}
	}
	/**
	* Generates a key schedule using the AES key expansion algorithm.
	*
	* The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
	* routine to generate a key schedule. The Key Expansion generates a total
	* of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
	* and each of the Nr rounds requires Nb words of key data. The resulting
	* key schedule consists of a linear array of 4-byte words, denoted [wi ],
	* with i in the range 0 <= i < Nb(Nr + 1).
	*
	* KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
	* AES-128 (Nb=4, Nk=4, Nr=10)
	* AES-192 (Nb=4, Nk=6, Nr=12)
	* AES-256 (Nb=4, Nk=8, Nr=14)
	* Note: Nr=Nk+6.
	*
	* Nb is the number of columns (32-bit words) comprising the State (or
	* number of bytes in a block). For AES, Nb=4.
	*
	* @param key the key to schedule (as an array of 32-bit words).
	* @param decrypt true to modify the key schedule to decrypt, false not to.
	*
	* @return the generated key schedule.
	*/
	function _expandKey(key, decrypt) {
		var w = key.slice(0);
		var temp, iNk = 1;
		var Nk = w.length;
		var end = Nb * (Nk + 6 + 1);
		for (var i = Nk; i < end; ++i) {
			temp = w[i - 1];
			if (i % Nk === 0) {
				temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
				iNk++;
			} else if (Nk > 6 && i % Nk === 4) temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
			w[i] = w[i - Nk] ^ temp;
		}
		if (decrypt) {
			var tmp;
			var m0 = imix[0];
			var m1 = imix[1];
			var m2 = imix[2];
			var m3 = imix[3];
			var wnew = w.slice(0);
			end = w.length;
			for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) if (i === 0 || i === end - Nb) {
				wnew[i] = w[wi];
				wnew[i + 1] = w[wi + 3];
				wnew[i + 2] = w[wi + 2];
				wnew[i + 3] = w[wi + 1];
			} else for (var n = 0; n < Nb; ++n) {
				tmp = w[wi + n];
				wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
			}
			w = wnew;
		}
		return w;
	}
	/**
	* Updates a single block (16 bytes) using AES. The update will either
	* encrypt or decrypt the block.
	*
	* @param w the key schedule.
	* @param input the input block (an array of 32-bit words).
	* @param output the updated output block.
	* @param decrypt true to decrypt the block, false to encrypt it.
	*/
	function _updateBlock(w, input, output, decrypt) {
		var Nr = w.length / 4 - 1;
		var m0, m1, m2, m3, sub;
		if (decrypt) {
			m0 = imix[0];
			m1 = imix[1];
			m2 = imix[2];
			m3 = imix[3];
			sub = isbox;
		} else {
			m0 = mix[0];
			m1 = mix[1];
			m2 = mix[2];
			m3 = mix[3];
			sub = sbox;
		}
		var a = input[0] ^ w[0], b = input[decrypt ? 3 : 1] ^ w[1], c = input[2] ^ w[2], d = input[decrypt ? 1 : 3] ^ w[3], a2, b2, c2;
		var i = 3;
		for (var round = 1; round < Nr; ++round) {
			a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
			b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
			c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
			d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
			a = a2;
			b = b2;
			c = c2;
		}
		output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
		output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
		output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
		output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
	}
	/**
	* Deprecated. Instead, use:
	*
	* forge.cipher.createCipher('AES-<mode>', key);
	* forge.cipher.createDecipher('AES-<mode>', key);
	*
	* Creates a deprecated AES cipher object. This object's mode will default to
	* CBC (cipher-block-chaining).
	*
	* The key and iv may be given as a string of bytes, an array of bytes, a
	* byte buffer, or an array of 32-bit words.
	*
	* @param options the options to use.
	*          key the symmetric key to use.
	*          output the buffer to write to.
	*          decrypt true for decryption, false for encryption.
	*          mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	function _createCipher(options) {
		options = options || {};
		var algorithm = "AES-" + (options.mode || "CBC").toUpperCase();
		var cipher;
		if (options.decrypt) cipher = forge.cipher.createDecipher(algorithm, options.key);
		else cipher = forge.cipher.createCipher(algorithm, options.key);
		var start = cipher.start;
		cipher.start = function(iv, options$1) {
			var output = null;
			if (options$1 instanceof forge.util.ByteBuffer) {
				output = options$1;
				options$1 = {};
			}
			options$1 = options$1 || {};
			options$1.output = output;
			options$1.iv = iv;
			start.call(cipher, options$1);
		};
		return cipher;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/oids.js
var require_oids = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Object IDs for ASN.1.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	forge.pki = forge.pki || {};
	var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
	function _IN(id, name$1) {
		oids[id] = name$1;
		oids[name$1] = id;
	}
	function _I_(id, name$1) {
		oids[id] = name$1;
	}
	_IN("1.2.840.113549.1.1.1", "rsaEncryption");
	_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
	_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
	_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
	_IN("1.2.840.113549.1.1.8", "mgf1");
	_IN("1.2.840.113549.1.1.9", "pSpecified");
	_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
	_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
	_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
	_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
	_IN("1.3.101.112", "EdDSA25519");
	_IN("1.2.840.10040.4.3", "dsa-with-sha1");
	_IN("1.3.14.3.2.7", "desCBC");
	_IN("1.3.14.3.2.26", "sha1");
	_IN("1.3.14.3.2.29", "sha1WithRSASignature");
	_IN("2.16.840.1.101.3.4.2.1", "sha256");
	_IN("2.16.840.1.101.3.4.2.2", "sha384");
	_IN("2.16.840.1.101.3.4.2.3", "sha512");
	_IN("2.16.840.1.101.3.4.2.4", "sha224");
	_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
	_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
	_IN("1.2.840.113549.2.2", "md2");
	_IN("1.2.840.113549.2.5", "md5");
	_IN("1.2.840.113549.1.7.1", "data");
	_IN("1.2.840.113549.1.7.2", "signedData");
	_IN("1.2.840.113549.1.7.3", "envelopedData");
	_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
	_IN("1.2.840.113549.1.7.5", "digestedData");
	_IN("1.2.840.113549.1.7.6", "encryptedData");
	_IN("1.2.840.113549.1.9.1", "emailAddress");
	_IN("1.2.840.113549.1.9.2", "unstructuredName");
	_IN("1.2.840.113549.1.9.3", "contentType");
	_IN("1.2.840.113549.1.9.4", "messageDigest");
	_IN("1.2.840.113549.1.9.5", "signingTime");
	_IN("1.2.840.113549.1.9.6", "counterSignature");
	_IN("1.2.840.113549.1.9.7", "challengePassword");
	_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
	_IN("1.2.840.113549.1.9.14", "extensionRequest");
	_IN("1.2.840.113549.1.9.20", "friendlyName");
	_IN("1.2.840.113549.1.9.21", "localKeyId");
	_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
	_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
	_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
	_IN("1.2.840.113549.1.12.10.1.3", "certBag");
	_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
	_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
	_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
	_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
	_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
	_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
	_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
	_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
	_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
	_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
	_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
	_IN("1.2.840.113549.2.7", "hmacWithSHA1");
	_IN("1.2.840.113549.2.8", "hmacWithSHA224");
	_IN("1.2.840.113549.2.9", "hmacWithSHA256");
	_IN("1.2.840.113549.2.10", "hmacWithSHA384");
	_IN("1.2.840.113549.2.11", "hmacWithSHA512");
	_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
	_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
	_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
	_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
	_IN("2.5.4.3", "commonName");
	_IN("2.5.4.4", "surname");
	_IN("2.5.4.5", "serialNumber");
	_IN("2.5.4.6", "countryName");
	_IN("2.5.4.7", "localityName");
	_IN("2.5.4.8", "stateOrProvinceName");
	_IN("2.5.4.9", "streetAddress");
	_IN("2.5.4.10", "organizationName");
	_IN("2.5.4.11", "organizationalUnitName");
	_IN("2.5.4.12", "title");
	_IN("2.5.4.13", "description");
	_IN("2.5.4.15", "businessCategory");
	_IN("2.5.4.17", "postalCode");
	_IN("2.5.4.42", "givenName");
	_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
	_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
	_IN("2.16.840.1.113730.1.1", "nsCertType");
	_IN("2.16.840.1.113730.1.13", "nsComment");
	_I_("2.5.29.1", "authorityKeyIdentifier");
	_I_("2.5.29.2", "keyAttributes");
	_I_("2.5.29.3", "certificatePolicies");
	_I_("2.5.29.4", "keyUsageRestriction");
	_I_("2.5.29.5", "policyMapping");
	_I_("2.5.29.6", "subtreesConstraint");
	_I_("2.5.29.7", "subjectAltName");
	_I_("2.5.29.8", "issuerAltName");
	_I_("2.5.29.9", "subjectDirectoryAttributes");
	_I_("2.5.29.10", "basicConstraints");
	_I_("2.5.29.11", "nameConstraints");
	_I_("2.5.29.12", "policyConstraints");
	_I_("2.5.29.13", "basicConstraints");
	_IN("2.5.29.14", "subjectKeyIdentifier");
	_IN("2.5.29.15", "keyUsage");
	_I_("2.5.29.16", "privateKeyUsagePeriod");
	_IN("2.5.29.17", "subjectAltName");
	_IN("2.5.29.18", "issuerAltName");
	_IN("2.5.29.19", "basicConstraints");
	_I_("2.5.29.20", "cRLNumber");
	_I_("2.5.29.21", "cRLReason");
	_I_("2.5.29.22", "expirationDate");
	_I_("2.5.29.23", "instructionCode");
	_I_("2.5.29.24", "invalidityDate");
	_I_("2.5.29.25", "cRLDistributionPoints");
	_I_("2.5.29.26", "issuingDistributionPoint");
	_I_("2.5.29.27", "deltaCRLIndicator");
	_I_("2.5.29.28", "issuingDistributionPoint");
	_I_("2.5.29.29", "certificateIssuer");
	_I_("2.5.29.30", "nameConstraints");
	_IN("2.5.29.31", "cRLDistributionPoints");
	_IN("2.5.29.32", "certificatePolicies");
	_I_("2.5.29.33", "policyMappings");
	_I_("2.5.29.34", "policyConstraints");
	_IN("2.5.29.35", "authorityKeyIdentifier");
	_I_("2.5.29.36", "policyConstraints");
	_IN("2.5.29.37", "extKeyUsage");
	_I_("2.5.29.46", "freshestCRL");
	_I_("2.5.29.54", "inhibitAnyPolicy");
	_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
	_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
	_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
	_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
	_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
	_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
	_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/asn1.js
var require_asn1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of Abstract Syntax Notation Number One.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2015 Digital Bazaar, Inc.
	*
	* An API for storing data using the Abstract Syntax Notation Number One
	* format using DER (Distinguished Encoding Rules) encoding. This encoding is
	* commonly used to store data for PKI, i.e. X.509 Certificates, and this
	* implementation exists for that purpose.
	*
	* Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
	* syntax of information without restricting the way the information is encoded
	* for transmission. It provides a standard that allows for open systems
	* communication. ASN.1 defines the syntax of information data and a number of
	* simple data types as well as a notation for describing them and specifying
	* values for them.
	*
	* The RSA algorithm creates public and private keys that are often stored in
	* X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
	* class provides the most basic functionality required to store and load DSA
	* keys that are encoded according to ASN.1.
	*
	* The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
	* and DER (Distinguished Encoding Rules). DER is just a subset of BER that
	* has stricter requirements for how data must be encoded.
	*
	* Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
	* and a byte array for the value of this ASN1 structure which may be data or a
	* list of ASN.1 structures.
	*
	* Each ASN.1 structure using BER is (Tag-Length-Value):
	*
	* | byte 0 | bytes X | bytes Y |
	* |--------|---------|----------
	* |  tag   | length  |  value  |
	*
	* ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
	* be two or more octets, but that is not supported by this class. A tag is
	* only 1 byte. Bits 1-5 give the tag number (ie the data type within a
	* particular 'class'), 6 indicates whether or not the ASN.1 value is
	* constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
	* bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
	* then the class is APPLICATION. If only bit 8 is set, then the class is
	* CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
	* The tag numbers for the data types for the class UNIVERSAL are listed below:
	*
	* UNIVERSAL 0 Reserved for use by the encoding rules
	* UNIVERSAL 1 Boolean type
	* UNIVERSAL 2 Integer type
	* UNIVERSAL 3 Bitstring type
	* UNIVERSAL 4 Octetstring type
	* UNIVERSAL 5 Null type
	* UNIVERSAL 6 Object identifier type
	* UNIVERSAL 7 Object descriptor type
	* UNIVERSAL 8 External type and Instance-of type
	* UNIVERSAL 9 Real type
	* UNIVERSAL 10 Enumerated type
	* UNIVERSAL 11 Embedded-pdv type
	* UNIVERSAL 12 UTF8String type
	* UNIVERSAL 13 Relative object identifier type
	* UNIVERSAL 14-15 Reserved for future editions
	* UNIVERSAL 16 Sequence and Sequence-of types
	* UNIVERSAL 17 Set and Set-of types
	* UNIVERSAL 18-22, 25-30 Character string types
	* UNIVERSAL 23-24 Time types
	*
	* The length of an ASN.1 structure is specified after the tag identifier.
	* There is a definite form and an indefinite form. The indefinite form may
	* be used if the encoding is constructed and not all immediately available.
	* The indefinite form is encoded using a length byte with only the 8th bit
	* set. The end of the constructed object is marked using end-of-contents
	* octets (two zero bytes).
	*
	* The definite form looks like this:
	*
	* The length may take up 1 or more bytes, it depends on the length of the
	* value of the ASN.1 structure. DER encoding requires that if the ASN.1
	* structure has a value that has a length greater than 127, more than 1 byte
	* will be used to store its length, otherwise just one byte will be used.
	* This is strict.
	*
	* In the case that the length of the ASN.1 value is less than 127, 1 octet
	* (byte) is used to store the "short form" length. The 8th bit has a value of
	* 0 indicating the length is "short form" and not "long form" and bits 7-1
	* give the length of the data. (The 8th bit is the left-most, most significant
	* bit: also known as big endian or network format).
	*
	* In the case that the length of the ASN.1 value is greater than 127, 2 to
	* 127 octets (bytes) are used to store the "long form" length. The first
	* byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
	* give the number of additional octets. All following octets are in base 256
	* with the most significant digit first (typical big-endian binary unsigned
	* integer storage). So, for instance, if the length of a value was 257, the
	* first byte would be set to:
	*
	* 10000010 = 130 = 0x82.
	*
	* This indicates there are 2 octets (base 256) for the length. The second and
	* third bytes (the octets just mentioned) would store the length in base 256:
	*
	* octet 2: 00000001 = 1 * 256^1 = 256
	* octet 3: 00000001 = 1 * 256^0 = 1
	* total = 257
	*
	* The algorithm for converting a js integer value of 257 to base-256 is:
	*
	* var value = 257;
	* var bytes = [];
	* bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
	* bytes[1] = value & 0xFF;        // least significant byte last
	*
	* On the ASN.1 UNIVERSAL Object Identifier (OID) type:
	*
	* An OID can be written like: "value1.value2.value3...valueN"
	*
	* The DER encoding rules:
	*
	* The first byte has the value 40 * value1 + value2.
	* The following bytes, if any, encode the remaining values. Each value is
	* encoded in base 128, most significant digit first (big endian), with as
	* few digits as possible, and the most significant bit of each byte set
	* to 1 except the last in each value's encoding. For example: Given the
	* OID "1.2.840.113549", its DER encoding is (remember each byte except the
	* last one in each encoding is OR'd with 0x80):
	*
	* byte 1: 40 * 1 + 2 = 42 = 0x2A.
	* bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
	* bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
	*
	* The final value is: 0x2A864886F70D.
	* The full OID (including ASN.1 tag and length of 6 bytes) is:
	* 0x06062A864886F70D
	*/
	var forge = require_forge();
	require_util();
	require_oids();
	var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
	/**
	* ASN.1 classes.
	*/
	asn1.Class = {
		UNIVERSAL: 0,
		APPLICATION: 64,
		CONTEXT_SPECIFIC: 128,
		PRIVATE: 192
	};
	/**
	* ASN.1 types. Not all types are supported by this implementation, only
	* those necessary to implement a simple PKI are implemented.
	*/
	asn1.Type = {
		NONE: 0,
		BOOLEAN: 1,
		INTEGER: 2,
		BITSTRING: 3,
		OCTETSTRING: 4,
		NULL: 5,
		OID: 6,
		ODESC: 7,
		EXTERNAL: 8,
		REAL: 9,
		ENUMERATED: 10,
		EMBEDDED: 11,
		UTF8: 12,
		ROID: 13,
		SEQUENCE: 16,
		SET: 17,
		PRINTABLESTRING: 19,
		IA5STRING: 22,
		UTCTIME: 23,
		GENERALIZEDTIME: 24,
		BMPSTRING: 30
	};
	/**
	* Sets the default maximum recursion depth when parsing ASN.1 structures.
	*/
	asn1.maxDepth = 256;
	/**
	* Creates a new asn1 object.
	*
	* @param tagClass the tag class for the object.
	* @param type the data type (tag number) for the object.
	* @param constructed true if the asn1 object is in constructed form.
	* @param value the value for the object, if it is not constructed.
	* @param [options] the options to use:
	*          [bitStringContents] the plain BIT STRING content including padding
	*            byte.
	*
	* @return the asn1 object.
	*/
	asn1.create = function(tagClass, type, constructed, value, options) {
		if (forge.util.isArray(value)) {
			var tmp = [];
			for (var i = 0; i < value.length; ++i) if (value[i] !== void 0) tmp.push(value[i]);
			value = tmp;
		}
		var obj = {
			tagClass,
			type,
			constructed,
			composed: constructed || forge.util.isArray(value),
			value
		};
		if (options && "bitStringContents" in options) {
			obj.bitStringContents = options.bitStringContents;
			obj.original = asn1.copy(obj);
		}
		return obj;
	};
	/**
	* Copies an asn1 object.
	*
	* @param obj the asn1 object.
	* @param [options] copy options:
	*          [excludeBitStringContents] true to not copy bitStringContents
	*
	* @return the a copy of the asn1 object.
	*/
	asn1.copy = function(obj, options) {
		var copy;
		if (forge.util.isArray(obj)) {
			copy = [];
			for (var i = 0; i < obj.length; ++i) copy.push(asn1.copy(obj[i], options));
			return copy;
		}
		if (typeof obj === "string") return obj;
		copy = {
			tagClass: obj.tagClass,
			type: obj.type,
			constructed: obj.constructed,
			composed: obj.composed,
			value: asn1.copy(obj.value, options)
		};
		if (options && !options.excludeBitStringContents) copy.bitStringContents = obj.bitStringContents;
		return copy;
	};
	/**
	* Compares asn1 objects for equality.
	*
	* Note this function does not run in constant time.
	*
	* @param obj1 the first asn1 object.
	* @param obj2 the second asn1 object.
	* @param [options] compare options:
	*          [includeBitStringContents] true to compare bitStringContents
	*
	* @return true if the asn1 objects are equal.
	*/
	asn1.equals = function(obj1, obj2, options) {
		if (forge.util.isArray(obj1)) {
			if (!forge.util.isArray(obj2)) return false;
			if (obj1.length !== obj2.length) return false;
			for (var i = 0; i < obj1.length; ++i) if (!asn1.equals(obj1[i], obj2[i])) return false;
			return true;
		}
		if (typeof obj1 !== typeof obj2) return false;
		if (typeof obj1 === "string") return obj1 === obj2;
		var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
		if (options && options.includeBitStringContents) equal = equal && obj1.bitStringContents === obj2.bitStringContents;
		return equal;
	};
	/**
	* Gets the length of a BER-encoded ASN.1 value.
	*
	* In case the length is not specified, undefined is returned.
	*
	* @param b the BER-encoded ASN.1 byte buffer, starting with the first
	*          length byte.
	*
	* @return the length of the BER-encoded ASN.1 value or undefined.
	*/
	asn1.getBerValueLength = function(b) {
		var b2 = b.getByte();
		if (b2 === 128) return;
		var length;
		if (!(b2 & 128)) length = b2;
		else length = b.getInt((b2 & 127) << 3);
		return length;
	};
	/**
	* Check if the byte buffer has enough bytes. Throws an Error if not.
	*
	* @param bytes the byte buffer to parse from.
	* @param remaining the bytes remaining in the current parsing state.
	* @param n the number of bytes the buffer must have.
	*/
	function _checkBufferLength(bytes, remaining, n) {
		if (n > remaining) {
			var error$47 = /* @__PURE__ */ new Error("Too few bytes to parse DER.");
			error$47.available = bytes.length();
			error$47.remaining = remaining;
			error$47.requested = n;
			throw error$47;
		}
	}
	/**
	* Gets the length of a BER-encoded ASN.1 value.
	*
	* In case the length is not specified, undefined is returned.
	*
	* @param bytes the byte buffer to parse from.
	* @param remaining the bytes remaining in the current parsing state.
	*
	* @return the length of the BER-encoded ASN.1 value or undefined.
	*/
	var _getValueLength = function(bytes, remaining) {
		var b2 = bytes.getByte();
		remaining--;
		if (b2 === 128) return;
		var length;
		if (!(b2 & 128)) length = b2;
		else {
			var longFormBytes = b2 & 127;
			_checkBufferLength(bytes, remaining, longFormBytes);
			length = bytes.getInt(longFormBytes << 3);
		}
		if (length < 0) throw new Error("Negative length: " + length);
		return length;
	};
	/**
	* Parses an asn1 object from a byte buffer in DER format.
	*
	* @param bytes the byte buffer to parse from.
	* @param [strict] true to be strict when checking value lengths, false to
	*          allow truncated values (default: true).
	* @param [options] object with options or boolean strict flag
	*          [strict] true to be strict when checking value lengths, false to
	*            allow truncated values (default: true).
	*          [parseAllBytes] true to ensure all bytes are parsed
	*            (default: true)
	*          [decodeBitStrings] true to attempt to decode the content of
	*            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
	*            without schema support to understand the data context this can
	*            erroneously decode values that happen to be valid ASN.1. This
	*            flag will be deprecated or removed as soon as schema support is
	*            available. (default: true)
	*          [maxDepth] override asn1.maxDepth recursion limit
	*            (default: asn1.maxDepth)
	*
	* @throws Will throw an error for various malformed input conditions.
	*
	* @return the parsed asn1 object.
	*/
	asn1.fromDer = function(bytes, options) {
		if (options === void 0) options = {
			strict: true,
			parseAllBytes: true,
			decodeBitStrings: true
		};
		if (typeof options === "boolean") options = {
			strict: options,
			parseAllBytes: true,
			decodeBitStrings: true
		};
		if (!("strict" in options)) options.strict = true;
		if (!("parseAllBytes" in options)) options.parseAllBytes = true;
		if (!("decodeBitStrings" in options)) options.decodeBitStrings = true;
		if (!("maxDepth" in options)) options.maxDepth = asn1.maxDepth;
		if (typeof bytes === "string") bytes = forge.util.createBuffer(bytes);
		var byteCount = bytes.length();
		var value = _fromDer(bytes, bytes.length(), 0, options);
		if (options.parseAllBytes && bytes.length() !== 0) {
			var error$47 = /* @__PURE__ */ new Error("Unparsed DER bytes remain after ASN.1 parsing.");
			error$47.byteCount = byteCount;
			error$47.remaining = bytes.length();
			throw error$47;
		}
		return value;
	};
	/**
	* Internal function to parse an asn1 object from a byte buffer in DER format.
	*
	* @param bytes the byte buffer to parse from.
	* @param remaining the number of bytes remaining for this chunk.
	* @param depth the current parsing depth.
	* @param options object with same options as fromDer().
	*
	* @return the parsed asn1 object.
	*/
	function _fromDer(bytes, remaining, depth, options) {
		if (depth >= options.maxDepth) throw new Error("ASN.1 parsing error: Max depth exceeded.");
		var start;
		_checkBufferLength(bytes, remaining, 2);
		var b1 = bytes.getByte();
		remaining--;
		var tagClass = b1 & 192;
		var type = b1 & 31;
		start = bytes.length();
		var length = _getValueLength(bytes, remaining);
		remaining -= start - bytes.length();
		if (length !== void 0 && length > remaining) {
			if (options.strict) {
				var error$47 = /* @__PURE__ */ new Error("Too few bytes to read ASN.1 value.");
				error$47.available = bytes.length();
				error$47.remaining = remaining;
				error$47.requested = length;
				throw error$47;
			}
			length = remaining;
		}
		var value;
		var bitStringContents;
		var constructed = (b1 & 32) === 32;
		if (constructed) {
			value = [];
			if (length === void 0) for (;;) {
				_checkBufferLength(bytes, remaining, 2);
				if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
					bytes.getBytes(2);
					remaining -= 2;
					break;
				}
				start = bytes.length();
				value.push(_fromDer(bytes, remaining, depth + 1, options));
				remaining -= start - bytes.length();
			}
			else while (length > 0) {
				start = bytes.length();
				value.push(_fromDer(bytes, length, depth + 1, options));
				remaining -= start - bytes.length();
				length -= start - bytes.length();
			}
		}
		if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) bitStringContents = bytes.bytes(length);
		if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
			var savedRead = bytes.read;
			var savedRemaining = remaining;
			var unused = 0;
			if (type === asn1.Type.BITSTRING) {
				_checkBufferLength(bytes, remaining, 1);
				unused = bytes.getByte();
				remaining--;
			}
			if (unused === 0) try {
				start = bytes.length();
				var composed = _fromDer(bytes, remaining, depth + 1, {
					strict: true,
					decodeBitStrings: true
				});
				var used = start - bytes.length();
				remaining -= used;
				if (type == asn1.Type.BITSTRING) used++;
				var tc = composed.tagClass;
				if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) value = [composed];
			} catch (ex) {}
			if (value === void 0) {
				bytes.read = savedRead;
				remaining = savedRemaining;
			}
		}
		if (value === void 0) {
			if (length === void 0) {
				if (options.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
				length = remaining;
			}
			if (type === asn1.Type.BMPSTRING) {
				value = "";
				for (; length > 0; length -= 2) {
					_checkBufferLength(bytes, remaining, 2);
					value += String.fromCharCode(bytes.getInt16());
					remaining -= 2;
				}
			} else {
				value = bytes.getBytes(length);
				remaining -= length;
			}
		}
		var asn1Options = bitStringContents === void 0 ? null : { bitStringContents };
		return asn1.create(tagClass, type, constructed, value, asn1Options);
	}
	/**
	* Converts the given asn1 object to a buffer of bytes in DER format.
	*
	* @param asn1 the asn1 object to convert to bytes.
	*
	* @return the buffer of bytes.
	*/
	asn1.toDer = function(obj) {
		var bytes = forge.util.createBuffer();
		var b1 = obj.tagClass | obj.type;
		var value = forge.util.createBuffer();
		var useBitStringContents = false;
		if ("bitStringContents" in obj) {
			useBitStringContents = true;
			if (obj.original) useBitStringContents = asn1.equals(obj, obj.original);
		}
		if (useBitStringContents) value.putBytes(obj.bitStringContents);
		else if (obj.composed) {
			if (obj.constructed) b1 |= 32;
			else value.putByte(0);
			for (var i = 0; i < obj.value.length; ++i) if (obj.value[i] !== void 0) value.putBuffer(asn1.toDer(obj.value[i]));
		} else if (obj.type === asn1.Type.BMPSTRING) for (var i = 0; i < obj.value.length; ++i) value.putInt16(obj.value.charCodeAt(i));
		else if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) value.putBytes(obj.value.substr(1));
		else value.putBytes(obj.value);
		bytes.putByte(b1);
		if (value.length() <= 127) bytes.putByte(value.length() & 127);
		else {
			var len = value.length();
			var lenBytes = "";
			do {
				lenBytes += String.fromCharCode(len & 255);
				len = len >>> 8;
			} while (len > 0);
			bytes.putByte(lenBytes.length | 128);
			for (var i = lenBytes.length - 1; i >= 0; --i) bytes.putByte(lenBytes.charCodeAt(i));
		}
		bytes.putBuffer(value);
		return bytes;
	};
	/**
	* Converts an OID dot-separated string to a byte buffer. The byte buffer
	* contains only the DER-encoded value, not any tag or length bytes.
	*
	* @param oid the OID dot-separated string.
	*
	* @return the byte buffer.
	*/
	asn1.oidToDer = function(oid) {
		var values = oid.split(".");
		var bytes = forge.util.createBuffer();
		bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
		var last, valueBytes, value, b;
		for (var i = 2; i < values.length; ++i) {
			last = true;
			valueBytes = [];
			value = parseInt(values[i], 10);
			if (value > 4294967295) throw new Error("OID value too large; max is 32-bits.");
			do {
				b = value & 127;
				value = value >>> 7;
				if (!last) b |= 128;
				valueBytes.push(b);
				last = false;
			} while (value > 0);
			for (var n = valueBytes.length - 1; n >= 0; --n) bytes.putByte(valueBytes[n]);
		}
		return bytes;
	};
	/**
	* Converts a DER-encoded byte buffer to an OID dot-separated string. The
	* byte buffer should contain only the DER-encoded value, not any tag or
	* length bytes.
	*
	* @param bytes the byte buffer.
	*
	* @return the OID dot-separated string.
	*/
	asn1.derToOid = function(bytes) {
		var oid;
		if (typeof bytes === "string") bytes = forge.util.createBuffer(bytes);
		var b = bytes.getByte();
		oid = Math.floor(b / 40) + "." + b % 40;
		var value = 0;
		while (bytes.length() > 0) {
			if (value > 70368744177663) throw new Error("OID value too large; max is 53-bits.");
			b = bytes.getByte();
			value = value * 128;
			if (b & 128) value += b & 127;
			else {
				oid += "." + (value + b);
				value = 0;
			}
		}
		return oid;
	};
	/**
	* Converts a UTCTime value to a date.
	*
	* Note: GeneralizedTime has 4 digits for the year and is used for X.509
	* dates past 2049. Parsing that structure hasn't been implemented yet.
	*
	* @param utc the UTCTime value to convert.
	*
	* @return the date.
	*/
	asn1.utcTimeToDate = function(utc) {
		var date$4 = /* @__PURE__ */ new Date();
		var year = parseInt(utc.substr(0, 2), 10);
		year = year >= 50 ? 1900 + year : 2e3 + year;
		var MM = parseInt(utc.substr(2, 2), 10) - 1;
		var DD = parseInt(utc.substr(4, 2), 10);
		var hh = parseInt(utc.substr(6, 2), 10);
		var mm = parseInt(utc.substr(8, 2), 10);
		var ss = 0;
		if (utc.length > 11) {
			var c = utc.charAt(10);
			var end = 10;
			if (c !== "+" && c !== "-") {
				ss = parseInt(utc.substr(10, 2), 10);
				end += 2;
			}
		}
		date$4.setUTCFullYear(year, MM, DD);
		date$4.setUTCHours(hh, mm, ss, 0);
		if (end) {
			c = utc.charAt(end);
			if (c === "+" || c === "-") {
				var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
				var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
				var offset = hhoffset * 60 + mmoffset;
				offset *= 6e4;
				if (c === "+") date$4.setTime(+date$4 - offset);
				else date$4.setTime(+date$4 + offset);
			}
		}
		return date$4;
	};
	/**
	* Converts a GeneralizedTime value to a date.
	*
	* @param gentime the GeneralizedTime value to convert.
	*
	* @return the date.
	*/
	asn1.generalizedTimeToDate = function(gentime) {
		var date$4 = /* @__PURE__ */ new Date();
		var YYYY = parseInt(gentime.substr(0, 4), 10);
		var MM = parseInt(gentime.substr(4, 2), 10) - 1;
		var DD = parseInt(gentime.substr(6, 2), 10);
		var hh = parseInt(gentime.substr(8, 2), 10);
		var mm = parseInt(gentime.substr(10, 2), 10);
		var ss = parseInt(gentime.substr(12, 2), 10);
		var fff = 0;
		var offset = 0;
		var isUTC = false;
		if (gentime.charAt(gentime.length - 1) === "Z") isUTC = true;
		var end = gentime.length - 5, c = gentime.charAt(end);
		if (c === "+" || c === "-") {
			var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
			var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
			offset = hhoffset * 60 + mmoffset;
			offset *= 6e4;
			if (c === "+") offset *= -1;
			isUTC = true;
		}
		if (gentime.charAt(14) === ".") fff = parseFloat(gentime.substr(14), 10) * 1e3;
		if (isUTC) {
			date$4.setUTCFullYear(YYYY, MM, DD);
			date$4.setUTCHours(hh, mm, ss, fff);
			date$4.setTime(+date$4 + offset);
		} else {
			date$4.setFullYear(YYYY, MM, DD);
			date$4.setHours(hh, mm, ss, fff);
		}
		return date$4;
	};
	/**
	* Converts a date to a UTCTime value.
	*
	* Note: GeneralizedTime has 4 digits for the year and is used for X.509
	* dates past 2049. Converting to a GeneralizedTime hasn't been
	* implemented yet.
	*
	* @param date the date to convert.
	*
	* @return the UTCTime value.
	*/
	asn1.dateToUtcTime = function(date$4) {
		if (typeof date$4 === "string") return date$4;
		var rval = "";
		var format = [];
		format.push(("" + date$4.getUTCFullYear()).substr(2));
		format.push("" + (date$4.getUTCMonth() + 1));
		format.push("" + date$4.getUTCDate());
		format.push("" + date$4.getUTCHours());
		format.push("" + date$4.getUTCMinutes());
		format.push("" + date$4.getUTCSeconds());
		for (var i = 0; i < format.length; ++i) {
			if (format[i].length < 2) rval += "0";
			rval += format[i];
		}
		rval += "Z";
		return rval;
	};
	/**
	* Converts a date to a GeneralizedTime value.
	*
	* @param date the date to convert.
	*
	* @return the GeneralizedTime value as a string.
	*/
	asn1.dateToGeneralizedTime = function(date$4) {
		if (typeof date$4 === "string") return date$4;
		var rval = "";
		var format = [];
		format.push("" + date$4.getUTCFullYear());
		format.push("" + (date$4.getUTCMonth() + 1));
		format.push("" + date$4.getUTCDate());
		format.push("" + date$4.getUTCHours());
		format.push("" + date$4.getUTCMinutes());
		format.push("" + date$4.getUTCSeconds());
		for (var i = 0; i < format.length; ++i) {
			if (format[i].length < 2) rval += "0";
			rval += format[i];
		}
		rval += "Z";
		return rval;
	};
	/**
	* Converts a javascript integer to a DER-encoded byte buffer to be used
	* as the value for an INTEGER type.
	*
	* @param x the integer.
	*
	* @return the byte buffer.
	*/
	asn1.integerToDer = function(x) {
		var rval = forge.util.createBuffer();
		if (x >= -128 && x < 128) return rval.putSignedInt(x, 8);
		if (x >= -32768 && x < 32768) return rval.putSignedInt(x, 16);
		if (x >= -8388608 && x < 8388608) return rval.putSignedInt(x, 24);
		if (x >= -2147483648 && x < 2147483648) return rval.putSignedInt(x, 32);
		var error$47 = /* @__PURE__ */ new Error("Integer too large; max is 32-bits.");
		error$47.integer = x;
		throw error$47;
	};
	/**
	* Converts a DER-encoded byte buffer to a javascript integer. This is
	* typically used to decode the value of an INTEGER type.
	*
	* @param bytes the byte buffer.
	*
	* @return the integer.
	*/
	asn1.derToInteger = function(bytes) {
		if (typeof bytes === "string") bytes = forge.util.createBuffer(bytes);
		var n = bytes.length() * 8;
		if (n > 32) throw new Error("Integer too large; max is 32-bits.");
		return bytes.getSignedInt(n);
	};
	/**
	* Validates that the given ASN.1 object is at least a super set of the
	* given ASN.1 structure. Only tag classes and types are checked. An
	* optional map may also be provided to capture ASN.1 values while the
	* structure is checked.
	*
	* To capture an ASN.1 value, set an object in the validator's 'capture'
	* parameter to the key to use in the capture map. To capture the full
	* ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
	* the leading unused bits counter byte, specify 'captureBitStringContents'.
	* To capture BIT STRING bytes, without the leading unused bits counter byte,
	* specify 'captureBitStringValue'.
	*
	* Objects in the validator may set a field 'optional' to true to indicate
	* that it isn't necessary to pass validation.
	*
	* @param obj the ASN.1 object to validate.
	* @param v the ASN.1 structure validator.
	* @param capture an optional map to capture values in.
	* @param errors an optional array for storing validation errors.
	*
	* @return true on success, false on failure.
	*/
	asn1.validate = function(obj, v, capture, errors) {
		var rval = false;
		if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
			if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
				rval = true;
				if (v.value && forge.util.isArray(v.value)) {
					var j = 0;
					for (var i = 0; rval && i < v.value.length; ++i) {
						var schemaItem = v.value[i];
						rval = !!schemaItem.optional;
						var objChild = obj.value[j];
						if (!objChild) {
							if (!schemaItem.optional) {
								rval = false;
								if (errors) errors.push("[" + v.name + "] Missing required element. Expected tag class \"" + schemaItem.tagClass + "\", type \"" + schemaItem.type + "\"");
							}
							continue;
						}
						if (typeof schemaItem.tagClass !== "undefined" && typeof schemaItem.type !== "undefined" && (objChild.tagClass !== schemaItem.tagClass || objChild.type !== schemaItem.type)) if (schemaItem.optional) {
							rval = true;
							continue;
						} else {
							rval = false;
							if (errors) errors.push("[" + v.name + "] Tag mismatch. Expected (" + schemaItem.tagClass + "," + schemaItem.type + "), got (" + objChild.tagClass + "," + objChild.type + ")");
							break;
						}
						if (asn1.validate(objChild, schemaItem, capture, errors)) {
							++j;
							rval = true;
						} else if (schemaItem.optional) rval = true;
						else {
							rval = false;
							break;
						}
					}
				}
				if (rval && capture) {
					if (v.capture) capture[v.capture] = obj.value;
					if (v.captureAsn1) capture[v.captureAsn1] = obj;
					if (v.captureBitStringContents && "bitStringContents" in obj) capture[v.captureBitStringContents] = obj.bitStringContents;
					if (v.captureBitStringValue && "bitStringContents" in obj) if (obj.bitStringContents.length < 2) capture[v.captureBitStringValue] = "";
					else {
						if (obj.bitStringContents.charCodeAt(0) !== 0) throw new Error("captureBitStringValue only supported for zero unused bits");
						capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
					}
				}
			} else if (errors) errors.push("[" + v.name + "] Expected constructed \"" + v.constructed + "\", got \"" + obj.constructed + "\"");
		} else if (errors) {
			if (obj.tagClass !== v.tagClass) errors.push("[" + v.name + "] Expected tag class \"" + v.tagClass + "\", got \"" + obj.tagClass + "\"");
			if (obj.type !== v.type) errors.push("[" + v.name + "] Expected type \"" + v.type + "\", got \"" + obj.type + "\"");
		}
		return rval;
	};
	var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
	/**
	* Pretty prints an ASN.1 object to a string.
	*
	* @param obj the object to write out.
	* @param level the level in the tree.
	* @param indentation the indentation to use.
	*
	* @return the string.
	*/
	asn1.prettyPrint = function(obj, level, indentation) {
		var rval = "";
		level = level || 0;
		indentation = indentation || 2;
		if (level > 0) rval += "\n";
		var indent = "";
		for (var i = 0; i < level * indentation; ++i) indent += " ";
		rval += indent + "Tag: ";
		switch (obj.tagClass) {
			case asn1.Class.UNIVERSAL:
				rval += "Universal:";
				break;
			case asn1.Class.APPLICATION:
				rval += "Application:";
				break;
			case asn1.Class.CONTEXT_SPECIFIC:
				rval += "Context-Specific:";
				break;
			case asn1.Class.PRIVATE:
				rval += "Private:";
				break;
		}
		if (obj.tagClass === asn1.Class.UNIVERSAL) {
			rval += obj.type;
			switch (obj.type) {
				case asn1.Type.NONE:
					rval += " (None)";
					break;
				case asn1.Type.BOOLEAN:
					rval += " (Boolean)";
					break;
				case asn1.Type.INTEGER:
					rval += " (Integer)";
					break;
				case asn1.Type.BITSTRING:
					rval += " (Bit string)";
					break;
				case asn1.Type.OCTETSTRING:
					rval += " (Octet string)";
					break;
				case asn1.Type.NULL:
					rval += " (Null)";
					break;
				case asn1.Type.OID:
					rval += " (Object Identifier)";
					break;
				case asn1.Type.ODESC:
					rval += " (Object Descriptor)";
					break;
				case asn1.Type.EXTERNAL:
					rval += " (External or Instance of)";
					break;
				case asn1.Type.REAL:
					rval += " (Real)";
					break;
				case asn1.Type.ENUMERATED:
					rval += " (Enumerated)";
					break;
				case asn1.Type.EMBEDDED:
					rval += " (Embedded PDV)";
					break;
				case asn1.Type.UTF8:
					rval += " (UTF8)";
					break;
				case asn1.Type.ROID:
					rval += " (Relative Object Identifier)";
					break;
				case asn1.Type.SEQUENCE:
					rval += " (Sequence)";
					break;
				case asn1.Type.SET:
					rval += " (Set)";
					break;
				case asn1.Type.PRINTABLESTRING:
					rval += " (Printable String)";
					break;
				case asn1.Type.IA5String:
					rval += " (IA5String (ASCII))";
					break;
				case asn1.Type.UTCTIME:
					rval += " (UTC time)";
					break;
				case asn1.Type.GENERALIZEDTIME:
					rval += " (Generalized time)";
					break;
				case asn1.Type.BMPSTRING:
					rval += " (BMP String)";
					break;
			}
		} else rval += obj.type;
		rval += "\n";
		rval += indent + "Constructed: " + obj.constructed + "\n";
		if (obj.composed) {
			var subvalues = 0;
			var sub = "";
			for (var i = 0; i < obj.value.length; ++i) if (obj.value[i] !== void 0) {
				subvalues += 1;
				sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
				if (i + 1 < obj.value.length) sub += ",";
			}
			rval += indent + "Sub values: " + subvalues + sub;
		} else {
			rval += indent + "Value: ";
			if (obj.type === asn1.Type.OID) {
				var oid = asn1.derToOid(obj.value);
				rval += oid;
				if (forge.pki && forge.pki.oids) {
					if (oid in forge.pki.oids) rval += " (" + forge.pki.oids[oid] + ") ";
				}
			}
			if (obj.type === asn1.Type.INTEGER) try {
				rval += asn1.derToInteger(obj.value);
			} catch (ex) {
				rval += "0x" + forge.util.bytesToHex(obj.value);
			}
			else if (obj.type === asn1.Type.BITSTRING) {
				if (obj.value.length > 1) rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
				else rval += "(none)";
				if (obj.value.length > 0) {
					var unused = obj.value.charCodeAt(0);
					if (unused == 1) rval += " (1 unused bit shown)";
					else if (unused > 1) rval += " (" + unused + " unused bits shown)";
				}
			} else if (obj.type === asn1.Type.OCTETSTRING) {
				if (!_nonLatinRegex.test(obj.value)) rval += "(" + obj.value + ") ";
				rval += "0x" + forge.util.bytesToHex(obj.value);
			} else if (obj.type === asn1.Type.UTF8) try {
				rval += forge.util.decodeUtf8(obj.value);
			} catch (e) {
				if (e.message === "URI malformed") rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
				else throw e;
			}
			else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) rval += obj.value;
			else if (_nonLatinRegex.test(obj.value)) rval += "0x" + forge.util.bytesToHex(obj.value);
			else if (obj.value.length === 0) rval += "[null]";
			else rval += obj.value;
		}
		return rval;
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/md.js
var require_md = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge message digests.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2017 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	module.exports = forge.md = forge.md || {};
	forge.md.algorithms = forge.md.algorithms || {};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/hmac.js
var require_hmac = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Hash-based Message Authentication Code implementation. Requires a message
	* digest object that can be obtained, for example, from forge.md.sha1 or
	* forge.md.md5.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var hmac = module.exports = forge.hmac = forge.hmac || {};
	/**
	* Creates an HMAC object that uses the given message digest object.
	*
	* @return an HMAC object.
	*/
	hmac.create = function() {
		var _key = null;
		var _md = null;
		var _ipadding = null;
		var _opadding = null;
		var ctx = {};
		/**
		* Starts or restarts the HMAC with the given key and message digest.
		*
		* @param md the message digest to use, null to reuse the previous one,
		*           a string to use builtin 'sha1', 'md5', 'sha256'.
		* @param key the key to use as a string, array of bytes, byte buffer,
		*           or null to reuse the previous key.
		*/
		ctx.start = function(md, key) {
			if (md !== null) if (typeof md === "string") {
				md = md.toLowerCase();
				if (md in forge.md.algorithms) _md = forge.md.algorithms[md].create();
				else throw new Error("Unknown hash algorithm \"" + md + "\"");
			} else _md = md;
			if (key === null) key = _key;
			else {
				if (typeof key === "string") key = forge.util.createBuffer(key);
				else if (forge.util.isArray(key)) {
					var tmp = key;
					key = forge.util.createBuffer();
					for (var i = 0; i < tmp.length; ++i) key.putByte(tmp[i]);
				}
				var keylen = key.length();
				if (keylen > _md.blockLength) {
					_md.start();
					_md.update(key.bytes());
					key = _md.digest();
				}
				_ipadding = forge.util.createBuffer();
				_opadding = forge.util.createBuffer();
				keylen = key.length();
				for (var i = 0; i < keylen; ++i) {
					var tmp = key.at(i);
					_ipadding.putByte(54 ^ tmp);
					_opadding.putByte(92 ^ tmp);
				}
				if (keylen < _md.blockLength) {
					var tmp = _md.blockLength - keylen;
					for (var i = 0; i < tmp; ++i) {
						_ipadding.putByte(54);
						_opadding.putByte(92);
					}
				}
				_key = key;
				_ipadding = _ipadding.bytes();
				_opadding = _opadding.bytes();
			}
			_md.start();
			_md.update(_ipadding);
		};
		/**
		* Updates the HMAC with the given message bytes.
		*
		* @param bytes the bytes to update with.
		*/
		ctx.update = function(bytes) {
			_md.update(bytes);
		};
		/**
		* Produces the Message Authentication Code (MAC).
		*
		* @return a byte buffer containing the digest value.
		*/
		ctx.getMac = function() {
			var inner = _md.digest().bytes();
			_md.start();
			_md.update(_opadding);
			_md.update(inner);
			return _md.digest();
		};
		ctx.digest = ctx.getMac;
		return ctx;
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/md5.js
var require_md5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var md5 = module.exports = forge.md5 = forge.md5 || {};
	forge.md.md5 = forge.md.algorithms.md5 = md5;
	/**
	* Creates an MD5 message digest object.
	*
	* @return a message digest object.
	*/
	md5.create = function() {
		if (!_initialized) _init();
		var _state = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(16);
		var md = {
			algorithm: "md5",
			blockLength: 64,
			digestLength: 16,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 8
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength64 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_state = {
				h0: 1732584193,
				h1: 4023233417,
				h2: 2562383102,
				h3: 271733878
			};
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_state, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var bits, carry = 0;
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				bits = md.fullMessageLength[i] * 8 + carry;
				carry = bits / 4294967296 >>> 0;
				finalBlock.putInt32Le(bits >>> 0);
			}
			var s2 = {
				h0: _state.h0,
				h1: _state.h1,
				h2: _state.h2,
				h3: _state.h3
			};
			_update(s2, _w, finalBlock);
			var rval = forge.util.createBuffer();
			rval.putInt32Le(s2.h0);
			rval.putInt32Le(s2.h1);
			rval.putInt32Le(s2.h2);
			rval.putInt32Le(s2.h3);
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _g = null;
	var _r = null;
	var _k = null;
	var _initialized = false;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 64);
		_g = [
			0,
			1,
			2,
			3,
			4,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			12,
			13,
			14,
			15,
			1,
			6,
			11,
			0,
			5,
			10,
			15,
			4,
			9,
			14,
			3,
			8,
			13,
			2,
			7,
			12,
			5,
			8,
			11,
			14,
			1,
			4,
			7,
			10,
			13,
			0,
			3,
			6,
			9,
			12,
			15,
			2,
			0,
			7,
			14,
			5,
			12,
			3,
			10,
			1,
			8,
			15,
			6,
			13,
			4,
			11,
			2,
			9
		];
		_r = [
			7,
			12,
			17,
			22,
			7,
			12,
			17,
			22,
			7,
			12,
			17,
			22,
			7,
			12,
			17,
			22,
			5,
			9,
			14,
			20,
			5,
			9,
			14,
			20,
			5,
			9,
			14,
			20,
			5,
			9,
			14,
			20,
			4,
			11,
			16,
			23,
			4,
			11,
			16,
			23,
			4,
			11,
			16,
			23,
			4,
			11,
			16,
			23,
			6,
			10,
			15,
			21,
			6,
			10,
			15,
			21,
			6,
			10,
			15,
			21,
			6,
			10,
			15,
			21
		];
		_k = new Array(64);
		for (var i = 0; i < 64; ++i) _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
		_initialized = true;
	}
	/**
	* Updates an MD5 state with the given byte buffer.
	*
	* @param s the MD5 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t, a, b, c, d, f, r, i;
		var len = bytes.length();
		while (len >= 64) {
			a = s.h0;
			b = s.h1;
			c = s.h2;
			d = s.h3;
			for (i = 0; i < 16; ++i) {
				w[i] = bytes.getInt32Le();
				f = d ^ b & (c ^ d);
				t = a + f + _k[i] + w[i];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			for (; i < 32; ++i) {
				f = c ^ d & (b ^ c);
				t = a + f + _k[i] + w[_g[i]];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			for (; i < 48; ++i) {
				f = b ^ c ^ d;
				t = a + f + _k[i] + w[_g[i]];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			for (; i < 64; ++i) {
				f = c ^ (b | ~d);
				t = a + f + _k[i] + w[_g[i]];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			s.h0 = s.h0 + a | 0;
			s.h1 = s.h1 + b | 0;
			s.h2 = s.h2 + c | 0;
			s.h3 = s.h3 + d | 0;
			len -= 64;
		}
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pem.js
var require_pem = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
	*
	* See: RFC 1421.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2013-2014 Digital Bazaar, Inc.
	*
	* A Forge PEM object has the following fields:
	*
	* type: identifies the type of message (eg: "RSA PRIVATE KEY").
	*
	* procType: identifies the type of processing performed on the message,
	*   it has two subfields: version and type, eg: 4,ENCRYPTED.
	*
	* contentDomain: identifies the type of content in the message, typically
	*   only uses the value: "RFC822".
	*
	* dekInfo: identifies the message encryption algorithm and mode and includes
	*   any parameters for the algorithm, it has two subfields: algorithm and
	*   parameters, eg: DES-CBC,F8143EDE5960C597.
	*
	* headers: contains all other PEM encapsulated headers -- where order is
	*   significant (for pairing data like recipient ID + key info).
	*
	* body: the binary-encoded body.
	*/
	var forge = require_forge();
	require_util();
	var pem = module.exports = forge.pem = forge.pem || {};
	/**
	* Encodes (serializes) the given PEM object.
	*
	* @param msg the PEM message object to encode.
	* @param options the options to use:
	*          maxline the maximum characters per line for the body, (default: 64).
	*
	* @return the PEM-formatted string.
	*/
	pem.encode = function(msg, options) {
		options = options || {};
		var rval = "-----BEGIN " + msg.type + "-----\r\n";
		var header;
		if (msg.procType) {
			header = {
				name: "Proc-Type",
				values: [String(msg.procType.version), msg.procType.type]
			};
			rval += foldHeader(header);
		}
		if (msg.contentDomain) {
			header = {
				name: "Content-Domain",
				values: [msg.contentDomain]
			};
			rval += foldHeader(header);
		}
		if (msg.dekInfo) {
			header = {
				name: "DEK-Info",
				values: [msg.dekInfo.algorithm]
			};
			if (msg.dekInfo.parameters) header.values.push(msg.dekInfo.parameters);
			rval += foldHeader(header);
		}
		if (msg.headers) for (var i = 0; i < msg.headers.length; ++i) rval += foldHeader(msg.headers[i]);
		if (msg.procType) rval += "\r\n";
		rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
		rval += "-----END " + msg.type + "-----\r\n";
		return rval;
	};
	/**
	* Decodes (deserializes) all PEM messages found in the given string.
	*
	* @param str the PEM-formatted string to decode.
	*
	* @return the PEM message objects in an array.
	*/
	pem.decode = function(str) {
		var rval = [];
		var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
		var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
		var rCRLF = /\r?\n/;
		var match;
		while (true) {
			match = rMessage.exec(str);
			if (!match) break;
			var type = match[1];
			if (type === "NEW CERTIFICATE REQUEST") type = "CERTIFICATE REQUEST";
			var msg = {
				type,
				procType: null,
				contentDomain: null,
				dekInfo: null,
				headers: [],
				body: forge.util.decode64(match[3])
			};
			rval.push(msg);
			if (!match[2]) continue;
			var lines = match[2].split(rCRLF);
			var li = 0;
			while (match && li < lines.length) {
				var line = lines[li].replace(/\s+$/, "");
				for (var nl = li + 1; nl < lines.length; ++nl) {
					var next = lines[nl];
					if (!/\s/.test(next[0])) break;
					line += next;
					li = nl;
				}
				match = line.match(rHeader);
				if (match) {
					var header = {
						name: match[1],
						values: []
					};
					var values = match[2].split(",");
					for (var vi = 0; vi < values.length; ++vi) header.values.push(ltrim(values[vi]));
					if (!msg.procType) {
						if (header.name !== "Proc-Type") throw new Error("Invalid PEM formatted message. The first encapsulated header must be \"Proc-Type\".");
						else if (header.values.length !== 2) throw new Error("Invalid PEM formatted message. The \"Proc-Type\" header must have two subfields.");
						msg.procType = {
							version: values[0],
							type: values[1]
						};
					} else if (!msg.contentDomain && header.name === "Content-Domain") msg.contentDomain = values[0] || "";
					else if (!msg.dekInfo && header.name === "DEK-Info") {
						if (header.values.length === 0) throw new Error("Invalid PEM formatted message. The \"DEK-Info\" header must have at least one subfield.");
						msg.dekInfo = {
							algorithm: values[0],
							parameters: values[1] || null
						};
					} else msg.headers.push(header);
				}
				++li;
			}
			if (msg.procType === "ENCRYPTED" && !msg.dekInfo) throw new Error("Invalid PEM formatted message. The \"DEK-Info\" header must be present if \"Proc-Type\" is \"ENCRYPTED\".");
		}
		if (rval.length === 0) throw new Error("Invalid PEM formatted message.");
		return rval;
	};
	function foldHeader(header) {
		var rval = header.name + ": ";
		var values = [];
		var insertSpace = function(match, $1) {
			return " " + $1;
		};
		for (var i = 0; i < header.values.length; ++i) values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
		rval += values.join(",") + "\r\n";
		var length = 0;
		var candidate = -1;
		for (var i = 0; i < rval.length; ++i, ++length) if (length > 65 && candidate !== -1) {
			var insert = rval[candidate];
			if (insert === ",") {
				++candidate;
				rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
			} else rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
			length = i - candidate - 1;
			candidate = -1;
			++i;
		} else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") candidate = i;
		return rval;
	}
	function ltrim(str) {
		return str.replace(/^\s+/, "");
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/des.js
var require_des = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* DES (Data Encryption Standard) implementation.
	*
	* This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
	* It is based on the BSD-licensed implementation by Paul Tero:
	*
	* Paul Tero, July 2001
	* http://www.tero.co.uk/des/
	*
	* Optimised for performance with large blocks by
	* Michael Hayworth, November 2001
	* http://www.netdealing.com
	*
	* THIS SOFTWARE IS PROVIDED "AS IS" AND
	* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	* ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
	* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
	* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	* SUCH DAMAGE.
	*
	* @author Stefan Siegl
	* @author Dave Longley
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	* Copyright (c) 2012-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_cipher();
	require_cipherModes();
	require_util();
	module.exports = forge.des = forge.des || {};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('DES-<mode>', key);
	* cipher.start({iv: iv});
	*
	* Creates an DES cipher object to encrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as binary-encoded strings of bytes or
	* byte buffers.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC' if IV is
	*          given, 'ECB' if null).
	*
	* @return the cipher.
	*/
	forge.des.startEncrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: false,
			mode: mode || (iv === null ? "ECB" : "CBC")
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('DES-<mode>', key);
	*
	* Creates an DES cipher object to encrypt data using the given symmetric key.
	*
	* The key may be given as a binary-encoded string of bytes or a byte buffer.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.des.createEncryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: false,
			mode
		});
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('DES-<mode>', key);
	* decipher.start({iv: iv});
	*
	* Creates an DES cipher object to decrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as binary-encoded strings of bytes or
	* byte buffers.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC' if IV is
	*          given, 'ECB' if null).
	*
	* @return the cipher.
	*/
	forge.des.startDecrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: true,
			mode: mode || (iv === null ? "ECB" : "CBC")
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('DES-<mode>', key);
	*
	* Creates an DES cipher object to decrypt data using the given symmetric key.
	*
	* The key may be given as a binary-encoded string of bytes or a byte buffer.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.des.createDecryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: true,
			mode
		});
	};
	/**
	* Creates a new DES cipher algorithm object.
	*
	* @param name the name of the algorithm.
	* @param mode the mode factory function.
	*
	* @return the DES algorithm object.
	*/
	forge.des.Algorithm = function(name$1, mode) {
		var self$1 = this;
		self$1.name = name$1;
		self$1.mode = new mode({
			blockSize: 8,
			cipher: {
				encrypt: function(inBlock, outBlock) {
					return _updateBlock(self$1._keys, inBlock, outBlock, false);
				},
				decrypt: function(inBlock, outBlock) {
					return _updateBlock(self$1._keys, inBlock, outBlock, true);
				}
			}
		});
		self$1._init = false;
	};
	/**
	* Initializes this DES algorithm by expanding its key.
	*
	* @param options the options to use.
	*          key the key to use with this algorithm.
	*          decrypt true if the algorithm should be initialized for decryption,
	*            false for encryption.
	*/
	forge.des.Algorithm.prototype.initialize = function(options) {
		if (this._init) return;
		var key = forge.util.createBuffer(options.key);
		if (this.name.indexOf("3DES") === 0) {
			if (key.length() !== 24) throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
		}
		this._keys = _createKeys(key);
		this._init = true;
	};
	/** Register DES algorithms **/
	registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
	registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
	registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
	registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
	registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
	registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
	registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
	registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
	registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
	registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
	function registerAlgorithm(name$1, mode) {
		var factory = function() {
			return new forge.des.Algorithm(name$1, mode);
		};
		forge.cipher.registerAlgorithm(name$1, factory);
	}
	/** DES implementation **/
	var spfunction1 = [
		16843776,
		0,
		65536,
		16843780,
		16842756,
		66564,
		4,
		65536,
		1024,
		16843776,
		16843780,
		1024,
		16778244,
		16842756,
		16777216,
		4,
		1028,
		16778240,
		16778240,
		66560,
		66560,
		16842752,
		16842752,
		16778244,
		65540,
		16777220,
		16777220,
		65540,
		0,
		1028,
		66564,
		16777216,
		65536,
		16843780,
		4,
		16842752,
		16843776,
		16777216,
		16777216,
		1024,
		16842756,
		65536,
		66560,
		16777220,
		1024,
		4,
		16778244,
		66564,
		16843780,
		65540,
		16842752,
		16778244,
		16777220,
		1028,
		66564,
		16843776,
		1028,
		16778240,
		16778240,
		0,
		65540,
		66560,
		0,
		16842756
	];
	var spfunction2 = [
		-2146402272,
		-2147450880,
		32768,
		1081376,
		1048576,
		32,
		-2146435040,
		-2147450848,
		-2147483616,
		-2146402272,
		-2146402304,
		-2147483648,
		-2147450880,
		1048576,
		32,
		-2146435040,
		1081344,
		1048608,
		-2147450848,
		0,
		-2147483648,
		32768,
		1081376,
		-2146435072,
		1048608,
		-2147483616,
		0,
		1081344,
		32800,
		-2146402304,
		-2146435072,
		32800,
		0,
		1081376,
		-2146435040,
		1048576,
		-2147450848,
		-2146435072,
		-2146402304,
		32768,
		-2146435072,
		-2147450880,
		32,
		-2146402272,
		1081376,
		32,
		32768,
		-2147483648,
		32800,
		-2146402304,
		1048576,
		-2147483616,
		1048608,
		-2147450848,
		-2147483616,
		1048608,
		1081344,
		0,
		-2147450880,
		32800,
		-2147483648,
		-2146435040,
		-2146402272,
		1081344
	];
	var spfunction3 = [
		520,
		134349312,
		0,
		134348808,
		134218240,
		0,
		131592,
		134218240,
		131080,
		134217736,
		134217736,
		131072,
		134349320,
		131080,
		134348800,
		520,
		134217728,
		8,
		134349312,
		512,
		131584,
		134348800,
		134348808,
		131592,
		134218248,
		131584,
		131072,
		134218248,
		8,
		134349320,
		512,
		134217728,
		134349312,
		134217728,
		131080,
		520,
		131072,
		134349312,
		134218240,
		0,
		512,
		131080,
		134349320,
		134218240,
		134217736,
		512,
		0,
		134348808,
		134218248,
		131072,
		134217728,
		134349320,
		8,
		131592,
		131584,
		134217736,
		134348800,
		134218248,
		520,
		134348800,
		131592,
		8,
		134348808,
		131584
	];
	var spfunction4 = [
		8396801,
		8321,
		8321,
		128,
		8396928,
		8388737,
		8388609,
		8193,
		0,
		8396800,
		8396800,
		8396929,
		129,
		0,
		8388736,
		8388609,
		1,
		8192,
		8388608,
		8396801,
		128,
		8388608,
		8193,
		8320,
		8388737,
		1,
		8320,
		8388736,
		8192,
		8396928,
		8396929,
		129,
		8388736,
		8388609,
		8396800,
		8396929,
		129,
		0,
		0,
		8396800,
		8320,
		8388736,
		8388737,
		1,
		8396801,
		8321,
		8321,
		128,
		8396929,
		129,
		1,
		8192,
		8388609,
		8193,
		8396928,
		8388737,
		8193,
		8320,
		8388608,
		8396801,
		128,
		8388608,
		8192,
		8396928
	];
	var spfunction5 = [
		256,
		34078976,
		34078720,
		1107296512,
		524288,
		256,
		1073741824,
		34078720,
		1074266368,
		524288,
		33554688,
		1074266368,
		1107296512,
		1107820544,
		524544,
		1073741824,
		33554432,
		1074266112,
		1074266112,
		0,
		1073742080,
		1107820800,
		1107820800,
		33554688,
		1107820544,
		1073742080,
		0,
		1107296256,
		34078976,
		33554432,
		1107296256,
		524544,
		524288,
		1107296512,
		256,
		33554432,
		1073741824,
		34078720,
		1107296512,
		1074266368,
		33554688,
		1073741824,
		1107820544,
		34078976,
		1074266368,
		256,
		33554432,
		1107820544,
		1107820800,
		524544,
		1107296256,
		1107820800,
		34078720,
		0,
		1074266112,
		1107296256,
		524544,
		33554688,
		1073742080,
		524288,
		0,
		1074266112,
		34078976,
		1073742080
	];
	var spfunction6 = [
		536870928,
		541065216,
		16384,
		541081616,
		541065216,
		16,
		541081616,
		4194304,
		536887296,
		4210704,
		4194304,
		536870928,
		4194320,
		536887296,
		536870912,
		16400,
		0,
		4194320,
		536887312,
		16384,
		4210688,
		536887312,
		16,
		541065232,
		541065232,
		0,
		4210704,
		541081600,
		16400,
		4210688,
		541081600,
		536870912,
		536887296,
		16,
		541065232,
		4210688,
		541081616,
		4194304,
		16400,
		536870928,
		4194304,
		536887296,
		536870912,
		16400,
		536870928,
		541081616,
		4210688,
		541065216,
		4210704,
		541081600,
		0,
		541065232,
		16,
		16384,
		541065216,
		4210704,
		16384,
		4194320,
		536887312,
		0,
		541081600,
		536870912,
		4194320,
		536887312
	];
	var spfunction7 = [
		2097152,
		69206018,
		67110914,
		0,
		2048,
		67110914,
		2099202,
		69208064,
		69208066,
		2097152,
		0,
		67108866,
		2,
		67108864,
		69206018,
		2050,
		67110912,
		2099202,
		2097154,
		67110912,
		67108866,
		69206016,
		69208064,
		2097154,
		69206016,
		2048,
		2050,
		69208066,
		2099200,
		2,
		67108864,
		2099200,
		67108864,
		2099200,
		2097152,
		67110914,
		67110914,
		69206018,
		69206018,
		2,
		2097154,
		67108864,
		67110912,
		2097152,
		69208064,
		2050,
		2099202,
		69208064,
		2050,
		67108866,
		69208066,
		69206016,
		2099200,
		0,
		2,
		69208066,
		0,
		2099202,
		69206016,
		2048,
		67108866,
		67110912,
		2048,
		2097154
	];
	var spfunction8 = [
		268439616,
		4096,
		262144,
		268701760,
		268435456,
		268439616,
		64,
		268435456,
		262208,
		268697600,
		268701760,
		266240,
		268701696,
		266304,
		4096,
		64,
		268697600,
		268435520,
		268439552,
		4160,
		266240,
		262208,
		268697664,
		268701696,
		4160,
		0,
		0,
		268697664,
		268435520,
		268439552,
		266304,
		262144,
		266304,
		262144,
		268701696,
		4096,
		64,
		268697664,
		4096,
		266304,
		268439552,
		64,
		268435520,
		268697600,
		268697664,
		268435456,
		262144,
		268439616,
		0,
		268701760,
		262208,
		268435520,
		268697600,
		268439552,
		268439616,
		0,
		268701760,
		266240,
		266240,
		4160,
		4160,
		262208,
		268435456,
		268701696
	];
	/**
	* Create necessary sub keys.
	*
	* @param key the 64-bit or 192-bit key.
	*
	* @return the expanded keys.
	*/
	function _createKeys(key) {
		var pc2bytes0 = [
			0,
			4,
			536870912,
			536870916,
			65536,
			65540,
			536936448,
			536936452,
			512,
			516,
			536871424,
			536871428,
			66048,
			66052,
			536936960,
			536936964
		], pc2bytes1 = [
			0,
			1,
			1048576,
			1048577,
			67108864,
			67108865,
			68157440,
			68157441,
			256,
			257,
			1048832,
			1048833,
			67109120,
			67109121,
			68157696,
			68157697
		], pc2bytes2 = [
			0,
			8,
			2048,
			2056,
			16777216,
			16777224,
			16779264,
			16779272,
			0,
			8,
			2048,
			2056,
			16777216,
			16777224,
			16779264,
			16779272
		], pc2bytes3 = [
			0,
			2097152,
			134217728,
			136314880,
			8192,
			2105344,
			134225920,
			136323072,
			131072,
			2228224,
			134348800,
			136445952,
			139264,
			2236416,
			134356992,
			136454144
		], pc2bytes4 = [
			0,
			262144,
			16,
			262160,
			0,
			262144,
			16,
			262160,
			4096,
			266240,
			4112,
			266256,
			4096,
			266240,
			4112,
			266256
		], pc2bytes5 = [
			0,
			1024,
			32,
			1056,
			0,
			1024,
			32,
			1056,
			33554432,
			33555456,
			33554464,
			33555488,
			33554432,
			33555456,
			33554464,
			33555488
		], pc2bytes6 = [
			0,
			268435456,
			524288,
			268959744,
			2,
			268435458,
			524290,
			268959746,
			0,
			268435456,
			524288,
			268959744,
			2,
			268435458,
			524290,
			268959746
		], pc2bytes7 = [
			0,
			65536,
			2048,
			67584,
			536870912,
			536936448,
			536872960,
			536938496,
			131072,
			196608,
			133120,
			198656,
			537001984,
			537067520,
			537004032,
			537069568
		], pc2bytes8 = [
			0,
			262144,
			0,
			262144,
			2,
			262146,
			2,
			262146,
			33554432,
			33816576,
			33554432,
			33816576,
			33554434,
			33816578,
			33554434,
			33816578
		], pc2bytes9 = [
			0,
			268435456,
			8,
			268435464,
			0,
			268435456,
			8,
			268435464,
			1024,
			268436480,
			1032,
			268436488,
			1024,
			268436480,
			1032,
			268436488
		], pc2bytes10 = [
			0,
			32,
			0,
			32,
			1048576,
			1048608,
			1048576,
			1048608,
			8192,
			8224,
			8192,
			8224,
			1056768,
			1056800,
			1056768,
			1056800
		], pc2bytes11 = [
			0,
			16777216,
			512,
			16777728,
			2097152,
			18874368,
			2097664,
			18874880,
			67108864,
			83886080,
			67109376,
			83886592,
			69206016,
			85983232,
			69206528,
			85983744
		], pc2bytes12 = [
			0,
			4096,
			134217728,
			134221824,
			524288,
			528384,
			134742016,
			134746112,
			16,
			4112,
			134217744,
			134221840,
			524304,
			528400,
			134742032,
			134746128
		], pc2bytes13 = [
			0,
			4,
			256,
			260,
			0,
			4,
			256,
			260,
			1,
			5,
			257,
			261,
			1,
			5,
			257,
			261
		];
		var iterations = key.length() > 8 ? 3 : 1;
		var keys = [];
		var shifts = [
			0,
			0,
			1,
			1,
			1,
			1,
			1,
			1,
			0,
			1,
			1,
			1,
			1,
			1,
			1,
			0
		];
		var n = 0, tmp;
		for (var j = 0; j < iterations; j++) {
			var left = key.getInt32();
			var right = key.getInt32();
			tmp = (left >>> 4 ^ right) & 252645135;
			right ^= tmp;
			left ^= tmp << 4;
			tmp = (right >>> -16 ^ left) & 65535;
			left ^= tmp;
			right ^= tmp << -16;
			tmp = (left >>> 2 ^ right) & 858993459;
			right ^= tmp;
			left ^= tmp << 2;
			tmp = (right >>> -16 ^ left) & 65535;
			left ^= tmp;
			right ^= tmp << -16;
			tmp = (left >>> 1 ^ right) & 1431655765;
			right ^= tmp;
			left ^= tmp << 1;
			tmp = (right >>> 8 ^ left) & 16711935;
			left ^= tmp;
			right ^= tmp << 8;
			tmp = (left >>> 1 ^ right) & 1431655765;
			right ^= tmp;
			left ^= tmp << 1;
			tmp = left << 8 | right >>> 20 & 240;
			left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
			right = tmp;
			for (var i = 0; i < shifts.length; ++i) {
				if (shifts[i]) {
					left = left << 2 | left >>> 26;
					right = right << 2 | right >>> 26;
				} else {
					left = left << 1 | left >>> 27;
					right = right << 1 | right >>> 27;
				}
				left &= -15;
				right &= -15;
				var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
				var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
				tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
				keys[n++] = lefttmp ^ tmp;
				keys[n++] = righttmp ^ tmp << 16;
			}
		}
		return keys;
	}
	/**
	* Updates a single block (1 byte) using DES. The update will either
	* encrypt or decrypt the block.
	*
	* @param keys the expanded keys.
	* @param input the input block (an array of 32-bit words).
	* @param output the updated output block.
	* @param decrypt true to decrypt the block, false to encrypt it.
	*/
	function _updateBlock(keys, input, output, decrypt) {
		var iterations = keys.length === 32 ? 3 : 9;
		var looping;
		if (iterations === 3) looping = decrypt ? [
			30,
			-2,
			-2
		] : [
			0,
			32,
			2
		];
		else looping = decrypt ? [
			94,
			62,
			-2,
			32,
			64,
			2,
			30,
			-2,
			-2
		] : [
			0,
			32,
			2,
			62,
			30,
			-2,
			64,
			96,
			2
		];
		var tmp;
		var left = input[0];
		var right = input[1];
		tmp = (left >>> 4 ^ right) & 252645135;
		right ^= tmp;
		left ^= tmp << 4;
		tmp = (left >>> 16 ^ right) & 65535;
		right ^= tmp;
		left ^= tmp << 16;
		tmp = (right >>> 2 ^ left) & 858993459;
		left ^= tmp;
		right ^= tmp << 2;
		tmp = (right >>> 8 ^ left) & 16711935;
		left ^= tmp;
		right ^= tmp << 8;
		tmp = (left >>> 1 ^ right) & 1431655765;
		right ^= tmp;
		left ^= tmp << 1;
		left = left << 1 | left >>> 31;
		right = right << 1 | right >>> 31;
		for (var j = 0; j < iterations; j += 3) {
			var endloop = looping[j + 1];
			var loopinc = looping[j + 2];
			for (var i = looping[j]; i != endloop; i += loopinc) {
				var right1 = right ^ keys[i];
				var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
				tmp = left;
				left = right;
				right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
			}
			tmp = left;
			left = right;
			right = tmp;
		}
		left = left >>> 1 | left << 31;
		right = right >>> 1 | right << 31;
		tmp = (left >>> 1 ^ right) & 1431655765;
		right ^= tmp;
		left ^= tmp << 1;
		tmp = (right >>> 8 ^ left) & 16711935;
		left ^= tmp;
		right ^= tmp << 8;
		tmp = (right >>> 2 ^ left) & 858993459;
		left ^= tmp;
		right ^= tmp << 2;
		tmp = (left >>> 16 ^ right) & 65535;
		right ^= tmp;
		left ^= tmp << 16;
		tmp = (left >>> 4 ^ right) & 252645135;
		right ^= tmp;
		left ^= tmp << 4;
		output[0] = left;
		output[1] = right;
	}
	/**
	* Deprecated. Instead, use:
	*
	* forge.cipher.createCipher('DES-<mode>', key);
	* forge.cipher.createDecipher('DES-<mode>', key);
	*
	* Creates a deprecated DES cipher object. This object's mode will default to
	* CBC (cipher-block-chaining).
	*
	* The key may be given as a binary-encoded string of bytes or a byte buffer.
	*
	* @param options the options to use.
	*          key the symmetric key to use (64 or 192 bits).
	*          output the buffer to write to.
	*          decrypt true for decryption, false for encryption.
	*          mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	function _createCipher(options) {
		options = options || {};
		var algorithm = "DES-" + (options.mode || "CBC").toUpperCase();
		var cipher;
		if (options.decrypt) cipher = forge.cipher.createDecipher(algorithm, options.key);
		else cipher = forge.cipher.createCipher(algorithm, options.key);
		var start = cipher.start;
		cipher.start = function(iv, options$1) {
			var output = null;
			if (options$1 instanceof forge.util.ByteBuffer) {
				output = options$1;
				options$1 = {};
			}
			options$1 = options$1 || {};
			options$1.output = output;
			options$1.iv = iv;
			start.call(cipher, options$1);
		};
		return cipher;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Password-Based Key-Derivation Function #2 implementation.
	*
	* See RFC 2898 for details.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_hmac();
	require_md();
	require_util();
	var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
	var crypto;
	if (forge.util.isNodejs && !forge.options.usePureJavaScript) crypto = __require("crypto");
	/**
	* Derives a key from a password.
	*
	* @param p the password as a binary-encoded string of bytes.
	* @param s the salt as a binary-encoded string of bytes.
	* @param c the iteration count, a positive integer.
	* @param dkLen the intended length, in bytes, of the derived key,
	*          (max: 2^32 - 1) * hash length of the PRF.
	* @param [md] the message digest (or algorithm identifier as a string) to use
	*          in the PRF, defaults to SHA-1.
	* @param [callback(err, key)] presence triggers asynchronous version, called
	*          once the operation completes.
	*
	* @return the derived key, as a binary-encoded string of bytes, for the
	*           synchronous version (if no callback is specified).
	*/
	module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback$1) {
		if (typeof md === "function") {
			callback$1 = md;
			md = null;
		}
		if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== "object") && (crypto.pbkdf2Sync.length > 4 || !md || md === "sha1")) {
			if (typeof md !== "string") md = "sha1";
			p = Buffer.from(p, "binary");
			s = Buffer.from(s, "binary");
			if (!callback$1) {
				if (crypto.pbkdf2Sync.length === 4) return crypto.pbkdf2Sync(p, s, c, dkLen).toString("binary");
				return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
			}
			if (crypto.pbkdf2Sync.length === 4) return crypto.pbkdf2(p, s, c, dkLen, function(err$1, key) {
				if (err$1) return callback$1(err$1);
				callback$1(null, key.toString("binary"));
			});
			return crypto.pbkdf2(p, s, c, dkLen, md, function(err$1, key) {
				if (err$1) return callback$1(err$1);
				callback$1(null, key.toString("binary"));
			});
		}
		if (typeof md === "undefined" || md === null) md = "sha1";
		if (typeof md === "string") {
			if (!(md in forge.md.algorithms)) throw new Error("Unknown hash algorithm: " + md);
			md = forge.md[md].create();
		}
		var hLen = md.digestLength;
		if (dkLen > 4294967295 * hLen) {
			var err = /* @__PURE__ */ new Error("Derived key is too long.");
			if (callback$1) return callback$1(err);
			throw err;
		}
		var len = Math.ceil(dkLen / hLen);
		var r = dkLen - (len - 1) * hLen;
		var prf = forge.hmac.create();
		prf.start(md, p);
		var dk = "";
		var xor$1, u_c, u_c1;
		if (!callback$1) {
			for (var i = 1; i <= len; ++i) {
				prf.start(null, null);
				prf.update(s);
				prf.update(forge.util.int32ToBytes(i));
				xor$1 = u_c1 = prf.digest().getBytes();
				for (var j = 2; j <= c; ++j) {
					prf.start(null, null);
					prf.update(u_c1);
					u_c = prf.digest().getBytes();
					xor$1 = forge.util.xorBytes(xor$1, u_c, hLen);
					u_c1 = u_c;
				}
				dk += i < len ? xor$1 : xor$1.substr(0, r);
			}
			return dk;
		}
		var i = 1, j;
		function outer() {
			if (i > len) return callback$1(null, dk);
			prf.start(null, null);
			prf.update(s);
			prf.update(forge.util.int32ToBytes(i));
			xor$1 = u_c1 = prf.digest().getBytes();
			j = 2;
			inner();
		}
		function inner() {
			if (j <= c) {
				prf.start(null, null);
				prf.update(u_c1);
				u_c = prf.digest().getBytes();
				xor$1 = forge.util.xorBytes(xor$1, u_c, hLen);
				u_c1 = u_c;
				++j;
				return forge.util.setImmediate(inner);
			}
			dk += i < len ? xor$1 : xor$1.substr(0, r);
			++i;
			outer();
		}
		outer();
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/sha256.js
var require_sha256 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
	*
	* See FIPS 180-2 for details.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2015 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
	forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
	/**
	* Creates a SHA-256 message digest object.
	*
	* @return a message digest object.
	*/
	sha256.create = function() {
		if (!_initialized) _init();
		var _state = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(64);
		var md = {
			algorithm: "sha256",
			blockLength: 64,
			digestLength: 32,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 8
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength64 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_state = {
				h0: 1779033703,
				h1: 3144134277,
				h2: 1013904242,
				h3: 2773480762,
				h4: 1359893119,
				h5: 2600822924,
				h6: 528734635,
				h7: 1541459225
			};
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_state, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var next, carry;
			var bits = md.fullMessageLength[0] * 8;
			for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
				next = md.fullMessageLength[i + 1] * 8;
				carry = next / 4294967296 >>> 0;
				bits += carry;
				finalBlock.putInt32(bits >>> 0);
				bits = next >>> 0;
			}
			finalBlock.putInt32(bits);
			var s2 = {
				h0: _state.h0,
				h1: _state.h1,
				h2: _state.h2,
				h3: _state.h3,
				h4: _state.h4,
				h5: _state.h5,
				h6: _state.h6,
				h7: _state.h7
			};
			_update(s2, _w, finalBlock);
			var rval = forge.util.createBuffer();
			rval.putInt32(s2.h0);
			rval.putInt32(s2.h1);
			rval.putInt32(s2.h2);
			rval.putInt32(s2.h3);
			rval.putInt32(s2.h4);
			rval.putInt32(s2.h5);
			rval.putInt32(s2.h6);
			rval.putInt32(s2.h7);
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _initialized = false;
	var _k = null;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 64);
		_k = [
			1116352408,
			1899447441,
			3049323471,
			3921009573,
			961987163,
			1508970993,
			2453635748,
			2870763221,
			3624381080,
			310598401,
			607225278,
			1426881987,
			1925078388,
			2162078206,
			2614888103,
			3248222580,
			3835390401,
			4022224774,
			264347078,
			604807628,
			770255983,
			1249150122,
			1555081692,
			1996064986,
			2554220882,
			2821834349,
			2952996808,
			3210313671,
			3336571891,
			3584528711,
			113926993,
			338241895,
			666307205,
			773529912,
			1294757372,
			1396182291,
			1695183700,
			1986661051,
			2177026350,
			2456956037,
			2730485921,
			2820302411,
			3259730800,
			3345764771,
			3516065817,
			3600352804,
			4094571909,
			275423344,
			430227734,
			506948616,
			659060556,
			883997877,
			958139571,
			1322822218,
			1537002063,
			1747873779,
			1955562222,
			2024104815,
			2227730452,
			2361852424,
			2428436474,
			2756734187,
			3204031479,
			3329325298
		];
		_initialized = true;
	}
	/**
	* Updates a SHA-256 state with the given byte buffer.
	*
	* @param s the SHA-256 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
		var len = bytes.length();
		while (len >= 64) {
			for (i = 0; i < 16; ++i) w[i] = bytes.getInt32();
			for (; i < 64; ++i) {
				t1 = w[i - 2];
				t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
				t2 = w[i - 15];
				t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
				w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
			}
			a = s.h0;
			b = s.h1;
			c = s.h2;
			d = s.h3;
			e = s.h4;
			f = s.h5;
			g = s.h6;
			h = s.h7;
			for (i = 0; i < 64; ++i) {
				s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
				ch = g ^ e & (f ^ g);
				s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
				maj = a & b | c & (a ^ b);
				t1 = h + s1 + ch + _k[i] + w[i];
				t2 = s0 + maj;
				h = g;
				g = f;
				f = e;
				e = d + t1 >>> 0;
				d = c;
				c = b;
				b = a;
				a = t1 + t2 >>> 0;
			}
			s.h0 = s.h0 + a | 0;
			s.h1 = s.h1 + b | 0;
			s.h2 = s.h2 + c | 0;
			s.h3 = s.h3 + d | 0;
			s.h4 = s.h4 + e | 0;
			s.h5 = s.h5 + f | 0;
			s.h6 = s.h6 + g | 0;
			s.h7 = s.h7 + h | 0;
			len -= 64;
		}
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/prng.js
var require_prng = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* A javascript implementation of a cryptographically-secure
	* Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
	* here though the use of SHA-256 is not enforced; when generating an
	* a PRNG context, the hashing algorithm and block cipher used for
	* the generator are specified via a plugin.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	var _crypto = null;
	if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) _crypto = __require("crypto");
	var prng = module.exports = forge.prng = forge.prng || {};
	/**
	* Creates a new PRNG context.
	*
	* A PRNG plugin must be passed in that will provide:
	*
	* 1. A function that initializes the key and seed of a PRNG context. It
	*   will be given a 16 byte key and a 16 byte seed. Any key expansion
	*   or transformation of the seed from a byte string into an array of
	*   integers (or similar) should be performed.
	* 2. The cryptographic function used by the generator. It takes a key and
	*   a seed.
	* 3. A seed increment function. It takes the seed and returns seed + 1.
	* 4. An api to create a message digest.
	*
	* For an example, see random.js.
	*
	* @param plugin the PRNG plugin to use.
	*/
	prng.create = function(plugin) {
		var ctx = {
			plugin,
			key: null,
			seed: null,
			time: null,
			reseeds: 0,
			generated: 0,
			keyBytes: ""
		};
		var md = plugin.md;
		var pools = new Array(32);
		for (var i = 0; i < 32; ++i) pools[i] = md.create();
		ctx.pools = pools;
		ctx.pool = 0;
		/**
		* Generates random bytes. The bytes may be generated synchronously or
		* asynchronously. Web workers must use the asynchronous interface or
		* else the behavior is undefined.
		*
		* @param count the number of random bytes to generate.
		* @param [callback(err, bytes)] called once the operation completes.
		*
		* @return count random bytes as a string.
		*/
		ctx.generate = function(count, callback$1) {
			if (!callback$1) return ctx.generateSync(count);
			var cipher = ctx.plugin.cipher;
			var increment = ctx.plugin.increment;
			var formatKey = ctx.plugin.formatKey;
			var formatSeed = ctx.plugin.formatSeed;
			var b = forge.util.createBuffer();
			ctx.key = null;
			generate();
			function generate(err) {
				if (err) return callback$1(err);
				if (b.length() >= count) return callback$1(null, b.getBytes(count));
				if (ctx.generated > 1048575) ctx.key = null;
				if (ctx.key === null) return forge.util.nextTick(function() {
					_reseed(generate);
				});
				var bytes = cipher(ctx.key, ctx.seed);
				ctx.generated += bytes.length;
				b.putBytes(bytes);
				ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
				ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
				forge.util.setImmediate(generate);
			}
		};
		/**
		* Generates random bytes synchronously.
		*
		* @param count the number of random bytes to generate.
		*
		* @return count random bytes as a string.
		*/
		ctx.generateSync = function(count) {
			var cipher = ctx.plugin.cipher;
			var increment = ctx.plugin.increment;
			var formatKey = ctx.plugin.formatKey;
			var formatSeed = ctx.plugin.formatSeed;
			ctx.key = null;
			var b = forge.util.createBuffer();
			while (b.length() < count) {
				if (ctx.generated > 1048575) ctx.key = null;
				if (ctx.key === null) _reseedSync();
				var bytes = cipher(ctx.key, ctx.seed);
				ctx.generated += bytes.length;
				b.putBytes(bytes);
				ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
				ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
			}
			return b.getBytes(count);
		};
		/**
		* Private function that asynchronously reseeds a generator.
		*
		* @param callback(err) called once the operation completes.
		*/
		function _reseed(callback$1) {
			if (ctx.pools[0].messageLength >= 32) {
				_seed();
				return callback$1();
			}
			var needed = 32 - ctx.pools[0].messageLength << 5;
			ctx.seedFile(needed, function(err, bytes) {
				if (err) return callback$1(err);
				ctx.collect(bytes);
				_seed();
				callback$1();
			});
		}
		/**
		* Private function that synchronously reseeds a generator.
		*/
		function _reseedSync() {
			if (ctx.pools[0].messageLength >= 32) return _seed();
			var needed = 32 - ctx.pools[0].messageLength << 5;
			ctx.collect(ctx.seedFileSync(needed));
			_seed();
		}
		/**
		* Private function that seeds a generator once enough bytes are available.
		*/
		function _seed() {
			ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
			var md$1 = ctx.plugin.md.create();
			md$1.update(ctx.keyBytes);
			var _2powK = 1;
			for (var k = 0; k < 32; ++k) {
				if (ctx.reseeds % _2powK === 0) {
					md$1.update(ctx.pools[k].digest().getBytes());
					ctx.pools[k].start();
				}
				_2powK = _2powK << 1;
			}
			ctx.keyBytes = md$1.digest().getBytes();
			md$1.start();
			md$1.update(ctx.keyBytes);
			var seedBytes = md$1.digest().getBytes();
			ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
			ctx.seed = ctx.plugin.formatSeed(seedBytes);
			ctx.generated = 0;
		}
		/**
		* The built-in default seedFile. This seedFile is used when entropy
		* is needed immediately.
		*
		* @param needed the number of bytes that are needed.
		*
		* @return the random bytes.
		*/
		function defaultSeedFile(needed) {
			var getRandomValues = null;
			var globalScope = forge.util.globalScope;
			var _crypto$1 = globalScope.crypto || globalScope.msCrypto;
			if (_crypto$1 && _crypto$1.getRandomValues) getRandomValues = function(arr) {
				return _crypto$1.getRandomValues(arr);
			};
			var b = forge.util.createBuffer();
			if (getRandomValues) while (b.length() < needed) {
				var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
				var entropy = new Uint32Array(Math.floor(count));
				try {
					getRandomValues(entropy);
					for (var i$1 = 0; i$1 < entropy.length; ++i$1) b.putInt32(entropy[i$1]);
				} catch (e) {
					if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) throw e;
				}
			}
			if (b.length() < needed) {
				var hi, lo, next;
				var seed = Math.floor(Math.random() * 65536);
				while (b.length() < needed) {
					lo = 16807 * (seed & 65535);
					hi = 16807 * (seed >> 16);
					lo += (hi & 32767) << 16;
					lo += hi >> 15;
					lo = (lo & 2147483647) + (lo >> 31);
					seed = lo & 4294967295;
					for (var i$1 = 0; i$1 < 3; ++i$1) {
						next = seed >>> (i$1 << 3);
						next ^= Math.floor(Math.random() * 256);
						b.putByte(next & 255);
					}
				}
			}
			return b.getBytes(needed);
		}
		if (_crypto) {
			ctx.seedFile = function(needed, callback$1) {
				_crypto.randomBytes(needed, function(err, bytes) {
					if (err) return callback$1(err);
					callback$1(null, bytes.toString());
				});
			};
			ctx.seedFileSync = function(needed) {
				return _crypto.randomBytes(needed).toString();
			};
		} else {
			ctx.seedFile = function(needed, callback$1) {
				try {
					callback$1(null, defaultSeedFile(needed));
				} catch (e) {
					callback$1(e);
				}
			};
			ctx.seedFileSync = defaultSeedFile;
		}
		/**
		* Adds entropy to a prng ctx's accumulator.
		*
		* @param bytes the bytes of entropy as a string.
		*/
		ctx.collect = function(bytes) {
			var count = bytes.length;
			for (var i$1 = 0; i$1 < count; ++i$1) {
				ctx.pools[ctx.pool].update(bytes.substr(i$1, 1));
				ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
			}
		};
		/**
		* Collects an integer of n bits.
		*
		* @param i the integer entropy.
		* @param n the number of bits in the integer.
		*/
		ctx.collectInt = function(i$1, n) {
			var bytes = "";
			for (var x = 0; x < n; x += 8) bytes += String.fromCharCode(i$1 >> x & 255);
			ctx.collect(bytes);
		};
		/**
		* Registers a Web Worker to receive immediate entropy from the main thread.
		* This method is required until Web Workers can access the native crypto
		* API. This method should be called twice for each created worker, once in
		* the main thread, and once in the worker itself.
		*
		* @param worker the worker to register.
		*/
		ctx.registerWorker = function(worker) {
			if (worker === self) ctx.seedFile = function(needed, callback$1) {
				function listener$1(e) {
					var data = e.data;
					if (data.forge && data.forge.prng) {
						self.removeEventListener("message", listener$1);
						callback$1(data.forge.prng.err, data.forge.prng.bytes);
					}
				}
				self.addEventListener("message", listener$1);
				self.postMessage({ forge: { prng: { needed } } });
			};
			else {
				var listener = function(e) {
					var data = e.data;
					if (data.forge && data.forge.prng) ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
						worker.postMessage({ forge: { prng: {
							err,
							bytes
						} } });
					});
				};
				worker.addEventListener("message", listener);
			}
		};
		return ctx;
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/random.js
var require_random = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* An API for getting cryptographically-secure random bytes. The bytes are
	* generated using the Fortuna algorithm devised by Bruce Schneier and
	* Niels Ferguson.
	*
	* Getting strong random bytes is not yet easy to do in javascript. The only
	* truish random entropy that can be collected is from the mouse, keyboard, or
	* from timing with respect to page loads, etc. This generator makes a poor
	* attempt at providing random bytes when those sources haven't yet provided
	* enough entropy to initially seed or to reseed the PRNG.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2009-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_aes();
	require_sha256();
	require_prng();
	require_util();
	(function() {
		if (forge.random && forge.random.getBytes) {
			module.exports = forge.random;
			return;
		}
		(function(jQuery$1) {
			var prng_aes = {};
			var _prng_aes_output = new Array(4);
			var _prng_aes_buffer = forge.util.createBuffer();
			prng_aes.formatKey = function(key$1) {
				var tmp = forge.util.createBuffer(key$1);
				key$1 = new Array(4);
				key$1[0] = tmp.getInt32();
				key$1[1] = tmp.getInt32();
				key$1[2] = tmp.getInt32();
				key$1[3] = tmp.getInt32();
				return forge.aes._expandKey(key$1, false);
			};
			prng_aes.formatSeed = function(seed) {
				var tmp = forge.util.createBuffer(seed);
				seed = new Array(4);
				seed[0] = tmp.getInt32();
				seed[1] = tmp.getInt32();
				seed[2] = tmp.getInt32();
				seed[3] = tmp.getInt32();
				return seed;
			};
			prng_aes.cipher = function(key$1, seed) {
				forge.aes._updateBlock(key$1, seed, _prng_aes_output, false);
				_prng_aes_buffer.putInt32(_prng_aes_output[0]);
				_prng_aes_buffer.putInt32(_prng_aes_output[1]);
				_prng_aes_buffer.putInt32(_prng_aes_output[2]);
				_prng_aes_buffer.putInt32(_prng_aes_output[3]);
				return _prng_aes_buffer.getBytes();
			};
			prng_aes.increment = function(seed) {
				++seed[3];
				return seed;
			};
			prng_aes.md = forge.md.sha256;
			/**
			* Creates a new PRNG.
			*/
			function spawnPrng() {
				var ctx = forge.prng.create(prng_aes);
				/**
				* Gets random bytes. If a native secure crypto API is unavailable, this
				* method tries to make the bytes more unpredictable by drawing from data that
				* can be collected from the user of the browser, eg: mouse movement.
				*
				* If a callback is given, this method will be called asynchronously.
				*
				* @param count the number of random bytes to get.
				* @param [callback(err, bytes)] called once the operation completes.
				*
				* @return the random bytes in a string.
				*/
				ctx.getBytes = function(count, callback$1) {
					return ctx.generate(count, callback$1);
				};
				/**
				* Gets random bytes asynchronously. If a native secure crypto API is
				* unavailable, this method tries to make the bytes more unpredictable by
				* drawing from data that can be collected from the user of the browser,
				* eg: mouse movement.
				*
				* @param count the number of random bytes to get.
				*
				* @return the random bytes in a string.
				*/
				ctx.getBytesSync = function(count) {
					return ctx.generate(count);
				};
				return ctx;
			}
			var _ctx = spawnPrng();
			var getRandomValues = null;
			var globalScope = forge.util.globalScope;
			var _crypto$1 = globalScope.crypto || globalScope.msCrypto;
			if (_crypto$1 && _crypto$1.getRandomValues) getRandomValues = function(arr) {
				return _crypto$1.getRandomValues(arr);
			};
			if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
				if (typeof window === "undefined" || window.document === void 0) {}
				_ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
				if (typeof navigator !== "undefined") {
					var _navBytes = "";
					for (var key in navigator) try {
						if (typeof navigator[key] == "string") _navBytes += navigator[key];
					} catch (e) {}
					_ctx.collect(_navBytes);
					_navBytes = null;
				}
				if (jQuery$1) {
					jQuery$1().mousemove(function(e) {
						_ctx.collectInt(e.clientX, 16);
						_ctx.collectInt(e.clientY, 16);
					});
					jQuery$1().keypress(function(e) {
						_ctx.collectInt(e.charCode, 8);
					});
				}
			}
			if (!forge.random) forge.random = _ctx;
			else for (var key in _ctx) forge.random[key] = _ctx[key];
			forge.random.createInstance = spawnPrng;
			module.exports = forge.random;
		})(typeof jQuery !== "undefined" ? jQuery : null);
	})();
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/rc2.js
var require_rc2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* RC2 implementation.
	*
	* @author Stefan Siegl
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* Information on the RC2 cipher is available from RFC #2268,
	* http://www.ietf.org/rfc/rfc2268.txt
	*/
	var forge = require_forge();
	require_util();
	var piTable = [
		217,
		120,
		249,
		196,
		25,
		221,
		181,
		237,
		40,
		233,
		253,
		121,
		74,
		160,
		216,
		157,
		198,
		126,
		55,
		131,
		43,
		118,
		83,
		142,
		98,
		76,
		100,
		136,
		68,
		139,
		251,
		162,
		23,
		154,
		89,
		245,
		135,
		179,
		79,
		19,
		97,
		69,
		109,
		141,
		9,
		129,
		125,
		50,
		189,
		143,
		64,
		235,
		134,
		183,
		123,
		11,
		240,
		149,
		33,
		34,
		92,
		107,
		78,
		130,
		84,
		214,
		101,
		147,
		206,
		96,
		178,
		28,
		115,
		86,
		192,
		20,
		167,
		140,
		241,
		220,
		18,
		117,
		202,
		31,
		59,
		190,
		228,
		209,
		66,
		61,
		212,
		48,
		163,
		60,
		182,
		38,
		111,
		191,
		14,
		218,
		70,
		105,
		7,
		87,
		39,
		242,
		29,
		155,
		188,
		148,
		67,
		3,
		248,
		17,
		199,
		246,
		144,
		239,
		62,
		231,
		6,
		195,
		213,
		47,
		200,
		102,
		30,
		215,
		8,
		232,
		234,
		222,
		128,
		82,
		238,
		247,
		132,
		170,
		114,
		172,
		53,
		77,
		106,
		42,
		150,
		26,
		210,
		113,
		90,
		21,
		73,
		116,
		75,
		159,
		208,
		94,
		4,
		24,
		164,
		236,
		194,
		224,
		65,
		110,
		15,
		81,
		203,
		204,
		36,
		145,
		175,
		80,
		161,
		244,
		112,
		57,
		153,
		124,
		58,
		133,
		35,
		184,
		180,
		122,
		252,
		2,
		54,
		91,
		37,
		85,
		151,
		49,
		45,
		93,
		250,
		152,
		227,
		138,
		146,
		174,
		5,
		223,
		41,
		16,
		103,
		108,
		186,
		201,
		211,
		0,
		230,
		207,
		225,
		158,
		168,
		44,
		99,
		22,
		1,
		63,
		88,
		226,
		137,
		169,
		13,
		56,
		52,
		27,
		171,
		51,
		255,
		176,
		187,
		72,
		12,
		95,
		185,
		177,
		205,
		46,
		197,
		243,
		219,
		71,
		229,
		165,
		156,
		119,
		10,
		166,
		32,
		104,
		254,
		127,
		193,
		173
	];
	var s = [
		1,
		2,
		3,
		5
	];
	/**
	* Rotate a word left by given number of bits.
	*
	* Bits that are shifted out on the left are put back in on the right
	* hand side.
	*
	* @param word The word to shift left.
	* @param bits The number of bits to shift by.
	* @return The rotated word.
	*/
	var rol = function(word, bits) {
		return word << bits & 65535 | (word & 65535) >> 16 - bits;
	};
	/**
	* Rotate a word right by given number of bits.
	*
	* Bits that are shifted out on the right are put back in on the left
	* hand side.
	*
	* @param word The word to shift right.
	* @param bits The number of bits to shift by.
	* @return The rotated word.
	*/
	var ror = function(word, bits) {
		return (word & 65535) >> bits | word << 16 - bits & 65535;
	};
	module.exports = forge.rc2 = forge.rc2 || {};
	/**
	* Perform RC2 key expansion as per RFC #2268, section 2.
	*
	* @param key variable-length user key (between 1 and 128 bytes)
	* @param effKeyBits number of effective key bits (default: 128)
	* @return the expanded RC2 key (ByteBuffer of 128 bytes)
	*/
	forge.rc2.expandKey = function(key, effKeyBits) {
		if (typeof key === "string") key = forge.util.createBuffer(key);
		effKeyBits = effKeyBits || 128;
		var L = key;
		var T = key.length();
		var T1 = effKeyBits;
		var T8 = Math.ceil(T1 / 8);
		var TM = 255 >> (T1 & 7);
		var i;
		for (i = T; i < 128; i++) L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
		L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
		for (i = 127 - T8; i >= 0; i--) L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
		return L;
	};
	/**
	* Creates a RC2 cipher object.
	*
	* @param key the symmetric key to use (as base for key generation).
	* @param bits the number of effective key bits.
	* @param encrypt false for decryption, true for encryption.
	*
	* @return the cipher.
	*/
	var createCipher = function(key, bits, encrypt) {
		var _finish = false, _input = null, _output = null, _iv = null;
		var mixRound, mashRound;
		var i, j, K = [];
		key = forge.rc2.expandKey(key, bits);
		for (i = 0; i < 64; i++) K.push(key.getInt16Le());
		if (encrypt) {
			/**
			* Perform one mixing round "in place".
			*
			* @param R Array of four words to perform mixing on.
			*/
			mixRound = function(R) {
				for (i = 0; i < 4; i++) {
					R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
					R[i] = rol(R[i], s[i]);
					j++;
				}
			};
			/**
			* Perform one mashing round "in place".
			*
			* @param R Array of four words to perform mashing on.
			*/
			mashRound = function(R) {
				for (i = 0; i < 4; i++) R[i] += K[R[(i + 3) % 4] & 63];
			};
		} else {
			/**
			* Perform one r-mixing round "in place".
			*
			* @param R Array of four words to perform mixing on.
			*/
			mixRound = function(R) {
				for (i = 3; i >= 0; i--) {
					R[i] = ror(R[i], s[i]);
					R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
					j--;
				}
			};
			/**
			* Perform one r-mashing round "in place".
			*
			* @param R Array of four words to perform mashing on.
			*/
			mashRound = function(R) {
				for (i = 3; i >= 0; i--) R[i] -= K[R[(i + 3) % 4] & 63];
			};
		}
		/**
		* Run the specified cipher execution plan.
		*
		* This function takes four words from the input buffer, applies the IV on
		* it (if requested) and runs the provided execution plan.
		*
		* The plan must be put together in form of a array of arrays.  Where the
		* outer one is simply a list of steps to perform and the inner one needs
		* to have two elements: the first one telling how many rounds to perform,
		* the second one telling what to do (i.e. the function to call).
		*
		* @param {Array} plan The plan to execute.
		*/
		var runPlan = function(plan) {
			var R = [];
			for (i = 0; i < 4; i++) {
				var val = _input.getInt16Le();
				if (_iv !== null) if (encrypt) val ^= _iv.getInt16Le();
				else _iv.putInt16Le(val);
				R.push(val & 65535);
			}
			j = encrypt ? 0 : 63;
			for (var ptr = 0; ptr < plan.length; ptr++) for (var ctr = 0; ctr < plan[ptr][0]; ctr++) plan[ptr][1](R);
			for (i = 0; i < 4; i++) {
				if (_iv !== null) if (encrypt) _iv.putInt16Le(R[i]);
				else R[i] ^= _iv.getInt16Le();
				_output.putInt16Le(R[i]);
			}
		};
		var cipher = null;
		cipher = {
			start: function(iv, output) {
				if (iv) {
					if (typeof iv === "string") iv = forge.util.createBuffer(iv);
				}
				_finish = false;
				_input = forge.util.createBuffer();
				_output = output || new forge.util.createBuffer();
				_iv = iv;
				cipher.output = _output;
			},
			update: function(input) {
				if (!_finish) _input.putBuffer(input);
				while (_input.length() >= 8) runPlan([
					[5, mixRound],
					[1, mashRound],
					[6, mixRound],
					[1, mashRound],
					[5, mixRound]
				]);
			},
			finish: function(pad) {
				var rval = true;
				if (encrypt) if (pad) rval = pad(8, _input, !encrypt);
				else {
					var padding = _input.length() === 8 ? 8 : 8 - _input.length();
					_input.fillWithByte(padding, padding);
				}
				if (rval) {
					_finish = true;
					cipher.update();
				}
				if (!encrypt) {
					rval = _input.length() === 0;
					if (rval) if (pad) rval = pad(8, _output, !encrypt);
					else {
						var len = _output.length();
						var count = _output.at(len - 1);
						if (count > len) rval = false;
						else _output.truncate(count);
					}
				}
				return rval;
			}
		};
		return cipher;
	};
	/**
	* Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
	* given symmetric key. The output will be stored in the 'output' member
	* of the returned cipher.
	*
	* The key and iv may be given as a string of bytes or a byte buffer.
	* The cipher is initialized to use 128 effective key bits.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	*
	* @return the cipher.
	*/
	forge.rc2.startEncrypting = function(key, iv, output) {
		var cipher = forge.rc2.createEncryptionCipher(key, 128);
		cipher.start(iv, output);
		return cipher;
	};
	/**
	* Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
	* given symmetric key.
	*
	* The key may be given as a string of bytes or a byte buffer.
	*
	* To start encrypting call start() on the cipher with an iv and optional
	* output buffer.
	*
	* @param key the symmetric key to use.
	*
	* @return the cipher.
	*/
	forge.rc2.createEncryptionCipher = function(key, bits) {
		return createCipher(key, bits, true);
	};
	/**
	* Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
	* given symmetric key. The output will be stored in the 'output' member
	* of the returned cipher.
	*
	* The key and iv may be given as a string of bytes or a byte buffer.
	* The cipher is initialized to use 128 effective key bits.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	*
	* @return the cipher.
	*/
	forge.rc2.startDecrypting = function(key, iv, output) {
		var cipher = forge.rc2.createDecryptionCipher(key, 128);
		cipher.start(iv, output);
		return cipher;
	};
	/**
	* Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
	* given symmetric key.
	*
	* The key may be given as a string of bytes or a byte buffer.
	*
	* To start decrypting call start() on the cipher with an iv and optional
	* output buffer.
	*
	* @param key the symmetric key to use.
	*
	* @return the cipher.
	*/
	forge.rc2.createDecryptionCipher = function(key, bits) {
		return createCipher(key, bits, false);
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/jsbn.js
var require_jsbn$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var forge = require_forge();
	module.exports = forge.jsbn = forge.jsbn || {};
	var dbits;
	var j_lm = true;
	function BigInteger(a, b, c) {
		this.data = [];
		if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c);
		else if (b == null && "string" != typeof a) this.fromString(a, 256);
		else this.fromString(a, b);
	}
	forge.jsbn.BigInteger = BigInteger;
	function nbi() {
		return new BigInteger(null);
	}
	function am1(i, x, w, j, c, n) {
		while (--n >= 0) {
			var v = x * this.data[i++] + w.data[j] + c;
			c = Math.floor(v / 67108864);
			w.data[j++] = v & 67108863;
		}
		return c;
	}
	function am2(i, x, w, j, c, n) {
		var xl = x & 32767, xh = x >> 15;
		while (--n >= 0) {
			var l = this.data[i] & 32767;
			var h = this.data[i++] >> 15;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
			c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
			w.data[j++] = l & 1073741823;
		}
		return c;
	}
	function am3(i, x, w, j, c, n) {
		var xl = x & 16383, xh = x >> 14;
		while (--n >= 0) {
			var l = this.data[i] & 16383;
			var h = this.data[i++] >> 14;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
			c = (l >> 28) + (m >> 14) + xh * h;
			w.data[j++] = l & 268435455;
		}
		return c;
	}
	if (typeof navigator === "undefined") {
		BigInteger.prototype.am = am3;
		dbits = 28;
	} else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
		BigInteger.prototype.am = am2;
		dbits = 30;
	} else if (j_lm && navigator.appName != "Netscape") {
		BigInteger.prototype.am = am1;
		dbits = 26;
	} else {
		BigInteger.prototype.am = am3;
		dbits = 28;
	}
	BigInteger.prototype.DB = dbits;
	BigInteger.prototype.DM = (1 << dbits) - 1;
	BigInteger.prototype.DV = 1 << dbits;
	var BI_FP = 52;
	BigInteger.prototype.FV = Math.pow(2, BI_FP);
	BigInteger.prototype.F1 = BI_FP - dbits;
	BigInteger.prototype.F2 = 2 * dbits - BI_FP;
	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	var BI_RC = new Array();
	var rr = "0".charCodeAt(0), vv;
	for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	rr = "a".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	rr = "A".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	function int2char(n) {
		return BI_RM.charAt(n);
	}
	function intAt(s, i) {
		var c = BI_RC[s.charCodeAt(i)];
		return c == null ? -1 : c;
	}
	function bnpCopyTo(r) {
		for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
		r.t = this.t;
		r.s = this.s;
	}
	function bnpFromInt(x) {
		this.t = 1;
		this.s = x < 0 ? -1 : 0;
		if (x > 0) this.data[0] = x;
		else if (x < -1) this.data[0] = x + this.DV;
		else this.t = 0;
	}
	function nbv(i) {
		var r = nbi();
		r.fromInt(i);
		return r;
	}
	function bnpFromString(s, b) {
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 256) k = 8;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else {
			this.fromRadix(s, b);
			return;
		}
		this.t = 0;
		this.s = 0;
		var i = s.length, mi = false, sh = 0;
		while (--i >= 0) {
			var x = k == 8 ? s[i] & 255 : intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-") mi = true;
				continue;
			}
			mi = false;
			if (sh == 0) this.data[this.t++] = x;
			else if (sh + k > this.DB) {
				this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
				this.data[this.t++] = x >> this.DB - sh;
			} else this.data[this.t - 1] |= x << sh;
			sh += k;
			if (sh >= this.DB) sh -= this.DB;
		}
		if (k == 8 && (s[0] & 128) != 0) {
			this.s = -1;
			if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
		}
		this.clamp();
		if (mi) BigInteger.ZERO.subTo(this, this);
	}
	function bnpClamp() {
		var c = this.s & this.DM;
		while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
	}
	function bnToString(b) {
		if (this.s < 0) return "-" + this.negate().toString(b);
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else return this.toRadix(b);
		var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
		var p = this.DB - i * this.DB % k;
		if (i-- > 0) {
			if (p < this.DB && (d = this.data[i] >> p) > 0) {
				m = true;
				r = int2char(d);
			}
			while (i >= 0) {
				if (p < k) {
					d = (this.data[i] & (1 << p) - 1) << k - p;
					d |= this.data[--i] >> (p += this.DB - k);
				} else {
					d = this.data[i] >> (p -= k) & km;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if (d > 0) m = true;
				if (m) r += int2char(d);
			}
		}
		return m ? r : "0";
	}
	function bnNegate() {
		var r = nbi();
		BigInteger.ZERO.subTo(this, r);
		return r;
	}
	function bnAbs() {
		return this.s < 0 ? this.negate() : this;
	}
	function bnCompareTo(a) {
		var r = this.s - a.s;
		if (r != 0) return r;
		var i = this.t;
		r = i - a.t;
		if (r != 0) return this.s < 0 ? -r : r;
		while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
		return 0;
	}
	function nbits(x) {
		var r = 1, t;
		if ((t = x >>> 16) != 0) {
			x = t;
			r += 16;
		}
		if ((t = x >> 8) != 0) {
			x = t;
			r += 8;
		}
		if ((t = x >> 4) != 0) {
			x = t;
			r += 4;
		}
		if ((t = x >> 2) != 0) {
			x = t;
			r += 2;
		}
		if ((t = x >> 1) != 0) {
			x = t;
			r += 1;
		}
		return r;
	}
	function bnBitLength() {
		if (this.t <= 0) return 0;
		return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
	}
	function bnpDLShiftTo(n, r) {
		var i;
		for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
		for (i = n - 1; i >= 0; --i) r.data[i] = 0;
		r.t = this.t + n;
		r.s = this.s;
	}
	function bnpDRShiftTo(n, r) {
		for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
		r.t = Math.max(this.t - n, 0);
		r.s = this.s;
	}
	function bnpLShiftTo(n, r) {
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << cbs) - 1;
		var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
		for (i = this.t - 1; i >= 0; --i) {
			r.data[i + ds + 1] = this.data[i] >> cbs | c;
			c = (this.data[i] & bm) << bs;
		}
		for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
		r.data[ds] = c;
		r.t = this.t + ds + 1;
		r.s = this.s;
		r.clamp();
	}
	function bnpRShiftTo(n, r) {
		r.s = this.s;
		var ds = Math.floor(n / this.DB);
		if (ds >= this.t) {
			r.t = 0;
			return;
		}
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << bs) - 1;
		r.data[0] = this.data[ds] >> bs;
		for (var i = ds + 1; i < this.t; ++i) {
			r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
			r.data[i - ds] = this.data[i] >> bs;
		}
		if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
		r.t = this.t - ds;
		r.clamp();
	}
	function bnpSubTo(a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this.data[i] - a.data[i];
			r.data[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c -= a.s;
			while (i < this.t) {
				c += this.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c -= a.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c -= a.s;
		}
		r.s = c < 0 ? -1 : 0;
		if (c < -1) r.data[i++] = this.DV + c;
		else if (c > 0) r.data[i++] = c;
		r.t = i;
		r.clamp();
	}
	function bnpMultiplyTo(a, r) {
		var x = this.abs(), y = a.abs();
		var i = x.t;
		r.t = i + y.t;
		while (--i >= 0) r.data[i] = 0;
		for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
		r.s = 0;
		r.clamp();
		if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
	}
	function bnpSquareTo(r) {
		var x = this.abs();
		var i = r.t = 2 * x.t;
		while (--i >= 0) r.data[i] = 0;
		for (i = 0; i < x.t - 1; ++i) {
			var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
			if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
				r.data[i + x.t] -= x.DV;
				r.data[i + x.t + 1] = 1;
			}
		}
		if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
		r.s = 0;
		r.clamp();
	}
	function bnpDivRemTo(m, q, r) {
		var pm = m.abs();
		if (pm.t <= 0) return;
		var pt = this.abs();
		if (pt.t < pm.t) {
			if (q != null) q.fromInt(0);
			if (r != null) this.copyTo(r);
			return;
		}
		if (r == null) r = nbi();
		var y = nbi(), ts = this.s, ms = m.s;
		var nsh = this.DB - nbits(pm.data[pm.t - 1]);
		if (nsh > 0) {
			pm.lShiftTo(nsh, y);
			pt.lShiftTo(nsh, r);
		} else {
			pm.copyTo(y);
			pt.copyTo(r);
		}
		var ys = y.t;
		var y0 = y.data[ys - 1];
		if (y0 == 0) return;
		var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
		var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
		var i = r.t, j = i - ys, t = q == null ? nbi() : q;
		y.dlShiftTo(j, t);
		if (r.compareTo(t) >= 0) {
			r.data[r.t++] = 1;
			r.subTo(t, r);
		}
		BigInteger.ONE.dlShiftTo(ys, t);
		t.subTo(y, y);
		while (y.t < ys) y.data[y.t++] = 0;
		while (--j >= 0) {
			var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
			if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
				y.dlShiftTo(j, t);
				r.subTo(t, r);
				while (r.data[i] < --qd) r.subTo(t, r);
			}
		}
		if (q != null) {
			r.drShiftTo(ys, q);
			if (ts != ms) BigInteger.ZERO.subTo(q, q);
		}
		r.t = ys;
		r.clamp();
		if (nsh > 0) r.rShiftTo(nsh, r);
		if (ts < 0) BigInteger.ZERO.subTo(r, r);
	}
	function bnMod(a) {
		var r = nbi();
		this.abs().divRemTo(a, null, r);
		if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
		return r;
	}
	function Classic(m) {
		this.m = m;
	}
	function cConvert(x) {
		if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
		else return x;
	}
	function cRevert(x) {
		return x;
	}
	function cReduce(x) {
		x.divRemTo(this.m, null, x);
	}
	function cMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	function cSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	Classic.prototype.convert = cConvert;
	Classic.prototype.revert = cRevert;
	Classic.prototype.reduce = cReduce;
	Classic.prototype.mulTo = cMulTo;
	Classic.prototype.sqrTo = cSqrTo;
	function bnpInvDigit() {
		if (this.t < 1) return 0;
		var x = this.data[0];
		if ((x & 1) == 0) return 0;
		var y = x & 3;
		y = y * (2 - (x & 15) * y) & 15;
		y = y * (2 - (x & 255) * y) & 255;
		y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
		y = y * (2 - x * y % this.DV) % this.DV;
		return y > 0 ? this.DV - y : -y;
	}
	function Montgomery(m) {
		this.m = m;
		this.mp = m.invDigit();
		this.mpl = this.mp & 32767;
		this.mph = this.mp >> 15;
		this.um = (1 << m.DB - 15) - 1;
		this.mt2 = 2 * m.t;
	}
	function montConvert(x) {
		var r = nbi();
		x.abs().dlShiftTo(this.m.t, r);
		r.divRemTo(this.m, null, r);
		if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
		return r;
	}
	function montRevert(x) {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	}
	function montReduce(x) {
		while (x.t <= this.mt2) x.data[x.t++] = 0;
		for (var i = 0; i < this.m.t; ++i) {
			var j = x.data[i] & 32767;
			var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
			j = i + this.m.t;
			x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
			while (x.data[j] >= x.DV) {
				x.data[j] -= x.DV;
				x.data[++j]++;
			}
		}
		x.clamp();
		x.drShiftTo(this.m.t, x);
		if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	}
	function montSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	function montMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	Montgomery.prototype.convert = montConvert;
	Montgomery.prototype.revert = montRevert;
	Montgomery.prototype.reduce = montReduce;
	Montgomery.prototype.mulTo = montMulTo;
	Montgomery.prototype.sqrTo = montSqrTo;
	function bnpIsEven() {
		return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
	}
	function bnpExp(e, z$1) {
		if (e > 4294967295 || e < 1) return BigInteger.ONE;
		var r = nbi(), r2 = nbi(), g = z$1.convert(this), i = nbits(e) - 1;
		g.copyTo(r);
		while (--i >= 0) {
			z$1.sqrTo(r, r2);
			if ((e & 1 << i) > 0) z$1.mulTo(r2, g, r);
			else {
				var t = r;
				r = r2;
				r2 = t;
			}
		}
		return z$1.revert(r);
	}
	function bnModPowInt(e, m) {
		var z$1;
		if (e < 256 || m.isEven()) z$1 = new Classic(m);
		else z$1 = new Montgomery(m);
		return this.exp(e, z$1);
	}
	BigInteger.prototype.copyTo = bnpCopyTo;
	BigInteger.prototype.fromInt = bnpFromInt;
	BigInteger.prototype.fromString = bnpFromString;
	BigInteger.prototype.clamp = bnpClamp;
	BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	BigInteger.prototype.lShiftTo = bnpLShiftTo;
	BigInteger.prototype.rShiftTo = bnpRShiftTo;
	BigInteger.prototype.subTo = bnpSubTo;
	BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	BigInteger.prototype.squareTo = bnpSquareTo;
	BigInteger.prototype.divRemTo = bnpDivRemTo;
	BigInteger.prototype.invDigit = bnpInvDigit;
	BigInteger.prototype.isEven = bnpIsEven;
	BigInteger.prototype.exp = bnpExp;
	BigInteger.prototype.toString = bnToString;
	BigInteger.prototype.negate = bnNegate;
	BigInteger.prototype.abs = bnAbs;
	BigInteger.prototype.compareTo = bnCompareTo;
	BigInteger.prototype.bitLength = bnBitLength;
	BigInteger.prototype.mod = bnMod;
	BigInteger.prototype.modPowInt = bnModPowInt;
	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);
	function bnClone() {
		var r = nbi();
		this.copyTo(r);
		return r;
	}
	function bnIntValue() {
		if (this.s < 0) {
			if (this.t == 1) return this.data[0] - this.DV;
			else if (this.t == 0) return -1;
		} else if (this.t == 1) return this.data[0];
		else if (this.t == 0) return 0;
		return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
	}
	function bnByteValue() {
		return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
	}
	function bnShortValue() {
		return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
	}
	function bnpChunkSize(r) {
		return Math.floor(Math.LN2 * this.DB / Math.log(r));
	}
	function bnSigNum() {
		if (this.s < 0) return -1;
		else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
		else return 1;
	}
	function bnpToRadix(b) {
		if (b == null) b = 10;
		if (this.signum() == 0 || b < 2 || b > 36) return "0";
		var cs = this.chunkSize(b);
		var a = Math.pow(b, cs);
		var d = nbv(a), y = nbi(), z$1 = nbi(), r = "";
		this.divRemTo(d, y, z$1);
		while (y.signum() > 0) {
			r = (a + z$1.intValue()).toString(b).substr(1) + r;
			y.divRemTo(d, y, z$1);
		}
		return z$1.intValue().toString(b) + r;
	}
	function bnpFromRadix(s, b) {
		this.fromInt(0);
		if (b == null) b = 10;
		var cs = this.chunkSize(b);
		var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
		for (var i = 0; i < s.length; ++i) {
			var x = intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
				continue;
			}
			w = b * w + x;
			if (++j >= cs) {
				this.dMultiply(d);
				this.dAddOffset(w, 0);
				j = 0;
				w = 0;
			}
		}
		if (j > 0) {
			this.dMultiply(Math.pow(b, j));
			this.dAddOffset(w, 0);
		}
		if (mi) BigInteger.ZERO.subTo(this, this);
	}
	function bnpFromNumber(a, b, c) {
		if ("number" == typeof b) if (a < 2) this.fromInt(1);
		else {
			this.fromNumber(a, c);
			if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
			if (this.isEven()) this.dAddOffset(1, 0);
			while (!this.isProbablePrime(b)) {
				this.dAddOffset(2, 0);
				if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
			}
		}
		else {
			var x = new Array(), t = a & 7;
			x.length = (a >> 3) + 1;
			b.nextBytes(x);
			if (t > 0) x[0] &= (1 << t) - 1;
			else x[0] = 0;
			this.fromString(x, 256);
		}
	}
	function bnToByteArray() {
		var i = this.t, r = new Array();
		r[0] = this.s;
		var p = this.DB - i * this.DB % 8, d, k = 0;
		if (i-- > 0) {
			if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;
			while (i >= 0) {
				if (p < 8) {
					d = (this.data[i] & (1 << p) - 1) << 8 - p;
					d |= this.data[--i] >> (p += this.DB - 8);
				} else {
					d = this.data[i] >> (p -= 8) & 255;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if ((d & 128) != 0) d |= -256;
				if (k == 0 && (this.s & 128) != (d & 128)) ++k;
				if (k > 0 || d != this.s) r[k++] = d;
			}
		}
		return r;
	}
	function bnEquals(a) {
		return this.compareTo(a) == 0;
	}
	function bnMin(a) {
		return this.compareTo(a) < 0 ? this : a;
	}
	function bnMax(a) {
		return this.compareTo(a) > 0 ? this : a;
	}
	function bnpBitwiseTo(a, op, r) {
		var i, f, m = Math.min(a.t, this.t);
		for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
		if (a.t < this.t) {
			f = a.s & this.DM;
			for (i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f);
			r.t = this.t;
		} else {
			f = this.s & this.DM;
			for (i = m; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
			r.t = a.t;
		}
		r.s = op(this.s, a.s);
		r.clamp();
	}
	function op_and(x, y) {
		return x & y;
	}
	function bnAnd(a) {
		var r = nbi();
		this.bitwiseTo(a, op_and, r);
		return r;
	}
	function op_or(x, y) {
		return x | y;
	}
	function bnOr(a) {
		var r = nbi();
		this.bitwiseTo(a, op_or, r);
		return r;
	}
	function op_xor(x, y) {
		return x ^ y;
	}
	function bnXor(a) {
		var r = nbi();
		this.bitwiseTo(a, op_xor, r);
		return r;
	}
	function op_andnot(x, y) {
		return x & ~y;
	}
	function bnAndNot(a) {
		var r = nbi();
		this.bitwiseTo(a, op_andnot, r);
		return r;
	}
	function bnNot() {
		var r = nbi();
		for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
		r.t = this.t;
		r.s = ~this.s;
		return r;
	}
	function bnShiftLeft(n) {
		var r = nbi();
		if (n < 0) this.rShiftTo(-n, r);
		else this.lShiftTo(n, r);
		return r;
	}
	function bnShiftRight(n) {
		var r = nbi();
		if (n < 0) this.lShiftTo(-n, r);
		else this.rShiftTo(n, r);
		return r;
	}
	function lbit(x) {
		if (x == 0) return -1;
		var r = 0;
		if ((x & 65535) == 0) {
			x >>= 16;
			r += 16;
		}
		if ((x & 255) == 0) {
			x >>= 8;
			r += 8;
		}
		if ((x & 15) == 0) {
			x >>= 4;
			r += 4;
		}
		if ((x & 3) == 0) {
			x >>= 2;
			r += 2;
		}
		if ((x & 1) == 0) ++r;
		return r;
	}
	function bnGetLowestSetBit() {
		for (var i = 0; i < this.t; ++i) if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
		if (this.s < 0) return this.t * this.DB;
		return -1;
	}
	function cbit(x) {
		var r = 0;
		while (x != 0) {
			x &= x - 1;
			++r;
		}
		return r;
	}
	function bnBitCount() {
		var r = 0, x = this.s & this.DM;
		for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
		return r;
	}
	function bnTestBit(n) {
		var j = Math.floor(n / this.DB);
		if (j >= this.t) return this.s != 0;
		return (this.data[j] & 1 << n % this.DB) != 0;
	}
	function bnpChangeBit(n, op) {
		var r = BigInteger.ONE.shiftLeft(n);
		this.bitwiseTo(r, op, r);
		return r;
	}
	function bnSetBit(n) {
		return this.changeBit(n, op_or);
	}
	function bnClearBit(n) {
		return this.changeBit(n, op_andnot);
	}
	function bnFlipBit(n) {
		return this.changeBit(n, op_xor);
	}
	function bnpAddTo(a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this.data[i] + a.data[i];
			r.data[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c += a.s;
			while (i < this.t) {
				c += this.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c += a.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += a.s;
		}
		r.s = c < 0 ? -1 : 0;
		if (c > 0) r.data[i++] = c;
		else if (c < -1) r.data[i++] = this.DV + c;
		r.t = i;
		r.clamp();
	}
	function bnAdd(a) {
		var r = nbi();
		this.addTo(a, r);
		return r;
	}
	function bnSubtract(a) {
		var r = nbi();
		this.subTo(a, r);
		return r;
	}
	function bnMultiply(a) {
		var r = nbi();
		this.multiplyTo(a, r);
		return r;
	}
	function bnDivide(a) {
		var r = nbi();
		this.divRemTo(a, r, null);
		return r;
	}
	function bnRemainder(a) {
		var r = nbi();
		this.divRemTo(a, null, r);
		return r;
	}
	function bnDivideAndRemainder(a) {
		var q = nbi(), r = nbi();
		this.divRemTo(a, q, r);
		return new Array(q, r);
	}
	function bnpDMultiply(n) {
		this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
		++this.t;
		this.clamp();
	}
	function bnpDAddOffset(n, w) {
		if (n == 0) return;
		while (this.t <= w) this.data[this.t++] = 0;
		this.data[w] += n;
		while (this.data[w] >= this.DV) {
			this.data[w] -= this.DV;
			if (++w >= this.t) this.data[this.t++] = 0;
			++this.data[w];
		}
	}
	function NullExp() {}
	function nNop(x) {
		return x;
	}
	function nMulTo(x, y, r) {
		x.multiplyTo(y, r);
	}
	function nSqrTo(x, r) {
		x.squareTo(r);
	}
	NullExp.prototype.convert = nNop;
	NullExp.prototype.revert = nNop;
	NullExp.prototype.mulTo = nMulTo;
	NullExp.prototype.sqrTo = nSqrTo;
	function bnPow(e) {
		return this.exp(e, new NullExp());
	}
	function bnpMultiplyLowerTo(a, n, r) {
		var i = Math.min(this.t + a.t, n);
		r.s = 0;
		r.t = i;
		while (i > 0) r.data[--i] = 0;
		var j;
		for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
		for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
		r.clamp();
	}
	function bnpMultiplyUpperTo(a, n, r) {
		--n;
		var i = r.t = this.t + a.t - n;
		r.s = 0;
		while (--i >= 0) r.data[i] = 0;
		for (i = Math.max(n - this.t, 0); i < a.t; ++i) r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
		r.clamp();
		r.drShiftTo(1, r);
	}
	function Barrett(m) {
		this.r2 = nbi();
		this.q3 = nbi();
		BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
		this.mu = this.r2.divide(m);
		this.m = m;
	}
	function barrettConvert(x) {
		if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
		else if (x.compareTo(this.m) < 0) return x;
		else {
			var r = nbi();
			x.copyTo(r);
			this.reduce(r);
			return r;
		}
	}
	function barrettRevert(x) {
		return x;
	}
	function barrettReduce(x) {
		x.drShiftTo(this.m.t - 1, this.r2);
		if (x.t > this.m.t + 1) {
			x.t = this.m.t + 1;
			x.clamp();
		}
		this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
		this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
		while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
		x.subTo(this.r2, x);
		while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	}
	function barrettSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	function barrettMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	Barrett.prototype.convert = barrettConvert;
	Barrett.prototype.revert = barrettRevert;
	Barrett.prototype.reduce = barrettReduce;
	Barrett.prototype.mulTo = barrettMulTo;
	Barrett.prototype.sqrTo = barrettSqrTo;
	function bnModPow(e, m) {
		var i = e.bitLength(), k, r = nbv(1), z$1;
		if (i <= 0) return r;
		else if (i < 18) k = 1;
		else if (i < 48) k = 3;
		else if (i < 144) k = 4;
		else if (i < 768) k = 5;
		else k = 6;
		if (i < 8) z$1 = new Classic(m);
		else if (m.isEven()) z$1 = new Barrett(m);
		else z$1 = new Montgomery(m);
		var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
		g[1] = z$1.convert(this);
		if (k > 1) {
			var g2 = nbi();
			z$1.sqrTo(g[1], g2);
			while (n <= km) {
				g[n] = nbi();
				z$1.mulTo(g2, g[n - 2], g[n]);
				n += 2;
			}
		}
		var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
		i = nbits(e.data[j]) - 1;
		while (j >= 0) {
			if (i >= k1) w = e.data[j] >> i - k1 & km;
			else {
				w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
				if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;
			}
			n = k;
			while ((w & 1) == 0) {
				w >>= 1;
				--n;
			}
			if ((i -= n) < 0) {
				i += this.DB;
				--j;
			}
			if (is1) {
				g[w].copyTo(r);
				is1 = false;
			} else {
				while (n > 1) {
					z$1.sqrTo(r, r2);
					z$1.sqrTo(r2, r);
					n -= 2;
				}
				if (n > 0) z$1.sqrTo(r, r2);
				else {
					t = r;
					r = r2;
					r2 = t;
				}
				z$1.mulTo(r2, g[w], r);
			}
			while (j >= 0 && (e.data[j] & 1 << i) == 0) {
				z$1.sqrTo(r, r2);
				t = r;
				r = r2;
				r2 = t;
				if (--i < 0) {
					i = this.DB - 1;
					--j;
				}
			}
		}
		return z$1.revert(r);
	}
	function bnGCD(a) {
		var x = this.s < 0 ? this.negate() : this.clone();
		var y = a.s < 0 ? a.negate() : a.clone();
		if (x.compareTo(y) < 0) {
			var t = x;
			x = y;
			y = t;
		}
		var i = x.getLowestSetBit(), g = y.getLowestSetBit();
		if (g < 0) return x;
		if (i < g) g = i;
		if (g > 0) {
			x.rShiftTo(g, x);
			y.rShiftTo(g, y);
		}
		while (x.signum() > 0) {
			if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
			if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
			if (x.compareTo(y) >= 0) {
				x.subTo(y, x);
				x.rShiftTo(1, x);
			} else {
				y.subTo(x, y);
				y.rShiftTo(1, y);
			}
		}
		if (g > 0) y.lShiftTo(g, y);
		return y;
	}
	function bnpModInt(n) {
		if (n <= 0) return 0;
		var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
		if (this.t > 0) if (d == 0) r = this.data[0] % n;
		else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
		return r;
	}
	function bnModInverse(m) {
		var ac = m.isEven();
		if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
		var u = m.clone(), v = this.clone();
		var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
		while (u.signum() != 0) {
			while (u.isEven()) {
				u.rShiftTo(1, u);
				if (ac) {
					if (!a.isEven() || !b.isEven()) {
						a.addTo(this, a);
						b.subTo(m, b);
					}
					a.rShiftTo(1, a);
				} else if (!b.isEven()) b.subTo(m, b);
				b.rShiftTo(1, b);
			}
			while (v.isEven()) {
				v.rShiftTo(1, v);
				if (ac) {
					if (!c.isEven() || !d.isEven()) {
						c.addTo(this, c);
						d.subTo(m, d);
					}
					c.rShiftTo(1, c);
				} else if (!d.isEven()) d.subTo(m, d);
				d.rShiftTo(1, d);
			}
			if (u.compareTo(v) >= 0) {
				u.subTo(v, u);
				if (ac) a.subTo(c, a);
				b.subTo(d, b);
			} else {
				v.subTo(u, v);
				if (ac) c.subTo(a, c);
				d.subTo(b, d);
			}
		}
		if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
		if (d.compareTo(m) >= 0) return d.subtract(m);
		if (d.signum() < 0) d.addTo(m, d);
		else return d;
		if (d.signum() < 0) return d.add(m);
		else return d;
	}
	var lowprimes = [
		2,
		3,
		5,
		7,
		11,
		13,
		17,
		19,
		23,
		29,
		31,
		37,
		41,
		43,
		47,
		53,
		59,
		61,
		67,
		71,
		73,
		79,
		83,
		89,
		97,
		101,
		103,
		107,
		109,
		113,
		127,
		131,
		137,
		139,
		149,
		151,
		157,
		163,
		167,
		173,
		179,
		181,
		191,
		193,
		197,
		199,
		211,
		223,
		227,
		229,
		233,
		239,
		241,
		251,
		257,
		263,
		269,
		271,
		277,
		281,
		283,
		293,
		307,
		311,
		313,
		317,
		331,
		337,
		347,
		349,
		353,
		359,
		367,
		373,
		379,
		383,
		389,
		397,
		401,
		409,
		419,
		421,
		431,
		433,
		439,
		443,
		449,
		457,
		461,
		463,
		467,
		479,
		487,
		491,
		499,
		503,
		509
	];
	var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
	function bnIsProbablePrime(t) {
		var i, x = this.abs();
		if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
			for (i = 0; i < lowprimes.length; ++i) if (x.data[0] == lowprimes[i]) return true;
			return false;
		}
		if (x.isEven()) return false;
		i = 1;
		while (i < lowprimes.length) {
			var m = lowprimes[i], j = i + 1;
			while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
			m = x.modInt(m);
			while (i < j) if (m % lowprimes[i++] == 0) return false;
		}
		return x.millerRabin(t);
	}
	function bnpMillerRabin(t) {
		var n1 = this.subtract(BigInteger.ONE);
		var k = n1.getLowestSetBit();
		if (k <= 0) return false;
		var r = n1.shiftRight(k);
		var prng = bnGetPrng();
		var a;
		for (var i = 0; i < t; ++i) {
			do
				a = new BigInteger(this.bitLength(), prng);
			while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
			var y = a.modPow(r, this);
			if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
				var j = 1;
				while (j++ < k && y.compareTo(n1) != 0) {
					y = y.modPowInt(2, this);
					if (y.compareTo(BigInteger.ONE) == 0) return false;
				}
				if (y.compareTo(n1) != 0) return false;
			}
		}
		return true;
	}
	function bnGetPrng() {
		return { nextBytes: function(x) {
			for (var i = 0; i < x.length; ++i) x[i] = Math.floor(Math.random() * 256);
		} };
	}
	BigInteger.prototype.chunkSize = bnpChunkSize;
	BigInteger.prototype.toRadix = bnpToRadix;
	BigInteger.prototype.fromRadix = bnpFromRadix;
	BigInteger.prototype.fromNumber = bnpFromNumber;
	BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	BigInteger.prototype.changeBit = bnpChangeBit;
	BigInteger.prototype.addTo = bnpAddTo;
	BigInteger.prototype.dMultiply = bnpDMultiply;
	BigInteger.prototype.dAddOffset = bnpDAddOffset;
	BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	BigInteger.prototype.modInt = bnpModInt;
	BigInteger.prototype.millerRabin = bnpMillerRabin;
	BigInteger.prototype.clone = bnClone;
	BigInteger.prototype.intValue = bnIntValue;
	BigInteger.prototype.byteValue = bnByteValue;
	BigInteger.prototype.shortValue = bnShortValue;
	BigInteger.prototype.signum = bnSigNum;
	BigInteger.prototype.toByteArray = bnToByteArray;
	BigInteger.prototype.equals = bnEquals;
	BigInteger.prototype.min = bnMin;
	BigInteger.prototype.max = bnMax;
	BigInteger.prototype.and = bnAnd;
	BigInteger.prototype.or = bnOr;
	BigInteger.prototype.xor = bnXor;
	BigInteger.prototype.andNot = bnAndNot;
	BigInteger.prototype.not = bnNot;
	BigInteger.prototype.shiftLeft = bnShiftLeft;
	BigInteger.prototype.shiftRight = bnShiftRight;
	BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	BigInteger.prototype.bitCount = bnBitCount;
	BigInteger.prototype.testBit = bnTestBit;
	BigInteger.prototype.setBit = bnSetBit;
	BigInteger.prototype.clearBit = bnClearBit;
	BigInteger.prototype.flipBit = bnFlipBit;
	BigInteger.prototype.add = bnAdd;
	BigInteger.prototype.subtract = bnSubtract;
	BigInteger.prototype.multiply = bnMultiply;
	BigInteger.prototype.divide = bnDivide;
	BigInteger.prototype.remainder = bnRemainder;
	BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	BigInteger.prototype.modPow = bnModPow;
	BigInteger.prototype.modInverse = bnModInverse;
	BigInteger.prototype.pow = bnPow;
	BigInteger.prototype.gcd = bnGCD;
	BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/sha1.js
var require_sha1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2015 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
	forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
	/**
	* Creates a SHA-1 message digest object.
	*
	* @return a message digest object.
	*/
	sha1.create = function() {
		if (!_initialized) _init();
		var _state = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(80);
		var md = {
			algorithm: "sha1",
			blockLength: 64,
			digestLength: 20,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 8
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength64 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_state = {
				h0: 1732584193,
				h1: 4023233417,
				h2: 2562383102,
				h3: 271733878,
				h4: 3285377520
			};
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_state, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var next, carry;
			var bits = md.fullMessageLength[0] * 8;
			for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
				next = md.fullMessageLength[i + 1] * 8;
				carry = next / 4294967296 >>> 0;
				bits += carry;
				finalBlock.putInt32(bits >>> 0);
				bits = next >>> 0;
			}
			finalBlock.putInt32(bits);
			var s2 = {
				h0: _state.h0,
				h1: _state.h1,
				h2: _state.h2,
				h3: _state.h3,
				h4: _state.h4
			};
			_update(s2, _w, finalBlock);
			var rval = forge.util.createBuffer();
			rval.putInt32(s2.h0);
			rval.putInt32(s2.h1);
			rval.putInt32(s2.h2);
			rval.putInt32(s2.h3);
			rval.putInt32(s2.h4);
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _initialized = false;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 64);
		_initialized = true;
	}
	/**
	* Updates a SHA-1 state with the given byte buffer.
	*
	* @param s the SHA-1 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t, a, b, c, d, e, f, i;
		var len = bytes.length();
		while (len >= 64) {
			a = s.h0;
			b = s.h1;
			c = s.h2;
			d = s.h3;
			e = s.h4;
			for (i = 0; i < 16; ++i) {
				t = bytes.getInt32();
				w[i] = t;
				f = d ^ b & (c ^ d);
				t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 20; ++i) {
				t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
				t = t << 1 | t >>> 31;
				w[i] = t;
				f = d ^ b & (c ^ d);
				t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 32; ++i) {
				t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
				t = t << 1 | t >>> 31;
				w[i] = t;
				f = b ^ c ^ d;
				t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 40; ++i) {
				t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
				t = t << 2 | t >>> 30;
				w[i] = t;
				f = b ^ c ^ d;
				t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 60; ++i) {
				t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
				t = t << 2 | t >>> 30;
				w[i] = t;
				f = b & c | d & (b ^ c);
				t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 80; ++i) {
				t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
				t = t << 2 | t >>> 30;
				w[i] = t;
				f = b ^ c ^ d;
				t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			s.h0 = s.h0 + a | 0;
			s.h1 = s.h1 + b | 0;
			s.h2 = s.h2 + c | 0;
			s.h3 = s.h3 + d | 0;
			s.h4 = s.h4 + e | 0;
			len -= 64;
		}
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pkcs1.js
var require_pkcs1$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Partial implementation of PKCS#1 v2.2: RSA-OEAP
	*
	* Modified but based on the following MIT and BSD licensed code:
	*
	* https://github.com/kjur/jsjws/blob/master/rsa.js:
	*
	* The 'jsjws'(JSON Web Signature JavaScript Library) License
	*
	* Copyright (c) 2012 Kenji Urushima
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to deal
	* in the Software without restriction, including without limitation the rights
	* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	* THE SOFTWARE.
	*
	* http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
	*
	* RSAES-OAEP.js
	* $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
	* JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
	* Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
	* Contact: ellis@nukinetics.com
	* Distributed under the BSD License.
	*
	* Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
	*
	* @author Evan Jones (http://evanjones.ca/)
	* @author Dave Longley
	*
	* Copyright (c) 2013-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	require_random();
	require_sha1();
	var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
	/**
	* Encode the given RSAES-OAEP message (M) using key, with optional label (L)
	* and seed.
	*
	* This method does not perform RSA encryption, it only encodes the message
	* using RSAES-OAEP.
	*
	* @param key the RSA key to use.
	* @param message the message to encode.
	* @param options the options to use:
	*          label an optional label to use.
	*          seed the seed to use.
	*          md the message digest object to use, undefined for SHA-1.
	*          mgf1 optional mgf1 parameters:
	*            md the message digest object to use for MGF1.
	*
	* @return the encoded message bytes.
	*/
	pkcs1.encode_rsa_oaep = function(key, message, options) {
		var label;
		var seed;
		var md;
		var mgf1Md;
		if (typeof options === "string") {
			label = options;
			seed = arguments[3] || void 0;
			md = arguments[4] || void 0;
		} else if (options) {
			label = options.label || void 0;
			seed = options.seed || void 0;
			md = options.md || void 0;
			if (options.mgf1 && options.mgf1.md) mgf1Md = options.mgf1.md;
		}
		if (!md) md = forge.md.sha1.create();
		else md.start();
		if (!mgf1Md) mgf1Md = md;
		var keyLength = Math.ceil(key.n.bitLength() / 8);
		var maxLength = keyLength - 2 * md.digestLength - 2;
		if (message.length > maxLength) {
			var error$47 = /* @__PURE__ */ new Error("RSAES-OAEP input message length is too long.");
			error$47.length = message.length;
			error$47.maxLength = maxLength;
			throw error$47;
		}
		if (!label) label = "";
		md.update(label, "raw");
		var lHash = md.digest();
		var PS = "";
		var PS_length = maxLength - message.length;
		for (var i = 0; i < PS_length; i++) PS += "\0";
		var DB = lHash.getBytes() + PS + "" + message;
		if (!seed) seed = forge.random.getBytes(md.digestLength);
		else if (seed.length !== md.digestLength) {
			var error$47 = /* @__PURE__ */ new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
			error$47.seedLength = seed.length;
			error$47.digestLength = md.digestLength;
			throw error$47;
		}
		var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
		var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
		var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
		return "\0" + forge.util.xorBytes(seed, seedMask, seed.length) + maskedDB;
	};
	/**
	* Decode the given RSAES-OAEP encoded message (EM) using key, with optional
	* label (L).
	*
	* This method does not perform RSA decryption, it only decodes the message
	* using RSAES-OAEP.
	*
	* @param key the RSA key to use.
	* @param em the encoded message to decode.
	* @param options the options to use:
	*          label an optional label to use.
	*          md the message digest object to use for OAEP, undefined for SHA-1.
	*          mgf1 optional mgf1 parameters:
	*            md the message digest object to use for MGF1.
	*
	* @return the decoded message bytes.
	*/
	pkcs1.decode_rsa_oaep = function(key, em, options) {
		var label;
		var md;
		var mgf1Md;
		if (typeof options === "string") {
			label = options;
			md = arguments[3] || void 0;
		} else if (options) {
			label = options.label || void 0;
			md = options.md || void 0;
			if (options.mgf1 && options.mgf1.md) mgf1Md = options.mgf1.md;
		}
		var keyLength = Math.ceil(key.n.bitLength() / 8);
		if (em.length !== keyLength) {
			var error$47 = /* @__PURE__ */ new Error("RSAES-OAEP encoded message length is invalid.");
			error$47.length = em.length;
			error$47.expectedLength = keyLength;
			throw error$47;
		}
		if (md === void 0) md = forge.md.sha1.create();
		else md.start();
		if (!mgf1Md) mgf1Md = md;
		if (keyLength < 2 * md.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
		if (!label) label = "";
		md.update(label, "raw");
		var lHash = md.digest().getBytes();
		var y = em.charAt(0);
		var maskedSeed = em.substring(1, md.digestLength + 1);
		var maskedDB = em.substring(1 + md.digestLength);
		var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
		var dbMask = rsa_mgf1(forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length), keyLength - md.digestLength - 1, mgf1Md);
		var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
		var lHashPrime = db.substring(0, md.digestLength);
		var error$47 = y !== "\0";
		for (var i = 0; i < md.digestLength; ++i) error$47 |= lHash.charAt(i) !== lHashPrime.charAt(i);
		var in_ps = 1;
		var index = md.digestLength;
		for (var j = md.digestLength; j < db.length; j++) {
			var code = db.charCodeAt(j);
			var is_0 = code & 1 ^ 1;
			error$47 |= code & (in_ps ? 65534 : 0);
			in_ps = in_ps & is_0;
			index += in_ps;
		}
		if (error$47 || db.charCodeAt(index) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
		return db.substring(index + 1);
	};
	function rsa_mgf1(seed, maskLength, hash$1) {
		if (!hash$1) hash$1 = forge.md.sha1.create();
		var t = "";
		var count = Math.ceil(maskLength / hash$1.digestLength);
		for (var i = 0; i < count; ++i) {
			var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
			hash$1.start();
			hash$1.update(seed + c);
			t += hash$1.digest().getBytes();
		}
		return t.substring(0, maskLength);
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/prime.js
var require_prime = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Prime number generation API.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	require_jsbn$1();
	require_random();
	(function() {
		if (forge.prime) {
			module.exports = forge.prime;
			return;
		}
		var prime = module.exports = forge.prime = forge.prime || {};
		var BigInteger = forge.jsbn.BigInteger;
		var GCD_30_DELTA = [
			6,
			4,
			2,
			4,
			2,
			4,
			6,
			2
		];
		var THIRTY = new BigInteger(null);
		THIRTY.fromInt(30);
		var op_or = function(x, y) {
			return x | y;
		};
		/**
		* Generates a random probable prime with the given number of bits.
		*
		* Alternative algorithms can be specified by name as a string or as an
		* object with custom options like so:
		*
		* {
		*   name: 'PRIMEINC',
		*   options: {
		*     maxBlockTime: <the maximum amount of time to block the main
		*       thread before allowing I/O other JS to run>,
		*     millerRabinTests: <the number of miller-rabin tests to run>,
		*     workerScript: <the worker script URL>,
		*     workers: <the number of web workers (if supported) to use,
		*       -1 to use estimated cores minus one>.
		*     workLoad: the size of the work load, ie: number of possible prime
		*       numbers for each web worker to check per work assignment,
		*       (default: 100).
		*   }
		* }
		*
		* @param bits the number of bits for the prime number.
		* @param options the options to use.
		*          [algorithm] the algorithm to use (default: 'PRIMEINC').
		*          [prng] a custom crypto-secure pseudo-random number generator to use,
		*            that must define "getBytesSync".
		*
		* @return callback(err, num) called once the operation completes.
		*/
		prime.generateProbablePrime = function(bits, options, callback$1) {
			if (typeof options === "function") {
				callback$1 = options;
				options = {};
			}
			options = options || {};
			var algorithm = options.algorithm || "PRIMEINC";
			if (typeof algorithm === "string") algorithm = { name: algorithm };
			algorithm.options = algorithm.options || {};
			var prng = options.prng || forge.random;
			var rng$1 = { nextBytes: function(x) {
				var b = prng.getBytesSync(x.length);
				for (var i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
			} };
			if (algorithm.name === "PRIMEINC") return primeincFindPrime(bits, rng$1, algorithm.options, callback$1);
			throw new Error("Invalid prime generation algorithm: " + algorithm.name);
		};
		function primeincFindPrime(bits, rng$1, options, callback$1) {
			if ("workers" in options) return primeincFindPrimeWithWorkers(bits, rng$1, options, callback$1);
			return primeincFindPrimeWithoutWorkers(bits, rng$1, options, callback$1);
		}
		function primeincFindPrimeWithoutWorkers(bits, rng$1, options, callback$1) {
			var num = generateRandom(bits, rng$1);
			var deltaIdx = 0;
			var mrTests = getMillerRabinTests(num.bitLength());
			if ("millerRabinTests" in options) mrTests = options.millerRabinTests;
			var maxBlockTime = 10;
			if ("maxBlockTime" in options) maxBlockTime = options.maxBlockTime;
			_primeinc(num, bits, rng$1, deltaIdx, mrTests, maxBlockTime, callback$1);
		}
		function _primeinc(num, bits, rng$1, deltaIdx, mrTests, maxBlockTime, callback$1) {
			var start = +/* @__PURE__ */ new Date();
			do {
				if (num.bitLength() > bits) num = generateRandom(bits, rng$1);
				if (num.isProbablePrime(mrTests)) return callback$1(null, num);
				num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
			} while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
			forge.util.setImmediate(function() {
				_primeinc(num, bits, rng$1, deltaIdx, mrTests, maxBlockTime, callback$1);
			});
		}
		function primeincFindPrimeWithWorkers(bits, rng$1, options, callback$1) {
			if (typeof Worker === "undefined") return primeincFindPrimeWithoutWorkers(bits, rng$1, options, callback$1);
			var num = generateRandom(bits, rng$1);
			var numWorkers = options.workers;
			var workLoad = options.workLoad || 100;
			var range = workLoad * 30 / 8;
			var workerScript = options.workerScript || "forge/prime.worker.js";
			if (numWorkers === -1) return forge.util.estimateCores(function(err, cores) {
				if (err) cores = 2;
				numWorkers = cores - 1;
				generate();
			});
			generate();
			function generate() {
				numWorkers = Math.max(1, numWorkers);
				var workers = [];
				for (var i = 0; i < numWorkers; ++i) workers[i] = new Worker(workerScript);
				var running = numWorkers;
				for (var i = 0; i < numWorkers; ++i) workers[i].addEventListener("message", workerMessage);
				var found = false;
				function workerMessage(e) {
					if (found) return;
					--running;
					var data = e.data;
					if (data.found) {
						for (var i$1 = 0; i$1 < workers.length; ++i$1) workers[i$1].terminate();
						found = true;
						return callback$1(null, new BigInteger(data.prime, 16));
					}
					if (num.bitLength() > bits) num = generateRandom(bits, rng$1);
					var hex$2 = num.toString(16);
					e.target.postMessage({
						hex: hex$2,
						workLoad
					});
					num.dAddOffset(range, 0);
				}
			}
		}
		/**
		* Generates a random number using the given number of bits and RNG.
		*
		* @param bits the number of bits for the number.
		* @param rng the random number generator to use.
		*
		* @return the random number.
		*/
		function generateRandom(bits, rng$1) {
			var num = new BigInteger(bits, rng$1);
			var bits1 = bits - 1;
			if (!num.testBit(bits1)) num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
			num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
			return num;
		}
		/**
		* Returns the required number of Miller-Rabin tests to generate a
		* prime with an error probability of (1/2)^80.
		*
		* See Handbook of Applied Cryptography Chapter 4, Table 4.4.
		*
		* @param bits the bit size.
		*
		* @return the required number of iterations.
		*/
		function getMillerRabinTests(bits) {
			if (bits <= 100) return 27;
			if (bits <= 150) return 18;
			if (bits <= 200) return 15;
			if (bits <= 250) return 12;
			if (bits <= 300) return 9;
			if (bits <= 350) return 8;
			if (bits <= 400) return 7;
			if (bits <= 500) return 6;
			if (bits <= 600) return 5;
			if (bits <= 800) return 4;
			if (bits <= 1250) return 3;
			return 2;
		}
	})();
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/rsa.js
var require_rsa$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of basic RSA algorithms.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*
	* The only algorithm currently supported for PKI is RSA.
	*
	* An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
	* ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
	* and a subjectPublicKey of type bit string.
	*
	* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
	* for the algorithm, if any. In the case of RSA, there aren't any.
	*
	* SubjectPublicKeyInfo ::= SEQUENCE {
	*   algorithm AlgorithmIdentifier,
	*   subjectPublicKey BIT STRING
	* }
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*   algorithm OBJECT IDENTIFIER,
	*   parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* For an RSA public key, the subjectPublicKey is:
	*
	* RSAPublicKey ::= SEQUENCE {
	*   modulus            INTEGER,    -- n
	*   publicExponent     INTEGER     -- e
	* }
	*
	* PrivateKeyInfo ::= SEQUENCE {
	*   version                   Version,
	*   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
	*   privateKey                PrivateKey,
	*   attributes           [0]  IMPLICIT Attributes OPTIONAL
	* }
	*
	* Version ::= INTEGER
	* PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
	* PrivateKey ::= OCTET STRING
	* Attributes ::= SET OF Attribute
	*
	* An RSA private key as the following structure:
	*
	* RSAPrivateKey ::= SEQUENCE {
	*   version Version,
	*   modulus INTEGER, -- n
	*   publicExponent INTEGER, -- e
	*   privateExponent INTEGER, -- d
	*   prime1 INTEGER, -- p
	*   prime2 INTEGER, -- q
	*   exponent1 INTEGER, -- d mod (p-1)
	*   exponent2 INTEGER, -- d mod (q-1)
	*   coefficient INTEGER -- (inverse of q) mod p
	* }
	*
	* Version ::= INTEGER
	*
	* The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
	*/
	var forge = require_forge();
	require_asn1();
	require_jsbn$1();
	require_oids();
	require_pkcs1$2();
	require_prime();
	require_random();
	require_util();
	if (typeof BigInteger === "undefined") var BigInteger = forge.jsbn.BigInteger;
	var _crypto = forge.util.isNodejs ? __require("crypto") : null;
	var asn1 = forge.asn1;
	var util = forge.util;
	forge.pki = forge.pki || {};
	module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
	var pki = forge.pki;
	var GCD_30_DELTA = [
		6,
		4,
		2,
		4,
		2,
		4,
		6,
		2
	];
	var privateKeyValidator = {
		name: "PrivateKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "PrivateKeyInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyVersion"
			},
			{
				name: "PrivateKeyInfo.privateKeyAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "AlgorithmIdentifier.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "privateKeyOid"
				}]
			},
			{
				name: "PrivateKeyInfo",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "privateKey"
			}
		]
	};
	var rsaPrivateKeyValidator = {
		name: "RSAPrivateKey",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "RSAPrivateKey.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyVersion"
			},
			{
				name: "RSAPrivateKey.modulus",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyModulus"
			},
			{
				name: "RSAPrivateKey.publicExponent",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPublicExponent"
			},
			{
				name: "RSAPrivateKey.privateExponent",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPrivateExponent"
			},
			{
				name: "RSAPrivateKey.prime1",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPrime1"
			},
			{
				name: "RSAPrivateKey.prime2",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPrime2"
			},
			{
				name: "RSAPrivateKey.exponent1",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyExponent1"
			},
			{
				name: "RSAPrivateKey.exponent2",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyExponent2"
			},
			{
				name: "RSAPrivateKey.coefficient",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyCoefficient"
			}
		]
	};
	var rsaPublicKeyValidator = {
		name: "RSAPublicKey",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "RSAPublicKey.modulus",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "publicKeyModulus"
		}, {
			name: "RSAPublicKey.exponent",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "publicKeyExponent"
		}]
	};
	var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
		name: "SubjectPublicKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "subjectPublicKeyInfo",
		value: [{
			name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "AlgorithmIdentifier.algorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "publicKeyOid"
			}]
		}, {
			name: "SubjectPublicKeyInfo.subjectPublicKey",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.BITSTRING,
			constructed: false,
			value: [{
				name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				optional: true,
				captureAsn1: "rsaPublicKey"
			}]
		}]
	};
	var digestInfoValidator = {
		name: "DigestInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "DigestInfo.DigestAlgorithm",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "algorithmIdentifier"
			}, {
				name: "DigestInfo.DigestAlgorithm.parameters",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.NULL,
				capture: "parameters",
				optional: true,
				constructed: false
			}]
		}, {
			name: "DigestInfo.digest",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OCTETSTRING,
			constructed: false,
			capture: "digest"
		}]
	};
	/**
	* Wrap digest in DigestInfo object.
	*
	* This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
	*
	* DigestInfo ::= SEQUENCE {
	*   digestAlgorithm DigestAlgorithmIdentifier,
	*   digest Digest
	* }
	*
	* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
	* Digest ::= OCTET STRING
	*
	* @param md the message digest object with the hash to sign.
	*
	* @return the encoded message (ready for RSA encryption)
	*/
	var emsaPkcs1v15encode = function(md) {
		var oid;
		if (md.algorithm in pki.oids) oid = pki.oids[md.algorithm];
		else {
			var error$47 = /* @__PURE__ */ new Error("Unknown message digest algorithm.");
			error$47.algorithm = md.algorithm;
			throw error$47;
		}
		var oidBytes = asn1.oidToDer(oid).getBytes();
		var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
		digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
		var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
		digestInfo.value.push(digestAlgorithm);
		digestInfo.value.push(digest);
		return asn1.toDer(digestInfo).getBytes();
	};
	/**
	* Performs x^c mod n (RSA encryption or decryption operation).
	*
	* @param x the number to raise and mod.
	* @param key the key to use.
	* @param pub true if the key is public, false if private.
	*
	* @return the result of x^c mod n.
	*/
	var _modPow = function(x, key, pub) {
		if (pub) return x.modPow(key.e, key.n);
		if (!key.p || !key.q) return x.modPow(key.d, key.n);
		if (!key.dP) key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
		if (!key.dQ) key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
		if (!key.qInv) key.qInv = key.q.modInverse(key.p);
		var r;
		do
			r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
		while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
		x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
		var xp = x.mod(key.p).modPow(key.dP, key.p);
		var xq = x.mod(key.q).modPow(key.dQ, key.q);
		while (xp.compareTo(xq) < 0) xp = xp.add(key.p);
		var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
		y = y.multiply(r.modInverse(key.n)).mod(key.n);
		return y;
	};
	/**
	* NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
	* 'encrypt' on a public key object instead.
	*
	* Performs RSA encryption.
	*
	* The parameter bt controls whether to put padding bytes before the
	* message passed in. Set bt to either true or false to disable padding
	* completely (in order to handle e.g. EMSA-PSS encoding separately before),
	* signaling whether the encryption operation is a public key operation
	* (i.e. encrypting data) or not, i.e. private key operation (data signing).
	*
	* For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
	* (for signing) or 0x02 (for encryption). The key operation mode (private
	* or public) is derived from this flag in that case).
	*
	* @param m the message to encrypt as a byte string.
	* @param key the RSA key to use.
	* @param bt for PKCS#1 v1.5 padding, the block type to use
	*   (0x01 for private key, 0x02 for public),
	*   to disable padding: true = public key, false = private key.
	*
	* @return the encrypted bytes as a string.
	*/
	pki.rsa.encrypt = function(m, key, bt) {
		var pub = bt;
		var eb;
		var k = Math.ceil(key.n.bitLength() / 8);
		if (bt !== false && bt !== true) {
			pub = bt === 2;
			eb = _encodePkcs1_v1_5(m, key, bt);
		} else {
			eb = forge.util.createBuffer();
			eb.putBytes(m);
		}
		var yhex = _modPow(new BigInteger(eb.toHex(), 16), key, pub).toString(16);
		var ed = forge.util.createBuffer();
		var zeros = k - Math.ceil(yhex.length / 2);
		while (zeros > 0) {
			ed.putByte(0);
			--zeros;
		}
		ed.putBytes(forge.util.hexToBytes(yhex));
		return ed.getBytes();
	};
	/**
	* NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
	* 'verify' on a public key object instead.
	*
	* Performs RSA decryption.
	*
	* The parameter ml controls whether to apply PKCS#1 v1.5 padding
	* or not.  Set ml = false to disable padding removal completely
	* (in order to handle e.g. EMSA-PSS later on) and simply pass back
	* the RSA encryption block.
	*
	* @param ed the encrypted data to decrypt in as a byte string.
	* @param key the RSA key to use.
	* @param pub true for a public key operation, false for private.
	* @param ml the message length, if known, false to disable padding.
	*
	* @return the decrypted message as a byte string.
	*/
	pki.rsa.decrypt = function(ed, key, pub, ml) {
		var k = Math.ceil(key.n.bitLength() / 8);
		if (ed.length !== k) {
			var error$47 = /* @__PURE__ */ new Error("Encrypted message length is invalid.");
			error$47.length = ed.length;
			error$47.expected = k;
			throw error$47;
		}
		var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
		if (y.compareTo(key.n) >= 0) throw new Error("Encrypted message is invalid.");
		var xhex = _modPow(y, key, pub).toString(16);
		var eb = forge.util.createBuffer();
		var zeros = k - Math.ceil(xhex.length / 2);
		while (zeros > 0) {
			eb.putByte(0);
			--zeros;
		}
		eb.putBytes(forge.util.hexToBytes(xhex));
		if (ml !== false) return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
		return eb.getBytes();
	};
	/**
	* Creates an RSA key-pair generation state object. It is used to allow
	* key-generation to be performed in steps. It also allows for a UI to
	* display progress updates.
	*
	* @param bits the size for the private key in bits, defaults to 2048.
	* @param e the public exponent to use, defaults to 65537 (0x10001).
	* @param [options] the options to use.
	*          prng a custom crypto-secure pseudo-random number generator to use,
	*            that must define "getBytesSync".
	*          algorithm the algorithm to use (default: 'PRIMEINC').
	*
	* @return the state object to use to generate the key-pair.
	*/
	pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
		if (typeof bits === "string") bits = parseInt(bits, 10);
		bits = bits || 2048;
		options = options || {};
		var prng = options.prng || forge.random;
		var rng$1 = { nextBytes: function(x) {
			var b = prng.getBytesSync(x.length);
			for (var i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
		} };
		var algorithm = options.algorithm || "PRIMEINC";
		var rval;
		if (algorithm === "PRIMEINC") {
			rval = {
				algorithm,
				state: 0,
				bits,
				rng: rng$1,
				eInt: e || 65537,
				e: new BigInteger(null),
				p: null,
				q: null,
				qBits: bits >> 1,
				pBits: bits - (bits >> 1),
				pqState: 0,
				num: null,
				keys: null
			};
			rval.e.fromInt(rval.eInt);
		} else throw new Error("Invalid key generation algorithm: " + algorithm);
		return rval;
	};
	/**
	* Attempts to runs the key-generation algorithm for at most n seconds
	* (approximately) using the given state. When key-generation has completed,
	* the keys will be stored in state.keys.
	*
	* To use this function to update a UI while generating a key or to prevent
	* causing browser lockups/warnings, set "n" to a value other than 0. A
	* simple pattern for generating a key and showing a progress indicator is:
	*
	* var state = pki.rsa.createKeyPairGenerationState(2048);
	* var step = function() {
	*   // step key-generation, run algorithm for 100 ms, repeat
	*   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
	*     setTimeout(step, 1);
	*   } else {
	*     // key-generation complete
	*     // TODO: turn off progress indicator here
	*     // TODO: use the generated key-pair in "state.keys"
	*   }
	* };
	* // TODO: turn on progress indicator here
	* setTimeout(step, 0);
	*
	* @param state the state to use.
	* @param n the maximum number of milliseconds to run the algorithm for, 0
	*          to run the algorithm to completion.
	*
	* @return true if the key-generation completed, false if not.
	*/
	pki.rsa.stepKeyPairGenerationState = function(state, n) {
		if (!("algorithm" in state)) state.algorithm = "PRIMEINC";
		var THIRTY = new BigInteger(null);
		THIRTY.fromInt(30);
		var deltaIdx = 0;
		var op_or = function(x, y) {
			return x | y;
		};
		var t1 = +/* @__PURE__ */ new Date();
		var t2;
		var total = 0;
		while (state.keys === null && (n <= 0 || total < n)) {
			if (state.state === 0) {
				var bits = state.p === null ? state.pBits : state.qBits;
				var bits1 = bits - 1;
				if (state.pqState === 0) {
					state.num = new BigInteger(bits, state.rng);
					if (!state.num.testBit(bits1)) state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
					state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
					deltaIdx = 0;
					++state.pqState;
				} else if (state.pqState === 1) if (state.num.bitLength() > bits) state.pqState = 0;
				else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) ++state.pqState;
				else state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
				else if (state.pqState === 2) state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
				else if (state.pqState === 3) {
					state.pqState = 0;
					if (state.p === null) state.p = state.num;
					else state.q = state.num;
					if (state.p !== null && state.q !== null) ++state.state;
					state.num = null;
				}
			} else if (state.state === 1) {
				if (state.p.compareTo(state.q) < 0) {
					state.num = state.p;
					state.p = state.q;
					state.q = state.num;
				}
				++state.state;
			} else if (state.state === 2) {
				state.p1 = state.p.subtract(BigInteger.ONE);
				state.q1 = state.q.subtract(BigInteger.ONE);
				state.phi = state.p1.multiply(state.q1);
				++state.state;
			} else if (state.state === 3) if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) ++state.state;
			else {
				state.p = null;
				state.q = null;
				state.state = 0;
			}
			else if (state.state === 4) {
				state.n = state.p.multiply(state.q);
				if (state.n.bitLength() === state.bits) ++state.state;
				else {
					state.q = null;
					state.state = 0;
				}
			} else if (state.state === 5) {
				var d = state.e.modInverse(state.phi);
				state.keys = {
					privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
					publicKey: pki.rsa.setPublicKey(state.n, state.e)
				};
			}
			t2 = +/* @__PURE__ */ new Date();
			total += t2 - t1;
			t1 = t2;
		}
		return state.keys !== null;
	};
	/**
	* Generates an RSA public-private key pair in a single call.
	*
	* To generate a key-pair in steps (to allow for progress updates and to
	* prevent blocking or warnings in slow browsers) then use the key-pair
	* generation state functions.
	*
	* To generate a key-pair asynchronously (either through web-workers, if
	* available, or by breaking up the work on the main thread), pass a
	* callback function.
	*
	* @param [bits] the size for the private key in bits, defaults to 2048.
	* @param [e] the public exponent to use, defaults to 65537.
	* @param [options] options for key-pair generation, if given then 'bits'
	*            and 'e' must *not* be given:
	*          bits the size for the private key in bits, (default: 2048).
	*          e the public exponent to use, (default: 65537 (0x10001)).
	*          workerScript the worker script URL.
	*          workers the number of web workers (if supported) to use,
	*            (default: 2).
	*          workLoad the size of the work load, ie: number of possible prime
	*            numbers for each web worker to check per work assignment,
	*            (default: 100).
	*          prng a custom crypto-secure pseudo-random number generator to use,
	*            that must define "getBytesSync". Disables use of native APIs.
	*          algorithm the algorithm to use (default: 'PRIMEINC').
	* @param [callback(err, keypair)] called once the operation completes.
	*
	* @return an object with privateKey and publicKey properties.
	*/
	pki.rsa.generateKeyPair = function(bits, e, options, callback$1) {
		if (arguments.length === 1) {
			if (typeof bits === "object") {
				options = bits;
				bits = void 0;
			} else if (typeof bits === "function") {
				callback$1 = bits;
				bits = void 0;
			}
		} else if (arguments.length === 2) if (typeof bits === "number") {
			if (typeof e === "function") {
				callback$1 = e;
				e = void 0;
			} else if (typeof e !== "number") {
				options = e;
				e = void 0;
			}
		} else {
			options = bits;
			callback$1 = e;
			bits = void 0;
			e = void 0;
		}
		else if (arguments.length === 3) if (typeof e === "number") {
			if (typeof options === "function") {
				callback$1 = options;
				options = void 0;
			}
		} else {
			callback$1 = options;
			options = e;
			e = void 0;
		}
		options = options || {};
		if (bits === void 0) bits = options.bits || 2048;
		if (e === void 0) e = options.e || 65537;
		if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
			if (callback$1) {
				if (_detectNodeCrypto("generateKeyPair")) return _crypto.generateKeyPair("rsa", {
					modulusLength: bits,
					publicExponent: e,
					publicKeyEncoding: {
						type: "spki",
						format: "pem"
					},
					privateKeyEncoding: {
						type: "pkcs8",
						format: "pem"
					}
				}, function(err, pub, priv) {
					if (err) return callback$1(err);
					callback$1(null, {
						privateKey: pki.privateKeyFromPem(priv),
						publicKey: pki.publicKeyFromPem(pub)
					});
				});
				if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) return util.globalScope.crypto.subtle.generateKey({
					name: "RSASSA-PKCS1-v1_5",
					modulusLength: bits,
					publicExponent: _intToUint8Array(e),
					hash: { name: "SHA-256" }
				}, true, ["sign", "verify"]).then(function(pair) {
					return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
				}).then(void 0, function(err) {
					callback$1(err);
				}).then(function(pkcs8) {
					if (pkcs8) {
						var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
						callback$1(null, {
							privateKey,
							publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
						});
					}
				});
				if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
					var genOp = util.globalScope.msCrypto.subtle.generateKey({
						name: "RSASSA-PKCS1-v1_5",
						modulusLength: bits,
						publicExponent: _intToUint8Array(e),
						hash: { name: "SHA-256" }
					}, true, ["sign", "verify"]);
					genOp.oncomplete = function(e$1) {
						var pair = e$1.target.result;
						var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
						exportOp.oncomplete = function(e$2) {
							var pkcs8 = e$2.target.result;
							var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
							callback$1(null, {
								privateKey,
								publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
							});
						};
						exportOp.onerror = function(err) {
							callback$1(err);
						};
					};
					genOp.onerror = function(err) {
						callback$1(err);
					};
					return;
				}
			} else if (_detectNodeCrypto("generateKeyPairSync")) {
				var keypair = _crypto.generateKeyPairSync("rsa", {
					modulusLength: bits,
					publicExponent: e,
					publicKeyEncoding: {
						type: "spki",
						format: "pem"
					},
					privateKeyEncoding: {
						type: "pkcs8",
						format: "pem"
					}
				});
				return {
					privateKey: pki.privateKeyFromPem(keypair.privateKey),
					publicKey: pki.publicKeyFromPem(keypair.publicKey)
				};
			}
		}
		var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
		if (!callback$1) {
			pki.rsa.stepKeyPairGenerationState(state, 0);
			return state.keys;
		}
		_generateKeyPair(state, options, callback$1);
	};
	/**
	* Sets an RSA public key from BigIntegers modulus and exponent.
	*
	* @param n the modulus.
	* @param e the exponent.
	*
	* @return the public key.
	*/
	pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
		var key = {
			n,
			e
		};
		/**
		* Encrypts the given data with this public key. Newer applications
		* should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
		* legacy applications.
		*
		* @param data the byte string to encrypt.
		* @param scheme the encryption scheme to use:
		*          'RSAES-PKCS1-V1_5' (default),
		*          'RSA-OAEP',
		*          'RAW', 'NONE', or null to perform raw RSA encryption,
		*          an object with an 'encode' property set to a function
		*          with the signature 'function(data, key)' that returns
		*          a binary-encoded string representing the encoded data.
		* @param schemeOptions any scheme-specific options.
		*
		* @return the encrypted byte string.
		*/
		key.encrypt = function(data, scheme, schemeOptions) {
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			else if (scheme === void 0) scheme = "RSAES-PKCS1-V1_5";
			if (scheme === "RSAES-PKCS1-V1_5") scheme = { encode: function(m, key$1, pub) {
				return _encodePkcs1_v1_5(m, key$1, 2).getBytes();
			} };
			else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = { encode: function(m, key$1) {
				return forge.pkcs1.encode_rsa_oaep(key$1, m, schemeOptions);
			} };
			else if ([
				"RAW",
				"NONE",
				"NULL",
				null
			].indexOf(scheme) !== -1) scheme = { encode: function(e$2) {
				return e$2;
			} };
			else if (typeof scheme === "string") throw new Error("Unsupported encryption scheme: \"" + scheme + "\".");
			var e$1 = scheme.encode(data, key, true);
			return pki.rsa.encrypt(e$1, key, true);
		};
		/**
		* Verifies the given signature against the given digest.
		*
		* PKCS#1 supports multiple (currently two) signature schemes:
		* RSASSA-PKCS1-V1_5 and RSASSA-PSS.
		*
		* By default this implementation uses the "old scheme", i.e.
		* RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
		* signature is an OCTET STRING that holds a DigestInfo.
		*
		* DigestInfo ::= SEQUENCE {
		*   digestAlgorithm DigestAlgorithmIdentifier,
		*   digest Digest
		* }
		* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
		* Digest ::= OCTET STRING
		*
		* To perform PSS signature verification, provide an instance
		* of Forge PSS object as the scheme parameter.
		*
		* @param digest the message digest hash to compare against the signature,
		*          as a binary-encoded string.
		* @param signature the signature to verify, as a binary-encoded string.
		* @param scheme signature verification scheme to use:
		*          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
		*          a Forge PSS object for RSASSA-PSS,
		*          'NONE' or null for none, DigestInfo will not be expected, but
		*            PKCS#1 v1.5 padding will still be used.
		* @param options optional verify options
		*          _parseAllDigestBytes testing flag to control parsing of all
		*            digest bytes. Unsupported and not for general usage.
		*            (default: true)
		*
		* @return true if the signature was verified, false if not.
		*/
		key.verify = function(digest, signature, scheme, options) {
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			else if (scheme === void 0) scheme = "RSASSA-PKCS1-V1_5";
			if (options === void 0) options = { _parseAllDigestBytes: true };
			if (!("_parseAllDigestBytes" in options)) options._parseAllDigestBytes = true;
			if (scheme === "RSASSA-PKCS1-V1_5") scheme = { verify: function(digest$1, d$1) {
				d$1 = _decodePkcs1_v1_5(d$1, key, true);
				var obj = asn1.fromDer(d$1, { parseAllBytes: options._parseAllDigestBytes });
				var capture = {};
				var errors = [];
				if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
					var error$47 = /* @__PURE__ */ new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
					error$47.errors = errors;
					throw error$47;
				}
				var oid = asn1.derToOid(capture.algorithmIdentifier);
				if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
					var error$47 = /* @__PURE__ */ new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
					error$47.oid = oid;
					throw error$47;
				}
				if (oid === forge.oids.md2 || oid === forge.oids.md5) {
					if (!("parameters" in capture)) throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters.");
				}
				return digest$1 === capture.digest;
			} };
			else if (scheme === "NONE" || scheme === "NULL" || scheme === null) scheme = { verify: function(digest$1, d$1) {
				d$1 = _decodePkcs1_v1_5(d$1, key, true);
				return digest$1 === d$1;
			} };
			var d = pki.rsa.decrypt(signature, key, true, false);
			return scheme.verify(digest, d, key.n.bitLength());
		};
		return key;
	};
	/**
	* Sets an RSA private key from BigIntegers modulus, exponent, primes,
	* prime exponents, and modular multiplicative inverse.
	*
	* @param n the modulus.
	* @param e the public exponent.
	* @param d the private exponent ((inverse of e) mod n).
	* @param p the first prime.
	* @param q the second prime.
	* @param dP exponent1 (d mod (p-1)).
	* @param dQ exponent2 (d mod (q-1)).
	* @param qInv ((inverse of q) mod p)
	*
	* @return the private key.
	*/
	pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
		var key = {
			n,
			e,
			d,
			p,
			q,
			dP,
			dQ,
			qInv
		};
		/**
		* Decrypts the given data with this private key. The decryption scheme
		* must match the one used to encrypt the data.
		*
		* @param data the byte string to decrypt.
		* @param scheme the decryption scheme to use:
		*          'RSAES-PKCS1-V1_5' (default),
		*          'RSA-OAEP',
		*          'RAW', 'NONE', or null to perform raw RSA decryption.
		* @param schemeOptions any scheme-specific options.
		*
		* @return the decrypted byte string.
		*/
		key.decrypt = function(data, scheme, schemeOptions) {
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			else if (scheme === void 0) scheme = "RSAES-PKCS1-V1_5";
			var d$1 = pki.rsa.decrypt(data, key, false, false);
			if (scheme === "RSAES-PKCS1-V1_5") scheme = { decode: _decodePkcs1_v1_5 };
			else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = { decode: function(d$2, key$1) {
				return forge.pkcs1.decode_rsa_oaep(key$1, d$2, schemeOptions);
			} };
			else if ([
				"RAW",
				"NONE",
				"NULL",
				null
			].indexOf(scheme) !== -1) scheme = { decode: function(d$2) {
				return d$2;
			} };
			else throw new Error("Unsupported encryption scheme: \"" + scheme + "\".");
			return scheme.decode(d$1, key, false);
		};
		/**
		* Signs the given digest, producing a signature.
		*
		* PKCS#1 supports multiple (currently two) signature schemes:
		* RSASSA-PKCS1-V1_5 and RSASSA-PSS.
		*
		* By default this implementation uses the "old scheme", i.e.
		* RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
		* an instance of Forge PSS object as the scheme parameter.
		*
		* @param md the message digest object with the hash to sign.
		* @param scheme the signature scheme to use:
		*          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
		*          a Forge PSS object for RSASSA-PSS,
		*          'NONE' or null for none, DigestInfo will not be used but
		*            PKCS#1 v1.5 padding will still be used.
		*
		* @return the signature as a byte string.
		*/
		key.sign = function(md, scheme) {
			var bt = false;
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
				scheme = { encode: emsaPkcs1v15encode };
				bt = 1;
			} else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
				scheme = { encode: function() {
					return md;
				} };
				bt = 1;
			}
			var d$1 = scheme.encode(md, key.n.bitLength());
			return pki.rsa.encrypt(d$1, key, bt);
		};
		return key;
	};
	/**
	* Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
	*
	* @param rsaKey the ASN.1 RSAPrivateKey.
	*
	* @return the ASN.1 PrivateKeyInfo.
	*/
	pki.wrapRsaPrivateKey = function(rsaKey) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
		]);
	};
	/**
	* Converts a private key from an ASN.1 object.
	*
	* @param obj the ASN.1 representation of a PrivateKeyInfo containing an
	*          RSAPrivateKey or an RSAPrivateKey.
	*
	* @return the private key.
	*/
	pki.privateKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (asn1.validate(obj, privateKeyValidator, capture, errors)) obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
		capture = {};
		errors = [];
		if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
			error$47.errors = errors;
			throw error$47;
		}
		var n = forge.util.createBuffer(capture.privateKeyModulus).toHex(), e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex(), d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex(), p = forge.util.createBuffer(capture.privateKeyPrime1).toHex(), q = forge.util.createBuffer(capture.privateKeyPrime2).toHex(), dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex(), dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex(), qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
		return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
	};
	/**
	* Converts a private key to an ASN.1 RSAPrivateKey.
	*
	* @param key the private key.
	*
	* @return the ASN.1 representation of an RSAPrivateKey.
	*/
	pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
		]);
	};
	/**
	* Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
	*
	* @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
	*
	* @return the public key.
	*/
	pki.publicKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
			var oid = asn1.derToOid(capture.publicKeyOid);
			if (oid !== pki.oids.rsaEncryption) {
				var error$47 = /* @__PURE__ */ new Error("Cannot read public key. Unknown OID.");
				error$47.oid = oid;
				throw error$47;
			}
			obj = capture.rsaPublicKey;
		}
		errors = [];
		if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
			error$47.errors = errors;
			throw error$47;
		}
		var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
		var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
		return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
	};
	/**
	* Converts a public key to an ASN.1 SubjectPublicKeyInfo.
	*
	* @param key the public key.
	*
	* @return the asn1 representation of a SubjectPublicKeyInfo.
	*/
	pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [pki.publicKeyToRSAPublicKey(key)])]);
	};
	/**
	* Converts a public key to an ASN.1 RSAPublicKey.
	*
	* @param key the public key.
	*
	* @return the asn1 representation of a RSAPublicKey.
	*/
	pki.publicKeyToRSAPublicKey = function(key) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))]);
	};
	/**
	* Encodes a message using PKCS#1 v1.5 padding.
	*
	* @param m the message to encode.
	* @param key the RSA key to use.
	* @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
	*          (for encryption).
	*
	* @return the padded byte buffer.
	*/
	function _encodePkcs1_v1_5(m, key, bt) {
		var eb = forge.util.createBuffer();
		var k = Math.ceil(key.n.bitLength() / 8);
		if (m.length > k - 11) {
			var error$47 = /* @__PURE__ */ new Error("Message is too long for PKCS#1 v1.5 padding.");
			error$47.length = m.length;
			error$47.max = k - 11;
			throw error$47;
		}
		eb.putByte(0);
		eb.putByte(bt);
		var padNum = k - 3 - m.length;
		var padByte;
		if (bt === 0 || bt === 1) {
			padByte = bt === 0 ? 0 : 255;
			for (var i = 0; i < padNum; ++i) eb.putByte(padByte);
		} else while (padNum > 0) {
			var numZeros = 0;
			var padBytes = forge.random.getBytes(padNum);
			for (var i = 0; i < padNum; ++i) {
				padByte = padBytes.charCodeAt(i);
				if (padByte === 0) ++numZeros;
				else eb.putByte(padByte);
			}
			padNum = numZeros;
		}
		eb.putByte(0);
		eb.putBytes(m);
		return eb;
	}
	/**
	* Decodes a message using PKCS#1 v1.5 padding.
	*
	* @param em the message to decode.
	* @param key the RSA key to use.
	* @param pub true if the key is a public key, false if it is private.
	* @param ml the message length, if specified.
	*
	* @return the decoded bytes.
	*/
	function _decodePkcs1_v1_5(em, key, pub, ml) {
		var k = Math.ceil(key.n.bitLength() / 8);
		var eb = forge.util.createBuffer(em);
		var first = eb.getByte();
		var bt = eb.getByte();
		if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") throw new Error("Encryption block is invalid.");
		var padNum = 0;
		if (bt === 0) {
			padNum = k - 3 - ml;
			for (var i = 0; i < padNum; ++i) if (eb.getByte() !== 0) throw new Error("Encryption block is invalid.");
		} else if (bt === 1) {
			padNum = 0;
			while (eb.length() > 1) {
				if (eb.getByte() !== 255) {
					--eb.read;
					break;
				}
				++padNum;
			}
		} else if (bt === 2) {
			padNum = 0;
			while (eb.length() > 1) {
				if (eb.getByte() === 0) {
					--eb.read;
					break;
				}
				++padNum;
			}
		}
		if (eb.getByte() !== 0 || padNum !== k - 3 - eb.length()) throw new Error("Encryption block is invalid.");
		return eb.getBytes();
	}
	/**
	* Runs the key-generation algorithm asynchronously, either in the background
	* via Web Workers, or using the main thread and setImmediate.
	*
	* @param state the key-pair generation state.
	* @param [options] options for key-pair generation:
	*          workerScript the worker script URL.
	*          workers the number of web workers (if supported) to use,
	*            (default: 2, -1 to use estimated cores minus one).
	*          workLoad the size of the work load, ie: number of possible prime
	*            numbers for each web worker to check per work assignment,
	*            (default: 100).
	* @param callback(err, keypair) called once the operation completes.
	*/
	function _generateKeyPair(state, options, callback$1) {
		if (typeof options === "function") {
			callback$1 = options;
			options = {};
		}
		options = options || {};
		var opts = { algorithm: {
			name: options.algorithm || "PRIMEINC",
			options: {
				workers: options.workers || 2,
				workLoad: options.workLoad || 100,
				workerScript: options.workerScript
			}
		} };
		if ("prng" in options) opts.prng = options.prng;
		generate();
		function generate() {
			getPrime(state.pBits, function(err, num) {
				if (err) return callback$1(err);
				state.p = num;
				if (state.q !== null) return finish(err, state.q);
				getPrime(state.qBits, finish);
			});
		}
		function getPrime(bits, callback$2) {
			forge.prime.generateProbablePrime(bits, opts, callback$2);
		}
		function finish(err, num) {
			if (err) return callback$1(err);
			state.q = num;
			if (state.p.compareTo(state.q) < 0) {
				var tmp = state.p;
				state.p = state.q;
				state.q = tmp;
			}
			if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
				state.p = null;
				generate();
				return;
			}
			if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
				state.q = null;
				getPrime(state.qBits, finish);
				return;
			}
			state.p1 = state.p.subtract(BigInteger.ONE);
			state.q1 = state.q.subtract(BigInteger.ONE);
			state.phi = state.p1.multiply(state.q1);
			if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
				state.p = state.q = null;
				generate();
				return;
			}
			state.n = state.p.multiply(state.q);
			if (state.n.bitLength() !== state.bits) {
				state.q = null;
				getPrime(state.qBits, finish);
				return;
			}
			var d = state.e.modInverse(state.phi);
			state.keys = {
				privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
				publicKey: pki.rsa.setPublicKey(state.n, state.e)
			};
			callback$1(null, state.keys);
		}
	}
	/**
	* Converts a positive BigInteger into 2's-complement big-endian bytes.
	*
	* @param b the big integer to convert.
	*
	* @return the bytes.
	*/
	function _bnToBytes(b) {
		var hex$2 = b.toString(16);
		if (hex$2[0] >= "8") hex$2 = "00" + hex$2;
		var bytes = forge.util.hexToBytes(hex$2);
		if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) return bytes.substr(1);
		return bytes;
	}
	/**
	* Returns the required number of Miller-Rabin tests to generate a
	* prime with an error probability of (1/2)^80.
	*
	* See Handbook of Applied Cryptography Chapter 4, Table 4.4.
	*
	* @param bits the bit size.
	*
	* @return the required number of iterations.
	*/
	function _getMillerRabinTests(bits) {
		if (bits <= 100) return 27;
		if (bits <= 150) return 18;
		if (bits <= 200) return 15;
		if (bits <= 250) return 12;
		if (bits <= 300) return 9;
		if (bits <= 350) return 8;
		if (bits <= 400) return 7;
		if (bits <= 500) return 6;
		if (bits <= 600) return 5;
		if (bits <= 800) return 4;
		if (bits <= 1250) return 3;
		return 2;
	}
	/**
	* Performs feature detection on the Node crypto interface.
	*
	* @param fn the feature (function) to detect.
	*
	* @return true if detected, false if not.
	*/
	function _detectNodeCrypto(fn$1) {
		return forge.util.isNodejs && typeof _crypto[fn$1] === "function";
	}
	/**
	* Performs feature detection on the SubtleCrypto interface.
	*
	* @param fn the feature (function) to detect.
	*
	* @return true if detected, false if not.
	*/
	function _detectSubtleCrypto(fn$1) {
		return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn$1] === "function";
	}
	/**
	* Performs feature detection on the deprecated Microsoft Internet Explorer
	* outdated SubtleCrypto interface. This function should only be used after
	* checking for the modern, standard SubtleCrypto interface.
	*
	* @param fn the feature (function) to detect.
	*
	* @return true if detected, false if not.
	*/
	function _detectSubtleMsCrypto(fn$1) {
		return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn$1] === "function";
	}
	function _intToUint8Array(x) {
		var bytes = forge.util.hexToBytes(x.toString(16));
		var buffer$1 = new Uint8Array(bytes.length);
		for (var i = 0; i < bytes.length; ++i) buffer$1[i] = bytes.charCodeAt(i);
		return buffer$1;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pbe.js
var require_pbe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Password-based encryption functions.
	*
	* @author Dave Longley
	* @author Stefan Siegl <stesie@brokenpipe.de>
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* An EncryptedPrivateKeyInfo:
	*
	* EncryptedPrivateKeyInfo ::= SEQUENCE {
	*   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
	*   encryptedData        EncryptedData }
	*
	* EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* EncryptedData ::= OCTET STRING
	*/
	var forge = require_forge();
	require_aes();
	require_asn1();
	require_des();
	require_md();
	require_oids();
	require_pbkdf2();
	require_pem();
	require_random();
	require_rc2();
	require_rsa$1();
	require_util();
	if (typeof BigInteger === "undefined") var BigInteger = forge.jsbn.BigInteger;
	var asn1 = forge.asn1;
	var pki = forge.pki = forge.pki || {};
	module.exports = pki.pbe = forge.pbe = forge.pbe || {};
	var oids = pki.oids;
	var encryptedPrivateKeyValidator = {
		name: "EncryptedPrivateKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "AlgorithmIdentifier.algorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "encryptionOid"
			}, {
				name: "AlgorithmIdentifier.parameters",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				captureAsn1: "encryptionParams"
			}]
		}, {
			name: "EncryptedPrivateKeyInfo.encryptedData",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OCTETSTRING,
			constructed: false,
			capture: "encryptedData"
		}]
	};
	var PBES2AlgorithmsValidator = {
		name: "PBES2Algorithms",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "PBES2Algorithms.keyDerivationFunc",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "PBES2Algorithms.keyDerivationFunc.oid",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "kdfOid"
			}, {
				name: "PBES2Algorithms.params",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [
					{
						name: "PBES2Algorithms.params.salt",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OCTETSTRING,
						constructed: false,
						capture: "kdfSalt"
					},
					{
						name: "PBES2Algorithms.params.iterationCount",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						capture: "kdfIterationCount"
					},
					{
						name: "PBES2Algorithms.params.keyLength",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						optional: true,
						capture: "keyLength"
					},
					{
						name: "PBES2Algorithms.params.prf",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						optional: true,
						value: [{
							name: "PBES2Algorithms.params.prf.algorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OID,
							constructed: false,
							capture: "prfOid"
						}]
					}
				]
			}]
		}, {
			name: "PBES2Algorithms.encryptionScheme",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "PBES2Algorithms.encryptionScheme.oid",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "encOid"
			}, {
				name: "PBES2Algorithms.encryptionScheme.iv",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "encIv"
			}]
		}]
	};
	var pkcs12PbeParamsValidator = {
		name: "pkcs-12PbeParams",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "pkcs-12PbeParams.salt",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OCTETSTRING,
			constructed: false,
			capture: "salt"
		}, {
			name: "pkcs-12PbeParams.iterations",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "iterations"
		}]
	};
	/**
	* Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
	*
	* PBES2Algorithms ALGORITHM-IDENTIFIER ::=
	*   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
	*
	* id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
	*
	* PBES2-params ::= SEQUENCE {
	*   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
	*   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
	* }
	*
	* PBES2-KDFs ALGORITHM-IDENTIFIER ::=
	*   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
	*
	* PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
	*
	* PBKDF2-params ::= SEQUENCE {
	*   salt CHOICE {
	*     specified OCTET STRING,
	*     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
	*   },
	*   iterationCount INTEGER (1..MAX),
	*   keyLength INTEGER (1..MAX) OPTIONAL,
	*   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
	* }
	*
	* @param obj the ASN.1 PrivateKeyInfo object.
	* @param password the password to encrypt with.
	* @param options:
	*          algorithm the encryption algorithm to use
	*            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
	*          count the iteration count to use.
	*          saltSize the salt size to use.
	*          prfAlgorithm the PRF message digest algorithm to use
	*            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
	*
	* @return the ASN.1 EncryptedPrivateKeyInfo.
	*/
	pki.encryptPrivateKeyInfo = function(obj, password, options) {
		options = options || {};
		options.saltSize = options.saltSize || 8;
		options.count = options.count || 2048;
		options.algorithm = options.algorithm || "aes128";
		options.prfAlgorithm = options.prfAlgorithm || "sha1";
		var salt = forge.random.getBytesSync(options.saltSize);
		var count = options.count;
		var countBytes = asn1.integerToDer(count);
		var dkLen;
		var encryptionAlgorithm;
		var encryptedData;
		if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
			var ivLen, encOid, cipherFn;
			switch (options.algorithm) {
				case "aes128":
					dkLen = 16;
					ivLen = 16;
					encOid = oids["aes128-CBC"];
					cipherFn = forge.aes.createEncryptionCipher;
					break;
				case "aes192":
					dkLen = 24;
					ivLen = 16;
					encOid = oids["aes192-CBC"];
					cipherFn = forge.aes.createEncryptionCipher;
					break;
				case "aes256":
					dkLen = 32;
					ivLen = 16;
					encOid = oids["aes256-CBC"];
					cipherFn = forge.aes.createEncryptionCipher;
					break;
				case "des":
					dkLen = 8;
					ivLen = 8;
					encOid = oids["desCBC"];
					cipherFn = forge.des.createEncryptionCipher;
					break;
				default:
					var error$47 = /* @__PURE__ */ new Error("Cannot encrypt private key. Unknown encryption algorithm.");
					error$47.algorithm = options.algorithm;
					throw error$47;
			}
			var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
			var md = prfAlgorithmToMessageDigest(prfAlgorithm);
			var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
			var iv = forge.random.getBytesSync(ivLen);
			var cipher = cipherFn(dk);
			cipher.start(iv);
			cipher.update(asn1.toDer(obj));
			cipher.finish();
			encryptedData = cipher.output.getBytes();
			var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
			encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()), params]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)])])]);
		} else if (options.algorithm === "3des") {
			dkLen = 24;
			var saltBytes = new forge.util.ByteBuffer(salt);
			var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
			var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
			var cipher = forge.des.createEncryptionCipher(dk);
			cipher.start(iv);
			cipher.update(asn1.toDer(obj));
			cipher.finish();
			encryptedData = cipher.output.getBytes();
			encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]);
		} else {
			var error$47 = /* @__PURE__ */ new Error("Cannot encrypt private key. Unknown encryption algorithm.");
			error$47.algorithm = options.algorithm;
			throw error$47;
		}
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)]);
	};
	/**
	* Decrypts a ASN.1 PrivateKeyInfo object.
	*
	* @param obj the ASN.1 EncryptedPrivateKeyInfo object.
	* @param password the password to decrypt with.
	*
	* @return the ASN.1 PrivateKeyInfo on success, null on failure.
	*/
	pki.decryptPrivateKeyInfo = function(obj, password) {
		var rval = null;
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
			error$47.errors = errors;
			throw error$47;
		}
		var oid = asn1.derToOid(capture.encryptionOid);
		var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
		var encrypted = forge.util.createBuffer(capture.encryptedData);
		cipher.update(encrypted);
		if (cipher.finish()) rval = asn1.fromDer(cipher.output);
		return rval;
	};
	/**
	* Converts a EncryptedPrivateKeyInfo to PEM format.
	*
	* @param epki the EncryptedPrivateKeyInfo.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted encrypted private key.
	*/
	pki.encryptedPrivateKeyToPem = function(epki, maxline) {
		var msg = {
			type: "ENCRYPTED PRIVATE KEY",
			body: asn1.toDer(epki).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
	* is not performed.
	*
	* @param pem the EncryptedPrivateKeyInfo in PEM-format.
	*
	* @return the ASN.1 EncryptedPrivateKeyInfo.
	*/
	pki.encryptedPrivateKeyFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "ENCRYPTED PRIVATE KEY") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert encrypted private key from PEM; PEM header type is \"ENCRYPTED PRIVATE KEY\".");
			error$47.headerType = msg.type;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
		return asn1.fromDer(msg.body);
	};
	/**
	* Encrypts an RSA private key. By default, the key will be wrapped in
	* a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
	* This is the standard, preferred way to encrypt a private key.
	*
	* To produce a non-standard PEM-encrypted private key that uses encapsulated
	* headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
	* private key encryption), set the 'legacy' option to true. Note: Using this
	* option will cause the iteration count to be forced to 1.
	*
	* Note: The 'des' algorithm is supported, but it is not considered to be
	* secure because it only uses a single 56-bit key. If possible, it is highly
	* recommended that a different algorithm be used.
	*
	* @param rsaKey the RSA key to encrypt.
	* @param password the password to use.
	* @param options:
	*          algorithm: the encryption algorithm to use
	*            ('aes128', 'aes192', 'aes256', '3des', 'des').
	*          count: the iteration count to use.
	*          saltSize: the salt size to use.
	*          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
	*            headers (DEK-Info) private key.
	*
	* @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
	*/
	pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
		options = options || {};
		if (!options.legacy) {
			var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
			rval = pki.encryptPrivateKeyInfo(rval, password, options);
			return pki.encryptedPrivateKeyToPem(rval);
		}
		var algorithm;
		var iv;
		var dkLen;
		var cipherFn;
		switch (options.algorithm) {
			case "aes128":
				algorithm = "AES-128-CBC";
				dkLen = 16;
				iv = forge.random.getBytesSync(16);
				cipherFn = forge.aes.createEncryptionCipher;
				break;
			case "aes192":
				algorithm = "AES-192-CBC";
				dkLen = 24;
				iv = forge.random.getBytesSync(16);
				cipherFn = forge.aes.createEncryptionCipher;
				break;
			case "aes256":
				algorithm = "AES-256-CBC";
				dkLen = 32;
				iv = forge.random.getBytesSync(16);
				cipherFn = forge.aes.createEncryptionCipher;
				break;
			case "3des":
				algorithm = "DES-EDE3-CBC";
				dkLen = 24;
				iv = forge.random.getBytesSync(8);
				cipherFn = forge.des.createEncryptionCipher;
				break;
			case "des":
				algorithm = "DES-CBC";
				dkLen = 8;
				iv = forge.random.getBytesSync(8);
				cipherFn = forge.des.createEncryptionCipher;
				break;
			default:
				var error$47 = /* @__PURE__ */ new Error("Could not encrypt RSA private key; unsupported encryption algorithm \"" + options.algorithm + "\".");
				error$47.algorithm = options.algorithm;
				throw error$47;
		}
		var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
		var cipher = cipherFn(dk);
		cipher.start(iv);
		cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
		cipher.finish();
		var msg = {
			type: "RSA PRIVATE KEY",
			procType: {
				version: "4",
				type: "ENCRYPTED"
			},
			dekInfo: {
				algorithm,
				parameters: forge.util.bytesToHex(iv).toUpperCase()
			},
			body: cipher.output.getBytes()
		};
		return forge.pem.encode(msg);
	};
	/**
	* Decrypts an RSA private key.
	*
	* @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
	* @param password the password to use.
	*
	* @return the RSA key on success, null on failure.
	*/
	pki.decryptRsaPrivateKey = function(pem, password) {
		var rval = null;
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert private key from PEM; PEM header type is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".");
			error$47.headerType = error$47;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") {
			var dkLen;
			var cipherFn;
			switch (msg.dekInfo.algorithm) {
				case "DES-CBC":
					dkLen = 8;
					cipherFn = forge.des.createDecryptionCipher;
					break;
				case "DES-EDE3-CBC":
					dkLen = 24;
					cipherFn = forge.des.createDecryptionCipher;
					break;
				case "AES-128-CBC":
					dkLen = 16;
					cipherFn = forge.aes.createDecryptionCipher;
					break;
				case "AES-192-CBC":
					dkLen = 24;
					cipherFn = forge.aes.createDecryptionCipher;
					break;
				case "AES-256-CBC":
					dkLen = 32;
					cipherFn = forge.aes.createDecryptionCipher;
					break;
				case "RC2-40-CBC":
					dkLen = 5;
					cipherFn = function(key) {
						return forge.rc2.createDecryptionCipher(key, 40);
					};
					break;
				case "RC2-64-CBC":
					dkLen = 8;
					cipherFn = function(key) {
						return forge.rc2.createDecryptionCipher(key, 64);
					};
					break;
				case "RC2-128-CBC":
					dkLen = 16;
					cipherFn = function(key) {
						return forge.rc2.createDecryptionCipher(key, 128);
					};
					break;
				default:
					var error$47 = /* @__PURE__ */ new Error("Could not decrypt private key; unsupported encryption algorithm \"" + msg.dekInfo.algorithm + "\".");
					error$47.algorithm = msg.dekInfo.algorithm;
					throw error$47;
			}
			var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
			var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
			var cipher = cipherFn(dk);
			cipher.start(iv);
			cipher.update(forge.util.createBuffer(msg.body));
			if (cipher.finish()) rval = cipher.output.getBytes();
			else return rval;
		} else rval = msg.body;
		if (msg.type === "ENCRYPTED PRIVATE KEY") rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
		else rval = asn1.fromDer(rval);
		if (rval !== null) rval = pki.privateKeyFromAsn1(rval);
		return rval;
	};
	/**
	* Derives a PKCS#12 key.
	*
	* @param password the password to derive the key material from, null or
	*          undefined for none.
	* @param salt the salt, as a ByteBuffer, to use.
	* @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
	* @param iter the iteration count.
	* @param n the number of bytes to derive from the password.
	* @param md the message digest to use, defaults to SHA-1.
	*
	* @return a ByteBuffer with the bytes derived from the password.
	*/
	pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
		var j, l;
		if (typeof md === "undefined" || md === null) {
			if (!("sha1" in forge.md)) throw new Error("\"sha1\" hash algorithm unavailable.");
			md = forge.md.sha1.create();
		}
		var u = md.digestLength;
		var v = md.blockLength;
		var result = new forge.util.ByteBuffer();
		var passBuf = new forge.util.ByteBuffer();
		if (password !== null && password !== void 0) {
			for (l = 0; l < password.length; l++) passBuf.putInt16(password.charCodeAt(l));
			passBuf.putInt16(0);
		}
		var p = passBuf.length();
		var s = salt.length();
		var D = new forge.util.ByteBuffer();
		D.fillWithByte(id, v);
		var Slen = v * Math.ceil(s / v);
		var S = new forge.util.ByteBuffer();
		for (l = 0; l < Slen; l++) S.putByte(salt.at(l % s));
		var Plen = v * Math.ceil(p / v);
		var P = new forge.util.ByteBuffer();
		for (l = 0; l < Plen; l++) P.putByte(passBuf.at(l % p));
		var I = S;
		I.putBuffer(P);
		var c = Math.ceil(n / u);
		for (var i = 1; i <= c; i++) {
			var buf = new forge.util.ByteBuffer();
			buf.putBytes(D.bytes());
			buf.putBytes(I.bytes());
			for (var round = 0; round < iter; round++) {
				md.start();
				md.update(buf.getBytes());
				buf = md.digest();
			}
			var B = new forge.util.ByteBuffer();
			for (l = 0; l < v; l++) B.putByte(buf.at(l % u));
			var k = Math.ceil(s / v) + Math.ceil(p / v);
			var Inew = new forge.util.ByteBuffer();
			for (j = 0; j < k; j++) {
				var chunk = new forge.util.ByteBuffer(I.getBytes(v));
				var x = 511;
				for (l = B.length() - 1; l >= 0; l--) {
					x = x >> 8;
					x += B.at(l) + chunk.at(l);
					chunk.setAt(l, x & 255);
				}
				Inew.putBuffer(chunk);
			}
			I = Inew;
			result.putBuffer(buf);
		}
		result.truncate(result.length() - n);
		return result;
	};
	/**
	* Get new Forge cipher object instance.
	*
	* @param oid the OID (in string notation).
	* @param params the ASN.1 params object.
	* @param password the password to decrypt with.
	*
	* @return new cipher object instance.
	*/
	pki.pbe.getCipher = function(oid, params, password) {
		switch (oid) {
			case pki.oids["pkcs5PBES2"]: return pki.pbe.getCipherForPBES2(oid, params, password);
			case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
			case pki.oids["pbewithSHAAnd40BitRC2-CBC"]: return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
			default:
				var error$47 = /* @__PURE__ */ new Error("Cannot read encrypted PBE data block. Unsupported OID.");
				error$47.oid = oid;
				error$47.supportedOids = [
					"pkcs5PBES2",
					"pbeWithSHAAnd3-KeyTripleDES-CBC",
					"pbewithSHAAnd40BitRC2-CBC"
				];
				throw error$47;
		}
	};
	/**
	* Get new Forge cipher object instance according to PBES2 params block.
	*
	* The returned cipher instance is already started using the IV
	* from PBES2 parameter block.
	*
	* @param oid the PKCS#5 PBKDF2 OID (in string notation).
	* @param params the ASN.1 PBES2-params object.
	* @param password the password to decrypt with.
	*
	* @return new cipher object instance.
	*/
	pki.pbe.getCipherForPBES2 = function(oid, params, password) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
			error$47.errors = errors;
			throw error$47;
		}
		oid = asn1.derToOid(capture.kdfOid);
		if (oid !== pki.oids["pkcs5PBKDF2"]) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
			error$47.oid = oid;
			error$47.supportedOids = ["pkcs5PBKDF2"];
			throw error$47;
		}
		oid = asn1.derToOid(capture.encOid);
		if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
			error$47.oid = oid;
			error$47.supportedOids = [
				"aes128-CBC",
				"aes192-CBC",
				"aes256-CBC",
				"des-EDE3-CBC",
				"desCBC"
			];
			throw error$47;
		}
		var salt = capture.kdfSalt;
		var count = forge.util.createBuffer(capture.kdfIterationCount);
		count = count.getInt(count.length() << 3);
		var dkLen;
		var cipherFn;
		switch (pki.oids[oid]) {
			case "aes128-CBC":
				dkLen = 16;
				cipherFn = forge.aes.createDecryptionCipher;
				break;
			case "aes192-CBC":
				dkLen = 24;
				cipherFn = forge.aes.createDecryptionCipher;
				break;
			case "aes256-CBC":
				dkLen = 32;
				cipherFn = forge.aes.createDecryptionCipher;
				break;
			case "des-EDE3-CBC":
				dkLen = 24;
				cipherFn = forge.des.createDecryptionCipher;
				break;
			case "desCBC":
				dkLen = 8;
				cipherFn = forge.des.createDecryptionCipher;
				break;
		}
		var md = prfOidToMessageDigest(capture.prfOid);
		var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
		var iv = capture.encIv;
		var cipher = cipherFn(dk);
		cipher.start(iv);
		return cipher;
	};
	/**
	* Get new Forge cipher object instance for PKCS#12 PBE.
	*
	* The returned cipher instance is already started using the key & IV
	* derived from the provided password and PKCS#12 PBE salt.
	*
	* @param oid The PKCS#12 PBE OID (in string notation).
	* @param params The ASN.1 PKCS#12 PBE-params object.
	* @param password The password to decrypt with.
	*
	* @return the new cipher object instance.
	*/
	pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
			error$47.errors = errors;
			throw error$47;
		}
		var salt = forge.util.createBuffer(capture.salt);
		var count = forge.util.createBuffer(capture.iterations);
		count = count.getInt(count.length() << 3);
		var dkLen, dIvLen, cipherFn;
		switch (oid) {
			case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
				dkLen = 24;
				dIvLen = 8;
				cipherFn = forge.des.startDecrypting;
				break;
			case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
				dkLen = 5;
				dIvLen = 8;
				cipherFn = function(key$1, iv$1) {
					var cipher = forge.rc2.createDecryptionCipher(key$1, 40);
					cipher.start(iv$1, null);
					return cipher;
				};
				break;
			default:
				var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
				error$47.oid = oid;
				throw error$47;
		}
		var md = prfOidToMessageDigest(capture.prfOid);
		var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
		md.start();
		var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
		return cipherFn(key, iv);
	};
	/**
	* OpenSSL's legacy key derivation function.
	*
	* See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
	*
	* @param password the password to derive the key from.
	* @param salt the salt to use, null for none.
	* @param dkLen the number of bytes needed for the derived key.
	* @param [options] the options to use:
	*          [md] an optional message digest object to use.
	*/
	pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
		if (typeof md === "undefined" || md === null) {
			if (!("md5" in forge.md)) throw new Error("\"md5\" hash algorithm unavailable.");
			md = forge.md.md5.create();
		}
		if (salt === null) salt = "";
		var digests = [hash(md, password + salt)];
		for (var length = 16, i = 1; length < dkLen; ++i, length += 16) digests.push(hash(md, digests[i - 1] + password + salt));
		return digests.join("").substr(0, dkLen);
	};
	function hash(md, bytes) {
		return md.start().update(bytes).digest().getBytes();
	}
	function prfOidToMessageDigest(prfOid) {
		var prfAlgorithm;
		if (!prfOid) prfAlgorithm = "hmacWithSHA1";
		else {
			prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
			if (!prfAlgorithm) {
				var error$47 = /* @__PURE__ */ new Error("Unsupported PRF OID.");
				error$47.oid = prfOid;
				error$47.supported = [
					"hmacWithSHA1",
					"hmacWithSHA224",
					"hmacWithSHA256",
					"hmacWithSHA384",
					"hmacWithSHA512"
				];
				throw error$47;
			}
		}
		return prfAlgorithmToMessageDigest(prfAlgorithm);
	}
	function prfAlgorithmToMessageDigest(prfAlgorithm) {
		var factory = forge.md;
		switch (prfAlgorithm) {
			case "hmacWithSHA224": factory = forge.md.sha512;
			case "hmacWithSHA1":
			case "hmacWithSHA256":
			case "hmacWithSHA384":
			case "hmacWithSHA512":
				prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
				break;
			default:
				var error$47 = /* @__PURE__ */ new Error("Unsupported PRF algorithm.");
				error$47.algorithm = prfAlgorithm;
				error$47.supported = [
					"hmacWithSHA1",
					"hmacWithSHA224",
					"hmacWithSHA256",
					"hmacWithSHA384",
					"hmacWithSHA512"
				];
				throw error$47;
		}
		if (!factory || !(prfAlgorithm in factory)) throw new Error("Unknown hash algorithm: " + prfAlgorithm);
		return factory[prfAlgorithm].create();
	}
	function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
		var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())]);
		if (prfAlgorithm !== "hmacWithSHA1") params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]));
		return params;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
	*
	* @author Dave Longley
	* @author Stefan Siegl
	*
	* Copyright (c) 2012-2015 Digital Bazaar, Inc.
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* The ASN.1 representation of PKCS#7 is as follows
	* (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
	*
	* A PKCS#7 message consists of a ContentInfo on root level, which may
	* contain any number of further ContentInfo nested into it.
	*
	* ContentInfo ::= SEQUENCE {
	*   contentType                ContentType,
	*   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
	* }
	*
	* ContentType ::= OBJECT IDENTIFIER
	*
	* EnvelopedData ::= SEQUENCE {
	*   version                    Version,
	*   recipientInfos             RecipientInfos,
	*   encryptedContentInfo       EncryptedContentInfo
	* }
	*
	* EncryptedData ::= SEQUENCE {
	*   version                    Version,
	*   encryptedContentInfo       EncryptedContentInfo
	* }
	*
	* id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
	*   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
	*
	* SignedData ::= SEQUENCE {
	*   version           INTEGER,
	*   digestAlgorithms  DigestAlgorithmIdentifiers,
	*   contentInfo       ContentInfo,
	*   certificates      [0] IMPLICIT Certificates OPTIONAL,
	*   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
	*   signerInfos       SignerInfos
	* }
	*
	* SignerInfos ::= SET OF SignerInfo
	*
	* SignerInfo ::= SEQUENCE {
	*   version                    Version,
	*   issuerAndSerialNumber      IssuerAndSerialNumber,
	*   digestAlgorithm            DigestAlgorithmIdentifier,
	*   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
	*   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
	*   encryptedDigest            EncryptedDigest,
	*   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
	* }
	*
	* EncryptedDigest ::= OCTET STRING
	*
	* Attributes ::= SET OF Attribute
	*
	* Attribute ::= SEQUENCE {
	*   attrType    OBJECT IDENTIFIER,
	*   attrValues  SET OF AttributeValue
	* }
	*
	* AttributeValue ::= ANY
	*
	* Version ::= INTEGER
	*
	* RecipientInfos ::= SET OF RecipientInfo
	*
	* EncryptedContentInfo ::= SEQUENCE {
	*   contentType                 ContentType,
	*   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
	*   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
	* }
	*
	* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
	* for the algorithm, if any. In the case of AES and DES3, there is only one,
	* the IV.
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*    algorithm OBJECT IDENTIFIER,
	*    parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* EncryptedContent ::= OCTET STRING
	*
	* RecipientInfo ::= SEQUENCE {
	*   version                     Version,
	*   issuerAndSerialNumber       IssuerAndSerialNumber,
	*   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
	*   encryptedKey                EncryptedKey
	* }
	*
	* IssuerAndSerialNumber ::= SEQUENCE {
	*   issuer                      Name,
	*   serialNumber                CertificateSerialNumber
	* }
	*
	* CertificateSerialNumber ::= INTEGER
	*
	* KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* EncryptedKey ::= OCTET STRING
	*/
	var forge = require_forge();
	require_asn1();
	require_util();
	var asn1 = forge.asn1;
	var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
	forge.pkcs7 = forge.pkcs7 || {};
	forge.pkcs7.asn1 = p7v;
	var contentInfoValidator = {
		name: "ContentInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "ContentInfo.ContentType",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "contentType"
		}, {
			name: "ContentInfo.content",
			tagClass: asn1.Class.CONTEXT_SPECIFIC,
			type: 0,
			constructed: true,
			optional: true,
			captureAsn1: "content"
		}]
	};
	p7v.contentInfoValidator = contentInfoValidator;
	var encryptedContentInfoValidator = {
		name: "EncryptedContentInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "EncryptedContentInfo.contentType",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "contentType"
			},
			{
				name: "EncryptedContentInfo.contentEncryptionAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "encAlgorithm"
				}, {
					name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
					tagClass: asn1.Class.UNIVERSAL,
					captureAsn1: "encParameter"
				}]
			},
			{
				name: "EncryptedContentInfo.encryptedContent",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				capture: "encryptedContent",
				captureAsn1: "encryptedContentAsn1"
			}
		]
	};
	p7v.envelopedDataValidator = {
		name: "EnvelopedData",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "EnvelopedData.Version",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "version"
		}, {
			name: "EnvelopedData.RecipientInfos",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SET,
			constructed: true,
			captureAsn1: "recipientInfos"
		}].concat(encryptedContentInfoValidator)
	};
	p7v.encryptedDataValidator = {
		name: "EncryptedData",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "EncryptedData.Version",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "version"
		}].concat(encryptedContentInfoValidator)
	};
	var signerValidator = {
		name: "SignerInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "SignerInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false
			},
			{
				name: "SignerInfo.issuerAndSerialNumber",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "SignerInfo.issuerAndSerialNumber.issuer",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.SEQUENCE,
					constructed: true,
					captureAsn1: "issuer"
				}, {
					name: "SignerInfo.issuerAndSerialNumber.serialNumber",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.INTEGER,
					constructed: false,
					capture: "serial"
				}]
			},
			{
				name: "SignerInfo.digestAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "SignerInfo.digestAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "digestAlgorithm"
				}, {
					name: "SignerInfo.digestAlgorithm.parameter",
					tagClass: asn1.Class.UNIVERSAL,
					constructed: false,
					captureAsn1: "digestParameter",
					optional: true
				}]
			},
			{
				name: "SignerInfo.authenticatedAttributes",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: true,
				optional: true,
				capture: "authenticatedAttributes"
			},
			{
				name: "SignerInfo.digestEncryptionAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				capture: "signatureAlgorithm"
			},
			{
				name: "SignerInfo.encryptedDigest",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "signature"
			},
			{
				name: "SignerInfo.unauthenticatedAttributes",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 1,
				constructed: true,
				optional: true,
				capture: "unauthenticatedAttributes"
			}
		]
	};
	p7v.signedDataValidator = {
		name: "SignedData",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "SignedData.Version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "version"
			},
			{
				name: "SignedData.DigestAlgorithms",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SET,
				constructed: true,
				captureAsn1: "digestAlgorithms"
			},
			contentInfoValidator,
			{
				name: "SignedData.Certificates",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				optional: true,
				captureAsn1: "certificates"
			},
			{
				name: "SignedData.CertificateRevocationLists",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 1,
				optional: true,
				captureAsn1: "crls"
			},
			{
				name: "SignedData.SignerInfos",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SET,
				capture: "signerInfos",
				optional: true,
				value: [signerValidator]
			}
		]
	};
	p7v.recipientInfoValidator = {
		name: "RecipientInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "RecipientInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "version"
			},
			{
				name: "RecipientInfo.issuerAndSerial",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "RecipientInfo.issuerAndSerial.issuer",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.SEQUENCE,
					constructed: true,
					captureAsn1: "issuer"
				}, {
					name: "RecipientInfo.issuerAndSerial.serialNumber",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.INTEGER,
					constructed: false,
					capture: "serial"
				}]
			},
			{
				name: "RecipientInfo.keyEncryptionAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "encAlgorithm"
				}, {
					name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
					tagClass: asn1.Class.UNIVERSAL,
					constructed: false,
					captureAsn1: "encParameter",
					optional: true
				}]
			},
			{
				name: "RecipientInfo.encryptedKey",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "encKey"
			}
		]
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/mgf1.js
var require_mgf1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of mask generation function MGF1.
	*
	* @author Stefan Siegl
	* @author Dave Longley
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	* Copyright (c) 2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	forge.mgf = forge.mgf || {};
	var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
	/**
	* Creates a MGF1 mask generation function object.
	*
	* @param md the message digest API to use (eg: forge.md.sha1.create()).
	*
	* @return a mask generation function object.
	*/
	mgf1.create = function(md) {
		return { generate: function(seed, maskLen) {
			var t = new forge.util.ByteBuffer();
			var len = Math.ceil(maskLen / md.digestLength);
			for (var i = 0; i < len; i++) {
				var c = new forge.util.ByteBuffer();
				c.putInt32(i);
				md.start();
				md.update(seed + c.getBytes());
				t.putBuffer(md.digest());
			}
			t.truncate(t.length() - maskLen);
			return t.getBytes();
		} };
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/mgf.js
var require_mgf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge mask generation functions.
	*
	* @author Stefan Siegl
	*
	* Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
	*/
	var forge = require_forge();
	require_mgf1();
	module.exports = forge.mgf = forge.mgf || {};
	forge.mgf.mgf1 = forge.mgf1;
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pss.js
var require_pss$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of PKCS#1 PSS signature padding.
	*
	* @author Stefan Siegl
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*/
	var forge = require_forge();
	require_random();
	require_util();
	var pss = module.exports = forge.pss = forge.pss || {};
	/**
	* Creates a PSS signature scheme object.
	*
	* There are several ways to provide a salt for encoding:
	*
	* 1. Specify the saltLength only and the built-in PRNG will generate it.
	* 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
	*   will be used.
	* 3. Specify the salt itself as a forge.util.ByteBuffer.
	*
	* @param options the options to use:
	*          md the message digest object to use, a forge md instance.
	*          mgf the mask generation function to use, a forge mgf instance.
	*          [saltLength] the length of the salt in octets.
	*          [prng] the pseudo-random number generator to use to produce a salt.
	*          [salt] the salt to use when encoding.
	*
	* @return a signature scheme object.
	*/
	pss.create = function(options) {
		if (arguments.length === 3) options = {
			md: arguments[0],
			mgf: arguments[1],
			saltLength: arguments[2]
		};
		var hash$1 = options.md;
		var mgf = options.mgf;
		var hLen = hash$1.digestLength;
		var salt_ = options.salt || null;
		if (typeof salt_ === "string") salt_ = forge.util.createBuffer(salt_);
		var sLen;
		if ("saltLength" in options) sLen = options.saltLength;
		else if (salt_ !== null) sLen = salt_.length();
		else throw new Error("Salt length not specified or specific salt not given.");
		if (salt_ !== null && salt_.length() !== sLen) throw new Error("Given salt length does not match length of given salt.");
		var prng = options.prng || forge.random;
		var pssobj = {};
		/**
		* Encodes a PSS signature.
		*
		* This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
		*
		* @param md the message digest object with the hash to sign.
		* @param modsBits the length of the RSA modulus in bits.
		*
		* @return the encoded message as a binary-encoded string of length
		*           ceil((modBits - 1) / 8).
		*/
		pssobj.encode = function(md, modBits) {
			var i;
			var emBits = modBits - 1;
			var emLen = Math.ceil(emBits / 8);
			var mHash = md.digest().getBytes();
			if (emLen < hLen + sLen + 2) throw new Error("Message is too long to encrypt.");
			var salt;
			if (salt_ === null) salt = prng.getBytesSync(sLen);
			else salt = salt_.bytes();
			var m_ = new forge.util.ByteBuffer();
			m_.fillWithByte(0, 8);
			m_.putBytes(mHash);
			m_.putBytes(salt);
			hash$1.start();
			hash$1.update(m_.getBytes());
			var h = hash$1.digest().getBytes();
			var ps = new forge.util.ByteBuffer();
			ps.fillWithByte(0, emLen - sLen - hLen - 2);
			ps.putByte(1);
			ps.putBytes(salt);
			var db = ps.getBytes();
			var maskLen = emLen - hLen - 1;
			var dbMask = mgf.generate(h, maskLen);
			var maskedDB = "";
			for (i = 0; i < maskLen; i++) maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
			var mask = 65280 >> 8 * emLen - emBits & 255;
			maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
			return maskedDB + h + String.fromCharCode(188);
		};
		/**
		* Verifies a PSS signature.
		*
		* This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
		*
		* @param mHash the message digest hash, as a binary-encoded string, to
		*         compare against the signature.
		* @param em the encoded message, as a binary-encoded string
		*          (RSA decryption result).
		* @param modsBits the length of the RSA modulus in bits.
		*
		* @return true if the signature was verified, false if not.
		*/
		pssobj.verify = function(mHash, em, modBits) {
			var i;
			var emBits = modBits - 1;
			var emLen = Math.ceil(emBits / 8);
			em = em.substr(-emLen);
			if (emLen < hLen + sLen + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
			if (em.charCodeAt(emLen - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.");
			var maskLen = emLen - hLen - 1;
			var maskedDB = em.substr(0, maskLen);
			var h = em.substr(maskLen, hLen);
			var mask = 65280 >> 8 * emLen - emBits & 255;
			if ((maskedDB.charCodeAt(0) & mask) !== 0) throw new Error("Bits beyond keysize not zero as expected.");
			var dbMask = mgf.generate(h, maskLen);
			var db = "";
			for (i = 0; i < maskLen; i++) db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
			db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
			var checkLen = emLen - hLen - sLen - 2;
			for (i = 0; i < checkLen; i++) if (db.charCodeAt(i) !== 0) throw new Error("Leftmost octets not zero as expected");
			if (db.charCodeAt(checkLen) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
			var salt = db.substr(-sLen);
			var m_ = new forge.util.ByteBuffer();
			m_.fillWithByte(0, 8);
			m_.putBytes(mHash);
			m_.putBytes(salt);
			hash$1.start();
			hash$1.update(m_.getBytes());
			return h === hash$1.digest().getBytes();
		};
		return pssobj;
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/x509.js
var require_x509 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of X.509 and related components (such as
	* Certification Signing Requests) of a Public Key Infrastructure.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*
	* The ASN.1 representation of an X.509v3 certificate is as follows
	* (see RFC 2459):
	*
	* Certificate ::= SEQUENCE {
	*   tbsCertificate       TBSCertificate,
	*   signatureAlgorithm   AlgorithmIdentifier,
	*   signatureValue       BIT STRING
	* }
	*
	* TBSCertificate ::= SEQUENCE {
	*   version         [0]  EXPLICIT Version DEFAULT v1,
	*   serialNumber         CertificateSerialNumber,
	*   signature            AlgorithmIdentifier,
	*   issuer               Name,
	*   validity             Validity,
	*   subject              Name,
	*   subjectPublicKeyInfo SubjectPublicKeyInfo,
	*   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
	*                        -- If present, version shall be v2 or v3
	*   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
	*                        -- If present, version shall be v2 or v3
	*   extensions      [3]  EXPLICIT Extensions OPTIONAL
	*                        -- If present, version shall be v3
	* }
	*
	* Version ::= INTEGER  { v1(0), v2(1), v3(2) }
	*
	* CertificateSerialNumber ::= INTEGER
	*
	* Name ::= CHOICE {
	*   // only one possible choice for now
	*   RDNSequence
	* }
	*
	* RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
	*
	* RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
	*
	* AttributeTypeAndValue ::= SEQUENCE {
	*   type     AttributeType,
	*   value    AttributeValue
	* }
	* AttributeType ::= OBJECT IDENTIFIER
	* AttributeValue ::= ANY DEFINED BY AttributeType
	*
	* Validity ::= SEQUENCE {
	*   notBefore      Time,
	*   notAfter       Time
	* }
	*
	* Time ::= CHOICE {
	*   utcTime        UTCTime,
	*   generalTime    GeneralizedTime
	* }
	*
	* UniqueIdentifier ::= BIT STRING
	*
	* SubjectPublicKeyInfo ::= SEQUENCE {
	*   algorithm            AlgorithmIdentifier,
	*   subjectPublicKey     BIT STRING
	* }
	*
	* Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
	*
	* Extension ::= SEQUENCE {
	*   extnID      OBJECT IDENTIFIER,
	*   critical    BOOLEAN DEFAULT FALSE,
	*   extnValue   OCTET STRING
	* }
	*
	* The only key algorithm currently supported for PKI is RSA.
	*
	* RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
	*
	* PKCS#10 v1.7 describes certificate signing requests:
	*
	* CertificationRequestInfo:
	*
	* CertificationRequestInfo ::= SEQUENCE {
	*   version       INTEGER { v1(0) } (v1,...),
	*   subject       Name,
	*   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
	*   attributes    [0] Attributes{{ CRIAttributes }}
	* }
	*
	* Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
	*
	* CRIAttributes  ATTRIBUTE  ::= {
	*   ... -- add any locally defined attributes here -- }
	*
	* Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
	*   type   ATTRIBUTE.&id({IOSet}),
	*   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
	* }
	*
	* CertificationRequest ::= SEQUENCE {
	*   certificationRequestInfo CertificationRequestInfo,
	*   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
	*   signature          BIT STRING
	* }
	*/
	var forge = require_forge();
	require_aes();
	require_asn1();
	require_des();
	require_md();
	require_mgf();
	require_oids();
	require_pem();
	require_pss$1();
	require_rsa$1();
	require_util();
	var asn1 = forge.asn1;
	var pki = module.exports = forge.pki = forge.pki || {};
	var oids = pki.oids;
	var _shortNames = {};
	_shortNames["CN"] = oids["commonName"];
	_shortNames["commonName"] = "CN";
	_shortNames["C"] = oids["countryName"];
	_shortNames["countryName"] = "C";
	_shortNames["L"] = oids["localityName"];
	_shortNames["localityName"] = "L";
	_shortNames["ST"] = oids["stateOrProvinceName"];
	_shortNames["stateOrProvinceName"] = "ST";
	_shortNames["O"] = oids["organizationName"];
	_shortNames["organizationName"] = "O";
	_shortNames["OU"] = oids["organizationalUnitName"];
	_shortNames["organizationalUnitName"] = "OU";
	_shortNames["E"] = oids["emailAddress"];
	_shortNames["emailAddress"] = "E";
	var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
	var x509CertificateValidator = {
		name: "Certificate",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "Certificate.TBSCertificate",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				captureAsn1: "tbsCertificate",
				value: [
					{
						name: "Certificate.TBSCertificate.version",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 0,
						constructed: true,
						optional: true,
						value: [{
							name: "Certificate.TBSCertificate.version.integer",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.INTEGER,
							constructed: false,
							capture: "certVersion"
						}]
					},
					{
						name: "Certificate.TBSCertificate.serialNumber",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						capture: "certSerialNumber"
					},
					{
						name: "Certificate.TBSCertificate.signature",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [{
							name: "Certificate.TBSCertificate.signature.algorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OID,
							constructed: false,
							capture: "certinfoSignatureOid"
						}, {
							name: "Certificate.TBSCertificate.signature.parameters",
							tagClass: asn1.Class.UNIVERSAL,
							optional: true,
							captureAsn1: "certinfoSignatureParams"
						}]
					},
					{
						name: "Certificate.TBSCertificate.issuer",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						captureAsn1: "certIssuer"
					},
					{
						name: "Certificate.TBSCertificate.validity",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [
							{
								name: "Certificate.TBSCertificate.validity.notBefore (utc)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.UTCTIME,
								constructed: false,
								optional: true,
								capture: "certValidity1UTCTime"
							},
							{
								name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.GENERALIZEDTIME,
								constructed: false,
								optional: true,
								capture: "certValidity2GeneralizedTime"
							},
							{
								name: "Certificate.TBSCertificate.validity.notAfter (utc)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.UTCTIME,
								constructed: false,
								optional: true,
								capture: "certValidity3UTCTime"
							},
							{
								name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.GENERALIZEDTIME,
								constructed: false,
								optional: true,
								capture: "certValidity4GeneralizedTime"
							}
						]
					},
					{
						name: "Certificate.TBSCertificate.subject",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						captureAsn1: "certSubject"
					},
					publicKeyValidator,
					{
						name: "Certificate.TBSCertificate.issuerUniqueID",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 1,
						constructed: true,
						optional: true,
						value: [{
							name: "Certificate.TBSCertificate.issuerUniqueID.id",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.BITSTRING,
							constructed: false,
							captureBitStringValue: "certIssuerUniqueId"
						}]
					},
					{
						name: "Certificate.TBSCertificate.subjectUniqueID",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 2,
						constructed: true,
						optional: true,
						value: [{
							name: "Certificate.TBSCertificate.subjectUniqueID.id",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.BITSTRING,
							constructed: false,
							captureBitStringValue: "certSubjectUniqueId"
						}]
					},
					{
						name: "Certificate.TBSCertificate.extensions",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 3,
						constructed: true,
						captureAsn1: "certExtensions",
						optional: true
					}
				]
			},
			{
				name: "Certificate.signatureAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "Certificate.signatureAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "certSignatureOid"
				}, {
					name: "Certificate.TBSCertificate.signature.parameters",
					tagClass: asn1.Class.UNIVERSAL,
					optional: true,
					captureAsn1: "certSignatureParams"
				}]
			},
			{
				name: "Certificate.signatureValue",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.BITSTRING,
				constructed: false,
				captureBitStringValue: "certSignature"
			}
		]
	};
	var rsassaPssParameterValidator = {
		name: "rsapss",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "rsapss.hashAlgorithm",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: true,
				value: [{
					name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.SEQUENCE,
					constructed: true,
					optional: true,
					value: [{
						name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OID,
						constructed: false,
						capture: "hashOid"
					}]
				}]
			},
			{
				name: "rsapss.maskGenAlgorithm",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 1,
				constructed: true,
				value: [{
					name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.SEQUENCE,
					constructed: true,
					optional: true,
					value: [{
						name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OID,
						constructed: false,
						capture: "maskGenOid"
					}, {
						name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [{
							name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OID,
							constructed: false,
							capture: "maskGenHashOid"
						}]
					}]
				}]
			},
			{
				name: "rsapss.saltLength",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 2,
				optional: true,
				value: [{
					name: "rsapss.saltLength.saltLength",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.INTEGER,
					constructed: false,
					capture: "saltLength"
				}]
			},
			{
				name: "rsapss.trailerField",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 3,
				optional: true,
				value: [{
					name: "rsapss.trailer.trailer",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.INTEGER,
					constructed: false,
					capture: "trailer"
				}]
			}
		]
	};
	var certificationRequestInfoValidator = {
		name: "CertificationRequestInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "certificationRequestInfo",
		value: [
			{
				name: "CertificationRequestInfo.integer",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "certificationRequestInfoVersion"
			},
			{
				name: "CertificationRequestInfo.subject",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				captureAsn1: "certificationRequestInfoSubject"
			},
			publicKeyValidator,
			{
				name: "CertificationRequestInfo.attributes",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: true,
				optional: true,
				capture: "certificationRequestInfoAttributes",
				value: [{
					name: "CertificationRequestInfo.attributes",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.SEQUENCE,
					constructed: true,
					value: [{
						name: "CertificationRequestInfo.attributes.type",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OID,
						constructed: false
					}, {
						name: "CertificationRequestInfo.attributes.value",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SET,
						constructed: true
					}]
				}]
			}
		]
	};
	var certificationRequestValidator = {
		name: "CertificationRequest",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "csr",
		value: [
			certificationRequestInfoValidator,
			{
				name: "CertificationRequest.signatureAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "CertificationRequest.signatureAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "csrSignatureOid"
				}, {
					name: "CertificationRequest.signatureAlgorithm.parameters",
					tagClass: asn1.Class.UNIVERSAL,
					optional: true,
					captureAsn1: "csrSignatureParams"
				}]
			},
			{
				name: "CertificationRequest.signature",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.BITSTRING,
				constructed: false,
				captureBitStringValue: "csrSignature"
			}
		]
	};
	/**
	* Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
	* sets into an array with objects that have type and value properties.
	*
	* @param rdn the RDNSequence to convert.
	* @param md a message digest to append type and value to if provided.
	*/
	pki.RDNAttributesAsArray = function(rdn, md) {
		var rval = [];
		var set$1, attr, obj;
		for (var si = 0; si < rdn.value.length; ++si) {
			set$1 = rdn.value[si];
			for (var i = 0; i < set$1.value.length; ++i) {
				obj = {};
				attr = set$1.value[i];
				obj.type = asn1.derToOid(attr.value[0].value);
				obj.value = attr.value[1].value;
				obj.valueTagClass = attr.value[1].type;
				if (obj.type in oids) {
					obj.name = oids[obj.type];
					if (obj.name in _shortNames) obj.shortName = _shortNames[obj.name];
				}
				if (md) {
					md.update(obj.type);
					md.update(obj.value);
				}
				rval.push(obj);
			}
		}
		return rval;
	};
	/**
	* Converts ASN.1 CRIAttributes into an array with objects that have type and
	* value properties.
	*
	* @param attributes the CRIAttributes to convert.
	*/
	pki.CRIAttributesAsArray = function(attributes) {
		var rval = [];
		for (var si = 0; si < attributes.length; ++si) {
			var seq = attributes[si];
			var type = asn1.derToOid(seq.value[0].value);
			var values = seq.value[1].value;
			for (var vi = 0; vi < values.length; ++vi) {
				var obj = {};
				obj.type = type;
				obj.value = values[vi].value;
				obj.valueTagClass = values[vi].type;
				if (obj.type in oids) {
					obj.name = oids[obj.type];
					if (obj.name in _shortNames) obj.shortName = _shortNames[obj.name];
				}
				if (obj.type === oids.extensionRequest) {
					obj.extensions = [];
					for (var ei = 0; ei < obj.value.length; ++ei) obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
				}
				rval.push(obj);
			}
		}
		return rval;
	};
	/**
	* Gets an issuer or subject attribute from its name, type, or short name.
	*
	* @param obj the issuer or subject object.
	* @param options a short name string or an object with:
	*          shortName the short name for the attribute.
	*          name the name for the attribute.
	*          type the type for the attribute.
	*
	* @return the attribute.
	*/
	function _getAttribute(obj, options) {
		if (typeof options === "string") options = { shortName: options };
		var rval = null;
		var attr;
		for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
			attr = obj.attributes[i];
			if (options.type && options.type === attr.type) rval = attr;
			else if (options.name && options.name === attr.name) rval = attr;
			else if (options.shortName && options.shortName === attr.shortName) rval = attr;
		}
		return rval;
	}
	/**
	* Converts signature parameters from ASN.1 structure.
	*
	* Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
	* no parameters.
	*
	* RSASSA-PSS-params  ::=  SEQUENCE  {
	*   hashAlgorithm      [0] HashAlgorithm DEFAULT
	*                             sha1Identifier,
	*   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
	*                             mgf1SHA1Identifier,
	*   saltLength         [2] INTEGER DEFAULT 20,
	*   trailerField       [3] INTEGER DEFAULT 1
	* }
	*
	* HashAlgorithm  ::=  AlgorithmIdentifier
	*
	* MaskGenAlgorithm  ::=  AlgorithmIdentifier
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*   algorithm OBJECT IDENTIFIER,
	*   parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* @param oid The OID specifying the signature algorithm
	* @param obj The ASN.1 structure holding the parameters
	* @param fillDefaults Whether to use return default values where omitted
	* @return signature parameter object
	*/
	var _readSignatureParameters = function(oid, obj, fillDefaults) {
		var params = {};
		if (oid !== oids["RSASSA-PSS"]) return params;
		if (fillDefaults) params = {
			hash: { algorithmOid: oids["sha1"] },
			mgf: {
				algorithmOid: oids["mgf1"],
				hash: { algorithmOid: oids["sha1"] }
			},
			saltLength: 20
		};
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read RSASSA-PSS parameter block.");
			error$47.errors = errors;
			throw error$47;
		}
		if (capture.hashOid !== void 0) {
			params.hash = params.hash || {};
			params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
		}
		if (capture.maskGenOid !== void 0) {
			params.mgf = params.mgf || {};
			params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
			params.mgf.hash = params.mgf.hash || {};
			params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
		}
		if (capture.saltLength !== void 0) params.saltLength = capture.saltLength.charCodeAt(0);
		return params;
	};
	/**
	* Create signature digest for OID.
	*
	* @param options
	*   signatureOid: the OID specifying the signature algorithm.
	*   type: a human readable type for error messages
	* @return a created md instance. throws if unknown oid.
	*/
	var _createSignatureDigest = function(options) {
		switch (oids[options.signatureOid]) {
			case "sha1WithRSAEncryption":
			case "sha1WithRSASignature": return forge.md.sha1.create();
			case "md5WithRSAEncryption": return forge.md.md5.create();
			case "sha256WithRSAEncryption": return forge.md.sha256.create();
			case "sha384WithRSAEncryption": return forge.md.sha384.create();
			case "sha512WithRSAEncryption": return forge.md.sha512.create();
			case "RSASSA-PSS": return forge.md.sha256.create();
			default:
				var error$47 = /* @__PURE__ */ new Error("Could not compute " + options.type + " digest. Unknown signature OID.");
				error$47.signatureOid = options.signatureOid;
				throw error$47;
		}
	};
	/**
	* Verify signature on certificate or CSR.
	*
	* @param options:
	*   certificate the certificate or CSR to verify.
	*   md the signature digest.
	*   signature the signature
	* @return a created md instance. throws if unknown oid.
	*/
	var _verifySignature = function(options) {
		var cert = options.certificate;
		var scheme;
		switch (cert.signatureOid) {
			case oids.sha1WithRSAEncryption:
			case oids.sha1WithRSASignature: break;
			case oids["RSASSA-PSS"]:
				var hash$1 = oids[cert.signatureParameters.mgf.hash.algorithmOid], mgf;
				if (hash$1 === void 0 || forge.md[hash$1] === void 0) {
					var error$47 = /* @__PURE__ */ new Error("Unsupported MGF hash function.");
					error$47.oid = cert.signatureParameters.mgf.hash.algorithmOid;
					error$47.name = hash$1;
					throw error$47;
				}
				mgf = oids[cert.signatureParameters.mgf.algorithmOid];
				if (mgf === void 0 || forge.mgf[mgf] === void 0) {
					var error$47 = /* @__PURE__ */ new Error("Unsupported MGF function.");
					error$47.oid = cert.signatureParameters.mgf.algorithmOid;
					error$47.name = mgf;
					throw error$47;
				}
				mgf = forge.mgf[mgf].create(forge.md[hash$1].create());
				hash$1 = oids[cert.signatureParameters.hash.algorithmOid];
				if (hash$1 === void 0 || forge.md[hash$1] === void 0) {
					var error$47 = /* @__PURE__ */ new Error("Unsupported RSASSA-PSS hash function.");
					error$47.oid = cert.signatureParameters.hash.algorithmOid;
					error$47.name = hash$1;
					throw error$47;
				}
				scheme = forge.pss.create(forge.md[hash$1].create(), mgf, cert.signatureParameters.saltLength);
				break;
		}
		return cert.publicKey.verify(options.md.digest().getBytes(), options.signature, scheme);
	};
	/**
	* Converts an X.509 certificate from PEM format.
	*
	* Note: If the certificate is to be verified then compute hash should
	* be set to true. This will scan the TBSCertificate part of the ASN.1
	* object while it is converted so it doesn't need to be converted back
	* to ASN.1-DER-encoding later.
	*
	* @param pem the PEM-formatted certificate.
	* @param computeHash true to compute the hash for verification.
	* @param strict true to be strict when checking ASN.1 value lengths, false to
	*          allow truncated values (default: true).
	*
	* @return the certificate.
	*/
	pki.certificateFromPem = function(pem, computeHash, strict) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert certificate from PEM; PEM header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".");
			error$47.headerType = msg.type;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body, strict);
		return pki.certificateFromAsn1(obj, computeHash);
	};
	/**
	* Converts an X.509 certificate to PEM format.
	*
	* @param cert the certificate.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted certificate.
	*/
	pki.certificateToPem = function(cert, maxline) {
		var msg = {
			type: "CERTIFICATE",
			body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts an RSA public key from PEM format.
	*
	* @param pem the PEM-formatted public key.
	*
	* @return the public key.
	*/
	pki.publicKeyFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert public key from PEM; PEM header type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".");
			error$47.headerType = msg.type;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body);
		return pki.publicKeyFromAsn1(obj);
	};
	/**
	* Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
	*
	* @param key the public key.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted public key.
	*/
	pki.publicKeyToPem = function(key, maxline) {
		var msg = {
			type: "PUBLIC KEY",
			body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts an RSA public key to PEM format (using an RSAPublicKey).
	*
	* @param key the public key.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted public key.
	*/
	pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
		var msg = {
			type: "RSA PUBLIC KEY",
			body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Gets a fingerprint for the given public key.
	*
	* @param options the options to use.
	*          [md] the message digest object to use (defaults to forge.md.sha1).
	*          [type] the type of fingerprint, such as 'RSAPublicKey',
	*            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
	*          [encoding] an alternative output encoding, such as 'hex'
	*            (defaults to none, outputs a byte buffer).
	*          [delimiter] the delimiter to use between bytes for 'hex' encoded
	*            output, eg: ':' (defaults to none).
	*
	* @return the fingerprint as a byte buffer or other encoding based on options.
	*/
	pki.getPublicKeyFingerprint = function(key, options) {
		options = options || {};
		var md = options.md || forge.md.sha1.create();
		var type = options.type || "RSAPublicKey";
		var bytes;
		switch (type) {
			case "RSAPublicKey":
				bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
				break;
			case "SubjectPublicKeyInfo":
				bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
				break;
			default: throw new Error("Unknown fingerprint type \"" + options.type + "\".");
		}
		md.start();
		md.update(bytes);
		var digest = md.digest();
		if (options.encoding === "hex") {
			var hex$2 = digest.toHex();
			if (options.delimiter) return hex$2.match(/.{2}/g).join(options.delimiter);
			return hex$2;
		} else if (options.encoding === "binary") return digest.getBytes();
		else if (options.encoding) throw new Error("Unknown encoding \"" + options.encoding + "\".");
		return digest;
	};
	/**
	* Converts a PKCS#10 certification request (CSR) from PEM format.
	*
	* Note: If the certification request is to be verified then compute hash
	* should be set to true. This will scan the CertificationRequestInfo part of
	* the ASN.1 object while it is converted so it doesn't need to be converted
	* back to ASN.1-DER-encoding later.
	*
	* @param pem the PEM-formatted certificate.
	* @param computeHash true to compute the hash for verification.
	* @param strict true to be strict when checking ASN.1 value lengths, false to
	*          allow truncated values (default: true).
	*
	* @return the certification request (CSR).
	*/
	pki.certificationRequestFromPem = function(pem, computeHash, strict) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "CERTIFICATE REQUEST") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert certification request from PEM; PEM header type is not \"CERTIFICATE REQUEST\".");
			error$47.headerType = msg.type;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body, strict);
		return pki.certificationRequestFromAsn1(obj, computeHash);
	};
	/**
	* Converts a PKCS#10 certification request (CSR) to PEM format.
	*
	* @param csr the certification request.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted certification request.
	*/
	pki.certificationRequestToPem = function(csr, maxline) {
		var msg = {
			type: "CERTIFICATE REQUEST",
			body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Creates an empty X.509v3 RSA certificate.
	*
	* @return the certificate.
	*/
	pki.createCertificate = function() {
		var cert = {};
		cert.version = 2;
		cert.serialNumber = "00";
		cert.signatureOid = null;
		cert.signature = null;
		cert.siginfo = {};
		cert.siginfo.algorithmOid = null;
		cert.validity = {};
		cert.validity.notBefore = /* @__PURE__ */ new Date();
		cert.validity.notAfter = /* @__PURE__ */ new Date();
		cert.issuer = {};
		cert.issuer.getField = function(sn) {
			return _getAttribute(cert.issuer, sn);
		};
		cert.issuer.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.issuer.attributes.push(attr);
		};
		cert.issuer.attributes = [];
		cert.issuer.hash = null;
		cert.subject = {};
		cert.subject.getField = function(sn) {
			return _getAttribute(cert.subject, sn);
		};
		cert.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.subject.attributes.push(attr);
		};
		cert.subject.attributes = [];
		cert.subject.hash = null;
		cert.extensions = [];
		cert.publicKey = null;
		cert.md = null;
		/**
		* Sets the subject of this certificate.
		*
		* @param attrs the array of subject attributes to use.
		* @param uniqueId an optional a unique ID to use.
		*/
		cert.setSubject = function(attrs, uniqueId) {
			_fillMissingFields(attrs);
			cert.subject.attributes = attrs;
			delete cert.subject.uniqueId;
			if (uniqueId) cert.subject.uniqueId = uniqueId;
			cert.subject.hash = null;
		};
		/**
		* Sets the issuer of this certificate.
		*
		* @param attrs the array of issuer attributes to use.
		* @param uniqueId an optional a unique ID to use.
		*/
		cert.setIssuer = function(attrs, uniqueId) {
			_fillMissingFields(attrs);
			cert.issuer.attributes = attrs;
			delete cert.issuer.uniqueId;
			if (uniqueId) cert.issuer.uniqueId = uniqueId;
			cert.issuer.hash = null;
		};
		/**
		* Sets the extensions of this certificate.
		*
		* @param exts the array of extensions to use.
		*/
		cert.setExtensions = function(exts) {
			for (var i = 0; i < exts.length; ++i) _fillMissingExtensionFields(exts[i], { cert });
			cert.extensions = exts;
		};
		/**
		* Gets an extension by its name or id.
		*
		* @param options the name to use or an object with:
		*          name the name to use.
		*          id the id to use.
		*
		* @return the extension or null if not found.
		*/
		cert.getExtension = function(options) {
			if (typeof options === "string") options = { name: options };
			var rval = null;
			var ext;
			for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
				ext = cert.extensions[i];
				if (options.id && ext.id === options.id) rval = ext;
				else if (options.name && ext.name === options.name) rval = ext;
			}
			return rval;
		};
		/**
		* Signs this certificate using the given private key.
		*
		* @param key the private key to sign with.
		* @param md the message digest object to use (defaults to forge.md.sha1).
		*/
		cert.sign = function(key, md) {
			cert.md = md || forge.md.sha1.create();
			var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
			if (!algorithmOid) {
				var error$47 = /* @__PURE__ */ new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
				error$47.algorithm = cert.md.algorithm;
				throw error$47;
			}
			cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
			cert.tbsCertificate = pki.getTBSCertificate(cert);
			var bytes = asn1.toDer(cert.tbsCertificate);
			cert.md.update(bytes.getBytes());
			cert.signature = key.sign(cert.md);
		};
		/**
		* Attempts verify the signature on the passed certificate using this
		* certificate's public key.
		*
		* @param child the certificate to verify.
		*
		* @return true if verified, false if not.
		*/
		cert.verify = function(child) {
			var rval = false;
			if (!cert.issued(child)) {
				var issuer = child.issuer;
				var subject = cert.subject;
				var error$47 = /* @__PURE__ */ new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
				error$47.expectedIssuer = subject.attributes;
				error$47.actualIssuer = issuer.attributes;
				throw error$47;
			}
			var md = child.md;
			if (md === null) {
				md = _createSignatureDigest({
					signatureOid: child.signatureOid,
					type: "certificate"
				});
				var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
				var bytes = asn1.toDer(tbsCertificate);
				md.update(bytes.getBytes());
			}
			if (md !== null) rval = _verifySignature({
				certificate: cert,
				md,
				signature: child.signature
			});
			return rval;
		};
		/**
		* Returns true if this certificate's issuer matches the passed
		* certificate's subject. Note that no signature check is performed.
		*
		* @param parent the certificate to check.
		*
		* @return true if this certificate's issuer matches the passed certificate's
		*         subject.
		*/
		cert.isIssuer = function(parent) {
			var rval = false;
			var i = cert.issuer;
			var s = parent.subject;
			if (i.hash && s.hash) rval = i.hash === s.hash;
			else if (i.attributes.length === s.attributes.length) {
				rval = true;
				var iattr, sattr;
				for (var n = 0; rval && n < i.attributes.length; ++n) {
					iattr = i.attributes[n];
					sattr = s.attributes[n];
					if (iattr.type !== sattr.type || iattr.value !== sattr.value) rval = false;
				}
			}
			return rval;
		};
		/**
		* Returns true if this certificate's subject matches the issuer of the
		* given certificate). Note that not signature check is performed.
		*
		* @param child the certificate to check.
		*
		* @return true if this certificate's subject matches the passed
		*         certificate's issuer.
		*/
		cert.issued = function(child) {
			return child.isIssuer(cert);
		};
		/**
		* Generates the subjectKeyIdentifier for this certificate as byte buffer.
		*
		* @return the subjectKeyIdentifier for this certificate as byte buffer.
		*/
		cert.generateSubjectKeyIdentifier = function() {
			return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
		};
		/**
		* Verifies the subjectKeyIdentifier extension value for this certificate
		* against its public key. If no extension is found, false will be
		* returned.
		*
		* @return true if verified, false if not.
		*/
		cert.verifySubjectKeyIdentifier = function() {
			var oid = oids["subjectKeyIdentifier"];
			for (var i = 0; i < cert.extensions.length; ++i) {
				var ext = cert.extensions[i];
				if (ext.id === oid) {
					var ski = cert.generateSubjectKeyIdentifier().getBytes();
					return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
				}
			}
			return false;
		};
		return cert;
	};
	/**
	* Converts an X.509v3 RSA certificate from an ASN.1 object.
	*
	* Note: If the certificate is to be verified then compute hash should
	* be set to true. There is currently no implementation for converting
	* a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
	* object needs to be scanned before the cert object is created.
	*
	* @param obj the asn1 representation of an X.509v3 RSA certificate.
	* @param computeHash true to compute the hash for verification.
	*
	* @return the certificate.
	*/
	pki.certificateFromAsn1 = function(obj, computeHash) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
			error$47.errors = errors;
			throw error$47;
		}
		if (asn1.derToOid(capture.publicKeyOid) !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
		var cert = pki.createCertificate();
		cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
		cert.serialNumber = forge.util.createBuffer(capture.certSerialNumber).toHex();
		cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
		cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
		cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
		cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
		cert.signature = capture.certSignature;
		var validity = [];
		if (capture.certValidity1UTCTime !== void 0) validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
		if (capture.certValidity2GeneralizedTime !== void 0) validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
		if (capture.certValidity3UTCTime !== void 0) validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
		if (capture.certValidity4GeneralizedTime !== void 0) validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
		if (validity.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
		if (validity.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
		cert.validity.notBefore = validity[0];
		cert.validity.notAfter = validity[1];
		cert.tbsCertificate = capture.tbsCertificate;
		if (computeHash) {
			cert.md = _createSignatureDigest({
				signatureOid: cert.signatureOid,
				type: "certificate"
			});
			var bytes = asn1.toDer(cert.tbsCertificate);
			cert.md.update(bytes.getBytes());
		}
		var imd = forge.md.sha1.create();
		var ibytes = asn1.toDer(capture.certIssuer);
		imd.update(ibytes.getBytes());
		cert.issuer.getField = function(sn) {
			return _getAttribute(cert.issuer, sn);
		};
		cert.issuer.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.issuer.attributes.push(attr);
		};
		cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
		if (capture.certIssuerUniqueId) cert.issuer.uniqueId = capture.certIssuerUniqueId;
		cert.issuer.hash = imd.digest().toHex();
		var smd = forge.md.sha1.create();
		var sbytes = asn1.toDer(capture.certSubject);
		smd.update(sbytes.getBytes());
		cert.subject.getField = function(sn) {
			return _getAttribute(cert.subject, sn);
		};
		cert.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.subject.attributes.push(attr);
		};
		cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
		if (capture.certSubjectUniqueId) cert.subject.uniqueId = capture.certSubjectUniqueId;
		cert.subject.hash = smd.digest().toHex();
		if (capture.certExtensions) cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
		else cert.extensions = [];
		cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
		return cert;
	};
	/**
	* Converts an ASN.1 extensions object (with extension sequences as its
	* values) into an array of extension objects with types and values.
	*
	* Supported extensions:
	*
	* id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
	* KeyUsage ::= BIT STRING {
	*   digitalSignature        (0),
	*   nonRepudiation          (1),
	*   keyEncipherment         (2),
	*   dataEncipherment        (3),
	*   keyAgreement            (4),
	*   keyCertSign             (5),
	*   cRLSign                 (6),
	*   encipherOnly            (7),
	*   decipherOnly            (8)
	* }
	*
	* id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
	* BasicConstraints ::= SEQUENCE {
	*   cA                      BOOLEAN DEFAULT FALSE,
	*   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
	* }
	*
	* subjectAltName EXTENSION ::= {
	*   SYNTAX GeneralNames
	*   IDENTIFIED BY id-ce-subjectAltName
	* }
	*
	* GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
	*
	* GeneralName ::= CHOICE {
	*   otherName      [0] INSTANCE OF OTHER-NAME,
	*   rfc822Name     [1] IA5String,
	*   dNSName        [2] IA5String,
	*   x400Address    [3] ORAddress,
	*   directoryName  [4] Name,
	*   ediPartyName   [5] EDIPartyName,
	*   uniformResourceIdentifier [6] IA5String,
	*   IPAddress      [7] OCTET STRING,
	*   registeredID   [8] OBJECT IDENTIFIER
	* }
	*
	* OTHER-NAME ::= TYPE-IDENTIFIER
	*
	* EDIPartyName ::= SEQUENCE {
	*   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
	*   partyName    [1] DirectoryString {ub-name}
	* }
	*
	* @param exts the extensions ASN.1 with extension sequences to parse.
	*
	* @return the array.
	*/
	pki.certificateExtensionsFromAsn1 = function(exts) {
		var rval = [];
		for (var i = 0; i < exts.value.length; ++i) {
			var extseq = exts.value[i];
			for (var ei = 0; ei < extseq.value.length; ++ei) rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
		}
		return rval;
	};
	/**
	* Parses a single certificate extension from ASN.1.
	*
	* @param ext the extension in ASN.1 format.
	*
	* @return the parsed extension as an object.
	*/
	pki.certificateExtensionFromAsn1 = function(ext) {
		var e = {};
		e.id = asn1.derToOid(ext.value[0].value);
		e.critical = false;
		if (ext.value[1].type === asn1.Type.BOOLEAN) {
			e.critical = ext.value[1].value.charCodeAt(0) !== 0;
			e.value = ext.value[2].value;
		} else e.value = ext.value[1].value;
		if (e.id in oids) {
			e.name = oids[e.id];
			if (e.name === "keyUsage") {
				var ev = asn1.fromDer(e.value);
				var b2 = 0;
				var b3 = 0;
				if (ev.value.length > 1) {
					b2 = ev.value.charCodeAt(1);
					b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
				}
				e.digitalSignature = (b2 & 128) === 128;
				e.nonRepudiation = (b2 & 64) === 64;
				e.keyEncipherment = (b2 & 32) === 32;
				e.dataEncipherment = (b2 & 16) === 16;
				e.keyAgreement = (b2 & 8) === 8;
				e.keyCertSign = (b2 & 4) === 4;
				e.cRLSign = (b2 & 2) === 2;
				e.encipherOnly = (b2 & 1) === 1;
				e.decipherOnly = (b3 & 128) === 128;
			} else if (e.name === "basicConstraints") {
				var ev = asn1.fromDer(e.value);
				if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) e.cA = ev.value[0].value.charCodeAt(0) !== 0;
				else e.cA = false;
				var value = null;
				if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) value = ev.value[0].value;
				else if (ev.value.length > 1) value = ev.value[1].value;
				if (value !== null) e.pathLenConstraint = asn1.derToInteger(value);
			} else if (e.name === "extKeyUsage") {
				var ev = asn1.fromDer(e.value);
				for (var vi = 0; vi < ev.value.length; ++vi) {
					var oid = asn1.derToOid(ev.value[vi].value);
					if (oid in oids) e[oids[oid]] = true;
					else e[oid] = true;
				}
			} else if (e.name === "nsCertType") {
				var ev = asn1.fromDer(e.value);
				var b2 = 0;
				if (ev.value.length > 1) b2 = ev.value.charCodeAt(1);
				e.client = (b2 & 128) === 128;
				e.server = (b2 & 64) === 64;
				e.email = (b2 & 32) === 32;
				e.objsign = (b2 & 16) === 16;
				e.reserved = (b2 & 8) === 8;
				e.sslCA = (b2 & 4) === 4;
				e.emailCA = (b2 & 2) === 2;
				e.objCA = (b2 & 1) === 1;
			} else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
				e.altNames = [];
				var gn;
				var ev = asn1.fromDer(e.value);
				for (var n = 0; n < ev.value.length; ++n) {
					gn = ev.value[n];
					var altName = {
						type: gn.type,
						value: gn.value
					};
					e.altNames.push(altName);
					switch (gn.type) {
						case 1:
						case 2:
						case 6: break;
						case 7:
							altName.ip = forge.util.bytesToIP(gn.value);
							break;
						case 8:
							altName.oid = asn1.derToOid(gn.value);
							break;
						default:
					}
				}
			} else if (e.name === "subjectKeyIdentifier") {
				var ev = asn1.fromDer(e.value);
				e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
			}
		}
		return e;
	};
	/**
	* Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
	*
	* Note: If the certification request is to be verified then compute hash
	* should be set to true. There is currently no implementation for converting
	* a certificate back to ASN.1 so the CertificationRequestInfo part of the
	* ASN.1 object needs to be scanned before the csr object is created.
	*
	* @param obj the asn1 representation of a PKCS#10 certification request (CSR).
	* @param computeHash true to compute the hash for verification.
	*
	* @return the certification request (CSR).
	*/
	pki.certificationRequestFromAsn1 = function(obj, computeHash) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
			error$47.errors = errors;
			throw error$47;
		}
		if (asn1.derToOid(capture.publicKeyOid) !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
		var csr = pki.createCertificationRequest();
		csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
		csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
		csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
		csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
		csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
		csr.signature = capture.csrSignature;
		csr.certificationRequestInfo = capture.certificationRequestInfo;
		if (computeHash) {
			csr.md = _createSignatureDigest({
				signatureOid: csr.signatureOid,
				type: "certification request"
			});
			var bytes = asn1.toDer(csr.certificationRequestInfo);
			csr.md.update(bytes.getBytes());
		}
		var smd = forge.md.sha1.create();
		csr.subject.getField = function(sn) {
			return _getAttribute(csr.subject, sn);
		};
		csr.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			csr.subject.attributes.push(attr);
		};
		csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
		csr.subject.hash = smd.digest().toHex();
		csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
		csr.getAttribute = function(sn) {
			return _getAttribute(csr, sn);
		};
		csr.addAttribute = function(attr) {
			_fillMissingFields([attr]);
			csr.attributes.push(attr);
		};
		csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
		return csr;
	};
	/**
	* Creates an empty certification request (a CSR or certificate signing
	* request). Once created, its public key and attributes can be set and then
	* it can be signed.
	*
	* @return the empty certification request.
	*/
	pki.createCertificationRequest = function() {
		var csr = {};
		csr.version = 0;
		csr.signatureOid = null;
		csr.signature = null;
		csr.siginfo = {};
		csr.siginfo.algorithmOid = null;
		csr.subject = {};
		csr.subject.getField = function(sn) {
			return _getAttribute(csr.subject, sn);
		};
		csr.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			csr.subject.attributes.push(attr);
		};
		csr.subject.attributes = [];
		csr.subject.hash = null;
		csr.publicKey = null;
		csr.attributes = [];
		csr.getAttribute = function(sn) {
			return _getAttribute(csr, sn);
		};
		csr.addAttribute = function(attr) {
			_fillMissingFields([attr]);
			csr.attributes.push(attr);
		};
		csr.md = null;
		/**
		* Sets the subject of this certification request.
		*
		* @param attrs the array of subject attributes to use.
		*/
		csr.setSubject = function(attrs) {
			_fillMissingFields(attrs);
			csr.subject.attributes = attrs;
			csr.subject.hash = null;
		};
		/**
		* Sets the attributes of this certification request.
		*
		* @param attrs the array of attributes to use.
		*/
		csr.setAttributes = function(attrs) {
			_fillMissingFields(attrs);
			csr.attributes = attrs;
		};
		/**
		* Signs this certification request using the given private key.
		*
		* @param key the private key to sign with.
		* @param md the message digest object to use (defaults to forge.md.sha1).
		*/
		csr.sign = function(key, md) {
			csr.md = md || forge.md.sha1.create();
			var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
			if (!algorithmOid) {
				var error$47 = /* @__PURE__ */ new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
				error$47.algorithm = csr.md.algorithm;
				throw error$47;
			}
			csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
			csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
			var bytes = asn1.toDer(csr.certificationRequestInfo);
			csr.md.update(bytes.getBytes());
			csr.signature = key.sign(csr.md);
		};
		/**
		* Attempts verify the signature on the passed certification request using
		* its public key.
		*
		* A CSR that has been exported to a file in PEM format can be verified using
		* OpenSSL using this command:
		*
		* openssl req -in <the-csr-pem-file> -verify -noout -text
		*
		* @return true if verified, false if not.
		*/
		csr.verify = function() {
			var rval = false;
			var md = csr.md;
			if (md === null) {
				md = _createSignatureDigest({
					signatureOid: csr.signatureOid,
					type: "certification request"
				});
				var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
				var bytes = asn1.toDer(cri);
				md.update(bytes.getBytes());
			}
			if (md !== null) rval = _verifySignature({
				certificate: csr,
				md,
				signature: csr.signature
			});
			return rval;
		};
		return csr;
	};
	/**
	* Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
	*
	* @param obj the subject or issuer (distinguished name).
	*
	* @return the ASN.1 RDNSequence.
	*/
	function _dnToAsn1(obj) {
		var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		var attr, set$1;
		var attrs = obj.attributes;
		for (var i = 0; i < attrs.length; ++i) {
			attr = attrs[i];
			var value = attr.value;
			var valueTagClass = asn1.Type.PRINTABLESTRING;
			if ("valueTagClass" in attr) {
				valueTagClass = attr.valueTagClass;
				if (valueTagClass === asn1.Type.UTF8) value = forge.util.encodeUtf8(value);
			}
			set$1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]);
			rval.value.push(set$1);
		}
		return rval;
	}
	/**
	* Fills in missing fields in attributes.
	*
	* @param attrs the attributes to fill missing fields in.
	*/
	function _fillMissingFields(attrs) {
		var attr;
		for (var i = 0; i < attrs.length; ++i) {
			attr = attrs[i];
			if (typeof attr.name === "undefined") {
				if (attr.type && attr.type in pki.oids) attr.name = pki.oids[attr.type];
				else if (attr.shortName && attr.shortName in _shortNames) attr.name = pki.oids[_shortNames[attr.shortName]];
			}
			if (typeof attr.type === "undefined") if (attr.name && attr.name in pki.oids) attr.type = pki.oids[attr.name];
			else {
				var error$47 = /* @__PURE__ */ new Error("Attribute type not specified.");
				error$47.attribute = attr;
				throw error$47;
			}
			if (typeof attr.shortName === "undefined") {
				if (attr.name && attr.name in _shortNames) attr.shortName = _shortNames[attr.name];
			}
			if (attr.type === oids.extensionRequest) {
				attr.valueConstructed = true;
				attr.valueTagClass = asn1.Type.SEQUENCE;
				if (!attr.value && attr.extensions) {
					attr.value = [];
					for (var ei = 0; ei < attr.extensions.length; ++ei) attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
				}
			}
			if (typeof attr.value === "undefined") {
				var error$47 = /* @__PURE__ */ new Error("Attribute value not specified.");
				error$47.attribute = attr;
				throw error$47;
			}
		}
	}
	/**
	* Fills in missing fields in certificate extensions.
	*
	* @param e the extension.
	* @param [options] the options to use.
	*          [cert] the certificate the extensions are for.
	*
	* @return the extension.
	*/
	function _fillMissingExtensionFields(e, options) {
		options = options || {};
		if (typeof e.name === "undefined") {
			if (e.id && e.id in pki.oids) e.name = pki.oids[e.id];
		}
		if (typeof e.id === "undefined") if (e.name && e.name in pki.oids) e.id = pki.oids[e.name];
		else {
			var error$47 = /* @__PURE__ */ new Error("Extension ID not specified.");
			error$47.extension = e;
			throw error$47;
		}
		if (typeof e.value !== "undefined") return e;
		if (e.name === "keyUsage") {
			var unused = 0;
			var b2 = 0;
			var b3 = 0;
			if (e.digitalSignature) {
				b2 |= 128;
				unused = 7;
			}
			if (e.nonRepudiation) {
				b2 |= 64;
				unused = 6;
			}
			if (e.keyEncipherment) {
				b2 |= 32;
				unused = 5;
			}
			if (e.dataEncipherment) {
				b2 |= 16;
				unused = 4;
			}
			if (e.keyAgreement) {
				b2 |= 8;
				unused = 3;
			}
			if (e.keyCertSign) {
				b2 |= 4;
				unused = 2;
			}
			if (e.cRLSign) {
				b2 |= 2;
				unused = 1;
			}
			if (e.encipherOnly) {
				b2 |= 1;
				unused = 0;
			}
			if (e.decipherOnly) {
				b3 |= 128;
				unused = 7;
			}
			var value = String.fromCharCode(unused);
			if (b3 !== 0) value += String.fromCharCode(b2) + String.fromCharCode(b3);
			else if (b2 !== 0) value += String.fromCharCode(b2);
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
		} else if (e.name === "basicConstraints") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			if (e.cA) e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
			if ("pathLenConstraint" in e) e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
		} else if (e.name === "extKeyUsage") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var seq = e.value.value;
			for (var key in e) {
				if (e[key] !== true) continue;
				if (key in oids) seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
				else if (key.indexOf(".") !== -1) seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
			}
		} else if (e.name === "nsCertType") {
			var unused = 0;
			var b2 = 0;
			if (e.client) {
				b2 |= 128;
				unused = 7;
			}
			if (e.server) {
				b2 |= 64;
				unused = 6;
			}
			if (e.email) {
				b2 |= 32;
				unused = 5;
			}
			if (e.objsign) {
				b2 |= 16;
				unused = 4;
			}
			if (e.reserved) {
				b2 |= 8;
				unused = 3;
			}
			if (e.sslCA) {
				b2 |= 4;
				unused = 2;
			}
			if (e.emailCA) {
				b2 |= 2;
				unused = 1;
			}
			if (e.objCA) {
				b2 |= 1;
				unused = 0;
			}
			var value = String.fromCharCode(unused);
			if (b2 !== 0) value += String.fromCharCode(b2);
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
		} else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var altName;
			for (var n = 0; n < e.altNames.length; ++n) {
				altName = e.altNames[n];
				var value = altName.value;
				if (altName.type === 7 && altName.ip) {
					value = forge.util.bytesFromIP(altName.ip);
					if (value === null) {
						var error$47 = /* @__PURE__ */ new Error("Extension \"ip\" value is not a valid IPv4 or IPv6 address.");
						error$47.extension = e;
						throw error$47;
					}
				} else if (altName.type === 8) if (altName.oid) value = asn1.oidToDer(asn1.oidToDer(altName.oid));
				else value = asn1.oidToDer(value);
				e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
			}
		} else if (e.name === "nsComment" && options.cert) {
			if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) throw new Error("Invalid \"nsComment\" content.");
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
		} else if (e.name === "subjectKeyIdentifier" && options.cert) {
			var ski = options.cert.generateSubjectKeyIdentifier();
			e.subjectKeyIdentifier = ski.toHex();
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
		} else if (e.name === "authorityKeyIdentifier" && options.cert) {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var seq = e.value.value;
			if (e.keyIdentifier) {
				var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
				seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
			}
			if (e.authorityCertIssuer) {
				var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [_dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)])];
				seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
			}
			if (e.serialNumber) {
				var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
				seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
			}
		} else if (e.name === "cRLDistributionPoints") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var seq = e.value.value;
			var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
			var altName;
			for (var n = 0; n < e.altNames.length; ++n) {
				altName = e.altNames[n];
				var value = altName.value;
				if (altName.type === 7 && altName.ip) {
					value = forge.util.bytesFromIP(altName.ip);
					if (value === null) {
						var error$47 = /* @__PURE__ */ new Error("Extension \"ip\" value is not a valid IPv4 or IPv6 address.");
						error$47.extension = e;
						throw error$47;
					}
				} else if (altName.type === 8) if (altName.oid) value = asn1.oidToDer(asn1.oidToDer(altName.oid));
				else value = asn1.oidToDer(value);
				fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
			}
			subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
			seq.push(subSeq);
		}
		if (typeof e.value === "undefined") {
			var error$47 = /* @__PURE__ */ new Error("Extension value not specified.");
			error$47.extension = e;
			throw error$47;
		}
		return e;
	}
	/**
	* Convert signature parameters object to ASN.1
	*
	* @param {String} oid Signature algorithm OID
	* @param params The signature parameters object
	* @return ASN.1 object representing signature parameters
	*/
	function _signatureParametersToAsn1(oid, params) {
		switch (oid) {
			case oids["RSASSA-PSS"]:
				var parts = [];
				if (params.hash.algorithmOid !== void 0) parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])]));
				if (params.mgf.algorithmOid !== void 0) parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])])]));
				if (params.saltLength !== void 0) parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())]));
				return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
			default: return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
		}
	}
	/**
	* Converts a certification request's attributes to an ASN.1 set of
	* CRIAttributes.
	*
	* @param csr certification request.
	*
	* @return the ASN.1 set of CRIAttributes.
	*/
	function _CRIAttributesToAsn1(csr) {
		var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
		if (csr.attributes.length === 0) return rval;
		var attrs = csr.attributes;
		for (var i = 0; i < attrs.length; ++i) {
			var attr = attrs[i];
			var value = attr.value;
			var valueTagClass = asn1.Type.UTF8;
			if ("valueTagClass" in attr) valueTagClass = attr.valueTagClass;
			if (valueTagClass === asn1.Type.UTF8) value = forge.util.encodeUtf8(value);
			var valueConstructed = false;
			if ("valueConstructed" in attr) valueConstructed = attr.valueConstructed;
			var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
			rval.value.push(seq);
		}
		return rval;
	}
	var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
	var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
	/**
	* Converts a Date object to ASN.1
	* Handles the different format before and after 1st January 2050
	*
	* @param date date object.
	*
	* @return the ASN.1 object representing the date.
	*/
	function _dateToAsn1(date$4) {
		if (date$4 >= jan_1_1950 && date$4 < jan_1_2050) return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date$4));
		else return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date$4));
	}
	/**
	* Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
	*
	* @param cert the certificate.
	*
	* @return the asn1 TBSCertificate.
	*/
	pki.getTBSCertificate = function(cert) {
		var notBefore = _dateToAsn1(cert.validity.notBefore);
		var notAfter = _dateToAsn1(cert.validity.notAfter);
		var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]),
			_dnToAsn1(cert.issuer),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [notBefore, notAfter]),
			_dnToAsn1(cert.subject),
			pki.publicKeyToAsn1(cert.publicKey)
		]);
		if (cert.issuer.uniqueId) tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)]));
		if (cert.subject.uniqueId) tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)]));
		if (cert.extensions.length > 0) tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
		return tbs;
	};
	/**
	* Gets the ASN.1 CertificationRequestInfo part of a
	* PKCS#10 CertificationRequest.
	*
	* @param csr the certification request.
	*
	* @return the asn1 CertificationRequestInfo.
	*/
	pki.getCertificationRequestInfo = function(csr) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
			_dnToAsn1(csr.subject),
			pki.publicKeyToAsn1(csr.publicKey),
			_CRIAttributesToAsn1(csr)
		]);
	};
	/**
	* Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
	*
	* @param dn the DistinguishedName.
	*
	* @return the asn1 representation of a DistinguishedName.
	*/
	pki.distinguishedNameToAsn1 = function(dn) {
		return _dnToAsn1(dn);
	};
	/**
	* Converts an X.509v3 RSA certificate to an ASN.1 object.
	*
	* @param cert the certificate.
	*
	* @return the asn1 representation of an X.509v3 RSA certificate.
	*/
	pki.certificateToAsn1 = function(cert) {
		var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			tbsCertificate,
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
		]);
	};
	/**
	* Converts X.509v3 certificate extensions to ASN.1.
	*
	* @param exts the extensions to convert.
	*
	* @return the extensions in ASN.1 format.
	*/
	pki.certificateExtensionsToAsn1 = function(exts) {
		var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
		var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		rval.value.push(seq);
		for (var i = 0; i < exts.length; ++i) seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
		return rval;
	};
	/**
	* Converts a single certificate extension to ASN.1.
	*
	* @param ext the extension to convert.
	*
	* @return the extension in ASN.1 format.
	*/
	pki.certificateExtensionToAsn1 = function(ext) {
		var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
		if (ext.critical) extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
		var value = ext.value;
		if (typeof ext.value !== "string") value = asn1.toDer(value).getBytes();
		extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
		return extseq;
	};
	/**
	* Converts a PKCS#10 certification request to an ASN.1 object.
	*
	* @param csr the certification request.
	*
	* @return the asn1 representation of a certification request.
	*/
	pki.certificationRequestToAsn1 = function(csr) {
		var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			cri,
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
		]);
	};
	/**
	* Creates a CA store.
	*
	* @param certs an optional array of certificate objects or PEM-formatted
	*          certificate strings to add to the CA store.
	*
	* @return the CA store.
	*/
	pki.createCaStore = function(certs) {
		var caStore = { certs: {} };
		/**
		* Gets the certificate that issued the passed certificate or its
		* 'parent'.
		*
		* @param cert the certificate to get the parent for.
		*
		* @return the parent certificate or null if none was found.
		*/
		caStore.getIssuer = function(cert$1) {
			return getBySubject(cert$1.issuer);
		};
		/**
		* Adds a trusted certificate to the store.
		*
		* @param cert the certificate to add as a trusted certificate (either a
		*          pki.certificate object or a PEM-formatted certificate).
		*/
		caStore.addCertificate = function(cert$1) {
			if (typeof cert$1 === "string") cert$1 = forge.pki.certificateFromPem(cert$1);
			ensureSubjectHasHash(cert$1.subject);
			if (!caStore.hasCertificate(cert$1)) if (cert$1.subject.hash in caStore.certs) {
				var tmp = caStore.certs[cert$1.subject.hash];
				if (!forge.util.isArray(tmp)) tmp = [tmp];
				tmp.push(cert$1);
				caStore.certs[cert$1.subject.hash] = tmp;
			} else caStore.certs[cert$1.subject.hash] = cert$1;
		};
		/**
		* Checks to see if the given certificate is in the store.
		*
		* @param cert the certificate to check (either a pki.certificate or a
		*          PEM-formatted certificate).
		*
		* @return true if the certificate is in the store, false if not.
		*/
		caStore.hasCertificate = function(cert$1) {
			if (typeof cert$1 === "string") cert$1 = forge.pki.certificateFromPem(cert$1);
			var match = getBySubject(cert$1.subject);
			if (!match) return false;
			if (!forge.util.isArray(match)) match = [match];
			var der1 = asn1.toDer(pki.certificateToAsn1(cert$1)).getBytes();
			for (var i$1 = 0; i$1 < match.length; ++i$1) if (der1 === asn1.toDer(pki.certificateToAsn1(match[i$1])).getBytes()) return true;
			return false;
		};
		/**
		* Lists all of the certificates kept in the store.
		*
		* @return an array of all of the pki.certificate objects in the store.
		*/
		caStore.listAllCertificates = function() {
			var certList = [];
			for (var hash$1 in caStore.certs) if (caStore.certs.hasOwnProperty(hash$1)) {
				var value = caStore.certs[hash$1];
				if (!forge.util.isArray(value)) certList.push(value);
				else for (var i$1 = 0; i$1 < value.length; ++i$1) certList.push(value[i$1]);
			}
			return certList;
		};
		/**
		* Removes a certificate from the store.
		*
		* @param cert the certificate to remove (either a pki.certificate or a
		*          PEM-formatted certificate).
		*
		* @return the certificate that was removed or null if the certificate
		*           wasn't in store.
		*/
		caStore.removeCertificate = function(cert$1) {
			var result;
			if (typeof cert$1 === "string") cert$1 = forge.pki.certificateFromPem(cert$1);
			ensureSubjectHasHash(cert$1.subject);
			if (!caStore.hasCertificate(cert$1)) return null;
			var match = getBySubject(cert$1.subject);
			if (!forge.util.isArray(match)) {
				result = caStore.certs[cert$1.subject.hash];
				delete caStore.certs[cert$1.subject.hash];
				return result;
			}
			var der1 = asn1.toDer(pki.certificateToAsn1(cert$1)).getBytes();
			for (var i$1 = 0; i$1 < match.length; ++i$1) if (der1 === asn1.toDer(pki.certificateToAsn1(match[i$1])).getBytes()) {
				result = match[i$1];
				match.splice(i$1, 1);
			}
			if (match.length === 0) delete caStore.certs[cert$1.subject.hash];
			return result;
		};
		function getBySubject(subject) {
			ensureSubjectHasHash(subject);
			return caStore.certs[subject.hash] || null;
		}
		function ensureSubjectHasHash(subject) {
			if (!subject.hash) {
				var md = forge.md.sha1.create();
				subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
				subject.hash = md.digest().toHex();
			}
		}
		if (certs) for (var i = 0; i < certs.length; ++i) {
			var cert = certs[i];
			caStore.addCertificate(cert);
		}
		return caStore;
	};
	/**
	* Certificate verification errors, based on TLS.
	*/
	pki.certificateError = {
		bad_certificate: "forge.pki.BadCertificate",
		unsupported_certificate: "forge.pki.UnsupportedCertificate",
		certificate_revoked: "forge.pki.CertificateRevoked",
		certificate_expired: "forge.pki.CertificateExpired",
		certificate_unknown: "forge.pki.CertificateUnknown",
		unknown_ca: "forge.pki.UnknownCertificateAuthority"
	};
	/**
	* Verifies a certificate chain against the given Certificate Authority store
	* with an optional custom verify callback.
	*
	* @param caStore a certificate store to verify against.
	* @param chain the certificate chain to verify, with the root or highest
	*          authority at the end (an array of certificates).
	* @param options a callback to be called for every certificate in the chain or
	*                  an object with:
	*                  verify a callback to be called for every certificate in the
	*                    chain
	*                  validityCheckDate the date against which the certificate
	*                    validity period should be checked. Pass null to not check
	*                    the validity period. By default, the current date is used.
	*
	* The verify callback has the following signature:
	*
	* verified - Set to true if certificate was verified, otherwise the
	*   pki.certificateError for why the certificate failed.
	* depth - The current index in the chain, where 0 is the end point's cert.
	* certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
	*   end point.
	*
	* The function returns true on success and on failure either the appropriate
	* pki.certificateError or an object with 'error' set to the appropriate
	* pki.certificateError and 'message' set to a custom error message.
	*
	* @return true if successful, error thrown if not.
	*/
	pki.verifyCertificateChain = function(caStore, chain, options) {
		if (typeof options === "function") options = { verify: options };
		options = options || {};
		chain = chain.slice(0);
		var certs = chain.slice(0);
		var validityCheckDate = options.validityCheckDate;
		if (typeof validityCheckDate === "undefined") validityCheckDate = /* @__PURE__ */ new Date();
		var first = true;
		var error$47 = null;
		var depth = 0;
		do {
			var cert = chain.shift();
			var parent = null;
			var selfSigned = false;
			if (validityCheckDate) {
				if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) error$47 = {
					message: "Certificate is not valid yet or has expired.",
					error: pki.certificateError.certificate_expired,
					notBefore: cert.validity.notBefore,
					notAfter: cert.validity.notAfter,
					now: validityCheckDate
				};
			}
			if (error$47 === null) {
				parent = chain[0] || caStore.getIssuer(cert);
				if (parent === null) {
					if (cert.isIssuer(cert)) {
						selfSigned = true;
						parent = cert;
					}
				}
				if (parent) {
					var parents = parent;
					if (!forge.util.isArray(parents)) parents = [parents];
					var verified = false;
					while (!verified && parents.length > 0) {
						parent = parents.shift();
						try {
							verified = parent.verify(cert);
						} catch (ex) {}
					}
					if (!verified) error$47 = {
						message: "Certificate signature is invalid.",
						error: pki.certificateError.bad_certificate
					};
				}
				if (error$47 === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) error$47 = {
					message: "Certificate is not trusted.",
					error: pki.certificateError.unknown_ca
				};
			}
			if (error$47 === null && parent && !cert.isIssuer(parent)) error$47 = {
				message: "Certificate issuer is invalid.",
				error: pki.certificateError.bad_certificate
			};
			if (error$47 === null) {
				var se = {
					keyUsage: true,
					basicConstraints: true
				};
				for (var i = 0; error$47 === null && i < cert.extensions.length; ++i) {
					var ext = cert.extensions[i];
					if (ext.critical && !(ext.name in se)) error$47 = {
						message: "Certificate has an unsupported critical extension.",
						error: pki.certificateError.unsupported_certificate
					};
				}
			}
			if (error$47 === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
				var bcExt = cert.getExtension("basicConstraints");
				var keyUsageExt = cert.getExtension("keyUsage");
				if (keyUsageExt !== null) {
					if (!keyUsageExt.keyCertSign || bcExt === null) error$47 = {
						message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
						error: pki.certificateError.bad_certificate
					};
				}
				if (error$47 === null && bcExt !== null && !bcExt.cA) error$47 = {
					message: "Certificate basicConstraints indicates the certificate is not a CA.",
					error: pki.certificateError.bad_certificate
				};
				if (error$47 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
					if (depth - 1 > bcExt.pathLenConstraint) error$47 = {
						message: "Certificate basicConstraints pathLenConstraint violated.",
						error: pki.certificateError.bad_certificate
					};
				}
			}
			var vfd = error$47 === null ? true : error$47.error;
			var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
			if (ret === true) error$47 = null;
			else {
				if (vfd === true) error$47 = {
					message: "The application rejected the certificate.",
					error: pki.certificateError.bad_certificate
				};
				if (ret || ret === 0) {
					if (typeof ret === "object" && !forge.util.isArray(ret)) {
						if (ret.message) error$47.message = ret.message;
						if (ret.error) error$47.error = ret.error;
					} else if (typeof ret === "string") error$47.error = ret;
				}
				throw error$47;
			}
			first = false;
			++depth;
		} while (chain.length > 0);
		return true;
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of PKCS#12.
	*
	* @author Dave Longley
	* @author Stefan Siegl <stesie@brokenpipe.de>
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* The ASN.1 representation of PKCS#12 is as follows
	* (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
	*
	* PFX ::= SEQUENCE {
	*   version  INTEGER {v3(3)}(v3,...),
	*   authSafe ContentInfo,
	*   macData  MacData OPTIONAL
	* }
	*
	* MacData ::= SEQUENCE {
	*   mac DigestInfo,
	*   macSalt OCTET STRING,
	*   iterations INTEGER DEFAULT 1
	* }
	* Note: The iterations default is for historical reasons and its use is
	* deprecated. A higher value, like 1024, is recommended.
	*
	* DigestInfo is defined in PKCS#7 as follows:
	*
	* DigestInfo ::= SEQUENCE {
	*   digestAlgorithm DigestAlgorithmIdentifier,
	*   digest Digest
	* }
	*
	* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
	* for the algorithm, if any. In the case of SHA1 there is none.
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*    algorithm OBJECT IDENTIFIER,
	*    parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* Digest ::= OCTET STRING
	*
	*
	* ContentInfo ::= SEQUENCE {
	*   contentType ContentType,
	*   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
	* }
	*
	* ContentType ::= OBJECT IDENTIFIER
	*
	* AuthenticatedSafe ::= SEQUENCE OF ContentInfo
	* -- Data if unencrypted
	* -- EncryptedData if password-encrypted
	* -- EnvelopedData if public key-encrypted
	*
	*
	* SafeContents ::= SEQUENCE OF SafeBag
	*
	* SafeBag ::= SEQUENCE {
	*   bagId     BAG-TYPE.&id ({PKCS12BagSet})
	*   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
	*   bagAttributes SET OF PKCS12Attribute OPTIONAL
	* }
	*
	* PKCS12Attribute ::= SEQUENCE {
	*   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
	*   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
	* } -- This type is compatible with the X.500 type 'Attribute'
	*
	* PKCS12AttrSet ATTRIBUTE ::= {
	*   friendlyName | -- from PKCS #9
	*   localKeyId, -- from PKCS #9
	*   ... -- Other attributes are allowed
	* }
	*
	* CertBag ::= SEQUENCE {
	*   certId    BAG-TYPE.&id   ({CertTypes}),
	*   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
	* }
	*
	* x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
	*   -- DER-encoded X.509 certificate stored in OCTET STRING
	*
	* sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
	* -- Base64-encoded SDSI certificate stored in IA5String
	*
	* CertTypes BAG-TYPE ::= {
	*   x509Certificate |
	*   sdsiCertificate,
	*   ... -- For future extensions
	* }
	*/
	var forge = require_forge();
	require_asn1();
	require_hmac();
	require_oids();
	require_pkcs7asn1();
	require_pbe();
	require_random();
	require_rsa$1();
	require_sha1();
	require_util();
	require_x509();
	var asn1 = forge.asn1;
	var pki = forge.pki;
	var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};
	var contentInfoValidator = {
		name: "ContentInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "ContentInfo.contentType",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "contentType"
		}, {
			name: "ContentInfo.content",
			tagClass: asn1.Class.CONTEXT_SPECIFIC,
			constructed: true,
			captureAsn1: "content"
		}]
	};
	var pfxValidator = {
		name: "PFX",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "PFX.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "version"
			},
			contentInfoValidator,
			{
				name: "PFX.macData",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				optional: true,
				captureAsn1: "mac",
				value: [
					{
						name: "PFX.macData.mac",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [{
							name: "PFX.macData.mac.digestAlgorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.SEQUENCE,
							constructed: true,
							value: [{
								name: "PFX.macData.mac.digestAlgorithm.algorithm",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.OID,
								constructed: false,
								capture: "macAlgorithm"
							}, {
								name: "PFX.macData.mac.digestAlgorithm.parameters",
								optional: true,
								tagClass: asn1.Class.UNIVERSAL,
								captureAsn1: "macAlgorithmParameters"
							}]
						}, {
							name: "PFX.macData.mac.digest",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OCTETSTRING,
							constructed: false,
							capture: "macDigest"
						}]
					},
					{
						name: "PFX.macData.macSalt",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OCTETSTRING,
						constructed: false,
						capture: "macSalt"
					},
					{
						name: "PFX.macData.iterations",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						optional: true,
						capture: "macIterations"
					}
				]
			}
		]
	};
	var safeBagValidator = {
		name: "SafeBag",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "SafeBag.bagId",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "bagId"
			},
			{
				name: "SafeBag.bagValue",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				constructed: true,
				captureAsn1: "bagValue"
			},
			{
				name: "SafeBag.bagAttributes",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SET,
				constructed: true,
				optional: true,
				capture: "bagAttributes"
			}
		]
	};
	var attributeValidator = {
		name: "Attribute",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "Attribute.attrId",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "oid"
		}, {
			name: "Attribute.attrValues",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SET,
			constructed: true,
			capture: "values"
		}]
	};
	var certBagValidator = {
		name: "CertBag",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "CertBag.certId",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "certId"
		}, {
			name: "CertBag.certValue",
			tagClass: asn1.Class.CONTEXT_SPECIFIC,
			constructed: true,
			value: [{
				name: "CertBag.certValue[0]",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Class.OCTETSTRING,
				constructed: false,
				capture: "cert"
			}]
		}]
	};
	/**
	* Search SafeContents structure for bags with matching attributes.
	*
	* The search can optionally be narrowed by a certain bag type.
	*
	* @param safeContents the SafeContents structure to search in.
	* @param attrName the name of the attribute to compare against.
	* @param attrValue the attribute value to search for.
	* @param [bagType] bag type to narrow search by.
	*
	* @return an array of matching bags.
	*/
	function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
		var result = [];
		for (var i = 0; i < safeContents.length; i++) for (var j = 0; j < safeContents[i].safeBags.length; j++) {
			var bag = safeContents[i].safeBags[j];
			if (bagType !== void 0 && bag.type !== bagType) continue;
			if (attrName === null) {
				result.push(bag);
				continue;
			}
			if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) result.push(bag);
		}
		return result;
	}
	/**
	* Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
	*
	* @param obj The PKCS#12 PFX in ASN.1 notation.
	* @param strict true to use strict DER decoding, false not to (default: true).
	* @param {String} password Password to decrypt with (optional).
	*
	* @return PKCS#12 PFX object.
	*/
	p12.pkcs12FromAsn1 = function(obj, strict, password) {
		if (typeof strict === "string") {
			password = strict;
			strict = true;
		} else if (strict === void 0) strict = true;
		var capture = {};
		if (!asn1.validate(obj, pfxValidator, capture, [])) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
			error$47.errors = error$47;
			throw error$47;
		}
		var pfx = {
			version: capture.version.charCodeAt(0),
			safeContents: [],
			getBags: function(filter) {
				var rval = {};
				var localKeyId;
				if ("localKeyId" in filter) localKeyId = filter.localKeyId;
				else if ("localKeyIdHex" in filter) localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
				if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);
				if (localKeyId !== void 0) rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType);
				if ("friendlyName" in filter) rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType);
				return rval;
			},
			getBagsByFriendlyName: function(friendlyName, bagType) {
				return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
			},
			getBagsByLocalKeyId: function(localKeyId, bagType) {
				return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
			}
		};
		if (capture.version.charCodeAt(0) !== 3) {
			var error$47 = /* @__PURE__ */ new Error("PKCS#12 PFX of version other than 3 not supported.");
			error$47.version = capture.version.charCodeAt(0);
			throw error$47;
		}
		if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
			var error$47 = /* @__PURE__ */ new Error("Only PKCS#12 PFX in password integrity mode supported.");
			error$47.oid = asn1.derToOid(capture.contentType);
			throw error$47;
		}
		var data = capture.content.value[0];
		if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
		data = _decodePkcs7Data(data);
		if (capture.mac) {
			var md = null;
			var macKeyBytes = 0;
			var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
			switch (macAlgorithm) {
				case pki.oids.sha1:
					md = forge.md.sha1.create();
					macKeyBytes = 20;
					break;
				case pki.oids.sha256:
					md = forge.md.sha256.create();
					macKeyBytes = 32;
					break;
				case pki.oids.sha384:
					md = forge.md.sha384.create();
					macKeyBytes = 48;
					break;
				case pki.oids.sha512:
					md = forge.md.sha512.create();
					macKeyBytes = 64;
					break;
				case pki.oids.md5:
					md = forge.md.md5.create();
					macKeyBytes = 16;
					break;
			}
			if (md === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
			var macSalt = new forge.util.ByteBuffer(capture.macSalt);
			var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
			var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
			var mac$2 = forge.hmac.create();
			mac$2.start(md, macKey);
			mac$2.update(data.value);
			if (mac$2.getMac().getBytes() !== capture.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
		} else if (Array.isArray(obj.value) && obj.value.length > 2) throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
		_decodeAuthenticatedSafe(pfx, data.value, strict, password);
		return pfx;
	};
	/**
	* Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
	* but it is sometimes an OCTET STRING that is composed/constructed of chunks,
	* each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
	* function transforms this corner-case into the usual simple,
	* non-composed/constructed OCTET STRING.
	*
	* This function may be moved to ASN.1 at some point to better deal with
	* more BER-encoding issues, should they arise.
	*
	* @param data the ASN.1 Data object to transform.
	*/
	function _decodePkcs7Data(data) {
		if (data.composed || data.constructed) {
			var value = forge.util.createBuffer();
			for (var i = 0; i < data.value.length; ++i) value.putBytes(data.value[i].value);
			data.composed = data.constructed = false;
			data.value = value.getBytes();
		}
		return data;
	}
	/**
	* Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
	*
	* The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
	*
	* @param pfx The PKCS#12 PFX object to fill.
	* @param {String} authSafe BER-encoded AuthenticatedSafe.
	* @param strict true to use strict DER decoding, false not to.
	* @param {String} password Password to decrypt with (optional).
	*/
	function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
		authSafe = asn1.fromDer(authSafe, strict);
		if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
		for (var i = 0; i < authSafe.value.length; i++) {
			var contentInfo = authSafe.value[i];
			var capture = {};
			var errors = [];
			if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
				var error$47 = /* @__PURE__ */ new Error("Cannot read ContentInfo.");
				error$47.errors = errors;
				throw error$47;
			}
			var obj = { encrypted: false };
			var safeContents = null;
			var data = capture.content.value[0];
			switch (asn1.derToOid(capture.contentType)) {
				case pki.oids.data:
					if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
					safeContents = _decodePkcs7Data(data).value;
					break;
				case pki.oids.encryptedData:
					safeContents = _decryptSafeContents(data, password);
					obj.encrypted = true;
					break;
				default:
					var error$47 = /* @__PURE__ */ new Error("Unsupported PKCS#12 contentType.");
					error$47.contentType = asn1.derToOid(capture.contentType);
					throw error$47;
			}
			obj.safeBags = _decodeSafeContents(safeContents, strict, password);
			pfx.safeContents.push(obj);
		}
	}
	/**
	* Decrypt PKCS#7 EncryptedData structure.
	*
	* @param data ASN.1 encoded EncryptedContentInfo object.
	* @param password The user-provided password.
	*
	* @return The decrypted SafeContents (ASN.1 object).
	*/
	function _decryptSafeContents(data, password) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read EncryptedContentInfo.");
			error$47.errors = errors;
			throw error$47;
		}
		var oid = asn1.derToOid(capture.contentType);
		if (oid !== pki.oids.data) {
			var error$47 = /* @__PURE__ */ new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
			error$47.oid = oid;
			throw error$47;
		}
		oid = asn1.derToOid(capture.encAlgorithm);
		var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
		var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
		var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
		cipher.update(encrypted);
		if (!cipher.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
		return cipher.output.getBytes();
	}
	/**
	* Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
	*
	* The safeContents is a BER-encoded SEQUENCE OF SafeBag.
	*
	* @param {String} safeContents BER-encoded safeContents.
	* @param strict true to use strict DER decoding, false not to.
	* @param {String} password Password to decrypt with (optional).
	*
	* @return {Array} Array of Bag objects.
	*/
	function _decodeSafeContents(safeContents, strict, password) {
		if (!strict && safeContents.length === 0) return [];
		safeContents = asn1.fromDer(safeContents, strict);
		if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
		var res = [];
		for (var i = 0; i < safeContents.value.length; i++) {
			var safeBag = safeContents.value[i];
			var capture = {};
			var errors = [];
			if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
				var error$47 = /* @__PURE__ */ new Error("Cannot read SafeBag.");
				error$47.errors = errors;
				throw error$47;
			}
			var bag = {
				type: asn1.derToOid(capture.bagId),
				attributes: _decodeBagAttributes(capture.bagAttributes)
			};
			res.push(bag);
			var validator, decoder;
			var bagAsn1 = capture.bagValue.value[0];
			switch (bag.type) {
				case pki.oids.pkcs8ShroudedKeyBag:
					bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
					if (bagAsn1 === null) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
				case pki.oids.keyBag:
					try {
						bag.key = pki.privateKeyFromAsn1(bagAsn1);
					} catch (e) {
						bag.key = null;
						bag.asn1 = bagAsn1;
					}
					continue;
				case pki.oids.certBag:
					validator = certBagValidator;
					decoder = function() {
						if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
							var error$48 = /* @__PURE__ */ new Error("Unsupported certificate type, only X.509 supported.");
							error$48.oid = asn1.derToOid(capture.certId);
							throw error$48;
						}
						var certAsn1 = asn1.fromDer(capture.cert, strict);
						try {
							bag.cert = pki.certificateFromAsn1(certAsn1, true);
						} catch (e) {
							bag.cert = null;
							bag.asn1 = certAsn1;
						}
					};
					break;
				default:
					var error$47 = /* @__PURE__ */ new Error("Unsupported PKCS#12 SafeBag type.");
					error$47.oid = bag.type;
					throw error$47;
			}
			if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
				var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#12 " + validator.name);
				error$47.errors = errors;
				throw error$47;
			}
			decoder();
		}
		return res;
	}
	/**
	* Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
	*
	* @param attributes SET OF PKCS12Attribute (ASN.1 object).
	*
	* @return the decoded attributes.
	*/
	function _decodeBagAttributes(attributes) {
		var decodedAttrs = {};
		if (attributes !== void 0) for (var i = 0; i < attributes.length; ++i) {
			var capture = {};
			var errors = [];
			if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
				var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#12 BagAttribute.");
				error$47.errors = errors;
				throw error$47;
			}
			var oid = asn1.derToOid(capture.oid);
			if (pki.oids[oid] === void 0) continue;
			decodedAttrs[pki.oids[oid]] = [];
			for (var j = 0; j < capture.values.length; ++j) decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
		}
		return decodedAttrs;
	}
	/**
	* Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
	* password is provided then the private key will be encrypted.
	*
	* An entire certificate chain may also be included. To do this, pass
	* an array for the "cert" parameter where the first certificate is
	* the one that is paired with the private key and each subsequent one
	* verifies the previous one. The certificates may be in PEM format or
	* have been already parsed by Forge.
	*
	* @todo implement password-based-encryption for the whole package
	*
	* @param key the private key.
	* @param cert the certificate (may be an array of certificates in order
	*          to specify a certificate chain).
	* @param password the password to use, null for none.
	* @param options:
	*          algorithm the encryption algorithm to use
	*            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
	*          count the iteration count to use.
	*          saltSize the salt size to use.
	*          useMac true to include a MAC, false not to, defaults to true.
	*          localKeyId the local key ID to use, in hex.
	*          friendlyName the friendly name to use.
	*          generateLocalKeyId true to generate a random local key ID,
	*            false not to, defaults to true.
	*
	* @return the PKCS#12 PFX ASN.1 object.
	*/
	p12.toPkcs12Asn1 = function(key, cert, password, options) {
		options = options || {};
		options.saltSize = options.saltSize || 8;
		options.count = options.count || 2048;
		options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
		if (!("useMac" in options)) options.useMac = true;
		if (!("localKeyId" in options)) options.localKeyId = null;
		if (!("generateLocalKeyId" in options)) options.generateLocalKeyId = true;
		var localKeyId = options.localKeyId;
		var bagAttrs;
		if (localKeyId !== null) localKeyId = forge.util.hexToBytes(localKeyId);
		else if (options.generateLocalKeyId) if (cert) {
			var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
			if (typeof pairedCert === "string") pairedCert = pki.certificateFromPem(pairedCert);
			var sha1$1 = forge.md.sha1.create();
			sha1$1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
			localKeyId = sha1$1.digest().getBytes();
		} else localKeyId = forge.random.getBytes(20);
		var attrs = [];
		if (localKeyId !== null) attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));
		if ("friendlyName" in options) attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));
		if (attrs.length > 0) bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
		var contents = [];
		var chain = [];
		if (cert !== null) if (forge.util.isArray(cert)) chain = cert;
		else chain = [cert];
		var certSafeBags = [];
		for (var i = 0; i < chain.length; ++i) {
			cert = chain[i];
			if (typeof cert === "string") cert = pki.certificateFromPem(cert);
			var certBagAttrs = i === 0 ? bagAttrs : void 0;
			var certAsn1 = pki.certificateToAsn1(cert);
			var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),
				asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]),
				certBagAttrs
			]);
			certSafeBags.push(certSafeBag);
		}
		if (certSafeBags.length > 0) {
			var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);
			var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);
			contents.push(certCI);
		}
		var keyBag = null;
		if (key !== null) {
			var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
			if (password === null) keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),
				asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pkAsn1]),
				bagAttrs
			]);
			else keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),
				asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]),
				bagAttrs
			]);
			var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
			var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);
			contents.push(keyCI);
		}
		var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);
		var macData;
		if (options.useMac) {
			var sha1$1 = forge.md.sha1.create();
			var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));
			var count = options.count;
			var key = p12.generateKey(password, macSalt, 3, count, 20);
			var mac$2 = forge.hmac.create();
			mac$2.start(sha1$1, key);
			mac$2.update(asn1.toDer(safe).getBytes());
			var macValue = mac$2.getMac();
			macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]),
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())
			]);
		}
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]),
			macData
		]);
	};
	/**
	* Derives a PKCS#12 key.
	*
	* @param password the password to derive the key material from, null or
	*          undefined for none.
	* @param salt the salt, as a ByteBuffer, to use.
	* @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
	* @param iter the iteration count.
	* @param n the number of bytes to derive from the password.
	* @param md the message digest to use, defaults to SHA-1.
	*
	* @return a ByteBuffer with the bytes derived from the password.
	*/
	p12.generateKey = forge.pbe.generatePkcs12Key;
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pki.js
var require_pki = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of a basic Public Key Infrastructure, including
	* support for RSA public and private keys.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_asn1();
	require_oids();
	require_pbe();
	require_pem();
	require_pbkdf2();
	require_pkcs12();
	require_pss$1();
	require_rsa$1();
	require_util();
	require_x509();
	var asn1 = forge.asn1;
	var pki = module.exports = forge.pki = forge.pki || {};
	/**
	* NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
	*
	* Converts PEM-formatted data to DER.
	*
	* @param pem the PEM-formatted data.
	*
	* @return the DER-formatted data.
	*/
	pki.pemToDer = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert PEM to DER; PEM is encrypted.");
		return forge.util.createBuffer(msg.body);
	};
	/**
	* Converts an RSA private key from PEM format.
	*
	* @param pem the PEM-formatted private key.
	*
	* @return the private key.
	*/
	pki.privateKeyFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert private key from PEM; PEM header type is not \"PRIVATE KEY\" or \"RSA PRIVATE KEY\".");
			error$47.headerType = msg.type;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert private key from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body);
		return pki.privateKeyFromAsn1(obj);
	};
	/**
	* Converts an RSA private key to PEM format.
	*
	* @param key the private key.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted private key.
	*/
	pki.privateKeyToPem = function(key, maxline) {
		var msg = {
			type: "RSA PRIVATE KEY",
			body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts a PrivateKeyInfo to PEM format.
	*
	* @param pki the PrivateKeyInfo.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted private key.
	*/
	pki.privateKeyInfoToPem = function(pki, maxline) {
		var msg = {
			type: "PRIVATE KEY",
			body: asn1.toDer(pki).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/tls.js
var require_tls = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* A Javascript implementation of Transport Layer Security (TLS).
	*
	* @author Dave Longley
	*
	* Copyright (c) 2009-2014 Digital Bazaar, Inc.
	*
	* The TLS Handshake Protocol involves the following steps:
	*
	* - Exchange hello messages to agree on algorithms, exchange random values,
	* and check for session resumption.
	*
	* - Exchange the necessary cryptographic parameters to allow the client and
	* server to agree on a premaster secret.
	*
	* - Exchange certificates and cryptographic information to allow the client
	* and server to authenticate themselves.
	*
	* - Generate a master secret from the premaster secret and exchanged random
	* values.
	*
	* - Provide security parameters to the record layer.
	*
	* - Allow the client and server to verify that their peer has calculated the
	* same security parameters and that the handshake occurred without tampering
	* by an attacker.
	*
	* Up to 4 different messages may be sent during a key exchange. The server
	* certificate, the server key exchange, the client certificate, and the
	* client key exchange.
	*
	* A typical handshake (from the client's perspective).
	*
	* 1. Client sends ClientHello.
	* 2. Client receives ServerHello.
	* 3. Client receives optional Certificate.
	* 4. Client receives optional ServerKeyExchange.
	* 5. Client receives ServerHelloDone.
	* 6. Client sends optional Certificate.
	* 7. Client sends ClientKeyExchange.
	* 8. Client sends optional CertificateVerify.
	* 9. Client sends ChangeCipherSpec.
	* 10. Client sends Finished.
	* 11. Client receives ChangeCipherSpec.
	* 12. Client receives Finished.
	* 13. Client sends/receives application data.
	*
	* To reuse an existing session:
	*
	* 1. Client sends ClientHello with session ID for reuse.
	* 2. Client receives ServerHello with same session ID if reusing.
	* 3. Client receives ChangeCipherSpec message if reusing.
	* 4. Client receives Finished.
	* 5. Client sends ChangeCipherSpec.
	* 6. Client sends Finished.
	*
	* Note: Client ignores HelloRequest if in the middle of a handshake.
	*
	* Record Layer:
	*
	* The record layer fragments information blocks into TLSPlaintext records
	* carrying data in chunks of 2^14 bytes or less. Client message boundaries are
	* not preserved in the record layer (i.e., multiple client messages of the
	* same ContentType MAY be coalesced into a single TLSPlaintext record, or a
	* single message MAY be fragmented across several records).
	*
	* struct {
	*   uint8 major;
	*   uint8 minor;
	* } ProtocolVersion;
	*
	* struct {
	*   ContentType type;
	*   ProtocolVersion version;
	*   uint16 length;
	*   opaque fragment[TLSPlaintext.length];
	* } TLSPlaintext;
	*
	* type:
	*   The higher-level protocol used to process the enclosed fragment.
	*
	* version:
	*   The version of the protocol being employed. TLS Version 1.2 uses version
	*   {3, 3}. TLS Version 1.0 uses version {3, 1}. Note that a client that
	*   supports multiple versions of TLS may not know what version will be
	*   employed before it receives the ServerHello.
	*
	* length:
	*   The length (in bytes) of the following TLSPlaintext.fragment. The length
	*   MUST NOT exceed 2^14 = 16384 bytes.
	*
	* fragment:
	*   The application data. This data is transparent and treated as an
	*   independent block to be dealt with by the higher-level protocol specified
	*   by the type field.
	*
	* Implementations MUST NOT send zero-length fragments of Handshake, Alert, or
	* ChangeCipherSpec content types. Zero-length fragments of Application data
	* MAY be sent as they are potentially useful as a traffic analysis
	* countermeasure.
	*
	* Note: Data of different TLS record layer content types MAY be interleaved.
	* Application data is generally of lower precedence for transmission than
	* other content types. However, records MUST be delivered to the network in
	* the same order as they are protected by the record layer. Recipients MUST
	* receive and process interleaved application layer traffic during handshakes
	* subsequent to the first one on a connection.
	*
	* struct {
	*   ContentType type;       // same as TLSPlaintext.type
	*   ProtocolVersion version;// same as TLSPlaintext.version
	*   uint16 length;
	*   opaque fragment[TLSCompressed.length];
	* } TLSCompressed;
	*
	* length:
	*   The length (in bytes) of the following TLSCompressed.fragment.
	*   The length MUST NOT exceed 2^14 + 1024.
	*
	* fragment:
	*   The compressed form of TLSPlaintext.fragment.
	*
	* Note: A CompressionMethod.null operation is an identity operation; no fields
	* are altered. In this implementation, since no compression is supported,
	* uncompressed records are always the same as compressed records.
	*
	* Encryption Information:
	*
	* The encryption and MAC functions translate a TLSCompressed structure into a
	* TLSCiphertext. The decryption functions reverse the process. The MAC of the
	* record also includes a sequence number so that missing, extra, or repeated
	* messages are detectable.
	*
	* struct {
	*   ContentType type;
	*   ProtocolVersion version;
	*   uint16 length;
	*   select (SecurityParameters.cipher_type) {
	*     case stream: GenericStreamCipher;
	*     case block:  GenericBlockCipher;
	*     case aead:   GenericAEADCipher;
	*   } fragment;
	* } TLSCiphertext;
	*
	* type:
	*   The type field is identical to TLSCompressed.type.
	*
	* version:
	*   The version field is identical to TLSCompressed.version.
	*
	* length:
	*   The length (in bytes) of the following TLSCiphertext.fragment.
	*   The length MUST NOT exceed 2^14 + 2048.
	*
	* fragment:
	*   The encrypted form of TLSCompressed.fragment, with the MAC.
	*
	* Note: Only CBC Block Ciphers are supported by this implementation.
	*
	* The TLSCompressed.fragment structures are converted to/from block
	* TLSCiphertext.fragment structures.
	*
	* struct {
	*   opaque IV[SecurityParameters.record_iv_length];
	*   block-ciphered struct {
	*     opaque content[TLSCompressed.length];
	*     opaque MAC[SecurityParameters.mac_length];
	*     uint8 padding[GenericBlockCipher.padding_length];
	*     uint8 padding_length;
	*   };
	* } GenericBlockCipher;
	*
	* The MAC is generated as described in Section 6.2.3.1.
	*
	* IV:
	*   The Initialization Vector (IV) SHOULD be chosen at random, and MUST be
	*   unpredictable. Note that in versions of TLS prior to 1.1, there was no
	*   IV field, and the last ciphertext block of the previous record (the "CBC
	*   residue") was used as the IV. This was changed to prevent the attacks
	*   described in [CBCATT]. For block ciphers, the IV length is of length
	*   SecurityParameters.record_iv_length, which is equal to the
	*   SecurityParameters.block_size.
	*
	* padding:
	*   Padding that is added to force the length of the plaintext to be an
	*   integral multiple of the block cipher's block length. The padding MAY be
	*   any length up to 255 bytes, as long as it results in the
	*   TLSCiphertext.length being an integral multiple of the block length.
	*   Lengths longer than necessary might be desirable to frustrate attacks on
	*   a protocol that are based on analysis of the lengths of exchanged
	*   messages. Each uint8 in the padding data vector MUST be filled with the
	*   padding length value. The receiver MUST check this padding and MUST use
	*   the bad_record_mac alert to indicate padding errors.
	*
	* padding_length:
	*   The padding length MUST be such that the total size of the
	*   GenericBlockCipher structure is a multiple of the cipher's block length.
	*   Legal values range from zero to 255, inclusive. This length specifies the
	*   length of the padding field exclusive of the padding_length field itself.
	*
	* The encrypted data length (TLSCiphertext.length) is one more than the sum of
	* SecurityParameters.block_length, TLSCompressed.length,
	* SecurityParameters.mac_length, and padding_length.
	*
	* Example: If the block length is 8 bytes, the content length
	* (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the
	* length before padding is 82 bytes (this does not include the IV. Thus, the
	* padding length modulo 8 must be equal to 6 in order to make the total length
	* an even multiple of 8 bytes (the block length). The padding length can be
	* 6, 14, 22, and so on, through 254. If the padding length were the minimum
	* necessary, 6, the padding would be 6 bytes, each containing the value 6.
	* Thus, the last 8 octets of the GenericBlockCipher before block encryption
	* would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.
	*
	* Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical
	* that the entire plaintext of the record be known before any ciphertext is
	* transmitted. Otherwise, it is possible for the attacker to mount the attack
	* described in [CBCATT].
	*
	* Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing
	* attack on CBC padding based on the time required to compute the MAC. In
	* order to defend against this attack, implementations MUST ensure that
	* record processing time is essentially the same whether or not the padding
	* is correct. In general, the best way to do this is to compute the MAC even
	* if the padding is incorrect, and only then reject the packet. For instance,
	* if the pad appears to be incorrect, the implementation might assume a
	* zero-length pad and then compute the MAC. This leaves a small timing
	* channel, since MAC performance depends, to some extent, on the size of the
	* data fragment, but it is not believed to be large enough to be exploitable,
	* due to the large block size of existing MACs and the small size of the
	* timing signal.
	*/
	var forge = require_forge();
	require_asn1();
	require_hmac();
	require_md5();
	require_pem();
	require_pki();
	require_random();
	require_sha1();
	require_util();
	/**
	* Generates pseudo random bytes by mixing the result of two hash functions,
	* MD5 and SHA-1.
	*
	* prf_TLS1(secret, label, seed) =
	*   P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed);
	*
	* Each P_hash function functions as follows:
	*
	* P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
	*                        HMAC_hash(secret, A(2) + seed) +
	*                        HMAC_hash(secret, A(3) + seed) + ...
	* A() is defined as:
	*   A(0) = seed
	*   A(i) = HMAC_hash(secret, A(i-1))
	*
	* The '+' operator denotes concatenation.
	*
	* As many iterations A(N) as are needed are performed to generate enough
	* pseudo random byte output. If an iteration creates more data than is
	* necessary, then it is truncated.
	*
	* Therefore:
	* A(1) = HMAC_hash(secret, A(0))
	*      = HMAC_hash(secret, seed)
	* A(2) = HMAC_hash(secret, A(1))
	*      = HMAC_hash(secret, HMAC_hash(secret, seed))
	*
	* Therefore:
	* P_hash(secret, seed) =
	*   HMAC_hash(secret, HMAC_hash(secret, A(0)) + seed) +
	*   HMAC_hash(secret, HMAC_hash(secret, A(1)) + seed) +
	*   ...
	*
	* Therefore:
	* P_hash(secret, seed) =
	*   HMAC_hash(secret, HMAC_hash(secret, seed) + seed) +
	*   HMAC_hash(secret, HMAC_hash(secret, HMAC_hash(secret, seed)) + seed) +
	*   ...
	*
	* @param secret the secret to use.
	* @param label the label to use.
	* @param seed the seed value to use.
	* @param length the number of bytes to generate.
	*
	* @return the pseudo random bytes in a byte buffer.
	*/
	var prf_TLS1 = function(secret, label, seed, length) {
		var rval = forge.util.createBuffer();
		var idx = secret.length >> 1;
		var slen = idx + (secret.length & 1);
		var s1 = secret.substr(0, slen);
		var s2 = secret.substr(idx, slen);
		var ai = forge.util.createBuffer();
		var hmac = forge.hmac.create();
		seed = label + seed;
		var md5itr = Math.ceil(length / 16);
		var sha1itr = Math.ceil(length / 20);
		hmac.start("MD5", s1);
		var md5bytes = forge.util.createBuffer();
		ai.putBytes(seed);
		for (var i = 0; i < md5itr; ++i) {
			hmac.start(null, null);
			hmac.update(ai.getBytes());
			ai.putBuffer(hmac.digest());
			hmac.start(null, null);
			hmac.update(ai.bytes() + seed);
			md5bytes.putBuffer(hmac.digest());
		}
		hmac.start("SHA1", s2);
		var sha1bytes = forge.util.createBuffer();
		ai.clear();
		ai.putBytes(seed);
		for (var i = 0; i < sha1itr; ++i) {
			hmac.start(null, null);
			hmac.update(ai.getBytes());
			ai.putBuffer(hmac.digest());
			hmac.start(null, null);
			hmac.update(ai.bytes() + seed);
			sha1bytes.putBuffer(hmac.digest());
		}
		rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
		return rval;
	};
	/**
	* Gets a MAC for a record using the SHA-1 hash algorithm.
	*
	* @param key the mac key.
	* @param state the sequence number (array of two 32-bit integers).
	* @param record the record.
	*
	* @return the sha-1 hash (20 bytes) for the given record.
	*/
	var hmac_sha1 = function(key, seqNum, record$1) {
		var hmac = forge.hmac.create();
		hmac.start("SHA1", key);
		var b = forge.util.createBuffer();
		b.putInt32(seqNum[0]);
		b.putInt32(seqNum[1]);
		b.putByte(record$1.type);
		b.putByte(record$1.version.major);
		b.putByte(record$1.version.minor);
		b.putInt16(record$1.length);
		b.putBytes(record$1.fragment.bytes());
		hmac.update(b.getBytes());
		return hmac.digest().getBytes();
	};
	/**
	* Compresses the TLSPlaintext record into a TLSCompressed record using the
	* deflate algorithm.
	*
	* @param c the TLS connection.
	* @param record the TLSPlaintext record to compress.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	var deflate = function(c, record$1, s) {
		var rval = false;
		try {
			var bytes = c.deflate(record$1.fragment.getBytes());
			record$1.fragment = forge.util.createBuffer(bytes);
			record$1.length = bytes.length;
			rval = true;
		} catch (ex) {}
		return rval;
	};
	/**
	* Decompresses the TLSCompressed record into a TLSPlaintext record using the
	* deflate algorithm.
	*
	* @param c the TLS connection.
	* @param record the TLSCompressed record to decompress.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	var inflate = function(c, record$1, s) {
		var rval = false;
		try {
			var bytes = c.inflate(record$1.fragment.getBytes());
			record$1.fragment = forge.util.createBuffer(bytes);
			record$1.length = bytes.length;
			rval = true;
		} catch (ex) {}
		return rval;
	};
	/**
	* Reads a TLS variable-length vector from a byte buffer.
	*
	* Variable-length vectors are defined by specifying a subrange of legal
	* lengths, inclusively, using the notation <floor..ceiling>. When these are
	* encoded, the actual length precedes the vector's contents in the byte
	* stream. The length will be in the form of a number consuming as many bytes
	* as required to hold the vector's specified maximum (ceiling) length. A
	* variable-length vector with an actual length field of zero is referred to
	* as an empty vector.
	*
	* @param b the byte buffer.
	* @param lenBytes the number of bytes required to store the length.
	*
	* @return the resulting byte buffer.
	*/
	var readVector = function(b, lenBytes) {
		var len = 0;
		switch (lenBytes) {
			case 1:
				len = b.getByte();
				break;
			case 2:
				len = b.getInt16();
				break;
			case 3:
				len = b.getInt24();
				break;
			case 4:
				len = b.getInt32();
				break;
		}
		return forge.util.createBuffer(b.getBytes(len));
	};
	/**
	* Writes a TLS variable-length vector to a byte buffer.
	*
	* @param b the byte buffer.
	* @param lenBytes the number of bytes required to store the length.
	* @param v the byte buffer vector.
	*/
	var writeVector = function(b, lenBytes, v) {
		b.putInt(v.length(), lenBytes << 3);
		b.putBuffer(v);
	};
	/**
	* The tls implementation.
	*/
	var tls = {};
	/**
	* Version: TLS 1.2 = 3.3, TLS 1.1 = 3.2, TLS 1.0 = 3.1. Both TLS 1.1 and
	* TLS 1.2 were still too new (ie: openSSL didn't implement them) at the time
	* of this implementation so TLS 1.0 was implemented instead.
	*/
	tls.Versions = {
		TLS_1_0: {
			major: 3,
			minor: 1
		},
		TLS_1_1: {
			major: 3,
			minor: 2
		},
		TLS_1_2: {
			major: 3,
			minor: 3
		}
	};
	tls.SupportedVersions = [tls.Versions.TLS_1_1, tls.Versions.TLS_1_0];
	tls.Version = tls.SupportedVersions[0];
	/**
	* Maximum fragment size. True maximum is 16384, but we fragment before that
	* to allow for unusual small increases during compression.
	*/
	tls.MaxFragment = 15360;
	/**
	* Whether this entity is considered the "client" or "server".
	* enum { server, client } ConnectionEnd;
	*/
	tls.ConnectionEnd = {
		server: 0,
		client: 1
	};
	/**
	* Pseudo-random function algorithm used to generate keys from the master
	* secret.
	* enum { tls_prf_sha256 } PRFAlgorithm;
	*/
	tls.PRFAlgorithm = { tls_prf_sha256: 0 };
	/**
	* Bulk encryption algorithms.
	* enum { null, rc4, des3, aes } BulkCipherAlgorithm;
	*/
	tls.BulkCipherAlgorithm = {
		none: null,
		rc4: 0,
		des3: 1,
		aes: 2
	};
	/**
	* Cipher types.
	* enum { stream, block, aead } CipherType;
	*/
	tls.CipherType = {
		stream: 0,
		block: 1,
		aead: 2
	};
	/**
	* MAC (Message Authentication Code) algorithms.
	* enum { null, hmac_md5, hmac_sha1, hmac_sha256,
	*   hmac_sha384, hmac_sha512} MACAlgorithm;
	*/
	tls.MACAlgorithm = {
		none: null,
		hmac_md5: 0,
		hmac_sha1: 1,
		hmac_sha256: 2,
		hmac_sha384: 3,
		hmac_sha512: 4
	};
	/**
	* Compression algorithms.
	* enum { null(0), deflate(1), (255) } CompressionMethod;
	*/
	tls.CompressionMethod = {
		none: 0,
		deflate: 1
	};
	/**
	* TLS record content types.
	* enum {
	*   change_cipher_spec(20), alert(21), handshake(22),
	*   application_data(23), (255)
	* } ContentType;
	*/
	tls.ContentType = {
		change_cipher_spec: 20,
		alert: 21,
		handshake: 22,
		application_data: 23,
		heartbeat: 24
	};
	/**
	* TLS handshake types.
	* enum {
	*   hello_request(0), client_hello(1), server_hello(2),
	*   certificate(11), server_key_exchange (12),
	*   certificate_request(13), server_hello_done(14),
	*   certificate_verify(15), client_key_exchange(16),
	*   finished(20), (255)
	* } HandshakeType;
	*/
	tls.HandshakeType = {
		hello_request: 0,
		client_hello: 1,
		server_hello: 2,
		certificate: 11,
		server_key_exchange: 12,
		certificate_request: 13,
		server_hello_done: 14,
		certificate_verify: 15,
		client_key_exchange: 16,
		finished: 20
	};
	/**
	* TLS Alert Protocol.
	*
	* enum { warning(1), fatal(2), (255) } AlertLevel;
	*
	* enum {
	*   close_notify(0),
	*   unexpected_message(10),
	*   bad_record_mac(20),
	*   decryption_failed(21),
	*   record_overflow(22),
	*   decompression_failure(30),
	*   handshake_failure(40),
	*   bad_certificate(42),
	*   unsupported_certificate(43),
	*   certificate_revoked(44),
	*   certificate_expired(45),
	*   certificate_unknown(46),
	*   illegal_parameter(47),
	*   unknown_ca(48),
	*   access_denied(49),
	*   decode_error(50),
	*   decrypt_error(51),
	*   export_restriction(60),
	*   protocol_version(70),
	*   insufficient_security(71),
	*   internal_error(80),
	*   user_canceled(90),
	*   no_renegotiation(100),
	*   (255)
	* } AlertDescription;
	*
	* struct {
	*   AlertLevel level;
	*   AlertDescription description;
	* } Alert;
	*/
	tls.Alert = {};
	tls.Alert.Level = {
		warning: 1,
		fatal: 2
	};
	tls.Alert.Description = {
		close_notify: 0,
		unexpected_message: 10,
		bad_record_mac: 20,
		decryption_failed: 21,
		record_overflow: 22,
		decompression_failure: 30,
		handshake_failure: 40,
		bad_certificate: 42,
		unsupported_certificate: 43,
		certificate_revoked: 44,
		certificate_expired: 45,
		certificate_unknown: 46,
		illegal_parameter: 47,
		unknown_ca: 48,
		access_denied: 49,
		decode_error: 50,
		decrypt_error: 51,
		export_restriction: 60,
		protocol_version: 70,
		insufficient_security: 71,
		internal_error: 80,
		user_canceled: 90,
		no_renegotiation: 100
	};
	/**
	* TLS Heartbeat Message types.
	* enum {
	*   heartbeat_request(1),
	*   heartbeat_response(2),
	*   (255)
	* } HeartbeatMessageType;
	*/
	tls.HeartbeatMessageType = {
		heartbeat_request: 1,
		heartbeat_response: 2
	};
	/**
	* Supported cipher suites.
	*/
	tls.CipherSuites = {};
	/**
	* Gets a supported cipher suite from its 2 byte ID.
	*
	* @param twoBytes two bytes in a string.
	*
	* @return the matching supported cipher suite or null.
	*/
	tls.getCipherSuite = function(twoBytes) {
		var rval = null;
		for (var key in tls.CipherSuites) {
			var cs = tls.CipherSuites[key];
			if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
				rval = cs;
				break;
			}
		}
		return rval;
	};
	/**
	* Called when an unexpected record is encountered.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleUnexpected = function(c, record$1) {
		if (!(!c.open && c.entity === tls.ConnectionEnd.client)) c.error(c, {
			message: "Unexpected message. Received TLS record out of order.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.unexpected_message
			}
		});
	};
	/**
	* Called when a client receives a HelloRequest record.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleHelloRequest = function(c, record$1, length) {
		if (!c.handshaking && c.handshakes > 0) {
			tls.queue(c, tls.createAlert(c, {
				level: tls.Alert.Level.warning,
				description: tls.Alert.Description.no_renegotiation
			}));
			tls.flush(c);
		}
		c.process();
	};
	/**
	* Parses a hello message from a ClientHello or ServerHello record.
	*
	* @param record the record to parse.
	*
	* @return the parsed message.
	*/
	tls.parseHelloMessage = function(c, record$1, length) {
		var msg = null;
		var client = c.entity === tls.ConnectionEnd.client;
		if (length < 38) c.error(c, {
			message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		else {
			var b = record$1.fragment;
			var remaining = b.length();
			msg = {
				version: {
					major: b.getByte(),
					minor: b.getByte()
				},
				random: forge.util.createBuffer(b.getBytes(32)),
				session_id: readVector(b, 1),
				extensions: []
			};
			if (client) {
				msg.cipher_suite = b.getBytes(2);
				msg.compression_method = b.getByte();
			} else {
				msg.cipher_suites = readVector(b, 2);
				msg.compression_methods = readVector(b, 1);
			}
			remaining = length - (remaining - b.length());
			if (remaining > 0) {
				var exts = readVector(b, 2);
				while (exts.length() > 0) msg.extensions.push({
					type: [exts.getByte(), exts.getByte()],
					data: readVector(exts, 2)
				});
				if (!client) for (var i = 0; i < msg.extensions.length; ++i) {
					var ext = msg.extensions[i];
					if (ext.type[0] === 0 && ext.type[1] === 0) {
						var snl = readVector(ext.data, 2);
						while (snl.length() > 0) {
							if (snl.getByte() !== 0) break;
							c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
						}
					}
				}
			}
			if (c.session.version) {
				if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) return c.error(c, {
					message: "TLS version change is disallowed during renegotiation.",
					send: true,
					alert: {
						level: tls.Alert.Level.fatal,
						description: tls.Alert.Description.protocol_version
					}
				});
			}
			if (client) c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
			else {
				var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
				while (tmp.length() > 0) {
					c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
					if (c.session.cipherSuite !== null) break;
				}
			}
			if (c.session.cipherSuite === null) return c.error(c, {
				message: "No cipher suites in common.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.handshake_failure
				},
				cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
			});
			if (client) c.session.compressionMethod = msg.compression_method;
			else c.session.compressionMethod = tls.CompressionMethod.none;
		}
		return msg;
	};
	/**
	* Creates security parameters for the given connection based on the given
	* hello message.
	*
	* @param c the TLS connection.
	* @param msg the hello message.
	*/
	tls.createSecurityParameters = function(c, msg) {
		var client = c.entity === tls.ConnectionEnd.client;
		var msgRandom = msg.random.bytes();
		var cRandom = client ? c.session.sp.client_random : msgRandom;
		var sRandom = client ? msgRandom : tls.createRandom().getBytes();
		c.session.sp = {
			entity: c.entity,
			prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
			bulk_cipher_algorithm: null,
			cipher_type: null,
			enc_key_length: null,
			block_length: null,
			fixed_iv_length: null,
			record_iv_length: null,
			mac_algorithm: null,
			mac_length: null,
			mac_key_length: null,
			compression_algorithm: c.session.compressionMethod,
			pre_master_secret: null,
			master_secret: null,
			client_random: cRandom,
			server_random: sRandom
		};
	};
	/**
	* Called when a client receives a ServerHello record.
	*
	* When a ServerHello message will be sent:
	*   The server will send this message in response to a client hello message
	*   when it was able to find an acceptable set of algorithms. If it cannot
	*   find such a match, it will respond with a handshake failure alert.
	*
	* uint24 length;
	* struct {
	*   ProtocolVersion server_version;
	*   Random random;
	*   SessionID session_id;
	*   CipherSuite cipher_suite;
	*   CompressionMethod compression_method;
	*   select(extensions_present) {
	*     case false:
	*       struct {};
	*     case true:
	*       Extension extensions<0..2^16-1>;
	*   };
	* } ServerHello;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleServerHello = function(c, record$1, length) {
		var msg = tls.parseHelloMessage(c, record$1, length);
		if (c.fail) return;
		if (msg.version.minor <= c.version.minor) c.version.minor = msg.version.minor;
		else return c.error(c, {
			message: "Incompatible TLS version.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.protocol_version
			}
		});
		c.session.version = c.version;
		var sessionId = msg.session_id.bytes();
		if (sessionId.length > 0 && sessionId === c.session.id) {
			c.expect = SCC;
			c.session.resuming = true;
			c.session.sp.server_random = msg.random.bytes();
		} else {
			c.expect = SCE;
			c.session.resuming = false;
			tls.createSecurityParameters(c, msg);
		}
		c.session.id = sessionId;
		c.process();
	};
	/**
	* Called when a server receives a ClientHello record.
	*
	* When a ClientHello message will be sent:
	*   When a client first connects to a server it is required to send the
	*   client hello as its first message. The client can also send a client
	*   hello in response to a hello request or on its own initiative in order
	*   to renegotiate the security parameters in an existing connection.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleClientHello = function(c, record$1, length) {
		var msg = tls.parseHelloMessage(c, record$1, length);
		if (c.fail) return;
		var sessionId = msg.session_id.bytes();
		var session = null;
		if (c.sessionCache) {
			session = c.sessionCache.getSession(sessionId);
			if (session === null) sessionId = "";
			else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
				session = null;
				sessionId = "";
			}
		}
		if (sessionId.length === 0) sessionId = forge.random.getBytes(32);
		c.session.id = sessionId;
		c.session.clientHelloVersion = msg.version;
		c.session.sp = {};
		if (session) {
			c.version = c.session.version = session.version;
			c.session.sp = session.sp;
		} else {
			var version$2;
			for (var i = 1; i < tls.SupportedVersions.length; ++i) {
				version$2 = tls.SupportedVersions[i];
				if (version$2.minor <= msg.version.minor) break;
			}
			c.version = {
				major: version$2.major,
				minor: version$2.minor
			};
			c.session.version = c.version;
		}
		if (session !== null) {
			c.expect = CCC;
			c.session.resuming = true;
			c.session.sp.client_random = msg.random.bytes();
		} else {
			c.expect = c.verifyClient !== false ? CCE : CKE;
			c.session.resuming = false;
			tls.createSecurityParameters(c, msg);
		}
		c.open = true;
		tls.queue(c, tls.createRecord(c, {
			type: tls.ContentType.handshake,
			data: tls.createServerHello(c)
		}));
		if (c.session.resuming) {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.change_cipher_spec,
				data: tls.createChangeCipherSpec()
			}));
			c.state.pending = tls.createConnectionState(c);
			c.state.current.write = c.state.pending.write;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createFinished(c)
			}));
		} else {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createCertificate(c)
			}));
			if (!c.fail) {
				tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createServerKeyExchange(c)
				}));
				if (c.verifyClient !== false) tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createCertificateRequest(c)
				}));
				tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createServerHelloDone(c)
				}));
			}
		}
		tls.flush(c);
		c.process();
	};
	/**
	* Called when a client receives a Certificate record.
	*
	* When this message will be sent:
	*   The server must send a certificate whenever the agreed-upon key exchange
	*   method is not an anonymous one. This message will always immediately
	*   follow the server hello message.
	*
	* Meaning of this message:
	*   The certificate type must be appropriate for the selected cipher suite's
	*   key exchange algorithm, and is generally an X.509v3 certificate. It must
	*   contain a key which matches the key exchange method, as follows. Unless
	*   otherwise specified, the signing algorithm for the certificate must be
	*   the same as the algorithm for the certificate key. Unless otherwise
	*   specified, the public key may be of any length.
	*
	* opaque ASN.1Cert<1..2^24-1>;
	* struct {
	*   ASN.1Cert certificate_list<1..2^24-1>;
	* } Certificate;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleCertificate = function(c, record$1, length) {
		if (length < 3) return c.error(c, {
			message: "Invalid Certificate message. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var b = record$1.fragment;
		var msg = { certificate_list: readVector(b, 3) };
		var cert, asn1;
		var certs = [];
		try {
			while (msg.certificate_list.length() > 0) {
				cert = readVector(msg.certificate_list, 3);
				asn1 = forge.asn1.fromDer(cert);
				cert = forge.pki.certificateFromAsn1(asn1, true);
				certs.push(cert);
			}
		} catch (ex) {
			return c.error(c, {
				message: "Could not parse certificate list.",
				cause: ex,
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.bad_certificate
				}
			});
		}
		var client = c.entity === tls.ConnectionEnd.client;
		if ((client || c.verifyClient === true) && certs.length === 0) c.error(c, {
			message: client ? "No server certificate provided." : "No client certificate provided.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		else if (certs.length === 0) c.expect = client ? SKE : CKE;
		else {
			if (client) c.session.serverCertificate = certs[0];
			else c.session.clientCertificate = certs[0];
			if (tls.verifyCertificateChain(c, certs)) c.expect = client ? SKE : CKE;
		}
		c.process();
	};
	/**
	* Called when a client receives a ServerKeyExchange record.
	*
	* When this message will be sent:
	*   This message will be sent immediately after the server certificate
	*   message (or the server hello message, if this is an anonymous
	*   negotiation).
	*
	*   The server key exchange message is sent by the server only when the
	*   server certificate message (if sent) does not contain enough data to
	*   allow the client to exchange a premaster secret.
	*
	* Meaning of this message:
	*   This message conveys cryptographic information to allow the client to
	*   communicate the premaster secret: either an RSA public key to encrypt
	*   the premaster secret with, or a Diffie-Hellman public key with which the
	*   client can complete a key exchange (with the result being the premaster
	*   secret.)
	*
	* enum {
	*   dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
	* } KeyExchangeAlgorithm;
	*
	* struct {
	*   opaque dh_p<1..2^16-1>;
	*   opaque dh_g<1..2^16-1>;
	*   opaque dh_Ys<1..2^16-1>;
	* } ServerDHParams;
	*
	* struct {
	*   select(KeyExchangeAlgorithm) {
	*     case dh_anon:
	*       ServerDHParams params;
	*     case dhe_dss:
	*     case dhe_rsa:
	*       ServerDHParams params;
	*       digitally-signed struct {
	*         opaque client_random[32];
	*         opaque server_random[32];
	*         ServerDHParams params;
	*       } signed_params;
	*     case rsa:
	*     case dh_dss:
	*     case dh_rsa:
	*       struct {};
	*   };
	* } ServerKeyExchange;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleServerKeyExchange = function(c, record$1, length) {
		if (length > 0) return c.error(c, {
			message: "Invalid key parameters. Only RSA is supported.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.unsupported_certificate
			}
		});
		c.expect = SCR;
		c.process();
	};
	/**
	* Called when a client receives a ClientKeyExchange record.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleClientKeyExchange = function(c, record$1, length) {
		if (length < 48) return c.error(c, {
			message: "Invalid key parameters. Only RSA is supported.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.unsupported_certificate
			}
		});
		var b = record$1.fragment;
		var msg = { enc_pre_master_secret: readVector(b, 2).getBytes() };
		var privateKey = null;
		if (c.getPrivateKey) try {
			privateKey = c.getPrivateKey(c, c.session.serverCertificate);
			privateKey = forge.pki.privateKeyFromPem(privateKey);
		} catch (ex) {
			c.error(c, {
				message: "Could not get private key.",
				cause: ex,
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
		}
		if (privateKey === null) return c.error(c, {
			message: "No private key set.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.internal_error
			}
		});
		try {
			var sp = c.session.sp;
			sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
			var version$2 = c.session.clientHelloVersion;
			if (version$2.major !== sp.pre_master_secret.charCodeAt(0) || version$2.minor !== sp.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.");
		} catch (ex) {
			sp.pre_master_secret = forge.random.getBytes(48);
		}
		c.expect = CCC;
		if (c.session.clientCertificate !== null) c.expect = CCV;
		c.process();
	};
	/**
	* Called when a client receives a CertificateRequest record.
	*
	* When this message will be sent:
	*   A non-anonymous server can optionally request a certificate from the
	*   client, if appropriate for the selected cipher suite. This message, if
	*   sent, will immediately follow the Server Key Exchange message (if it is
	*   sent; otherwise, the Server Certificate message).
	*
	* enum {
	*   rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
	*   rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
	*   fortezza_dms_RESERVED(20), (255)
	* } ClientCertificateType;
	*
	* opaque DistinguishedName<1..2^16-1>;
	*
	* struct {
	*   ClientCertificateType certificate_types<1..2^8-1>;
	*   SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;
	*   DistinguishedName certificate_authorities<0..2^16-1>;
	* } CertificateRequest;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleCertificateRequest = function(c, record$1, length) {
		if (length < 3) return c.error(c, {
			message: "Invalid CertificateRequest. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var b = record$1.fragment;
		var msg = {
			certificate_types: readVector(b, 1),
			certificate_authorities: readVector(b, 2)
		};
		c.session.certificateRequest = msg;
		c.expect = SHD;
		c.process();
	};
	/**
	* Called when a server receives a CertificateVerify record.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleCertificateVerify = function(c, record$1, length) {
		if (length < 2) return c.error(c, {
			message: "Invalid CertificateVerify. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var b = record$1.fragment;
		b.read -= 4;
		var msgBytes = b.bytes();
		b.read += 4;
		var msg = { signature: readVector(b, 2).getBytes() };
		var verify = forge.util.createBuffer();
		verify.putBuffer(c.session.md5.digest());
		verify.putBuffer(c.session.sha1.digest());
		verify = verify.getBytes();
		try {
			if (!c.session.clientCertificate.publicKey.verify(verify, msg.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
			c.session.md5.update(msgBytes);
			c.session.sha1.update(msgBytes);
		} catch (ex) {
			return c.error(c, {
				message: "Bad signature in CertificateVerify.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.handshake_failure
				}
			});
		}
		c.expect = CCC;
		c.process();
	};
	/**
	* Called when a client receives a ServerHelloDone record.
	*
	* When this message will be sent:
	*   The server hello done message is sent by the server to indicate the end
	*   of the server hello and associated messages. After sending this message
	*   the server will wait for a client response.
	*
	* Meaning of this message:
	*   This message means that the server is done sending messages to support
	*   the key exchange, and the client can proceed with its phase of the key
	*   exchange.
	*
	*   Upon receipt of the server hello done message the client should verify
	*   that the server provided a valid certificate if required and check that
	*   the server hello parameters are acceptable.
	*
	* struct {} ServerHelloDone;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleServerHelloDone = function(c, record$1, length) {
		if (length > 0) return c.error(c, {
			message: "Invalid ServerHelloDone message. Invalid length.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.record_overflow
			}
		});
		if (c.serverCertificate === null) {
			var error$47 = {
				message: "No server certificate provided. Not enough security.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.insufficient_security
				}
			};
			var ret = c.verify(c, error$47.alert.description, 0, []);
			if (ret !== true) {
				if (ret || ret === 0) {
					if (typeof ret === "object" && !forge.util.isArray(ret)) {
						if (ret.message) error$47.message = ret.message;
						if (ret.alert) error$47.alert.description = ret.alert;
					} else if (typeof ret === "number") error$47.alert.description = ret;
				}
				return c.error(c, error$47);
			}
		}
		if (c.session.certificateRequest !== null) {
			record$1 = tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createCertificate(c)
			});
			tls.queue(c, record$1);
		}
		record$1 = tls.createRecord(c, {
			type: tls.ContentType.handshake,
			data: tls.createClientKeyExchange(c)
		});
		tls.queue(c, record$1);
		c.expect = SER;
		var callback$1 = function(c$1, signature) {
			if (c$1.session.certificateRequest !== null && c$1.session.clientCertificate !== null) tls.queue(c$1, tls.createRecord(c$1, {
				type: tls.ContentType.handshake,
				data: tls.createCertificateVerify(c$1, signature)
			}));
			tls.queue(c$1, tls.createRecord(c$1, {
				type: tls.ContentType.change_cipher_spec,
				data: tls.createChangeCipherSpec()
			}));
			c$1.state.pending = tls.createConnectionState(c$1);
			c$1.state.current.write = c$1.state.pending.write;
			tls.queue(c$1, tls.createRecord(c$1, {
				type: tls.ContentType.handshake,
				data: tls.createFinished(c$1)
			}));
			c$1.expect = SCC;
			tls.flush(c$1);
			c$1.process();
		};
		if (c.session.certificateRequest === null || c.session.clientCertificate === null) return callback$1(c, null);
		tls.getClientSignature(c, callback$1);
	};
	/**
	* Called when a ChangeCipherSpec record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleChangeCipherSpec = function(c, record$1) {
		if (record$1.fragment.getByte() !== 1) return c.error(c, {
			message: "Invalid ChangeCipherSpec message received.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var client = c.entity === tls.ConnectionEnd.client;
		if (c.session.resuming && client || !c.session.resuming && !client) c.state.pending = tls.createConnectionState(c);
		c.state.current.read = c.state.pending.read;
		if (!c.session.resuming && client || c.session.resuming && !client) c.state.pending = null;
		c.expect = client ? SFI : CFI;
		c.process();
	};
	/**
	* Called when a Finished record is received.
	*
	* When this message will be sent:
	*   A finished message is always sent immediately after a change
	*   cipher spec message to verify that the key exchange and
	*   authentication processes were successful. It is essential that a
	*   change cipher spec message be received between the other
	*   handshake messages and the Finished message.
	*
	* Meaning of this message:
	*   The finished message is the first protected with the just-
	*   negotiated algorithms, keys, and secrets. Recipients of finished
	*   messages must verify that the contents are correct.  Once a side
	*   has sent its Finished message and received and validated the
	*   Finished message from its peer, it may begin to send and receive
	*   application data over the connection.
	*
	* struct {
	*   opaque verify_data[verify_data_length];
	* } Finished;
	*
	* verify_data
	*   PRF(master_secret, finished_label, Hash(handshake_messages))
	*     [0..verify_data_length-1];
	*
	* finished_label
	*   For Finished messages sent by the client, the string
	*   "client finished". For Finished messages sent by the server, the
	*   string "server finished".
	*
	* verify_data_length depends on the cipher suite. If it is not specified
	* by the cipher suite, then it is 12. Versions of TLS < 1.2 always used
	* 12 bytes.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleFinished = function(c, record$1, length) {
		var b = record$1.fragment;
		b.read -= 4;
		var msgBytes = b.bytes();
		b.read += 4;
		var vd = record$1.fragment.getBytes();
		b = forge.util.createBuffer();
		b.putBuffer(c.session.md5.digest());
		b.putBuffer(c.session.sha1.digest());
		var client = c.entity === tls.ConnectionEnd.client;
		var label = client ? "server finished" : "client finished";
		var sp = c.session.sp;
		b = prf_TLS1(sp.master_secret, label, b.getBytes(), 12);
		if (b.getBytes() !== vd) return c.error(c, {
			message: "Invalid verify_data in Finished message.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.decrypt_error
			}
		});
		c.session.md5.update(msgBytes);
		c.session.sha1.update(msgBytes);
		if (c.session.resuming && client || !c.session.resuming && !client) {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.change_cipher_spec,
				data: tls.createChangeCipherSpec()
			}));
			c.state.current.write = c.state.pending.write;
			c.state.pending = null;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createFinished(c)
			}));
		}
		c.expect = client ? SAD : CAD;
		c.handshaking = false;
		++c.handshakes;
		c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
		tls.flush(c);
		c.isConnected = true;
		c.connected(c);
		c.process();
	};
	/**
	* Called when an Alert record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleAlert = function(c, record$1) {
		var b = record$1.fragment;
		var alert = {
			level: b.getByte(),
			description: b.getByte()
		};
		var msg;
		switch (alert.description) {
			case tls.Alert.Description.close_notify:
				msg = "Connection closed.";
				break;
			case tls.Alert.Description.unexpected_message:
				msg = "Unexpected message.";
				break;
			case tls.Alert.Description.bad_record_mac:
				msg = "Bad record MAC.";
				break;
			case tls.Alert.Description.decryption_failed:
				msg = "Decryption failed.";
				break;
			case tls.Alert.Description.record_overflow:
				msg = "Record overflow.";
				break;
			case tls.Alert.Description.decompression_failure:
				msg = "Decompression failed.";
				break;
			case tls.Alert.Description.handshake_failure:
				msg = "Handshake failure.";
				break;
			case tls.Alert.Description.bad_certificate:
				msg = "Bad certificate.";
				break;
			case tls.Alert.Description.unsupported_certificate:
				msg = "Unsupported certificate.";
				break;
			case tls.Alert.Description.certificate_revoked:
				msg = "Certificate revoked.";
				break;
			case tls.Alert.Description.certificate_expired:
				msg = "Certificate expired.";
				break;
			case tls.Alert.Description.certificate_unknown:
				msg = "Certificate unknown.";
				break;
			case tls.Alert.Description.illegal_parameter:
				msg = "Illegal parameter.";
				break;
			case tls.Alert.Description.unknown_ca:
				msg = "Unknown certificate authority.";
				break;
			case tls.Alert.Description.access_denied:
				msg = "Access denied.";
				break;
			case tls.Alert.Description.decode_error:
				msg = "Decode error.";
				break;
			case tls.Alert.Description.decrypt_error:
				msg = "Decrypt error.";
				break;
			case tls.Alert.Description.export_restriction:
				msg = "Export restriction.";
				break;
			case tls.Alert.Description.protocol_version:
				msg = "Unsupported protocol version.";
				break;
			case tls.Alert.Description.insufficient_security:
				msg = "Insufficient security.";
				break;
			case tls.Alert.Description.internal_error:
				msg = "Internal error.";
				break;
			case tls.Alert.Description.user_canceled:
				msg = "User canceled.";
				break;
			case tls.Alert.Description.no_renegotiation:
				msg = "Renegotiation not supported.";
				break;
			default:
				msg = "Unknown error.";
				break;
		}
		if (alert.description === tls.Alert.Description.close_notify) return c.close();
		c.error(c, {
			message: msg,
			send: false,
			origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
			alert
		});
		c.process();
	};
	/**
	* Called when a Handshake record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleHandshake = function(c, record$1) {
		var b = record$1.fragment;
		var type = b.getByte();
		var length = b.getInt24();
		if (length > b.length()) {
			c.fragmented = record$1;
			record$1.fragment = forge.util.createBuffer();
			b.read -= 4;
			return c.process();
		}
		c.fragmented = null;
		b.read -= 4;
		var bytes = b.bytes(length + 4);
		b.read += 4;
		if (type in hsTable[c.entity][c.expect]) {
			if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
				c.handshaking = true;
				c.session = {
					version: null,
					extensions: { server_name: { serverNameList: [] } },
					cipherSuite: null,
					compressionMethod: null,
					serverCertificate: null,
					clientCertificate: null,
					md5: forge.md.md5.create(),
					sha1: forge.md.sha1.create()
				};
			}
			if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
				c.session.md5.update(bytes);
				c.session.sha1.update(bytes);
			}
			hsTable[c.entity][c.expect][type](c, record$1, length);
		} else tls.handleUnexpected(c, record$1);
	};
	/**
	* Called when an ApplicationData record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleApplicationData = function(c, record$1) {
		c.data.putBuffer(record$1.fragment);
		c.dataReady(c);
		c.process();
	};
	/**
	* Called when a Heartbeat record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleHeartbeat = function(c, record$1) {
		var b = record$1.fragment;
		var type = b.getByte();
		var length = b.getInt16();
		var payload = b.getBytes(length);
		if (type === tls.HeartbeatMessageType.heartbeat_request) {
			if (c.handshaking || length > payload.length) return c.process();
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.heartbeat,
				data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
			}));
			tls.flush(c);
		} else if (type === tls.HeartbeatMessageType.heartbeat_response) {
			if (payload !== c.expectedHeartbeatPayload) return c.process();
			if (c.heartbeatReceived) c.heartbeatReceived(c, forge.util.createBuffer(payload));
		}
		c.process();
	};
	/**
	* The transistional state tables for receiving TLS records. It maps the
	* current TLS engine state and a received record to a function to handle the
	* record and update the state.
	*
	* For instance, if the current state is SHE, then the TLS engine is expecting
	* a ServerHello record. Once a record is received, the handler function is
	* looked up using the state SHE and the record's content type.
	*
	* The resulting function will either be an error handler or a record handler.
	* The function will take whatever action is appropriate and update the state
	* for the next record.
	*
	* The states are all based on possible server record types. Note that the
	* client will never specifically expect to receive a HelloRequest or an alert
	* from the server so there is no state that reflects this. These messages may
	* occur at any time.
	*
	* There are two tables for mapping states because there is a second tier of
	* types for handshake messages. Once a record with a content type of handshake
	* is received, the handshake record handler will look up the handshake type in
	* the secondary map to get its appropriate handler.
	*
	* Valid message orders are as follows:
	*
	* =======================FULL HANDSHAKE======================
	* Client                                               Server
	*
	* ClientHello                  -------->
	*                                                 ServerHello
	*                                                Certificate*
	*                                          ServerKeyExchange*
	*                                         CertificateRequest*
	*                              <--------      ServerHelloDone
	* Certificate*
	* ClientKeyExchange
	* CertificateVerify*
	* [ChangeCipherSpec]
	* Finished                     -------->
	*                                          [ChangeCipherSpec]
	*                              <--------             Finished
	* Application Data             <------->     Application Data
	*
	* =====================SESSION RESUMPTION=====================
	* Client                                                Server
	*
	* ClientHello                   -------->
	*                                                  ServerHello
	*                                           [ChangeCipherSpec]
	*                               <--------             Finished
	* [ChangeCipherSpec]
	* Finished                      -------->
	* Application Data              <------->     Application Data
	*/
	var SHE = 0;
	var SCE = 1;
	var SKE = 2;
	var SCR = 3;
	var SHD = 4;
	var SCC = 5;
	var SFI = 6;
	var SAD = 7;
	var SER = 8;
	var CHE = 0;
	var CCE = 1;
	var CKE = 2;
	var CCV = 3;
	var CCC = 4;
	var CFI = 5;
	var CAD = 6;
	var __ = tls.handleUnexpected;
	var R0 = tls.handleChangeCipherSpec;
	var R1 = tls.handleAlert;
	var R2 = tls.handleHandshake;
	var R3 = tls.handleApplicationData;
	var R4 = tls.handleHeartbeat;
	var ctTable = [];
	ctTable[tls.ConnectionEnd.client] = [
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			R0,
			R1,
			__,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			R3,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		]
	];
	ctTable[tls.ConnectionEnd.server] = [
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			R0,
			R1,
			__,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			R3,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		]
	];
	var H0 = tls.handleHelloRequest;
	var H1 = tls.handleServerHello;
	var H2 = tls.handleCertificate;
	var H3 = tls.handleServerKeyExchange;
	var H4 = tls.handleCertificateRequest;
	var H5 = tls.handleServerHelloDone;
	var H6 = tls.handleFinished;
	var hsTable = [];
	hsTable[tls.ConnectionEnd.client] = [
		[
			__,
			__,
			H1,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H2,
			H3,
			H4,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H3,
			H4,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H4,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H6
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		]
	];
	var H7 = tls.handleClientHello;
	var H8 = tls.handleClientKeyExchange;
	var H9 = tls.handleCertificateVerify;
	hsTable[tls.ConnectionEnd.server] = [
		[
			__,
			H7,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H2,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H8,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H9,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H6
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		]
	];
	/**
	* Generates the master_secret and keys using the given security parameters.
	*
	* The security parameters for a TLS connection state are defined as such:
	*
	* struct {
	*   ConnectionEnd          entity;
	*   PRFAlgorithm           prf_algorithm;
	*   BulkCipherAlgorithm    bulk_cipher_algorithm;
	*   CipherType             cipher_type;
	*   uint8                  enc_key_length;
	*   uint8                  block_length;
	*   uint8                  fixed_iv_length;
	*   uint8                  record_iv_length;
	*   MACAlgorithm           mac_algorithm;
	*   uint8                  mac_length;
	*   uint8                  mac_key_length;
	*   CompressionMethod      compression_algorithm;
	*   opaque                 master_secret[48];
	*   opaque                 client_random[32];
	*   opaque                 server_random[32];
	* } SecurityParameters;
	*
	* Note that this definition is from TLS 1.2. In TLS 1.0 some of these
	* parameters are ignored because, for instance, the PRFAlgorithm is a
	* builtin-fixed algorithm combining iterations of MD5 and SHA-1 in TLS 1.0.
	*
	* The Record Protocol requires an algorithm to generate keys required by the
	* current connection state.
	*
	* The master secret is expanded into a sequence of secure bytes, which is then
	* split to a client write MAC key, a server write MAC key, a client write
	* encryption key, and a server write encryption key. In TLS 1.0 a client write
	* IV and server write IV are also generated. Each of these is generated from
	* the byte sequence in that order. Unused values are empty. In TLS 1.2, some
	* AEAD ciphers may additionally require a client write IV and a server write
	* IV (see Section 6.2.3.3).
	*
	* When keys, MAC keys, and IVs are generated, the master secret is used as an
	* entropy source.
	*
	* To generate the key material, compute:
	*
	* master_secret = PRF(pre_master_secret, "master secret",
	*                     ClientHello.random + ServerHello.random)
	*
	* key_block = PRF(SecurityParameters.master_secret,
	*                 "key expansion",
	*                 SecurityParameters.server_random +
	*                 SecurityParameters.client_random);
	*
	* until enough output has been generated. Then, the key_block is
	* partitioned as follows:
	*
	* client_write_MAC_key[SecurityParameters.mac_key_length]
	* server_write_MAC_key[SecurityParameters.mac_key_length]
	* client_write_key[SecurityParameters.enc_key_length]
	* server_write_key[SecurityParameters.enc_key_length]
	* client_write_IV[SecurityParameters.fixed_iv_length]
	* server_write_IV[SecurityParameters.fixed_iv_length]
	*
	* In TLS 1.2, the client_write_IV and server_write_IV are only generated for
	* implicit nonce techniques as described in Section 3.2.1 of [AEAD]. This
	* implementation uses TLS 1.0 so IVs are generated.
	*
	* Implementation note: The currently defined cipher suite which requires the
	* most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32
	* byte MAC keys, for a total 128 bytes of key material. In TLS 1.0 it also
	* requires 2 x 16 byte IVs, so it actually takes 160 bytes of key material.
	*
	* @param c the connection.
	* @param sp the security parameters to use.
	*
	* @return the security keys.
	*/
	tls.generateKeys = function(c, sp) {
		var prf = prf_TLS1;
		var random = sp.client_random + sp.server_random;
		if (!c.session.resuming) {
			sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes();
			sp.pre_master_secret = null;
		}
		random = sp.server_random + sp.client_random;
		var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
		var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
		if (tls10) length += 2 * sp.fixed_iv_length;
		var km = prf(sp.master_secret, "key expansion", random, length);
		var rval = {
			client_write_MAC_key: km.getBytes(sp.mac_key_length),
			server_write_MAC_key: km.getBytes(sp.mac_key_length),
			client_write_key: km.getBytes(sp.enc_key_length),
			server_write_key: km.getBytes(sp.enc_key_length)
		};
		if (tls10) {
			rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
			rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
		}
		return rval;
	};
	/**
	* Creates a new initialized TLS connection state. A connection state has
	* a read mode and a write mode.
	*
	* compression state:
	*   The current state of the compression algorithm.
	*
	* cipher state:
	*   The current state of the encryption algorithm. This will consist of the
	*   scheduled key for that connection. For stream ciphers, this will also
	*   contain whatever state information is necessary to allow the stream to
	*   continue to encrypt or decrypt data.
	*
	* MAC key:
	*   The MAC key for the connection.
	*
	* sequence number:
	*   Each connection state contains a sequence number, which is maintained
	*   separately for read and write states. The sequence number MUST be set to
	*   zero whenever a connection state is made the active state. Sequence
	*   numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do
	*   not wrap. If a TLS implementation would need to wrap a sequence number,
	*   it must renegotiate instead. A sequence number is incremented after each
	*   record: specifically, the first record transmitted under a particular
	*   connection state MUST use sequence number 0.
	*
	* @param c the connection.
	*
	* @return the new initialized TLS connection state.
	*/
	tls.createConnectionState = function(c) {
		var client = c.entity === tls.ConnectionEnd.client;
		var createMode = function() {
			var mode = {
				sequenceNumber: [0, 0],
				macKey: null,
				macLength: 0,
				macFunction: null,
				cipherState: null,
				cipherFunction: function(record$1) {
					return true;
				},
				compressionState: null,
				compressFunction: function(record$1) {
					return true;
				},
				updateSequenceNumber: function() {
					if (mode.sequenceNumber[1] === 4294967295) {
						mode.sequenceNumber[1] = 0;
						++mode.sequenceNumber[0];
					} else ++mode.sequenceNumber[1];
				}
			};
			return mode;
		};
		var state = {
			read: createMode(),
			write: createMode()
		};
		state.read.update = function(c$1, record$1) {
			if (!state.read.cipherFunction(record$1, state.read)) c$1.error(c$1, {
				message: "Could not decrypt record or bad MAC.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.bad_record_mac
				}
			});
			else if (!state.read.compressFunction(c$1, record$1, state.read)) c$1.error(c$1, {
				message: "Could not decompress record.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.decompression_failure
				}
			});
			return !c$1.fail;
		};
		state.write.update = function(c$1, record$1) {
			if (!state.write.compressFunction(c$1, record$1, state.write)) c$1.error(c$1, {
				message: "Could not compress record.",
				send: false,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
			else if (!state.write.cipherFunction(record$1, state.write)) c$1.error(c$1, {
				message: "Could not encrypt record.",
				send: false,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
			return !c$1.fail;
		};
		if (c.session) {
			var sp = c.session.sp;
			c.session.cipherSuite.initSecurityParameters(sp);
			sp.keys = tls.generateKeys(c, sp);
			state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
			state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
			c.session.cipherSuite.initConnectionState(state, c, sp);
			switch (sp.compression_algorithm) {
				case tls.CompressionMethod.none: break;
				case tls.CompressionMethod.deflate:
					state.read.compressFunction = inflate;
					state.write.compressFunction = deflate;
					break;
				default: throw new Error("Unsupported compression algorithm.");
			}
		}
		return state;
	};
	/**
	* Creates a Random structure.
	*
	* struct {
	*   uint32 gmt_unix_time;
	*   opaque random_bytes[28];
	* } Random;
	*
	* gmt_unix_time:
	*   The current time and date in standard UNIX 32-bit format (seconds since
	*   the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according
	*   to the sender's internal clock. Clocks are not required to be set
	*   correctly by the basic TLS protocol; higher-level or application
	*   protocols may define additional requirements. Note that, for historical
	*   reasons, the data element is named using GMT, the predecessor of the
	*   current worldwide time base, UTC.
	* random_bytes:
	*   28 bytes generated by a secure random number generator.
	*
	* @return the Random structure as a byte array.
	*/
	tls.createRandom = function() {
		var d = /* @__PURE__ */ new Date();
		var utc = +d + d.getTimezoneOffset() * 6e4;
		var rval = forge.util.createBuffer();
		rval.putInt32(utc);
		rval.putBytes(forge.random.getBytes(28));
		return rval;
	};
	/**
	* Creates a TLS record with the given type and data.
	*
	* @param c the connection.
	* @param options:
	*   type: the record type.
	*   data: the plain text data in a byte buffer.
	*
	* @return the created record.
	*/
	tls.createRecord = function(c, options) {
		if (!options.data) return null;
		return {
			type: options.type,
			version: {
				major: c.version.major,
				minor: c.version.minor
			},
			length: options.data.length(),
			fragment: options.data
		};
	};
	/**
	* Creates a TLS alert record.
	*
	* @param c the connection.
	* @param alert:
	*   level: the TLS alert level.
	*   description: the TLS alert description.
	*
	* @return the created alert record.
	*/
	tls.createAlert = function(c, alert) {
		var b = forge.util.createBuffer();
		b.putByte(alert.level);
		b.putByte(alert.description);
		return tls.createRecord(c, {
			type: tls.ContentType.alert,
			data: b
		});
	};
	/**
	* Creates a ClientHello message.
	*
	* opaque SessionID<0..32>;
	* enum { null(0), deflate(1), (255) } CompressionMethod;
	* uint8 CipherSuite[2];
	*
	* struct {
	*   ProtocolVersion client_version;
	*   Random random;
	*   SessionID session_id;
	*   CipherSuite cipher_suites<2..2^16-2>;
	*   CompressionMethod compression_methods<1..2^8-1>;
	*   select(extensions_present) {
	*     case false:
	*       struct {};
	*     case true:
	*       Extension extensions<0..2^16-1>;
	*   };
	* } ClientHello;
	*
	* The extension format for extended client hellos and server hellos is:
	*
	* struct {
	*   ExtensionType extension_type;
	*   opaque extension_data<0..2^16-1>;
	* } Extension;
	*
	* Here:
	*
	* - "extension_type" identifies the particular extension type.
	* - "extension_data" contains information specific to the particular
	* extension type.
	*
	* The extension types defined in this document are:
	*
	* enum {
	*   server_name(0), max_fragment_length(1),
	*   client_certificate_url(2), trusted_ca_keys(3),
	*   truncated_hmac(4), status_request(5), (65535)
	* } ExtensionType;
	*
	* @param c the connection.
	*
	* @return the ClientHello byte buffer.
	*/
	tls.createClientHello = function(c) {
		c.session.clientHelloVersion = {
			major: c.version.major,
			minor: c.version.minor
		};
		var cipherSuites = forge.util.createBuffer();
		for (var i = 0; i < c.cipherSuites.length; ++i) {
			var cs = c.cipherSuites[i];
			cipherSuites.putByte(cs.id[0]);
			cipherSuites.putByte(cs.id[1]);
		}
		var cSuites = cipherSuites.length();
		var compressionMethods = forge.util.createBuffer();
		compressionMethods.putByte(tls.CompressionMethod.none);
		var cMethods = compressionMethods.length();
		var extensions = forge.util.createBuffer();
		if (c.virtualHost) {
			var ext = forge.util.createBuffer();
			ext.putByte(0);
			ext.putByte(0);
			var serverName = forge.util.createBuffer();
			serverName.putByte(0);
			writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
			var snList = forge.util.createBuffer();
			writeVector(snList, 2, serverName);
			writeVector(ext, 2, snList);
			extensions.putBuffer(ext);
		}
		var extLength = extensions.length();
		if (extLength > 0) extLength += 2;
		var sessionId = c.session.id;
		var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.client_hello);
		rval.putInt24(length);
		rval.putByte(c.version.major);
		rval.putByte(c.version.minor);
		rval.putBytes(c.session.sp.client_random);
		writeVector(rval, 1, forge.util.createBuffer(sessionId));
		writeVector(rval, 2, cipherSuites);
		writeVector(rval, 1, compressionMethods);
		if (extLength > 0) writeVector(rval, 2, extensions);
		return rval;
	};
	/**
	* Creates a ServerHello message.
	*
	* @param c the connection.
	*
	* @return the ServerHello byte buffer.
	*/
	tls.createServerHello = function(c) {
		var sessionId = c.session.id;
		var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.server_hello);
		rval.putInt24(length);
		rval.putByte(c.version.major);
		rval.putByte(c.version.minor);
		rval.putBytes(c.session.sp.server_random);
		writeVector(rval, 1, forge.util.createBuffer(sessionId));
		rval.putByte(c.session.cipherSuite.id[0]);
		rval.putByte(c.session.cipherSuite.id[1]);
		rval.putByte(c.session.compressionMethod);
		return rval;
	};
	/**
	* Creates a Certificate message.
	*
	* When this message will be sent:
	*   This is the first message the client can send after receiving a server
	*   hello done message and the first message the server can send after
	*   sending a ServerHello. This client message is only sent if the server
	*   requests a certificate. If no suitable certificate is available, the
	*   client should send a certificate message containing no certificates. If
	*   client authentication is required by the server for the handshake to
	*   continue, it may respond with a fatal handshake failure alert.
	*
	* opaque ASN.1Cert<1..2^24-1>;
	*
	* struct {
	*   ASN.1Cert certificate_list<0..2^24-1>;
	* } Certificate;
	*
	* @param c the connection.
	*
	* @return the Certificate byte buffer.
	*/
	tls.createCertificate = function(c) {
		var client = c.entity === tls.ConnectionEnd.client;
		var cert = null;
		if (c.getCertificate) {
			var hint;
			if (client) hint = c.session.certificateRequest;
			else hint = c.session.extensions.server_name.serverNameList;
			cert = c.getCertificate(c, hint);
		}
		var certList = forge.util.createBuffer();
		if (cert !== null) try {
			if (!forge.util.isArray(cert)) cert = [cert];
			var asn1 = null;
			for (var i = 0; i < cert.length; ++i) {
				var msg = forge.pem.decode(cert[i])[0];
				if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
					var error$47 = /* @__PURE__ */ new Error("Could not convert certificate from PEM; PEM header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".");
					error$47.headerType = msg.type;
					throw error$47;
				}
				if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
				var der = forge.util.createBuffer(msg.body);
				if (asn1 === null) asn1 = forge.asn1.fromDer(der.bytes(), false);
				var certBuffer = forge.util.createBuffer();
				writeVector(certBuffer, 3, der);
				certList.putBuffer(certBuffer);
			}
			cert = forge.pki.certificateFromAsn1(asn1);
			if (client) c.session.clientCertificate = cert;
			else c.session.serverCertificate = cert;
		} catch (ex) {
			return c.error(c, {
				message: "Could not send certificate list.",
				cause: ex,
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.bad_certificate
				}
			});
		}
		var length = 3 + certList.length();
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.certificate);
		rval.putInt24(length);
		writeVector(rval, 3, certList);
		return rval;
	};
	/**
	* Creates a ClientKeyExchange message.
	*
	* When this message will be sent:
	*   This message is always sent by the client. It will immediately follow the
	*   client certificate message, if it is sent. Otherwise it will be the first
	*   message sent by the client after it receives the server hello done
	*   message.
	*
	* Meaning of this message:
	*   With this message, the premaster secret is set, either though direct
	*   transmission of the RSA-encrypted secret, or by the transmission of
	*   Diffie-Hellman parameters which will allow each side to agree upon the
	*   same premaster secret. When the key exchange method is DH_RSA or DH_DSS,
	*   client certification has been requested, and the client was able to
	*   respond with a certificate which contained a Diffie-Hellman public key
	*   whose parameters (group and generator) matched those specified by the
	*   server in its certificate, this message will not contain any data.
	*
	* Meaning of this message:
	*   If RSA is being used for key agreement and authentication, the client
	*   generates a 48-byte premaster secret, encrypts it using the public key
	*   from the server's certificate or the temporary RSA key provided in a
	*   server key exchange message, and sends the result in an encrypted
	*   premaster secret message. This structure is a variant of the client
	*   key exchange message, not a message in itself.
	*
	* struct {
	*   select(KeyExchangeAlgorithm) {
	*     case rsa: EncryptedPreMasterSecret;
	*     case diffie_hellman: ClientDiffieHellmanPublic;
	*   } exchange_keys;
	* } ClientKeyExchange;
	*
	* struct {
	*   ProtocolVersion client_version;
	*   opaque random[46];
	* } PreMasterSecret;
	*
	* struct {
	*   public-key-encrypted PreMasterSecret pre_master_secret;
	* } EncryptedPreMasterSecret;
	*
	* A public-key-encrypted element is encoded as a vector <0..2^16-1>.
	*
	* @param c the connection.
	*
	* @return the ClientKeyExchange byte buffer.
	*/
	tls.createClientKeyExchange = function(c) {
		var b = forge.util.createBuffer();
		b.putByte(c.session.clientHelloVersion.major);
		b.putByte(c.session.clientHelloVersion.minor);
		b.putBytes(forge.random.getBytes(46));
		var sp = c.session.sp;
		sp.pre_master_secret = b.getBytes();
		b = c.session.serverCertificate.publicKey.encrypt(sp.pre_master_secret);
		var length = b.length + 2;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.client_key_exchange);
		rval.putInt24(length);
		rval.putInt16(b.length);
		rval.putBytes(b);
		return rval;
	};
	/**
	* Creates a ServerKeyExchange message.
	*
	* @param c the connection.
	*
	* @return the ServerKeyExchange byte buffer.
	*/
	tls.createServerKeyExchange = function(c) {
		var length = 0;
		var rval = forge.util.createBuffer();
		if (length > 0) {
			rval.putByte(tls.HandshakeType.server_key_exchange);
			rval.putInt24(length);
		}
		return rval;
	};
	/**
	* Gets the signed data used to verify a client-side certificate. See
	* tls.createCertificateVerify() for details.
	*
	* @param c the connection.
	* @param callback the callback to call once the signed data is ready.
	*/
	tls.getClientSignature = function(c, callback$1) {
		var b = forge.util.createBuffer();
		b.putBuffer(c.session.md5.digest());
		b.putBuffer(c.session.sha1.digest());
		b = b.getBytes();
		c.getSignature = c.getSignature || function(c$1, b$1, callback$2) {
			var privateKey = null;
			if (c$1.getPrivateKey) try {
				privateKey = c$1.getPrivateKey(c$1, c$1.session.clientCertificate);
				privateKey = forge.pki.privateKeyFromPem(privateKey);
			} catch (ex) {
				c$1.error(c$1, {
					message: "Could not get private key.",
					cause: ex,
					send: true,
					alert: {
						level: tls.Alert.Level.fatal,
						description: tls.Alert.Description.internal_error
					}
				});
			}
			if (privateKey === null) c$1.error(c$1, {
				message: "No private key set.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
			else b$1 = privateKey.sign(b$1, null);
			callback$2(c$1, b$1);
		};
		c.getSignature(c, b, callback$1);
	};
	/**
	* Creates a CertificateVerify message.
	*
	* Meaning of this message:
	*   This structure conveys the client's Diffie-Hellman public value
	*   (Yc) if it was not already included in the client's certificate.
	*   The encoding used for Yc is determined by the enumerated
	*   PublicValueEncoding. This structure is a variant of the client
	*   key exchange message, not a message in itself.
	*
	* When this message will be sent:
	*   This message is used to provide explicit verification of a client
	*   certificate. This message is only sent following a client
	*   certificate that has signing capability (i.e. all certificates
	*   except those containing fixed Diffie-Hellman parameters). When
	*   sent, it will immediately follow the client key exchange message.
	*
	* struct {
	*   Signature signature;
	* } CertificateVerify;
	*
	* CertificateVerify.signature.md5_hash
	*   MD5(handshake_messages);
	*
	* Certificate.signature.sha_hash
	*   SHA(handshake_messages);
	*
	* Here handshake_messages refers to all handshake messages sent or
	* received starting at client hello up to but not including this
	* message, including the type and length fields of the handshake
	* messages.
	*
	* select(SignatureAlgorithm) {
	*   case anonymous: struct { };
	*   case rsa:
	*     digitally-signed struct {
	*       opaque md5_hash[16];
	*       opaque sha_hash[20];
	*     };
	*   case dsa:
	*     digitally-signed struct {
	*       opaque sha_hash[20];
	*     };
	* } Signature;
	*
	* In digital signing, one-way hash functions are used as input for a
	* signing algorithm. A digitally-signed element is encoded as an opaque
	* vector <0..2^16-1>, where the length is specified by the signing
	* algorithm and key.
	*
	* In RSA signing, a 36-byte structure of two hashes (one SHA and one
	* MD5) is signed (encrypted with the private key). It is encoded with
	* PKCS #1 block type 0 or type 1 as described in [PKCS1].
	*
	* In DSS, the 20 bytes of the SHA hash are run directly through the
	* Digital Signing Algorithm with no additional hashing.
	*
	* @param c the connection.
	* @param signature the signature to include in the message.
	*
	* @return the CertificateVerify byte buffer.
	*/
	tls.createCertificateVerify = function(c, signature) {
		var length = signature.length + 2;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.certificate_verify);
		rval.putInt24(length);
		rval.putInt16(signature.length);
		rval.putBytes(signature);
		return rval;
	};
	/**
	* Creates a CertificateRequest message.
	*
	* @param c the connection.
	*
	* @return the CertificateRequest byte buffer.
	*/
	tls.createCertificateRequest = function(c) {
		var certTypes = forge.util.createBuffer();
		certTypes.putByte(1);
		var cAs = forge.util.createBuffer();
		for (var key in c.caStore.certs) {
			var cert = c.caStore.certs[key];
			var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
			var byteBuffer = forge.asn1.toDer(dn);
			cAs.putInt16(byteBuffer.length());
			cAs.putBuffer(byteBuffer);
		}
		var length = 1 + certTypes.length() + 2 + cAs.length();
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.certificate_request);
		rval.putInt24(length);
		writeVector(rval, 1, certTypes);
		writeVector(rval, 2, cAs);
		return rval;
	};
	/**
	* Creates a ServerHelloDone message.
	*
	* @param c the connection.
	*
	* @return the ServerHelloDone byte buffer.
	*/
	tls.createServerHelloDone = function(c) {
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.server_hello_done);
		rval.putInt24(0);
		return rval;
	};
	/**
	* Creates a ChangeCipherSpec message.
	*
	* The change cipher spec protocol exists to signal transitions in
	* ciphering strategies. The protocol consists of a single message,
	* which is encrypted and compressed under the current (not the pending)
	* connection state. The message consists of a single byte of value 1.
	*
	* struct {
	*   enum { change_cipher_spec(1), (255) } type;
	* } ChangeCipherSpec;
	*
	* @return the ChangeCipherSpec byte buffer.
	*/
	tls.createChangeCipherSpec = function() {
		var rval = forge.util.createBuffer();
		rval.putByte(1);
		return rval;
	};
	/**
	* Creates a Finished message.
	*
	* struct {
	*   opaque verify_data[12];
	* } Finished;
	*
	* verify_data
	*   PRF(master_secret, finished_label, MD5(handshake_messages) +
	*   SHA-1(handshake_messages)) [0..11];
	*
	* finished_label
	*   For Finished messages sent by the client, the string "client
	*   finished". For Finished messages sent by the server, the
	*   string "server finished".
	*
	* handshake_messages
	*   All of the data from all handshake messages up to but not
	*   including this message. This is only data visible at the
	*   handshake layer and does not include record layer headers.
	*   This is the concatenation of all the Handshake structures as
	*   defined in 7.4 exchanged thus far.
	*
	* @param c the connection.
	*
	* @return the Finished byte buffer.
	*/
	tls.createFinished = function(c) {
		var b = forge.util.createBuffer();
		b.putBuffer(c.session.md5.digest());
		b.putBuffer(c.session.sha1.digest());
		var client = c.entity === tls.ConnectionEnd.client;
		var sp = c.session.sp;
		var vdl = 12;
		var prf = prf_TLS1;
		var label = client ? "client finished" : "server finished";
		b = prf(sp.master_secret, label, b.getBytes(), vdl);
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.finished);
		rval.putInt24(b.length());
		rval.putBuffer(b);
		return rval;
	};
	/**
	* Creates a HeartbeatMessage (See RFC 6520).
	*
	* struct {
	*   HeartbeatMessageType type;
	*   uint16 payload_length;
	*   opaque payload[HeartbeatMessage.payload_length];
	*   opaque padding[padding_length];
	* } HeartbeatMessage;
	*
	* The total length of a HeartbeatMessage MUST NOT exceed 2^14 or
	* max_fragment_length when negotiated as defined in [RFC6066].
	*
	* type: The message type, either heartbeat_request or heartbeat_response.
	*
	* payload_length: The length of the payload.
	*
	* payload: The payload consists of arbitrary content.
	*
	* padding: The padding is random content that MUST be ignored by the
	*   receiver. The length of a HeartbeatMessage is TLSPlaintext.length
	*   for TLS and DTLSPlaintext.length for DTLS. Furthermore, the
	*   length of the type field is 1 byte, and the length of the
	*   payload_length is 2. Therefore, the padding_length is
	*   TLSPlaintext.length - payload_length - 3 for TLS and
	*   DTLSPlaintext.length - payload_length - 3 for DTLS. The
	*   padding_length MUST be at least 16.
	*
	* The sender of a HeartbeatMessage MUST use a random padding of at
	* least 16 bytes. The padding of a received HeartbeatMessage message
	* MUST be ignored.
	*
	* If the payload_length of a received HeartbeatMessage is too large,
	* the received HeartbeatMessage MUST be discarded silently.
	*
	* @param c the connection.
	* @param type the tls.HeartbeatMessageType.
	* @param payload the heartbeat data to send as the payload.
	* @param [payloadLength] the payload length to use, defaults to the
	*          actual payload length.
	*
	* @return the HeartbeatRequest byte buffer.
	*/
	tls.createHeartbeat = function(type, payload, payloadLength) {
		if (typeof payloadLength === "undefined") payloadLength = payload.length;
		var rval = forge.util.createBuffer();
		rval.putByte(type);
		rval.putInt16(payloadLength);
		rval.putBytes(payload);
		var plaintextLength = rval.length();
		var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
		rval.putBytes(forge.random.getBytes(paddingLength));
		return rval;
	};
	/**
	* Fragments, compresses, encrypts, and queues a record for delivery.
	*
	* @param c the connection.
	* @param record the record to queue.
	*/
	tls.queue = function(c, record$1) {
		if (!record$1) return;
		if (record$1.fragment.length() === 0) {
			if (record$1.type === tls.ContentType.handshake || record$1.type === tls.ContentType.alert || record$1.type === tls.ContentType.change_cipher_spec) return;
		}
		if (record$1.type === tls.ContentType.handshake) {
			var bytes = record$1.fragment.bytes();
			c.session.md5.update(bytes);
			c.session.sha1.update(bytes);
			bytes = null;
		}
		var records;
		if (record$1.fragment.length() <= tls.MaxFragment) records = [record$1];
		else {
			records = [];
			var data = record$1.fragment.bytes();
			while (data.length > tls.MaxFragment) {
				records.push(tls.createRecord(c, {
					type: record$1.type,
					data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
				}));
				data = data.slice(tls.MaxFragment);
			}
			if (data.length > 0) records.push(tls.createRecord(c, {
				type: record$1.type,
				data: forge.util.createBuffer(data)
			}));
		}
		for (var i = 0; i < records.length && !c.fail; ++i) {
			var rec = records[i];
			if (c.state.current.write.update(c, rec)) c.records.push(rec);
		}
	};
	/**
	* Flushes all queued records to the output buffer and calls the
	* tlsDataReady() handler on the given connection.
	*
	* @param c the connection.
	*
	* @return true on success, false on failure.
	*/
	tls.flush = function(c) {
		for (var i = 0; i < c.records.length; ++i) {
			var record$1 = c.records[i];
			c.tlsData.putByte(record$1.type);
			c.tlsData.putByte(record$1.version.major);
			c.tlsData.putByte(record$1.version.minor);
			c.tlsData.putInt16(record$1.fragment.length());
			c.tlsData.putBuffer(c.records[i].fragment);
		}
		c.records = [];
		return c.tlsDataReady(c);
	};
	/**
	* Maps a pki.certificateError to a tls.Alert.Description.
	*
	* @param error the error to map.
	*
	* @return the alert description.
	*/
	var _certErrorToAlertDesc = function(error$47) {
		switch (error$47) {
			case true: return true;
			case forge.pki.certificateError.bad_certificate: return tls.Alert.Description.bad_certificate;
			case forge.pki.certificateError.unsupported_certificate: return tls.Alert.Description.unsupported_certificate;
			case forge.pki.certificateError.certificate_revoked: return tls.Alert.Description.certificate_revoked;
			case forge.pki.certificateError.certificate_expired: return tls.Alert.Description.certificate_expired;
			case forge.pki.certificateError.certificate_unknown: return tls.Alert.Description.certificate_unknown;
			case forge.pki.certificateError.unknown_ca: return tls.Alert.Description.unknown_ca;
			default: return tls.Alert.Description.bad_certificate;
		}
	};
	/**
	* Maps a tls.Alert.Description to a pki.certificateError.
	*
	* @param desc the alert description.
	*
	* @return the certificate error.
	*/
	var _alertDescToCertError = function(desc) {
		switch (desc) {
			case true: return true;
			case tls.Alert.Description.bad_certificate: return forge.pki.certificateError.bad_certificate;
			case tls.Alert.Description.unsupported_certificate: return forge.pki.certificateError.unsupported_certificate;
			case tls.Alert.Description.certificate_revoked: return forge.pki.certificateError.certificate_revoked;
			case tls.Alert.Description.certificate_expired: return forge.pki.certificateError.certificate_expired;
			case tls.Alert.Description.certificate_unknown: return forge.pki.certificateError.certificate_unknown;
			case tls.Alert.Description.unknown_ca: return forge.pki.certificateError.unknown_ca;
			default: return forge.pki.certificateError.bad_certificate;
		}
	};
	/**
	* Verifies a certificate chain against the given connection's
	* Certificate Authority store.
	*
	* @param c the TLS connection.
	* @param chain the certificate chain to verify, with the root or highest
	*          authority at the end.
	*
	* @return true if successful, false if not.
	*/
	tls.verifyCertificateChain = function(c, chain) {
		try {
			var options = {};
			for (var key in c.verifyOptions) options[key] = c.verifyOptions[key];
			options.verify = function(vfd, depth, chain$1) {
				_certErrorToAlertDesc(vfd);
				var ret = c.verify(c, vfd, depth, chain$1);
				if (ret !== true) {
					if (typeof ret === "object" && !forge.util.isArray(ret)) {
						var error$47 = /* @__PURE__ */ new Error("The application rejected the certificate.");
						error$47.send = true;
						error$47.alert = {
							level: tls.Alert.Level.fatal,
							description: tls.Alert.Description.bad_certificate
						};
						if (ret.message) error$47.message = ret.message;
						if (ret.alert) error$47.alert.description = ret.alert;
						throw error$47;
					}
					if (ret !== vfd) ret = _alertDescToCertError(ret);
				}
				return ret;
			};
			forge.pki.verifyCertificateChain(c.caStore, chain, options);
		} catch (ex) {
			var err = ex;
			if (typeof err !== "object" || forge.util.isArray(err)) err = {
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: _certErrorToAlertDesc(ex)
				}
			};
			if (!("send" in err)) err.send = true;
			if (!("alert" in err)) err.alert = {
				level: tls.Alert.Level.fatal,
				description: _certErrorToAlertDesc(err.error)
			};
			c.error(c, err);
		}
		return !c.fail;
	};
	/**
	* Creates a new TLS session cache.
	*
	* @param cache optional map of session ID to cached session.
	* @param capacity the maximum size for the cache (default: 100).
	*
	* @return the new TLS session cache.
	*/
	tls.createSessionCache = function(cache, capacity) {
		var rval = null;
		if (cache && cache.getSession && cache.setSession && cache.order) rval = cache;
		else {
			rval = {};
			rval.cache = cache || {};
			rval.capacity = Math.max(capacity || 100, 1);
			rval.order = [];
			for (var key in cache) if (rval.order.length <= capacity) rval.order.push(key);
			else delete cache[key];
			rval.getSession = function(sessionId) {
				var session = null;
				var key$1 = null;
				if (sessionId) key$1 = forge.util.bytesToHex(sessionId);
				else if (rval.order.length > 0) key$1 = rval.order[0];
				if (key$1 !== null && key$1 in rval.cache) {
					session = rval.cache[key$1];
					delete rval.cache[key$1];
					for (var i in rval.order) if (rval.order[i] === key$1) {
						rval.order.splice(i, 1);
						break;
					}
				}
				return session;
			};
			rval.setSession = function(sessionId, session) {
				if (rval.order.length === rval.capacity) {
					var key$1 = rval.order.shift();
					delete rval.cache[key$1];
				}
				var key$1 = forge.util.bytesToHex(sessionId);
				rval.order.push(key$1);
				rval.cache[key$1] = session;
			};
		}
		return rval;
	};
	/**
	* Creates a new TLS connection.
	*
	* See public createConnection() docs for more details.
	*
	* @param options the options for this connection.
	*
	* @return the new TLS connection.
	*/
	tls.createConnection = function(options) {
		var caStore = null;
		if (options.caStore) if (forge.util.isArray(options.caStore)) caStore = forge.pki.createCaStore(options.caStore);
		else caStore = options.caStore;
		else caStore = forge.pki.createCaStore();
		var cipherSuites = options.cipherSuites || null;
		if (cipherSuites === null) {
			cipherSuites = [];
			for (var key in tls.CipherSuites) cipherSuites.push(tls.CipherSuites[key]);
		}
		var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
		var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
		var c = {
			version: {
				major: tls.Version.major,
				minor: tls.Version.minor
			},
			entity,
			sessionId: options.sessionId,
			caStore,
			sessionCache,
			cipherSuites,
			connected: options.connected,
			virtualHost: options.virtualHost || null,
			verifyClient: options.verifyClient || false,
			verify: options.verify || function(cn, vfd, dpth, cts) {
				return vfd;
			},
			verifyOptions: options.verifyOptions || {},
			getCertificate: options.getCertificate || null,
			getPrivateKey: options.getPrivateKey || null,
			getSignature: options.getSignature || null,
			input: forge.util.createBuffer(),
			tlsData: forge.util.createBuffer(),
			data: forge.util.createBuffer(),
			tlsDataReady: options.tlsDataReady,
			dataReady: options.dataReady,
			heartbeatReceived: options.heartbeatReceived,
			closed: options.closed,
			error: function(c$1, ex) {
				ex.origin = ex.origin || (c$1.entity === tls.ConnectionEnd.client ? "client" : "server");
				if (ex.send) {
					tls.queue(c$1, tls.createAlert(c$1, ex.alert));
					tls.flush(c$1);
				}
				var fatal = ex.fatal !== false;
				if (fatal) c$1.fail = true;
				options.error(c$1, ex);
				if (fatal) c$1.close(false);
			},
			deflate: options.deflate || null,
			inflate: options.inflate || null
		};
		/**
		* Resets a closed TLS connection for reuse. Called in c.close().
		*
		* @param clearFail true to clear the fail flag (default: true).
		*/
		c.reset = function(clearFail) {
			c.version = {
				major: tls.Version.major,
				minor: tls.Version.minor
			};
			c.record = null;
			c.session = null;
			c.peerCertificate = null;
			c.state = {
				pending: null,
				current: null
			};
			c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
			c.fragmented = null;
			c.records = [];
			c.open = false;
			c.handshakes = 0;
			c.handshaking = false;
			c.isConnected = false;
			c.fail = !(clearFail || typeof clearFail === "undefined");
			c.input.clear();
			c.tlsData.clear();
			c.data.clear();
			c.state.current = tls.createConnectionState(c);
		};
		c.reset();
		/**
		* Updates the current TLS engine state based on the given record.
		*
		* @param c the TLS connection.
		* @param record the TLS record to act on.
		*/
		var _update = function(c$1, record$1) {
			var aligned = record$1.type - tls.ContentType.change_cipher_spec;
			var handlers = ctTable[c$1.entity][c$1.expect];
			if (aligned in handlers) handlers[aligned](c$1, record$1);
			else tls.handleUnexpected(c$1, record$1);
		};
		/**
		* Reads the record header and initializes the next record on the given
		* connection.
		*
		* @param c the TLS connection with the next record.
		*
		* @return 0 if the input data could be processed, otherwise the
		*         number of bytes required for data to be processed.
		*/
		var _readRecordHeader = function(c$1) {
			var rval = 0;
			var b = c$1.input;
			var len = b.length();
			if (len < 5) rval = 5 - len;
			else {
				c$1.record = {
					type: b.getByte(),
					version: {
						major: b.getByte(),
						minor: b.getByte()
					},
					length: b.getInt16(),
					fragment: forge.util.createBuffer(),
					ready: false
				};
				var compatibleVersion = c$1.record.version.major === c$1.version.major;
				if (compatibleVersion && c$1.session && c$1.session.version) compatibleVersion = c$1.record.version.minor === c$1.version.minor;
				if (!compatibleVersion) c$1.error(c$1, {
					message: "Incompatible TLS version.",
					send: true,
					alert: {
						level: tls.Alert.Level.fatal,
						description: tls.Alert.Description.protocol_version
					}
				});
			}
			return rval;
		};
		/**
		* Reads the next record's contents and appends its message to any
		* previously fragmented message.
		*
		* @param c the TLS connection with the next record.
		*
		* @return 0 if the input data could be processed, otherwise the
		*         number of bytes required for data to be processed.
		*/
		var _readRecord = function(c$1) {
			var rval = 0;
			var b = c$1.input;
			var len = b.length();
			if (len < c$1.record.length) rval = c$1.record.length - len;
			else {
				c$1.record.fragment.putBytes(b.getBytes(c$1.record.length));
				b.compact();
				if (c$1.state.current.read.update(c$1, c$1.record)) {
					if (c$1.fragmented !== null) if (c$1.fragmented.type === c$1.record.type) {
						c$1.fragmented.fragment.putBuffer(c$1.record.fragment);
						c$1.record = c$1.fragmented;
					} else c$1.error(c$1, {
						message: "Invalid fragmented record.",
						send: true,
						alert: {
							level: tls.Alert.Level.fatal,
							description: tls.Alert.Description.unexpected_message
						}
					});
					c$1.record.ready = true;
				}
			}
			return rval;
		};
		/**
		* Performs a handshake using the TLS Handshake Protocol, as a client.
		*
		* This method should only be called if the connection is in client mode.
		*
		* @param sessionId the session ID to use, null to start a new one.
		*/
		c.handshake = function(sessionId) {
			if (c.entity !== tls.ConnectionEnd.client) c.error(c, {
				message: "Cannot initiate handshake as a server.",
				fatal: false
			});
			else if (c.handshaking) c.error(c, {
				message: "Handshake already in progress.",
				fatal: false
			});
			else {
				if (c.fail && !c.open && c.handshakes === 0) c.fail = false;
				c.handshaking = true;
				sessionId = sessionId || "";
				var session = null;
				if (sessionId.length > 0) {
					if (c.sessionCache) session = c.sessionCache.getSession(sessionId);
					if (session === null) sessionId = "";
				}
				if (sessionId.length === 0 && c.sessionCache) {
					session = c.sessionCache.getSession();
					if (session !== null) sessionId = session.id;
				}
				c.session = {
					id: sessionId,
					version: null,
					cipherSuite: null,
					compressionMethod: null,
					serverCertificate: null,
					certificateRequest: null,
					clientCertificate: null,
					sp: {},
					md5: forge.md.md5.create(),
					sha1: forge.md.sha1.create()
				};
				if (session) {
					c.version = session.version;
					c.session.sp = session.sp;
				}
				c.session.sp.client_random = tls.createRandom().getBytes();
				c.open = true;
				tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createClientHello(c)
				}));
				tls.flush(c);
			}
		};
		/**
		* Called when TLS protocol data has been received from somewhere and should
		* be processed by the TLS engine.
		*
		* @param data the TLS protocol data, as a string, to process.
		*
		* @return 0 if the data could be processed, otherwise the number of bytes
		*         required for data to be processed.
		*/
		c.process = function(data) {
			var rval = 0;
			if (data) c.input.putBytes(data);
			if (!c.fail) {
				if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) c.record = null;
				if (c.record === null) rval = _readRecordHeader(c);
				if (!c.fail && c.record !== null && !c.record.ready) rval = _readRecord(c);
				if (!c.fail && c.record !== null && c.record.ready) _update(c, c.record);
			}
			return rval;
		};
		/**
		* Requests that application data be packaged into a TLS record. The
		* tlsDataReady handler will be called when the TLS record(s) have been
		* prepared.
		*
		* @param data the application data, as a raw 'binary' encoded string, to
		*          be sent; to send utf-16/utf-8 string data, use the return value
		*          of util.encodeUtf8(str).
		*
		* @return true on success, false on failure.
		*/
		c.prepare = function(data) {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.application_data,
				data: forge.util.createBuffer(data)
			}));
			return tls.flush(c);
		};
		/**
		* Requests that a heartbeat request be packaged into a TLS record for
		* transmission. The tlsDataReady handler will be called when TLS record(s)
		* have been prepared.
		*
		* When a heartbeat response has been received, the heartbeatReceived
		* handler will be called with the matching payload. This handler can
		* be used to clear a retransmission timer, etc.
		*
		* @param payload the heartbeat data to send as the payload in the message.
		* @param [payloadLength] the payload length to use, defaults to the
		*          actual payload length.
		*
		* @return true on success, false on failure.
		*/
		c.prepareHeartbeatRequest = function(payload, payloadLength) {
			if (payload instanceof forge.util.ByteBuffer) payload = payload.bytes();
			if (typeof payloadLength === "undefined") payloadLength = payload.length;
			c.expectedHeartbeatPayload = payload;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.heartbeat,
				data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
			}));
			return tls.flush(c);
		};
		/**
		* Closes the connection (sends a close_notify alert).
		*
		* @param clearFail true to clear the fail flag (default: true).
		*/
		c.close = function(clearFail) {
			if (!c.fail && c.sessionCache && c.session) {
				var session = {
					id: c.session.id,
					version: c.session.version,
					sp: c.session.sp
				};
				session.sp.keys = null;
				c.sessionCache.setSession(session.id, session);
			}
			if (c.open) {
				c.open = false;
				c.input.clear();
				if (c.isConnected || c.handshaking) {
					c.isConnected = c.handshaking = false;
					tls.queue(c, tls.createAlert(c, {
						level: tls.Alert.Level.warning,
						description: tls.Alert.Description.close_notify
					}));
					tls.flush(c);
				}
				c.closed(c);
			}
			c.reset(clearFail);
		};
		return c;
	};
	module.exports = forge.tls = forge.tls || {};
	for (var key in tls) if (typeof tls[key] !== "function") forge.tls[key] = tls[key];
	forge.tls.prf_tls1 = prf_TLS1;
	forge.tls.hmac_sha1 = hmac_sha1;
	forge.tls.createSessionCache = tls.createSessionCache;
	/**
	* Creates a new TLS connection. This does not make any assumptions about the
	* transport layer that TLS is working on top of, ie: it does not assume there
	* is a TCP/IP connection or establish one. A TLS connection is totally
	* abstracted away from the layer is runs on top of, it merely establishes a
	* secure channel between a client" and a "server".
	*
	* A TLS connection contains 4 connection states: pending read and write, and
	* current read and write.
	*
	* At initialization, the current read and write states will be null. Only once
	* the security parameters have been set and the keys have been generated can
	* the pending states be converted into current states. Current states will be
	* updated for each record processed.
	*
	* A custom certificate verify callback may be provided to check information
	* like the common name on the server's certificate. It will be called for
	* every certificate in the chain. It has the following signature:
	*
	* variable func(c, certs, index, preVerify)
	* Where:
	* c         The TLS connection
	* verified  Set to true if certificate was verified, otherwise the alert
	*           tls.Alert.Description for why the certificate failed.
	* depth     The current index in the chain, where 0 is the server's cert.
	* certs     The certificate chain, *NOTE* if the server was anonymous then
	*           the chain will be empty.
	*
	* The function returns true on success and on failure either the appropriate
	* tls.Alert.Description or an object with 'alert' set to the appropriate
	* tls.Alert.Description and 'message' set to a custom error message. If true
	* is not returned then the connection will abort using, in order of
	* availability, first the returned alert description, second the preVerify
	* alert description, and lastly the default 'bad_certificate'.
	*
	* There are three callbacks that can be used to make use of client-side
	* certificates where each takes the TLS connection as the first parameter:
	*
	* getCertificate(conn, hint)
	*   The second parameter is a hint as to which certificate should be
	*   returned. If the connection entity is a client, then the hint will be
	*   the CertificateRequest message from the server that is part of the
	*   TLS protocol. If the connection entity is a server, then it will be
	*   the servername list provided via an SNI extension the ClientHello, if
	*   one was provided (empty array if not). The hint can be examined to
	*   determine which certificate to use (advanced). Most implementations
	*   will just return a certificate. The return value must be a
	*   PEM-formatted certificate or an array of PEM-formatted certificates
	*   that constitute a certificate chain, with the first in the array/chain
	*   being the client's certificate.
	* getPrivateKey(conn, certificate)
	*   The second parameter is an forge.pki X.509 certificate object that
	*   is associated with the requested private key. The return value must
	*   be a PEM-formatted private key.
	* getSignature(conn, bytes, callback)
	*   This callback can be used instead of getPrivateKey if the private key
	*   is not directly accessible in javascript or should not be. For
	*   instance, a secure external web service could provide the signature
	*   in exchange for appropriate credentials. The second parameter is a
	*   string of bytes to be signed that are part of the TLS protocol. These
	*   bytes are used to verify that the private key for the previously
	*   provided client-side certificate is accessible to the client. The
	*   callback is a function that takes 2 parameters, the TLS connection
	*   and the RSA encrypted (signed) bytes as a string. This callback must
	*   be called once the signature is ready.
	*
	* @param options the options for this connection:
	*   server: true if the connection is server-side, false for client.
	*   sessionId: a session ID to reuse, null for a new connection.
	*   caStore: an array of certificates to trust.
	*   sessionCache: a session cache to use.
	*   cipherSuites: an optional array of cipher suites to use,
	*     see tls.CipherSuites.
	*   connected: function(conn) called when the first handshake completes.
	*   virtualHost: the virtual server name to use in a TLS SNI extension.
	*   verifyClient: true to require a client certificate in server mode,
	*     'optional' to request one, false not to (default: false).
	*   verify: a handler used to custom verify certificates in the chain.
	*   verifyOptions: an object with options for the certificate chain validation.
	*     See documentation of pki.verifyCertificateChain for possible options.
	*     verifyOptions.verify is ignored. If you wish to specify a verify handler
	*     use the verify key.
	*   getCertificate: an optional callback used to get a certificate or
	*     a chain of certificates (as an array).
	*   getPrivateKey: an optional callback used to get a private key.
	*   getSignature: an optional callback used to get a signature.
	*   tlsDataReady: function(conn) called when TLS protocol data has been
	*     prepared and is ready to be used (typically sent over a socket
	*     connection to its destination), read from conn.tlsData buffer.
	*   dataReady: function(conn) called when application data has
	*     been parsed from a TLS record and should be consumed by the
	*     application, read from conn.data buffer.
	*   closed: function(conn) called when the connection has been closed.
	*   error: function(conn, error) called when there was an error.
	*   deflate: function(inBytes) if provided, will deflate TLS records using
	*     the deflate algorithm if the server supports it.
	*   inflate: function(inBytes) if provided, will inflate TLS records using
	*     the deflate algorithm if the server supports it.
	*
	* @return the new TLS connection.
	*/
	forge.tls.createConnection = tls.createConnection;
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* A Javascript implementation of AES Cipher Suites for TLS.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2009-2015 Digital Bazaar, Inc.
	*
	*/
	var forge = require_forge();
	require_aes();
	require_tls();
	var tls = module.exports = forge.tls;
	/**
	* Supported cipher suites.
	*/
	tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
		id: [0, 47],
		name: "TLS_RSA_WITH_AES_128_CBC_SHA",
		initSecurityParameters: function(sp) {
			sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
			sp.cipher_type = tls.CipherType.block;
			sp.enc_key_length = 16;
			sp.block_length = 16;
			sp.fixed_iv_length = 16;
			sp.record_iv_length = 16;
			sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
			sp.mac_length = 20;
			sp.mac_key_length = 20;
		},
		initConnectionState
	};
	tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
		id: [0, 53],
		name: "TLS_RSA_WITH_AES_256_CBC_SHA",
		initSecurityParameters: function(sp) {
			sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
			sp.cipher_type = tls.CipherType.block;
			sp.enc_key_length = 32;
			sp.block_length = 16;
			sp.fixed_iv_length = 16;
			sp.record_iv_length = 16;
			sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
			sp.mac_length = 20;
			sp.mac_key_length = 20;
		},
		initConnectionState
	};
	function initConnectionState(state, c, sp) {
		var client = c.entity === forge.tls.ConnectionEnd.client;
		state.read.cipherState = {
			init: false,
			cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
			iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
		};
		state.write.cipherState = {
			init: false,
			cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
			iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
		};
		state.read.cipherFunction = decrypt_aes_cbc_sha1;
		state.write.cipherFunction = encrypt_aes_cbc_sha1;
		state.read.macLength = state.write.macLength = sp.mac_length;
		state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
	}
	/**
	* Encrypts the TLSCompressed record into a TLSCipherText record using AES
	* in CBC mode.
	*
	* @param record the TLSCompressed record to encrypt.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	function encrypt_aes_cbc_sha1(record$1, s) {
		var rval = false;
		var mac$2 = s.macFunction(s.macKey, s.sequenceNumber, record$1);
		record$1.fragment.putBytes(mac$2);
		s.updateSequenceNumber();
		var iv;
		if (record$1.version.minor === tls.Versions.TLS_1_0.minor) iv = s.cipherState.init ? null : s.cipherState.iv;
		else iv = forge.random.getBytesSync(16);
		s.cipherState.init = true;
		var cipher = s.cipherState.cipher;
		cipher.start({ iv });
		if (record$1.version.minor >= tls.Versions.TLS_1_1.minor) cipher.output.putBytes(iv);
		cipher.update(record$1.fragment);
		if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
			record$1.fragment = cipher.output;
			record$1.length = record$1.fragment.length();
			rval = true;
		}
		return rval;
	}
	/**
	* Handles padding for aes_cbc_sha1 in encrypt mode.
	*
	* @param blockSize the block size.
	* @param input the input buffer.
	* @param decrypt true in decrypt mode, false in encrypt mode.
	*
	* @return true on success, false on failure.
	*/
	function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
		if (!decrypt) {
			var padding = blockSize - input.length() % blockSize;
			input.fillWithByte(padding - 1, padding);
		}
		return true;
	}
	/**
	* Handles padding for aes_cbc_sha1 in decrypt mode.
	*
	* @param blockSize the block size.
	* @param output the output buffer.
	* @param decrypt true in decrypt mode, false in encrypt mode.
	*
	* @return true on success, false on failure.
	*/
	function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
		var rval = true;
		if (decrypt) {
			var len = output.length();
			var paddingLength = output.last();
			for (var i = len - 1 - paddingLength; i < len - 1; ++i) rval = rval && output.at(i) == paddingLength;
			if (rval) output.truncate(paddingLength + 1);
		}
		return rval;
	}
	/**
	* Decrypts a TLSCipherText record into a TLSCompressed record using
	* AES in CBC mode.
	*
	* @param record the TLSCipherText record to decrypt.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	function decrypt_aes_cbc_sha1(record$1, s) {
		var rval = false;
		var iv;
		if (record$1.version.minor === tls.Versions.TLS_1_0.minor) iv = s.cipherState.init ? null : s.cipherState.iv;
		else iv = record$1.fragment.getBytes(16);
		s.cipherState.init = true;
		var cipher = s.cipherState.cipher;
		cipher.start({ iv });
		cipher.update(record$1.fragment);
		rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
		var macLen = s.macLength;
		var mac$2 = forge.random.getBytesSync(macLen);
		var len = cipher.output.length();
		if (len >= macLen) {
			record$1.fragment = cipher.output.getBytes(len - macLen);
			mac$2 = cipher.output.getBytes(macLen);
		} else record$1.fragment = cipher.output.getBytes();
		record$1.fragment = forge.util.createBuffer(record$1.fragment);
		record$1.length = record$1.fragment.length();
		var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record$1);
		s.updateSequenceNumber();
		rval = compareMacs(s.macKey, mac$2, mac2) && rval;
		return rval;
	}
	/**
	* Safely compare two MACs. This function will compare two MACs in a way
	* that protects against timing attacks.
	*
	* TODO: Expose elsewhere as a utility API.
	*
	* See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/
	*
	* @param key the MAC key to use.
	* @param mac1 as a binary-encoded string of bytes.
	* @param mac2 as a binary-encoded string of bytes.
	*
	* @return true if the MACs are the same, false if not.
	*/
	function compareMacs(key, mac1, mac2) {
		var hmac = forge.hmac.create();
		hmac.start("SHA1", key);
		hmac.update(mac1);
		mac1 = hmac.digest().getBytes();
		hmac.start(null, null);
		hmac.update(mac2);
		mac2 = hmac.digest().getBytes();
		return mac1 === mac2;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/sha512.js
var require_sha512 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Secure Hash Algorithm with a 1024-bit block size implementation.
	*
	* This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For
	* SHA-256 (block size 512 bits), see sha256.js.
	*
	* See FIPS 180-4 for details.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2014-2015 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
	forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
	var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
	sha384.create = function() {
		return sha512.create("SHA-384");
	};
	forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
	forge.sha512.sha256 = forge.sha512.sha256 || { create: function() {
		return sha512.create("SHA-512/256");
	} };
	forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
	forge.sha512.sha224 = forge.sha512.sha224 || { create: function() {
		return sha512.create("SHA-512/224");
	} };
	forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
	/**
	* Creates a SHA-2 message digest object.
	*
	* @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,
	*          SHA-512/256).
	*
	* @return a message digest object.
	*/
	sha512.create = function(algorithm) {
		if (!_initialized) _init();
		if (typeof algorithm === "undefined") algorithm = "SHA-512";
		if (!(algorithm in _states)) throw new Error("Invalid SHA-512 algorithm: " + algorithm);
		var _state = _states[algorithm];
		var _h = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(80);
		for (var wi = 0; wi < 80; ++wi) _w[wi] = new Array(2);
		var digestLength = 64;
		switch (algorithm) {
			case "SHA-384":
				digestLength = 48;
				break;
			case "SHA-512/256":
				digestLength = 32;
				break;
			case "SHA-512/224":
				digestLength = 28;
				break;
		}
		var md = {
			algorithm: algorithm.replace("-", "").toLowerCase(),
			blockLength: 128,
			digestLength,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 16
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength128 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_h = new Array(_state.length);
			for (var i = 0; i < _state.length; ++i) _h[i] = _state[i].slice(0);
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_h, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var next, carry;
			var bits = md.fullMessageLength[0] * 8;
			for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
				next = md.fullMessageLength[i + 1] * 8;
				carry = next / 4294967296 >>> 0;
				bits += carry;
				finalBlock.putInt32(bits >>> 0);
				bits = next >>> 0;
			}
			finalBlock.putInt32(bits);
			var h = new Array(_h.length);
			for (var i = 0; i < _h.length; ++i) h[i] = _h[i].slice(0);
			_update(h, _w, finalBlock);
			var rval = forge.util.createBuffer();
			var hlen;
			if (algorithm === "SHA-512") hlen = h.length;
			else if (algorithm === "SHA-384") hlen = h.length - 2;
			else hlen = h.length - 4;
			for (var i = 0; i < hlen; ++i) {
				rval.putInt32(h[i][0]);
				if (i !== hlen - 1 || algorithm !== "SHA-512/224") rval.putInt32(h[i][1]);
			}
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _initialized = false;
	var _k = null;
	var _states = null;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 128);
		_k = [
			[1116352408, 3609767458],
			[1899447441, 602891725],
			[3049323471, 3964484399],
			[3921009573, 2173295548],
			[961987163, 4081628472],
			[1508970993, 3053834265],
			[2453635748, 2937671579],
			[2870763221, 3664609560],
			[3624381080, 2734883394],
			[310598401, 1164996542],
			[607225278, 1323610764],
			[1426881987, 3590304994],
			[1925078388, 4068182383],
			[2162078206, 991336113],
			[2614888103, 633803317],
			[3248222580, 3479774868],
			[3835390401, 2666613458],
			[4022224774, 944711139],
			[264347078, 2341262773],
			[604807628, 2007800933],
			[770255983, 1495990901],
			[1249150122, 1856431235],
			[1555081692, 3175218132],
			[1996064986, 2198950837],
			[2554220882, 3999719339],
			[2821834349, 766784016],
			[2952996808, 2566594879],
			[3210313671, 3203337956],
			[3336571891, 1034457026],
			[3584528711, 2466948901],
			[113926993, 3758326383],
			[338241895, 168717936],
			[666307205, 1188179964],
			[773529912, 1546045734],
			[1294757372, 1522805485],
			[1396182291, 2643833823],
			[1695183700, 2343527390],
			[1986661051, 1014477480],
			[2177026350, 1206759142],
			[2456956037, 344077627],
			[2730485921, 1290863460],
			[2820302411, 3158454273],
			[3259730800, 3505952657],
			[3345764771, 106217008],
			[3516065817, 3606008344],
			[3600352804, 1432725776],
			[4094571909, 1467031594],
			[275423344, 851169720],
			[430227734, 3100823752],
			[506948616, 1363258195],
			[659060556, 3750685593],
			[883997877, 3785050280],
			[958139571, 3318307427],
			[1322822218, 3812723403],
			[1537002063, 2003034995],
			[1747873779, 3602036899],
			[1955562222, 1575990012],
			[2024104815, 1125592928],
			[2227730452, 2716904306],
			[2361852424, 442776044],
			[2428436474, 593698344],
			[2756734187, 3733110249],
			[3204031479, 2999351573],
			[3329325298, 3815920427],
			[3391569614, 3928383900],
			[3515267271, 566280711],
			[3940187606, 3454069534],
			[4118630271, 4000239992],
			[116418474, 1914138554],
			[174292421, 2731055270],
			[289380356, 3203993006],
			[460393269, 320620315],
			[685471733, 587496836],
			[852142971, 1086792851],
			[1017036298, 365543100],
			[1126000580, 2618297676],
			[1288033470, 3409855158],
			[1501505948, 4234509866],
			[1607167915, 987167468],
			[1816402316, 1246189591]
		];
		_states = {};
		_states["SHA-512"] = [
			[1779033703, 4089235720],
			[3144134277, 2227873595],
			[1013904242, 4271175723],
			[2773480762, 1595750129],
			[1359893119, 2917565137],
			[2600822924, 725511199],
			[528734635, 4215389547],
			[1541459225, 327033209]
		];
		_states["SHA-384"] = [
			[3418070365, 3238371032],
			[1654270250, 914150663],
			[2438529370, 812702999],
			[355462360, 4144912697],
			[1731405415, 4290775857],
			[2394180231, 1750603025],
			[3675008525, 1694076839],
			[1203062813, 3204075428]
		];
		_states["SHA-512/256"] = [
			[573645204, 4230739756],
			[2673172387, 3360449730],
			[596883563, 1867755857],
			[2520282905, 1497426621],
			[2519219938, 2827943907],
			[3193839141, 1401305490],
			[721525244, 746961066],
			[246885852, 2177182882]
		];
		_states["SHA-512/224"] = [
			[2352822216, 424955298],
			[1944164710, 2312950998],
			[502970286, 855612546],
			[1738396948, 1479516111],
			[258812777, 2077511080],
			[2011393907, 79989058],
			[1067287976, 1780299464],
			[286451373, 2446758561]
		];
		_initialized = true;
	}
	/**
	* Updates a SHA-512 state with the given byte buffer.
	*
	* @param s the SHA-512 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t1_hi, t1_lo;
		var t2_hi, t2_lo;
		var s0_hi, s0_lo;
		var s1_hi, s1_lo;
		var ch_hi, ch_lo;
		var maj_hi, maj_lo;
		var a_hi, a_lo;
		var b_hi, b_lo;
		var c_hi, c_lo;
		var d_hi, d_lo;
		var e_hi, e_lo;
		var f_hi, f_lo;
		var g_hi, g_lo;
		var h_hi, h_lo;
		var i, hi, lo, w2, w7, w15, w16;
		var len = bytes.length();
		while (len >= 128) {
			for (i = 0; i < 16; ++i) {
				w[i][0] = bytes.getInt32() >>> 0;
				w[i][1] = bytes.getInt32() >>> 0;
			}
			for (; i < 80; ++i) {
				w2 = w[i - 2];
				hi = w2[0];
				lo = w2[1];
				t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
				t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
				w15 = w[i - 15];
				hi = w15[0];
				lo = w15[1];
				t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
				t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
				w7 = w[i - 7];
				w16 = w[i - 16];
				lo = t1_lo + w7[1] + t2_lo + w16[1];
				w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
				w[i][1] = lo >>> 0;
			}
			a_hi = s[0][0];
			a_lo = s[0][1];
			b_hi = s[1][0];
			b_lo = s[1][1];
			c_hi = s[2][0];
			c_lo = s[2][1];
			d_hi = s[3][0];
			d_lo = s[3][1];
			e_hi = s[4][0];
			e_lo = s[4][1];
			f_hi = s[5][0];
			f_lo = s[5][1];
			g_hi = s[6][0];
			g_lo = s[6][1];
			h_hi = s[7][0];
			h_lo = s[7][1];
			for (i = 0; i < 80; ++i) {
				s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
				s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
				ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
				ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
				s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
				s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
				maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
				maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
				lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
				t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
				t1_lo = lo >>> 0;
				lo = s0_lo + maj_lo;
				t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
				t2_lo = lo >>> 0;
				h_hi = g_hi;
				h_lo = g_lo;
				g_hi = f_hi;
				g_lo = f_lo;
				f_hi = e_hi;
				f_lo = e_lo;
				lo = d_lo + t1_lo;
				e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
				e_lo = lo >>> 0;
				d_hi = c_hi;
				d_lo = c_lo;
				c_hi = b_hi;
				c_lo = b_lo;
				b_hi = a_hi;
				b_lo = a_lo;
				lo = t1_lo + t2_lo;
				a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
				a_lo = lo >>> 0;
			}
			lo = s[0][1] + a_lo;
			s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[0][1] = lo >>> 0;
			lo = s[1][1] + b_lo;
			s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[1][1] = lo >>> 0;
			lo = s[2][1] + c_lo;
			s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[2][1] = lo >>> 0;
			lo = s[3][1] + d_lo;
			s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[3][1] = lo >>> 0;
			lo = s[4][1] + e_lo;
			s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[4][1] = lo >>> 0;
			lo = s[5][1] + f_lo;
			s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[5][1] = lo >>> 0;
			lo = s[6][1] + g_lo;
			s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[6][1] = lo >>> 0;
			lo = s[7][1] + h_lo;
			s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[7][1] = lo >>> 0;
			len -= 128;
		}
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Copyright (c) 2019 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_asn1();
	var asn1 = forge.asn1;
	exports.privateKeyValidator = {
		name: "PrivateKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "PrivateKeyInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyVersion"
			},
			{
				name: "PrivateKeyInfo.privateKeyAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "AlgorithmIdentifier.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "privateKeyOid"
				}]
			},
			{
				name: "PrivateKeyInfo",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "privateKey"
			}
		]
	};
	exports.publicKeyValidator = {
		name: "SubjectPublicKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "subjectPublicKeyInfo",
		value: [{
			name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "AlgorithmIdentifier.algorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "publicKeyOid"
			}]
		}, {
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.BITSTRING,
			constructed: false,
			composed: true,
			captureBitStringValue: "ed25519PublicKey"
		}]
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/ed25519.js
var require_ed25519 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* JavaScript implementation of Ed25519.
	*
	* Copyright (c) 2017-2019 Digital Bazaar, Inc.
	*
	* This implementation is based on the most excellent TweetNaCl which is
	* in the public domain. Many thanks to its contributors:
	*
	* https://github.com/dchest/tweetnacl-js
	*/
	var forge = require_forge();
	require_jsbn$1();
	require_random();
	require_sha512();
	require_util();
	var asn1Validator = require_asn1_validator();
	var publicKeyValidator = asn1Validator.publicKeyValidator;
	var privateKeyValidator = asn1Validator.privateKeyValidator;
	if (typeof BigInteger === "undefined") var BigInteger = forge.jsbn.BigInteger;
	var ByteBuffer = forge.util.ByteBuffer;
	var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
	forge.pki = forge.pki || {};
	module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
	var ed25519 = forge.ed25519;
	ed25519.constants = {};
	ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
	ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
	ed25519.constants.SEED_BYTE_LENGTH = 32;
	ed25519.constants.SIGN_BYTE_LENGTH = 64;
	ed25519.constants.HASH_BYTE_LENGTH = 64;
	ed25519.generateKeyPair = function(options) {
		options = options || {};
		var seed = options.seed;
		if (seed === void 0) seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
		else if (typeof seed === "string") {
			if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) throw new TypeError("\"seed\" must be " + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
		} else if (!(seed instanceof Uint8Array)) throw new TypeError("\"seed\" must be a node.js Buffer, Uint8Array, or a binary string.");
		seed = messageToNativeBuffer({
			message: seed,
			encoding: "binary"
		});
		var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
		var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
		for (var i = 0; i < 32; ++i) sk[i] = seed[i];
		crypto_sign_keypair(pk, sk);
		return {
			publicKey: pk,
			privateKey: sk
		};
	};
	/**
	* Converts a private key from a RFC8410 ASN.1 encoding.
	*
	* @param obj - The asn1 representation of a private key.
	*
	* @returns {Object} keyInfo - The key information.
	* @returns {Buffer|Uint8Array} keyInfo.privateKeyBytes - 32 private key bytes.
	*/
	ed25519.privateKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (!forge.asn1.validate(obj, privateKeyValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Invalid Key.");
			error$47.errors = errors;
			throw error$47;
		}
		var oid = forge.asn1.derToOid(capture.privateKeyOid);
		var ed25519Oid = forge.oids.EdDSA25519;
		if (oid !== ed25519Oid) throw new Error("Invalid OID \"" + oid + "\"; OID must be \"" + ed25519Oid + "\".");
		var privateKey = capture.privateKey;
		return { privateKeyBytes: messageToNativeBuffer({
			message: forge.asn1.fromDer(privateKey).value,
			encoding: "binary"
		}) };
	};
	/**
	* Converts a public key from a RFC8410 ASN.1 encoding.
	*
	* @param obj - The asn1 representation of a public key.
	*
	* @return {Buffer|Uint8Array} - 32 public key bytes.
	*/
	ed25519.publicKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (!forge.asn1.validate(obj, publicKeyValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Invalid Key.");
			error$47.errors = errors;
			throw error$47;
		}
		var oid = forge.asn1.derToOid(capture.publicKeyOid);
		var ed25519Oid = forge.oids.EdDSA25519;
		if (oid !== ed25519Oid) throw new Error("Invalid OID \"" + oid + "\"; OID must be \"" + ed25519Oid + "\".");
		var publicKeyBytes = capture.ed25519PublicKey;
		if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
		return messageToNativeBuffer({
			message: publicKeyBytes,
			encoding: "binary"
		});
	};
	ed25519.publicKeyFromPrivateKey = function(options) {
		options = options || {};
		var privateKey = messageToNativeBuffer({
			message: options.privateKey,
			encoding: "binary"
		});
		if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError("\"options.privateKey\" must have a byte length of " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
		var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
		for (var i = 0; i < pk.length; ++i) pk[i] = privateKey[32 + i];
		return pk;
	};
	ed25519.sign = function(options) {
		options = options || {};
		var msg = messageToNativeBuffer(options);
		var privateKey = messageToNativeBuffer({
			message: options.privateKey,
			encoding: "binary"
		});
		if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) privateKey = ed25519.generateKeyPair({ seed: privateKey }).privateKey;
		else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError("\"options.privateKey\" must have a byte length of " + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
		var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
		crypto_sign(signedMsg, msg, msg.length, privateKey);
		var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
		for (var i = 0; i < sig.length; ++i) sig[i] = signedMsg[i];
		return sig;
	};
	ed25519.verify = function(options) {
		options = options || {};
		var msg = messageToNativeBuffer(options);
		if (options.signature === void 0) throw new TypeError("\"options.signature\" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.");
		var sig = messageToNativeBuffer({
			message: options.signature,
			encoding: "binary"
		});
		if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) throw new TypeError("\"options.signature\" must have a byte length of " + ed25519.constants.SIGN_BYTE_LENGTH);
		var publicKey = messageToNativeBuffer({
			message: options.publicKey,
			encoding: "binary"
		});
		if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError("\"options.publicKey\" must have a byte length of " + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
		var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
		var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
		var i;
		for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) sm[i] = sig[i];
		for (i = 0; i < msg.length; ++i) sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
		return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
	};
	function messageToNativeBuffer(options) {
		var message = options.message;
		if (message instanceof Uint8Array || message instanceof NativeBuffer) return message;
		var encoding = options.encoding;
		if (message === void 0) if (options.md) {
			message = options.md.digest().getBytes();
			encoding = "binary";
		} else throw new TypeError("\"options.message\" or \"options.md\" not specified.");
		if (typeof message === "string" && !encoding) throw new TypeError("\"options.encoding\" must be \"binary\" or \"utf8\".");
		if (typeof message === "string") {
			if (typeof Buffer !== "undefined") return Buffer.from(message, encoding);
			message = new ByteBuffer(message, encoding);
		} else if (!(message instanceof ByteBuffer)) throw new TypeError("\"options.message\" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with \"options.encoding\" specifying its encoding.");
		var buffer$1 = new NativeBuffer(message.length());
		for (var i = 0; i < buffer$1.length; ++i) buffer$1[i] = message.at(i);
		return buffer$1;
	}
	var gf0 = gf();
	var gf1 = gf([1]);
	var D = gf([
		30883,
		4953,
		19914,
		30187,
		55467,
		16705,
		2637,
		112,
		59544,
		30585,
		16505,
		36039,
		65139,
		11119,
		27886,
		20995
	]);
	var D2 = gf([
		61785,
		9906,
		39828,
		60374,
		45398,
		33411,
		5274,
		224,
		53552,
		61171,
		33010,
		6542,
		64743,
		22239,
		55772,
		9222
	]);
	var X = gf([
		54554,
		36645,
		11616,
		51542,
		42930,
		38181,
		51040,
		26924,
		56412,
		64982,
		57905,
		49316,
		21502,
		52590,
		14035,
		8553
	]);
	var Y = gf([
		26200,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214
	]);
	var L = new Float64Array([
		237,
		211,
		245,
		92,
		26,
		99,
		18,
		88,
		214,
		156,
		247,
		162,
		222,
		249,
		222,
		20,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		16
	]);
	var I = gf([
		41136,
		18958,
		6951,
		50414,
		58488,
		44335,
		6150,
		12099,
		55207,
		15867,
		153,
		11085,
		57099,
		20417,
		9344,
		11139
	]);
	function sha512(msg, msgLen) {
		var md = forge.md.sha512.create();
		var buffer$1 = new ByteBuffer(msg);
		md.update(buffer$1.getBytes(msgLen), "binary");
		var hash$1 = md.digest().getBytes();
		if (typeof Buffer !== "undefined") return Buffer.from(hash$1, "binary");
		var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
		for (var i = 0; i < 64; ++i) out[i] = hash$1.charCodeAt(i);
		return out;
	}
	function crypto_sign_keypair(pk, sk) {
		var p = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		var i;
		var d = sha512(sk, 32);
		d[0] &= 248;
		d[31] &= 127;
		d[31] |= 64;
		scalarbase(p, d);
		pack(pk, p);
		for (i = 0; i < 32; ++i) sk[i + 32] = pk[i];
		return 0;
	}
	function crypto_sign(sm, m, n, sk) {
		var i, j, x = new Float64Array(64);
		var p = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		var d = sha512(sk, 32);
		d[0] &= 248;
		d[31] &= 127;
		d[31] |= 64;
		var smlen = n + 64;
		for (i = 0; i < n; ++i) sm[64 + i] = m[i];
		for (i = 0; i < 32; ++i) sm[32 + i] = d[32 + i];
		var r = sha512(sm.subarray(32), n + 32);
		reduce(r);
		scalarbase(p, r);
		pack(sm, p);
		for (i = 32; i < 64; ++i) sm[i] = sk[i];
		var h = sha512(sm, n + 64);
		reduce(h);
		for (i = 32; i < 64; ++i) x[i] = 0;
		for (i = 0; i < 32; ++i) x[i] = r[i];
		for (i = 0; i < 32; ++i) for (j = 0; j < 32; j++) x[i + j] += h[i] * d[j];
		modL(sm.subarray(32), x);
		return smlen;
	}
	function crypto_sign_open(m, sm, n, pk) {
		var i, mlen;
		var t = new NativeBuffer(32);
		var p = [
			gf(),
			gf(),
			gf(),
			gf()
		], q = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		mlen = -1;
		if (n < 64) return -1;
		if (unpackneg(q, pk)) return -1;
		for (i = 0; i < n; ++i) m[i] = sm[i];
		for (i = 0; i < 32; ++i) m[i + 32] = pk[i];
		var h = sha512(m, n);
		reduce(h);
		scalarmult(p, q, h);
		scalarbase(q, sm.subarray(32));
		add(p, q);
		pack(t, p);
		n -= 64;
		if (crypto_verify_32(sm, 0, t, 0)) {
			for (i = 0; i < n; ++i) m[i] = 0;
			return -1;
		}
		for (i = 0; i < n; ++i) m[i] = sm[i + 64];
		mlen = n;
		return mlen;
	}
	function modL(r, x) {
		var carry, i, j, k;
		for (i = 63; i >= 32; --i) {
			carry = 0;
			for (j = i - 32, k = i - 12; j < k; ++j) {
				x[j] += carry - 16 * x[i] * L[j - (i - 32)];
				carry = x[j] + 128 >> 8;
				x[j] -= carry * 256;
			}
			x[j] += carry;
			x[i] = 0;
		}
		carry = 0;
		for (j = 0; j < 32; ++j) {
			x[j] += carry - (x[31] >> 4) * L[j];
			carry = x[j] >> 8;
			x[j] &= 255;
		}
		for (j = 0; j < 32; ++j) x[j] -= carry * L[j];
		for (i = 0; i < 32; ++i) {
			x[i + 1] += x[i] >> 8;
			r[i] = x[i] & 255;
		}
	}
	function reduce(r) {
		var x = new Float64Array(64);
		for (var i = 0; i < 64; ++i) {
			x[i] = r[i];
			r[i] = 0;
		}
		modL(r, x);
	}
	function add(p, q) {
		var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
		Z(a, p[1], p[0]);
		Z(t, q[1], q[0]);
		M(a, a, t);
		A(b, p[0], p[1]);
		A(t, q[0], q[1]);
		M(b, b, t);
		M(c, p[3], q[3]);
		M(c, c, D2);
		M(d, p[2], q[2]);
		A(d, d, d);
		Z(e, b, a);
		Z(f, d, c);
		A(g, d, c);
		A(h, b, a);
		M(p[0], e, f);
		M(p[1], h, g);
		M(p[2], g, f);
		M(p[3], e, h);
	}
	function cswap(p, q, b) {
		for (var i = 0; i < 4; ++i) sel25519(p[i], q[i], b);
	}
	function pack(r, p) {
		var tx = gf(), ty = gf(), zi = gf();
		inv25519(zi, p[2]);
		M(tx, p[0], zi);
		M(ty, p[1], zi);
		pack25519(r, ty);
		r[31] ^= par25519(tx) << 7;
	}
	function pack25519(o, n) {
		var i, j, b;
		var m = gf(), t = gf();
		for (i = 0; i < 16; ++i) t[i] = n[i];
		car25519(t);
		car25519(t);
		car25519(t);
		for (j = 0; j < 2; ++j) {
			m[0] = t[0] - 65517;
			for (i = 1; i < 15; ++i) {
				m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
				m[i - 1] &= 65535;
			}
			m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
			b = m[15] >> 16 & 1;
			m[14] &= 65535;
			sel25519(t, m, 1 - b);
		}
		for (i = 0; i < 16; i++) {
			o[2 * i] = t[i] & 255;
			o[2 * i + 1] = t[i] >> 8;
		}
	}
	function unpackneg(r, p) {
		var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
		set25519(r[2], gf1);
		unpack25519(r[1], p);
		S(num, r[1]);
		M(den, num, D);
		Z(num, num, r[2]);
		A(den, r[2], den);
		S(den2, den);
		S(den4, den2);
		M(den6, den4, den2);
		M(t, den6, num);
		M(t, t, den);
		pow2523(t, t);
		M(t, t, num);
		M(t, t, den);
		M(t, t, den);
		M(r[0], t, den);
		S(chk, r[0]);
		M(chk, chk, den);
		if (neq25519(chk, num)) M(r[0], r[0], I);
		S(chk, r[0]);
		M(chk, chk, den);
		if (neq25519(chk, num)) return -1;
		if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
		M(r[3], r[0], r[1]);
		return 0;
	}
	function unpack25519(o, n) {
		var i;
		for (i = 0; i < 16; ++i) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
		o[15] &= 32767;
	}
	function pow2523(o, i) {
		var c = gf();
		var a;
		for (a = 0; a < 16; ++a) c[a] = i[a];
		for (a = 250; a >= 0; --a) {
			S(c, c);
			if (a !== 1) M(c, c, i);
		}
		for (a = 0; a < 16; ++a) o[a] = c[a];
	}
	function neq25519(a, b) {
		var c = new NativeBuffer(32);
		var d = new NativeBuffer(32);
		pack25519(c, a);
		pack25519(d, b);
		return crypto_verify_32(c, 0, d, 0);
	}
	function crypto_verify_32(x, xi, y, yi) {
		return vn(x, xi, y, yi, 32);
	}
	function vn(x, xi, y, yi, n) {
		var i, d = 0;
		for (i = 0; i < n; ++i) d |= x[xi + i] ^ y[yi + i];
		return (1 & d - 1 >>> 8) - 1;
	}
	function par25519(a) {
		var d = new NativeBuffer(32);
		pack25519(d, a);
		return d[0] & 1;
	}
	function scalarmult(p, q, s) {
		var b, i;
		set25519(p[0], gf0);
		set25519(p[1], gf1);
		set25519(p[2], gf1);
		set25519(p[3], gf0);
		for (i = 255; i >= 0; --i) {
			b = s[i / 8 | 0] >> (i & 7) & 1;
			cswap(p, q, b);
			add(q, p);
			add(p, p);
			cswap(p, q, b);
		}
	}
	function scalarbase(p, s) {
		var q = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		set25519(q[0], X);
		set25519(q[1], Y);
		set25519(q[2], gf1);
		M(q[3], X, Y);
		scalarmult(p, q, s);
	}
	function set25519(r, a) {
		var i;
		for (i = 0; i < 16; i++) r[i] = a[i] | 0;
	}
	function inv25519(o, i) {
		var c = gf();
		var a;
		for (a = 0; a < 16; ++a) c[a] = i[a];
		for (a = 253; a >= 0; --a) {
			S(c, c);
			if (a !== 2 && a !== 4) M(c, c, i);
		}
		for (a = 0; a < 16; ++a) o[a] = c[a];
	}
	function car25519(o) {
		var i, v, c = 1;
		for (i = 0; i < 16; ++i) {
			v = o[i] + c + 65535;
			c = Math.floor(v / 65536);
			o[i] = v - c * 65536;
		}
		o[0] += c - 1 + 37 * (c - 1);
	}
	function sel25519(p, q, b) {
		var t, c = ~(b - 1);
		for (var i = 0; i < 16; ++i) {
			t = c & (p[i] ^ q[i]);
			p[i] ^= t;
			q[i] ^= t;
		}
	}
	function gf(init) {
		var i, r = new Float64Array(16);
		if (init) for (i = 0; i < init.length; ++i) r[i] = init[i];
		return r;
	}
	function A(o, a, b) {
		for (var i = 0; i < 16; ++i) o[i] = a[i] + b[i];
	}
	function Z(o, a, b) {
		for (var i = 0; i < 16; ++i) o[i] = a[i] - b[i];
	}
	function S(o, a) {
		M(o, a, a);
	}
	function M(o, a, b) {
		var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
		v = a[0];
		t0 += v * b0;
		t1 += v * b1;
		t2 += v * b2;
		t3 += v * b3;
		t4 += v * b4;
		t5 += v * b5;
		t6 += v * b6;
		t7 += v * b7;
		t8 += v * b8;
		t9 += v * b9;
		t10 += v * b10;
		t11 += v * b11;
		t12 += v * b12;
		t13 += v * b13;
		t14 += v * b14;
		t15 += v * b15;
		v = a[1];
		t1 += v * b0;
		t2 += v * b1;
		t3 += v * b2;
		t4 += v * b3;
		t5 += v * b4;
		t6 += v * b5;
		t7 += v * b6;
		t8 += v * b7;
		t9 += v * b8;
		t10 += v * b9;
		t11 += v * b10;
		t12 += v * b11;
		t13 += v * b12;
		t14 += v * b13;
		t15 += v * b14;
		t16 += v * b15;
		v = a[2];
		t2 += v * b0;
		t3 += v * b1;
		t4 += v * b2;
		t5 += v * b3;
		t6 += v * b4;
		t7 += v * b5;
		t8 += v * b6;
		t9 += v * b7;
		t10 += v * b8;
		t11 += v * b9;
		t12 += v * b10;
		t13 += v * b11;
		t14 += v * b12;
		t15 += v * b13;
		t16 += v * b14;
		t17 += v * b15;
		v = a[3];
		t3 += v * b0;
		t4 += v * b1;
		t5 += v * b2;
		t6 += v * b3;
		t7 += v * b4;
		t8 += v * b5;
		t9 += v * b6;
		t10 += v * b7;
		t11 += v * b8;
		t12 += v * b9;
		t13 += v * b10;
		t14 += v * b11;
		t15 += v * b12;
		t16 += v * b13;
		t17 += v * b14;
		t18 += v * b15;
		v = a[4];
		t4 += v * b0;
		t5 += v * b1;
		t6 += v * b2;
		t7 += v * b3;
		t8 += v * b4;
		t9 += v * b5;
		t10 += v * b6;
		t11 += v * b7;
		t12 += v * b8;
		t13 += v * b9;
		t14 += v * b10;
		t15 += v * b11;
		t16 += v * b12;
		t17 += v * b13;
		t18 += v * b14;
		t19 += v * b15;
		v = a[5];
		t5 += v * b0;
		t6 += v * b1;
		t7 += v * b2;
		t8 += v * b3;
		t9 += v * b4;
		t10 += v * b5;
		t11 += v * b6;
		t12 += v * b7;
		t13 += v * b8;
		t14 += v * b9;
		t15 += v * b10;
		t16 += v * b11;
		t17 += v * b12;
		t18 += v * b13;
		t19 += v * b14;
		t20 += v * b15;
		v = a[6];
		t6 += v * b0;
		t7 += v * b1;
		t8 += v * b2;
		t9 += v * b3;
		t10 += v * b4;
		t11 += v * b5;
		t12 += v * b6;
		t13 += v * b7;
		t14 += v * b8;
		t15 += v * b9;
		t16 += v * b10;
		t17 += v * b11;
		t18 += v * b12;
		t19 += v * b13;
		t20 += v * b14;
		t21 += v * b15;
		v = a[7];
		t7 += v * b0;
		t8 += v * b1;
		t9 += v * b2;
		t10 += v * b3;
		t11 += v * b4;
		t12 += v * b5;
		t13 += v * b6;
		t14 += v * b7;
		t15 += v * b8;
		t16 += v * b9;
		t17 += v * b10;
		t18 += v * b11;
		t19 += v * b12;
		t20 += v * b13;
		t21 += v * b14;
		t22 += v * b15;
		v = a[8];
		t8 += v * b0;
		t9 += v * b1;
		t10 += v * b2;
		t11 += v * b3;
		t12 += v * b4;
		t13 += v * b5;
		t14 += v * b6;
		t15 += v * b7;
		t16 += v * b8;
		t17 += v * b9;
		t18 += v * b10;
		t19 += v * b11;
		t20 += v * b12;
		t21 += v * b13;
		t22 += v * b14;
		t23 += v * b15;
		v = a[9];
		t9 += v * b0;
		t10 += v * b1;
		t11 += v * b2;
		t12 += v * b3;
		t13 += v * b4;
		t14 += v * b5;
		t15 += v * b6;
		t16 += v * b7;
		t17 += v * b8;
		t18 += v * b9;
		t19 += v * b10;
		t20 += v * b11;
		t21 += v * b12;
		t22 += v * b13;
		t23 += v * b14;
		t24 += v * b15;
		v = a[10];
		t10 += v * b0;
		t11 += v * b1;
		t12 += v * b2;
		t13 += v * b3;
		t14 += v * b4;
		t15 += v * b5;
		t16 += v * b6;
		t17 += v * b7;
		t18 += v * b8;
		t19 += v * b9;
		t20 += v * b10;
		t21 += v * b11;
		t22 += v * b12;
		t23 += v * b13;
		t24 += v * b14;
		t25 += v * b15;
		v = a[11];
		t11 += v * b0;
		t12 += v * b1;
		t13 += v * b2;
		t14 += v * b3;
		t15 += v * b4;
		t16 += v * b5;
		t17 += v * b6;
		t18 += v * b7;
		t19 += v * b8;
		t20 += v * b9;
		t21 += v * b10;
		t22 += v * b11;
		t23 += v * b12;
		t24 += v * b13;
		t25 += v * b14;
		t26 += v * b15;
		v = a[12];
		t12 += v * b0;
		t13 += v * b1;
		t14 += v * b2;
		t15 += v * b3;
		t16 += v * b4;
		t17 += v * b5;
		t18 += v * b6;
		t19 += v * b7;
		t20 += v * b8;
		t21 += v * b9;
		t22 += v * b10;
		t23 += v * b11;
		t24 += v * b12;
		t25 += v * b13;
		t26 += v * b14;
		t27 += v * b15;
		v = a[13];
		t13 += v * b0;
		t14 += v * b1;
		t15 += v * b2;
		t16 += v * b3;
		t17 += v * b4;
		t18 += v * b5;
		t19 += v * b6;
		t20 += v * b7;
		t21 += v * b8;
		t22 += v * b9;
		t23 += v * b10;
		t24 += v * b11;
		t25 += v * b12;
		t26 += v * b13;
		t27 += v * b14;
		t28 += v * b15;
		v = a[14];
		t14 += v * b0;
		t15 += v * b1;
		t16 += v * b2;
		t17 += v * b3;
		t18 += v * b4;
		t19 += v * b5;
		t20 += v * b6;
		t21 += v * b7;
		t22 += v * b8;
		t23 += v * b9;
		t24 += v * b10;
		t25 += v * b11;
		t26 += v * b12;
		t27 += v * b13;
		t28 += v * b14;
		t29 += v * b15;
		v = a[15];
		t15 += v * b0;
		t16 += v * b1;
		t17 += v * b2;
		t18 += v * b3;
		t19 += v * b4;
		t20 += v * b5;
		t21 += v * b6;
		t22 += v * b7;
		t23 += v * b8;
		t24 += v * b9;
		t25 += v * b10;
		t26 += v * b11;
		t27 += v * b12;
		t28 += v * b13;
		t29 += v * b14;
		t30 += v * b15;
		t0 += 38 * t16;
		t1 += 38 * t17;
		t2 += 38 * t18;
		t3 += 38 * t19;
		t4 += 38 * t20;
		t5 += 38 * t21;
		t6 += 38 * t22;
		t7 += 38 * t23;
		t8 += 38 * t24;
		t9 += 38 * t25;
		t10 += 38 * t26;
		t11 += 38 * t27;
		t12 += 38 * t28;
		t13 += 38 * t29;
		t14 += 38 * t30;
		c = 1;
		v = t0 + c + 65535;
		c = Math.floor(v / 65536);
		t0 = v - c * 65536;
		v = t1 + c + 65535;
		c = Math.floor(v / 65536);
		t1 = v - c * 65536;
		v = t2 + c + 65535;
		c = Math.floor(v / 65536);
		t2 = v - c * 65536;
		v = t3 + c + 65535;
		c = Math.floor(v / 65536);
		t3 = v - c * 65536;
		v = t4 + c + 65535;
		c = Math.floor(v / 65536);
		t4 = v - c * 65536;
		v = t5 + c + 65535;
		c = Math.floor(v / 65536);
		t5 = v - c * 65536;
		v = t6 + c + 65535;
		c = Math.floor(v / 65536);
		t6 = v - c * 65536;
		v = t7 + c + 65535;
		c = Math.floor(v / 65536);
		t7 = v - c * 65536;
		v = t8 + c + 65535;
		c = Math.floor(v / 65536);
		t8 = v - c * 65536;
		v = t9 + c + 65535;
		c = Math.floor(v / 65536);
		t9 = v - c * 65536;
		v = t10 + c + 65535;
		c = Math.floor(v / 65536);
		t10 = v - c * 65536;
		v = t11 + c + 65535;
		c = Math.floor(v / 65536);
		t11 = v - c * 65536;
		v = t12 + c + 65535;
		c = Math.floor(v / 65536);
		t12 = v - c * 65536;
		v = t13 + c + 65535;
		c = Math.floor(v / 65536);
		t13 = v - c * 65536;
		v = t14 + c + 65535;
		c = Math.floor(v / 65536);
		t14 = v - c * 65536;
		v = t15 + c + 65535;
		c = Math.floor(v / 65536);
		t15 = v - c * 65536;
		t0 += c - 1 + 37 * (c - 1);
		c = 1;
		v = t0 + c + 65535;
		c = Math.floor(v / 65536);
		t0 = v - c * 65536;
		v = t1 + c + 65535;
		c = Math.floor(v / 65536);
		t1 = v - c * 65536;
		v = t2 + c + 65535;
		c = Math.floor(v / 65536);
		t2 = v - c * 65536;
		v = t3 + c + 65535;
		c = Math.floor(v / 65536);
		t3 = v - c * 65536;
		v = t4 + c + 65535;
		c = Math.floor(v / 65536);
		t4 = v - c * 65536;
		v = t5 + c + 65535;
		c = Math.floor(v / 65536);
		t5 = v - c * 65536;
		v = t6 + c + 65535;
		c = Math.floor(v / 65536);
		t6 = v - c * 65536;
		v = t7 + c + 65535;
		c = Math.floor(v / 65536);
		t7 = v - c * 65536;
		v = t8 + c + 65535;
		c = Math.floor(v / 65536);
		t8 = v - c * 65536;
		v = t9 + c + 65535;
		c = Math.floor(v / 65536);
		t9 = v - c * 65536;
		v = t10 + c + 65535;
		c = Math.floor(v / 65536);
		t10 = v - c * 65536;
		v = t11 + c + 65535;
		c = Math.floor(v / 65536);
		t11 = v - c * 65536;
		v = t12 + c + 65535;
		c = Math.floor(v / 65536);
		t12 = v - c * 65536;
		v = t13 + c + 65535;
		c = Math.floor(v / 65536);
		t13 = v - c * 65536;
		v = t14 + c + 65535;
		c = Math.floor(v / 65536);
		t14 = v - c * 65536;
		v = t15 + c + 65535;
		c = Math.floor(v / 65536);
		t15 = v - c * 65536;
		t0 += c - 1 + 37 * (c - 1);
		o[0] = t0;
		o[1] = t1;
		o[2] = t2;
		o[3] = t3;
		o[4] = t4;
		o[5] = t5;
		o[6] = t6;
		o[7] = t7;
		o[8] = t8;
		o[9] = t9;
		o[10] = t10;
		o[11] = t11;
		o[12] = t12;
		o[13] = t13;
		o[14] = t14;
		o[15] = t15;
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/kem.js
var require_kem = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of RSA-KEM.
	*
	* @author Lautaro Cozzani Rodriguez
	* @author Dave Longley
	*
	* Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>
	* Copyright (c) 2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	require_random();
	require_jsbn$1();
	module.exports = forge.kem = forge.kem || {};
	var BigInteger = forge.jsbn.BigInteger;
	/**
	* The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.
	*/
	forge.kem.rsa = {};
	/**
	* Creates an RSA KEM API object for generating a secret asymmetric key.
	*
	* The symmetric key may be generated via a call to 'encrypt', which will
	* produce a ciphertext to be transmitted to the recipient and a key to be
	* kept secret. The ciphertext is a parameter to be passed to 'decrypt' which
	* will produce the same secret key for the recipient to use to decrypt a
	* message that was encrypted with the secret key.
	*
	* @param kdf the KDF API to use (eg: new forge.kem.kdf1()).
	* @param options the options to use.
	*          [prng] a custom crypto-secure pseudo-random number generator to use,
	*            that must define "getBytesSync".
	*/
	forge.kem.rsa.create = function(kdf, options) {
		options = options || {};
		var prng = options.prng || forge.random;
		var kem = {};
		/**
		* Generates a secret key and its encapsulation.
		*
		* @param publicKey the RSA public key to encrypt with.
		* @param keyLength the length, in bytes, of the secret key to generate.
		*
		* @return an object with:
		*   encapsulation: the ciphertext for generating the secret key, as a
		*     binary-encoded string of bytes.
		*   key: the secret key to use for encrypting a message.
		*/
		kem.encrypt = function(publicKey, keyLength) {
			var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
			var r;
			do
				r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);
			while (r.compareTo(BigInteger.ONE) <= 0);
			r = forge.util.hexToBytes(r.toString(16));
			var zeros = byteLength - r.length;
			if (zeros > 0) r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
			return {
				encapsulation: publicKey.encrypt(r, "NONE"),
				key: kdf.generate(r, keyLength)
			};
		};
		/**
		* Decrypts an encapsulated secret key.
		*
		* @param privateKey the RSA private key to decrypt with.
		* @param encapsulation the ciphertext for generating the secret key, as
		*          a binary-encoded string of bytes.
		* @param keyLength the length, in bytes, of the secret key to generate.
		*
		* @return the secret key as a binary-encoded string of bytes.
		*/
		kem.decrypt = function(privateKey, encapsulation, keyLength) {
			var r = privateKey.decrypt(encapsulation, "NONE");
			return kdf.generate(r, keyLength);
		};
		return kem;
	};
	/**
	* Creates a key derivation API object that implements KDF1 per ISO 18033-2.
	*
	* @param md the hash API to use.
	* @param [digestLength] an optional digest length that must be positive and
	*          less than or equal to md.digestLength.
	*
	* @return a KDF1 API object.
	*/
	forge.kem.kdf1 = function(md, digestLength) {
		_createKDF(this, md, 0, digestLength || md.digestLength);
	};
	/**
	* Creates a key derivation API object that implements KDF2 per ISO 18033-2.
	*
	* @param md the hash API to use.
	* @param [digestLength] an optional digest length that must be positive and
	*          less than or equal to md.digestLength.
	*
	* @return a KDF2 API object.
	*/
	forge.kem.kdf2 = function(md, digestLength) {
		_createKDF(this, md, 1, digestLength || md.digestLength);
	};
	/**
	* Creates a KDF1 or KDF2 API object.
	*
	* @param md the hash API to use.
	* @param counterStart the starting index for the counter.
	* @param digestLength the digest length to use.
	*
	* @return the KDF API object.
	*/
	function _createKDF(kdf, md, counterStart, digestLength) {
		/**
		* Generate a key of the specified length.
		*
		* @param x the binary-encoded byte string to generate a key from.
		* @param length the number of bytes to generate (the size of the key).
		*
		* @return the key as a binary-encoded string.
		*/
		kdf.generate = function(x, length) {
			var key = new forge.util.ByteBuffer();
			var k = Math.ceil(length / digestLength) + counterStart;
			var c = new forge.util.ByteBuffer();
			for (var i = counterStart; i < k; ++i) {
				c.putInt32(i);
				md.start();
				md.update(x + c.getBytes());
				var hash$1 = md.digest();
				key.putBytes(hash$1.getBytes(digestLength));
			}
			key.truncate(key.length() - length);
			return key.getBytes();
		};
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/log.js
var require_log = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Cross-browser support for logging in a web application.
	*
	* @author David I. Lehn <dlehn@digitalbazaar.com>
	*
	* Copyright (c) 2008-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	module.exports = forge.log = forge.log || {};
	/**
	* Application logging system.
	*
	* Each logger level available as it's own function of the form:
	*   forge.log.level(category, args...)
	* The category is an arbitrary string, and the args are the same as
	* Firebug's console.log API. By default the call will be output as:
	*   'LEVEL [category] <args[0]>, args[1], ...'
	* This enables proper % formatting via the first argument.
	* Each category is enabled by default but can be enabled or disabled with
	* the setCategoryEnabled() function.
	*/
	forge.log.levels = [
		"none",
		"error",
		"warning",
		"info",
		"debug",
		"verbose",
		"max"
	];
	var sLevelInfo = {};
	var sLoggers = [];
	/**
	* Standard console logger. If no console support is enabled this will
	* remain null. Check before using.
	*/
	var sConsoleLogger = null;
	/**
	* Lock the level at the current value. Used in cases where user config may
	* set the level such that only critical messages are seen but more verbose
	* messages are needed for debugging or other purposes.
	*/
	forge.log.LEVEL_LOCKED = 2;
	/**
	* Always call log function. By default, the logging system will check the
	* message level against logger.level before calling the log function. This
	* flag allows the function to do its own check.
	*/
	forge.log.NO_LEVEL_CHECK = 4;
	/**
	* Perform message interpolation with the passed arguments. "%" style
	* fields in log messages will be replaced by arguments as needed. Some
	* loggers, such as Firebug, may do this automatically. The original log
	* message will be available as 'message' and the interpolated version will
	* be available as 'fullMessage'.
	*/
	forge.log.INTERPOLATE = 8;
	for (var i = 0; i < forge.log.levels.length; ++i) {
		var level = forge.log.levels[i];
		sLevelInfo[level] = {
			index: i,
			name: level.toUpperCase()
		};
	}
	/**
	* Message logger. Will dispatch a message to registered loggers as needed.
	*
	* @param message message object
	*/
	forge.log.logMessage = function(message) {
		var messageLevelIndex = sLevelInfo[message.level].index;
		for (var i = 0; i < sLoggers.length; ++i) {
			var logger$1 = sLoggers[i];
			if (logger$1.flags & forge.log.NO_LEVEL_CHECK) logger$1.f(message);
			else if (messageLevelIndex <= sLevelInfo[logger$1.level].index) logger$1.f(logger$1, message);
		}
	};
	/**
	* Sets the 'standard' key on a message object to:
	* "LEVEL [category] " + message
	*
	* @param message a message log object
	*/
	forge.log.prepareStandard = function(message) {
		if (!("standard" in message)) message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message;
	};
	/**
	* Sets the 'full' key on a message object to the original message
	* interpolated via % formatting with the message arguments.
	*
	* @param message a message log object.
	*/
	forge.log.prepareFull = function(message) {
		if (!("full" in message)) {
			var args = [message.message];
			args = args.concat([]);
			message.full = forge.util.format.apply(this, args);
		}
	};
	/**
	* Applies both preparseStandard() and prepareFull() to a message object and
	* store result in 'standardFull'.
	*
	* @param message a message log object.
	*/
	forge.log.prepareStandardFull = function(message) {
		if (!("standardFull" in message)) {
			forge.log.prepareStandard(message);
			message.standardFull = message.standard;
		}
	};
	var levels = [
		"error",
		"warning",
		"info",
		"debug",
		"verbose"
	];
	for (var i = 0; i < levels.length; ++i) (function(level) {
		forge.log[level] = function(category, message) {
			var args = Array.prototype.slice.call(arguments).slice(2);
			var msg = {
				timestamp: /* @__PURE__ */ new Date(),
				level,
				category,
				message,
				"arguments": args
			};
			forge.log.logMessage(msg);
		};
	})(levels[i]);
	/**
	* Creates a new logger with specified custom logging function.
	*
	* The logging function has a signature of:
	*   function(logger, message)
	* logger: current logger
	* message: object:
	*   level: level id
	*   category: category
	*   message: string message
	*   arguments: Array of extra arguments
	*   fullMessage: interpolated message and arguments if INTERPOLATE flag set
	*
	* @param logFunction a logging function which takes a log message object
	*          as a parameter.
	*
	* @return a logger object.
	*/
	forge.log.makeLogger = function(logFunction) {
		var logger$1 = {
			flags: 0,
			f: logFunction
		};
		forge.log.setLevel(logger$1, "none");
		return logger$1;
	};
	/**
	* Sets the current log level on a logger.
	*
	* @param logger the target logger.
	* @param level the new maximum log level as a string.
	*
	* @return true if set, false if not.
	*/
	forge.log.setLevel = function(logger$1, level) {
		var rval = false;
		if (logger$1 && !(logger$1.flags & forge.log.LEVEL_LOCKED)) {
			for (var i = 0; i < forge.log.levels.length; ++i) if (level == forge.log.levels[i]) {
				logger$1.level = level;
				rval = true;
				break;
			}
		}
		return rval;
	};
	/**
	* Locks the log level at its current value.
	*
	* @param logger the target logger.
	* @param lock boolean lock value, default to true.
	*/
	forge.log.lock = function(logger$1, lock) {
		if (typeof lock === "undefined" || lock) logger$1.flags |= forge.log.LEVEL_LOCKED;
		else logger$1.flags &= ~forge.log.LEVEL_LOCKED;
	};
	/**
	* Adds a logger.
	*
	* @param logger the logger object.
	*/
	forge.log.addLogger = function(logger$1) {
		sLoggers.push(logger$1);
	};
	if (typeof console !== "undefined" && "log" in console) {
		var logger;
		if (console.error && console.warn && console.info && console.debug) {
			var levelHandlers = {
				error: console.error,
				warning: console.warn,
				info: console.info,
				debug: console.debug,
				verbose: console.debug
			};
			var f = function(logger$1, message) {
				forge.log.prepareStandard(message);
				var handler = levelHandlers[message.level];
				var args = [message.standard];
				args = args.concat(message["arguments"].slice());
				handler.apply(console, args);
			};
			logger = forge.log.makeLogger(f);
		} else {
			var f = function(logger$1, message) {
				forge.log.prepareStandardFull(message);
				console.log(message.standardFull);
			};
			logger = forge.log.makeLogger(f);
		}
		forge.log.setLevel(logger, "debug");
		forge.log.addLogger(logger);
		sConsoleLogger = logger;
	} else console = { log: function() {} };
	if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
		var query = new URL(window.location.href).searchParams;
		if (query.has("console.level")) forge.log.setLevel(sConsoleLogger, query.get("console.level").slice(-1)[0]);
		if (query.has("console.lock")) {
			if (query.get("console.lock").slice(-1)[0] == "true") forge.log.lock(sConsoleLogger);
		}
	}
	forge.log.consoleLogger = sConsoleLogger;
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/md.all.js
var require_md_all = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for all known Forge message digests.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2017 Digital Bazaar, Inc.
	*/
	module.exports = require_md();
	require_md5();
	require_sha1();
	require_sha256();
	require_sha512();
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of PKCS#7 v1.5.
	*
	* @author Stefan Siegl
	* @author Dave Longley
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	* Copyright (c) 2012-2015 Digital Bazaar, Inc.
	*
	* Currently this implementation only supports ContentType of EnvelopedData,
	* EncryptedData, or SignedData at the root level. The top level elements may
	* contain only a ContentInfo of ContentType Data, i.e. plain data. Further
	* nesting is not (yet) supported.
	*
	* The Forge validators for PKCS #7's ASN.1 structures are available from
	* a separate file pkcs7asn1.js, since those are referenced from other
	* PKCS standards like PKCS #12.
	*/
	var forge = require_forge();
	require_aes();
	require_asn1();
	require_des();
	require_oids();
	require_pem();
	require_pkcs7asn1();
	require_random();
	require_util();
	require_x509();
	var asn1 = forge.asn1;
	var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
	/**
	* Converts a PKCS#7 message from PEM format.
	*
	* @param pem the PEM-formatted PKCS#7 message.
	*
	* @return the PKCS#7 message.
	*/
	p7.messageFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "PKCS7") {
			var error$47 = /* @__PURE__ */ new Error("Could not convert PKCS#7 message from PEM; PEM header type is not \"PKCS#7\".");
			error$47.headerType = msg.type;
			throw error$47;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body);
		return p7.messageFromAsn1(obj);
	};
	/**
	* Converts a PKCS#7 message to PEM format.
	*
	* @param msg The PKCS#7 message object
	* @param maxline The maximum characters per line, defaults to 64.
	*
	* @return The PEM-formatted PKCS#7 message.
	*/
	p7.messageToPem = function(msg, maxline) {
		var pemObj = {
			type: "PKCS7",
			body: asn1.toDer(msg.toAsn1()).getBytes()
		};
		return forge.pem.encode(pemObj, { maxline });
	};
	/**
	* Converts a PKCS#7 message from an ASN.1 object.
	*
	* @param obj the ASN.1 representation of a ContentInfo.
	*
	* @return the PKCS#7 message.
	*/
	p7.messageFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
			error$47.errors = errors;
			throw error$47;
		}
		var contentType = asn1.derToOid(capture.contentType);
		var msg;
		switch (contentType) {
			case forge.pki.oids.envelopedData:
				msg = p7.createEnvelopedData();
				break;
			case forge.pki.oids.encryptedData:
				msg = p7.createEncryptedData();
				break;
			case forge.pki.oids.signedData:
				msg = p7.createSignedData();
				break;
			default: throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
		}
		msg.fromAsn1(capture.content.value[0]);
		return msg;
	};
	p7.createSignedData = function() {
		var msg = null;
		msg = {
			type: forge.pki.oids.signedData,
			version: 1,
			certificates: [],
			crls: [],
			signers: [],
			digestAlgorithmIdentifiers: [],
			contentInfo: null,
			signerInfos: [],
			fromAsn1: function(obj) {
				_fromAsn1(msg, obj, p7.asn1.signedDataValidator);
				msg.certificates = [];
				msg.crls = [];
				msg.digestAlgorithmIdentifiers = [];
				msg.contentInfo = null;
				msg.signerInfos = [];
				if (msg.rawCapture.certificates) {
					var certs = msg.rawCapture.certificates.value;
					for (var i = 0; i < certs.length; ++i) msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
				}
			},
			toAsn1: function() {
				if (!msg.contentInfo) msg.sign();
				var certs = [];
				for (var i = 0; i < msg.certificates.length; ++i) certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
				var crls = [];
				var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
					msg.contentInfo
				])]);
				if (certs.length > 0) signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
				if (crls.length > 0) signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
				signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
				return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), signedData]);
			},
			addSigner: function(signer) {
				var issuer = signer.issuer;
				var serialNumber = signer.serialNumber;
				if (signer.certificate) {
					var cert = signer.certificate;
					if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
					issuer = cert.issuer.attributes;
					serialNumber = cert.serialNumber;
				}
				var key = signer.key;
				if (!key) throw new Error("Could not add PKCS#7 signer; no private key specified.");
				if (typeof key === "string") key = forge.pki.privateKeyFromPem(key);
				var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
				switch (digestAlgorithm) {
					case forge.pki.oids.sha1:
					case forge.pki.oids.sha256:
					case forge.pki.oids.sha384:
					case forge.pki.oids.sha512:
					case forge.pki.oids.md5: break;
					default: throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
				}
				var authenticatedAttributes = signer.authenticatedAttributes || [];
				if (authenticatedAttributes.length > 0) {
					var contentType = false;
					var messageDigest = false;
					for (var i = 0; i < authenticatedAttributes.length; ++i) {
						var attr = authenticatedAttributes[i];
						if (!contentType && attr.type === forge.pki.oids.contentType) {
							contentType = true;
							if (messageDigest) break;
							continue;
						}
						if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
							messageDigest = true;
							if (contentType) break;
							continue;
						}
					}
					if (!contentType || !messageDigest) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
				}
				msg.signers.push({
					key,
					version: 1,
					issuer,
					serialNumber,
					digestAlgorithm,
					signatureAlgorithm: forge.pki.oids.rsaEncryption,
					signature: null,
					authenticatedAttributes,
					unauthenticatedAttributes: []
				});
			},
			sign: function(options) {
				options = options || {};
				if (typeof msg.content !== "object" || msg.contentInfo === null) {
					msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())]);
					if ("content" in msg) {
						var content;
						if (msg.content instanceof forge.util.ByteBuffer) content = msg.content.bytes();
						else if (typeof msg.content === "string") content = forge.util.encodeUtf8(msg.content);
						if (options.detached) msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
						else msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)]));
					}
				}
				if (msg.signers.length === 0) return;
				addSignerInfos(addDigestAlgorithmIds());
			},
			verify: function() {
				throw new Error("PKCS#7 signature verification not yet implemented.");
			},
			addCertificate: function(cert) {
				if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
				msg.certificates.push(cert);
			},
			addCertificateRevokationList: function(crl) {
				throw new Error("PKCS#7 CRL support not yet implemented.");
			}
		};
		return msg;
		function addDigestAlgorithmIds() {
			var mds = {};
			for (var i = 0; i < msg.signers.length; ++i) {
				var signer = msg.signers[i];
				var oid = signer.digestAlgorithm;
				if (!(oid in mds)) mds[oid] = forge.md[forge.pki.oids[oid]].create();
				if (signer.authenticatedAttributes.length === 0) signer.md = mds[oid];
				else signer.md = forge.md[forge.pki.oids[oid]].create();
			}
			msg.digestAlgorithmIdentifiers = [];
			for (var oid in mds) msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]));
			return mds;
		}
		function addSignerInfos(mds) {
			var content;
			if (msg.detachedContent) content = msg.detachedContent;
			else {
				content = msg.contentInfo.value[1];
				content = content.value[0];
			}
			if (!content) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
			var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
			var bytes = asn1.toDer(content);
			bytes.getByte();
			asn1.getBerValueLength(bytes);
			bytes = bytes.getBytes();
			for (var oid in mds) mds[oid].start().update(bytes);
			var signingTime = /* @__PURE__ */ new Date();
			for (var i = 0; i < msg.signers.length; ++i) {
				var signer = msg.signers[i];
				if (signer.authenticatedAttributes.length === 0) {
					if (contentType !== forge.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
				} else {
					signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
					var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
					for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
						var attr = signer.authenticatedAttributes[ai];
						if (attr.type === forge.pki.oids.messageDigest) attr.value = mds[signer.digestAlgorithm].digest();
						else if (attr.type === forge.pki.oids.signingTime) {
							if (!attr.value) attr.value = signingTime;
						}
						attrsAsn1.value.push(_attributeToAsn1(attr));
						signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
					}
					bytes = asn1.toDer(attrsAsn1).getBytes();
					signer.md.start().update(bytes);
				}
				signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
			}
			msg.signerInfos = _signersToAsn1(msg.signers);
		}
	};
	/**
	* Creates an empty PKCS#7 message of type EncryptedData.
	*
	* @return the message.
	*/
	p7.createEncryptedData = function() {
		var msg = null;
		msg = {
			type: forge.pki.oids.encryptedData,
			version: 0,
			encryptedContent: { algorithm: forge.pki.oids["aes256-CBC"] },
			fromAsn1: function(obj) {
				_fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
			},
			decrypt: function(key) {
				if (key !== void 0) msg.encryptedContent.key = key;
				_decryptContent(msg);
			}
		};
		return msg;
	};
	/**
	* Creates an empty PKCS#7 message of type EnvelopedData.
	*
	* @return the message.
	*/
	p7.createEnvelopedData = function() {
		var msg = null;
		msg = {
			type: forge.pki.oids.envelopedData,
			version: 0,
			recipients: [],
			encryptedContent: { algorithm: forge.pki.oids["aes256-CBC"] },
			fromAsn1: function(obj) {
				var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
				msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
			},
			toAsn1: function() {
				return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
				])])]);
			},
			findRecipient: function(cert) {
				var sAttr = cert.issuer.attributes;
				for (var i = 0; i < msg.recipients.length; ++i) {
					var r = msg.recipients[i];
					var rAttr = r.issuer;
					if (r.serialNumber !== cert.serialNumber) continue;
					if (rAttr.length !== sAttr.length) continue;
					var match = true;
					for (var j = 0; j < sAttr.length; ++j) if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
						match = false;
						break;
					}
					if (match) return r;
				}
				return null;
			},
			decrypt: function(recipient, privKey) {
				if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) switch (recipient.encryptedContent.algorithm) {
					case forge.pki.oids.rsaEncryption:
					case forge.pki.oids.desCBC:
						var key = privKey.decrypt(recipient.encryptedContent.content);
						msg.encryptedContent.key = forge.util.createBuffer(key);
						break;
					default: throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
				}
				_decryptContent(msg);
			},
			addRecipient: function(cert) {
				msg.recipients.push({
					version: 0,
					issuer: cert.issuer.attributes,
					serialNumber: cert.serialNumber,
					encryptedContent: {
						algorithm: forge.pki.oids.rsaEncryption,
						key: cert.publicKey
					}
				});
			},
			encrypt: function(key, cipher) {
				if (msg.encryptedContent.content === void 0) {
					cipher = cipher || msg.encryptedContent.algorithm;
					key = key || msg.encryptedContent.key;
					var keyLen, ivLen, ciphFn;
					switch (cipher) {
						case forge.pki.oids["aes128-CBC"]:
							keyLen = 16;
							ivLen = 16;
							ciphFn = forge.aes.createEncryptionCipher;
							break;
						case forge.pki.oids["aes192-CBC"]:
							keyLen = 24;
							ivLen = 16;
							ciphFn = forge.aes.createEncryptionCipher;
							break;
						case forge.pki.oids["aes256-CBC"]:
							keyLen = 32;
							ivLen = 16;
							ciphFn = forge.aes.createEncryptionCipher;
							break;
						case forge.pki.oids["des-EDE3-CBC"]:
							keyLen = 24;
							ivLen = 8;
							ciphFn = forge.des.createEncryptionCipher;
							break;
						default: throw new Error("Unsupported symmetric cipher, OID " + cipher);
					}
					if (key === void 0) key = forge.util.createBuffer(forge.random.getBytes(keyLen));
					else if (key.length() != keyLen) throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
					msg.encryptedContent.algorithm = cipher;
					msg.encryptedContent.key = key;
					msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
					var ciph = ciphFn(key);
					ciph.start(msg.encryptedContent.parameter.copy());
					ciph.update(msg.content);
					if (!ciph.finish()) throw new Error("Symmetric encryption failed.");
					msg.encryptedContent.content = ciph.output;
				}
				for (var i = 0; i < msg.recipients.length; ++i) {
					var recipient = msg.recipients[i];
					if (recipient.encryptedContent.content !== void 0) continue;
					switch (recipient.encryptedContent.algorithm) {
						case forge.pki.oids.rsaEncryption:
							recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
							break;
						default: throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
					}
				}
			}
		};
		return msg;
	};
	/**
	* Converts a single recipient from an ASN.1 object.
	*
	* @param obj the ASN.1 RecipientInfo.
	*
	* @return the recipient object.
	*/
	function _recipientFromAsn1(obj) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
			error$47.errors = errors;
			throw error$47;
		}
		return {
			version: capture.version.charCodeAt(0),
			issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
			serialNumber: forge.util.createBuffer(capture.serial).toHex(),
			encryptedContent: {
				algorithm: asn1.derToOid(capture.encAlgorithm),
				parameter: capture.encParameter ? capture.encParameter.value : void 0,
				content: capture.encKey
			}
		};
	}
	/**
	* Converts a single recipient object to an ASN.1 object.
	*
	* @param obj the recipient object.
	*
	* @return the ASN.1 RecipientInfo.
	*/
	function _recipientToAsn1(obj) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
		]);
	}
	/**
	* Map a set of RecipientInfo ASN.1 objects to recipient objects.
	*
	* @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).
	*
	* @return an array of recipient objects.
	*/
	function _recipientsFromAsn1(infos) {
		var ret = [];
		for (var i = 0; i < infos.length; ++i) ret.push(_recipientFromAsn1(infos[i]));
		return ret;
	}
	/**
	* Map an array of recipient objects to ASN.1 RecipientInfo objects.
	*
	* @param recipients an array of recipientInfo objects.
	*
	* @return an array of ASN.1 RecipientInfos.
	*/
	function _recipientsToAsn1(recipients) {
		var ret = [];
		for (var i = 0; i < recipients.length; ++i) ret.push(_recipientToAsn1(recipients[i]));
		return ret;
	}
	/**
	* Converts a single signerInfo object to an ASN.1 object.
	*
	* @param obj the signerInfo object.
	*
	* @return the ASN.1 representation of a SignerInfo.
	*/
	function _signerToAsn1(obj) {
		var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])
		]);
		if (obj.authenticatedAttributesAsn1) rval.value.push(obj.authenticatedAttributesAsn1);
		rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]));
		rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
		if (obj.unauthenticatedAttributes.length > 0) {
			var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
			for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
				var attr = obj.unauthenticatedAttributes[i];
				attrsAsn1.values.push(_attributeToAsn1(attr));
			}
			rval.value.push(attrsAsn1);
		}
		return rval;
	}
	/**
	* Map an array of signer objects to ASN.1 objects.
	*
	* @param signers an array of signer objects.
	*
	* @return an array of ASN.1 SignerInfos.
	*/
	function _signersToAsn1(signers) {
		var ret = [];
		for (var i = 0; i < signers.length; ++i) ret.push(_signerToAsn1(signers[i]));
		return ret;
	}
	/**
	* Convert an attribute object to an ASN.1 Attribute.
	*
	* @param attr the attribute object.
	*
	* @return the ASN.1 Attribute.
	*/
	function _attributeToAsn1(attr) {
		var value;
		if (attr.type === forge.pki.oids.contentType) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
		else if (attr.type === forge.pki.oids.messageDigest) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
		else if (attr.type === forge.pki.oids.signingTime) {
			var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
			var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
			var date$4 = attr.value;
			if (typeof date$4 === "string") {
				var timestamp = Date.parse(date$4);
				if (!isNaN(timestamp)) date$4 = new Date(timestamp);
				else if (date$4.length === 13) date$4 = asn1.utcTimeToDate(date$4);
				else date$4 = asn1.generalizedTimeToDate(date$4);
			}
			if (date$4 >= jan_1_1950 && date$4 < jan_1_2050) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date$4));
			else value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date$4));
		}
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [value])]);
	}
	/**
	* Map messages encrypted content to ASN.1 objects.
	*
	* @param ec The encryptedContent object of the message.
	*
	* @return ASN.1 representation of the encryptedContent object (SEQUENCE).
	*/
	function _encryptedContentToAsn1(ec) {
		return [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()), !ec.parameter ? void 0 : asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())]),
			asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())])
		];
	}
	/**
	* Reads the "common part" of an PKCS#7 content block (in ASN.1 format)
	*
	* This function reads the "common part" of the PKCS#7 content blocks
	* EncryptedData and EnvelopedData, i.e. version number and symmetrically
	* encrypted content block.
	*
	* The result of the ASN.1 validate and capture process is returned
	* to allow the caller to extract further data, e.g. the list of recipients
	* in case of a EnvelopedData object.
	*
	* @param msg the PKCS#7 object to read the data to.
	* @param obj the ASN.1 representation of the content block.
	* @param validator the ASN.1 structure validator object to use.
	*
	* @return the value map captured by validator object.
	*/
	function _fromAsn1(msg, obj, validator) {
		var capture = {};
		if (!asn1.validate(obj, validator, capture, [])) {
			var error$47 = /* @__PURE__ */ new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
			error$47.errors = error$47;
			throw error$47;
		}
		if (asn1.derToOid(capture.contentType) !== forge.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
		if (capture.encryptedContent) {
			var content = "";
			if (forge.util.isArray(capture.encryptedContent)) for (var i = 0; i < capture.encryptedContent.length; ++i) {
				if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
				content += capture.encryptedContent[i].value;
			}
			else content = capture.encryptedContent;
			msg.encryptedContent = {
				algorithm: asn1.derToOid(capture.encAlgorithm),
				parameter: forge.util.createBuffer(capture.encParameter.value),
				content: forge.util.createBuffer(content)
			};
		}
		if (capture.content) {
			var content = "";
			if (forge.util.isArray(capture.content)) for (var i = 0; i < capture.content.length; ++i) {
				if (capture.content[i].type !== asn1.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
				content += capture.content[i].value;
			}
			else content = capture.content;
			msg.content = forge.util.createBuffer(content);
		}
		msg.version = capture.version.charCodeAt(0);
		msg.rawCapture = capture;
		return capture;
	}
	/**
	* Decrypt the symmetrically encrypted content block of the PKCS#7 message.
	*
	* Decryption is skipped in case the PKCS#7 message object already has a
	* (decrypted) content attribute.  The algorithm, key and cipher parameters
	* (probably the iv) are taken from the encryptedContent attribute of the
	* message object.
	*
	* @param The PKCS#7 message object.
	*/
	function _decryptContent(msg) {
		if (msg.encryptedContent.key === void 0) throw new Error("Symmetric key not available.");
		if (msg.content === void 0) {
			var ciph;
			switch (msg.encryptedContent.algorithm) {
				case forge.pki.oids["aes128-CBC"]:
				case forge.pki.oids["aes192-CBC"]:
				case forge.pki.oids["aes256-CBC"]:
					ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
					break;
				case forge.pki.oids["desCBC"]:
				case forge.pki.oids["des-EDE3-CBC"]:
					ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
					break;
				default: throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
			}
			ciph.start(msg.encryptedContent.parameter);
			ciph.update(msg.encryptedContent.content);
			if (!ciph.finish()) throw new Error("Symmetric decryption failed.");
			msg.content = ciph.output;
		}
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/ssh.js
var require_ssh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Functions to output keys in SSH-friendly formats.
	*
	* This is part of the Forge project which may be used under the terms of
	* either the BSD License or the GNU General Public License (GPL) Version 2.
	*
	* See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE
	*
	* @author https://github.com/shellac
	*/
	var forge = require_forge();
	require_aes();
	require_hmac();
	require_md5();
	require_sha1();
	require_util();
	var ssh = module.exports = forge.ssh = forge.ssh || {};
	/**
	* Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.
	*
	* @param privateKey the key.
	* @param passphrase a passphrase to protect the key (falsy for no encryption).
	* @param comment a comment to include in the key file.
	*
	* @return the PPK file as a string.
	*/
	ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
		comment = comment || "";
		passphrase = passphrase || "";
		var algorithm = "ssh-rsa";
		var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
		var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
		ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
		ppk += "Comment: " + comment + "\r\n";
		var pubbuffer = forge.util.createBuffer();
		_addStringToBuffer(pubbuffer, algorithm);
		_addBigIntegerToBuffer(pubbuffer, privateKey.e);
		_addBigIntegerToBuffer(pubbuffer, privateKey.n);
		var pub = forge.util.encode64(pubbuffer.bytes(), 64);
		var length = Math.floor(pub.length / 66) + 1;
		ppk += "Public-Lines: " + length + "\r\n";
		ppk += pub;
		var privbuffer = forge.util.createBuffer();
		_addBigIntegerToBuffer(privbuffer, privateKey.d);
		_addBigIntegerToBuffer(privbuffer, privateKey.p);
		_addBigIntegerToBuffer(privbuffer, privateKey.q);
		_addBigIntegerToBuffer(privbuffer, privateKey.qInv);
		var priv;
		if (!passphrase) priv = forge.util.encode64(privbuffer.bytes(), 64);
		else {
			var encLen = privbuffer.length() + 16 - 1;
			encLen -= encLen % 16;
			var padding = _sha1(privbuffer.bytes());
			padding.truncate(padding.length() - encLen + privbuffer.length());
			privbuffer.putBuffer(padding);
			var aeskey = forge.util.createBuffer();
			aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
			aeskey.putBuffer(_sha1("\0\0\0", passphrase));
			var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
			cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
			cipher.update(privbuffer.copy());
			cipher.finish();
			var encrypted = cipher.output;
			encrypted.truncate(16);
			priv = forge.util.encode64(encrypted.bytes(), 64);
		}
		length = Math.floor(priv.length / 66) + 1;
		ppk += "\r\nPrivate-Lines: " + length + "\r\n";
		ppk += priv;
		var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
		var macbuffer = forge.util.createBuffer();
		_addStringToBuffer(macbuffer, algorithm);
		_addStringToBuffer(macbuffer, encryptionAlgorithm);
		_addStringToBuffer(macbuffer, comment);
		macbuffer.putInt32(pubbuffer.length());
		macbuffer.putBuffer(pubbuffer);
		macbuffer.putInt32(privbuffer.length());
		macbuffer.putBuffer(privbuffer);
		var hmac = forge.hmac.create();
		hmac.start("sha1", mackey);
		hmac.update(macbuffer.bytes());
		ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
		return ppk;
	};
	/**
	* Encodes a public RSA key as an OpenSSH file.
	*
	* @param key the key.
	* @param comment a comment.
	*
	* @return the public key in OpenSSH format.
	*/
	ssh.publicKeyToOpenSSH = function(key, comment) {
		var type = "ssh-rsa";
		comment = comment || "";
		var buffer$1 = forge.util.createBuffer();
		_addStringToBuffer(buffer$1, type);
		_addBigIntegerToBuffer(buffer$1, key.e);
		_addBigIntegerToBuffer(buffer$1, key.n);
		return type + " " + forge.util.encode64(buffer$1.bytes()) + " " + comment;
	};
	/**
	* Encodes a private RSA key as an OpenSSH file.
	*
	* @param key the key.
	* @param passphrase a passphrase to protect the key (falsy for no encryption).
	*
	* @return the public key in OpenSSH format.
	*/
	ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
		if (!passphrase) return forge.pki.privateKeyToPem(privateKey);
		return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {
			legacy: true,
			algorithm: "aes128"
		});
	};
	/**
	* Gets the SSH fingerprint for the given public key.
	*
	* @param options the options to use.
	*          [md] the message digest object to use (defaults to forge.md.md5).
	*          [encoding] an alternative output encoding, such as 'hex'
	*            (defaults to none, outputs a byte buffer).
	*          [delimiter] the delimiter to use between bytes for 'hex' encoded
	*            output, eg: ':' (defaults to none).
	*
	* @return the fingerprint as a byte buffer or other encoding based on options.
	*/
	ssh.getPublicKeyFingerprint = function(key, options) {
		options = options || {};
		var md = options.md || forge.md.md5.create();
		var type = "ssh-rsa";
		var buffer$1 = forge.util.createBuffer();
		_addStringToBuffer(buffer$1, type);
		_addBigIntegerToBuffer(buffer$1, key.e);
		_addBigIntegerToBuffer(buffer$1, key.n);
		md.start();
		md.update(buffer$1.getBytes());
		var digest = md.digest();
		if (options.encoding === "hex") {
			var hex$2 = digest.toHex();
			if (options.delimiter) return hex$2.match(/.{2}/g).join(options.delimiter);
			return hex$2;
		} else if (options.encoding === "binary") return digest.getBytes();
		else if (options.encoding) throw new Error("Unknown encoding \"" + options.encoding + "\".");
		return digest;
	};
	/**
	* Adds len(val) then val to a buffer.
	*
	* @param buffer the buffer to add to.
	* @param val a big integer.
	*/
	function _addBigIntegerToBuffer(buffer$1, val) {
		var hexVal = val.toString(16);
		if (hexVal[0] >= "8") hexVal = "00" + hexVal;
		var bytes = forge.util.hexToBytes(hexVal);
		buffer$1.putInt32(bytes.length);
		buffer$1.putBytes(bytes);
	}
	/**
	* Adds len(val) then val to a buffer.
	*
	* @param buffer the buffer to add to.
	* @param val a string.
	*/
	function _addStringToBuffer(buffer$1, val) {
		buffer$1.putInt32(val.length);
		buffer$1.putString(val);
	}
	/**
	* Hashes the arguments into one value using SHA-1.
	*
	* @return the sha1 hash of the provided arguments.
	*/
	function _sha1() {
		var sha = forge.md.sha1.create();
		var num = arguments.length;
		for (var i = 0; i < num; ++i) sha.update(arguments[i]);
		return sha.digest();
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-forge@1.3.3/node_modules/node-forge/lib/index.js
var require_lib$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2016 Digital Bazaar, Inc.
	*/
	module.exports = require_forge();
	require_aes();
	require_aesCipherSuites();
	require_asn1();
	require_cipher();
	require_des();
	require_ed25519();
	require_hmac();
	require_kem();
	require_log();
	require_md_all();
	require_mgf1();
	require_pbkdf2();
	require_pem();
	require_pkcs1$2();
	require_pkcs12();
	require_pkcs7();
	require_pki();
	require_prime();
	require_prng();
	require_pss$1();
	require_random();
	require_rc2();
	require_ssh();
	require_tls();
	require_util();
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common = /* @__PURE__ */ __commonJSMin(((exports) => {
	var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
	function _has(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	}
	exports.assign = function(obj) {
		var sources = Array.prototype.slice.call(arguments, 1);
		while (sources.length) {
			var source = sources.shift();
			if (!source) continue;
			if (typeof source !== "object") throw new TypeError(source + "must be non-object");
			for (var p in source) if (_has(source, p)) obj[p] = source[p];
		}
		return obj;
	};
	exports.shrinkBuf = function(buf, size) {
		if (buf.length === size) return buf;
		if (buf.subarray) return buf.subarray(0, size);
		buf.length = size;
		return buf;
	};
	var fnTyped = {
		arraySet: function(dest, src, src_offs, len, dest_offs) {
			if (src.subarray && dest.subarray) {
				dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
				return;
			}
			for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
		},
		flattenChunks: function(chunks) {
			var i, l, len = 0, pos, chunk, result;
			for (i = 0, l = chunks.length; i < l; i++) len += chunks[i].length;
			result = new Uint8Array(len);
			pos = 0;
			for (i = 0, l = chunks.length; i < l; i++) {
				chunk = chunks[i];
				result.set(chunk, pos);
				pos += chunk.length;
			}
			return result;
		}
	};
	var fnUntyped = {
		arraySet: function(dest, src, src_offs, len, dest_offs) {
			for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
		},
		flattenChunks: function(chunks) {
			return [].concat.apply([], chunks);
		}
	};
	exports.setTyped = function(on) {
		if (on) {
			exports.Buf8 = Uint8Array;
			exports.Buf16 = Uint16Array;
			exports.Buf32 = Int32Array;
			exports.assign(exports, fnTyped);
		} else {
			exports.Buf8 = Array;
			exports.Buf16 = Array;
			exports.Buf32 = Array;
			exports.assign(exports, fnUntyped);
		}
	};
	exports.setTyped(TYPED_OK);
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utils = require_common();
	var Z_FIXED = 4;
	var Z_BINARY = 0;
	var Z_TEXT = 1;
	var Z_UNKNOWN = 2;
	function zero(buf) {
		var len = buf.length;
		while (--len >= 0) buf[len] = 0;
	}
	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES = 2;
	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var LENGTH_CODES = 29;
	var LITERALS = 256;
	var L_CODES = LITERALS + 1 + LENGTH_CODES;
	var D_CODES = 30;
	var BL_CODES = 19;
	var HEAP_SIZE = 2 * L_CODES + 1;
	var MAX_BITS = 15;
	var Buf_size = 16;
	var MAX_BL_BITS = 7;
	var END_BLOCK = 256;
	var REP_3_6 = 16;
	var REPZ_3_10 = 17;
	var REPZ_11_138 = 18;
	var extra_lbits = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		3,
		3,
		3,
		3,
		4,
		4,
		4,
		4,
		5,
		5,
		5,
		5,
		0
	];
	var extra_dbits = [
		0,
		0,
		0,
		0,
		1,
		1,
		2,
		2,
		3,
		3,
		4,
		4,
		5,
		5,
		6,
		6,
		7,
		7,
		8,
		8,
		9,
		9,
		10,
		10,
		11,
		11,
		12,
		12,
		13,
		13
	];
	var extra_blbits = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		2,
		3,
		7
	];
	var bl_order = [
		16,
		17,
		18,
		0,
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15
	];
	var DIST_CODE_LEN = 512;
	var static_ltree = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	var static_dtree = new Array(D_CODES * 2);
	zero(static_dtree);
	var _dist_code = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	var base_length = new Array(LENGTH_CODES);
	zero(base_length);
	var base_dist = new Array(D_CODES);
	zero(base_dist);
	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
		this.static_tree = static_tree;
		this.extra_bits = extra_bits;
		this.extra_base = extra_base;
		this.elems = elems;
		this.max_length = max_length;
		this.has_stree = static_tree && static_tree.length;
	}
	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;
	function TreeDesc(dyn_tree, stat_desc) {
		this.dyn_tree = dyn_tree;
		this.max_code = 0;
		this.stat_desc = stat_desc;
	}
	function d_code(dist) {
		return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}
	function put_short(s, w) {
		s.pending_buf[s.pending++] = w & 255;
		s.pending_buf[s.pending++] = w >>> 8 & 255;
	}
	function send_bits(s, value, length) {
		if (s.bi_valid > Buf_size - length) {
			s.bi_buf |= value << s.bi_valid & 65535;
			put_short(s, s.bi_buf);
			s.bi_buf = value >> Buf_size - s.bi_valid;
			s.bi_valid += length - Buf_size;
		} else {
			s.bi_buf |= value << s.bi_valid & 65535;
			s.bi_valid += length;
		}
	}
	function send_code(s, c, tree) {
		send_bits(s, tree[c * 2], tree[c * 2 + 1]);
	}
	function bi_reverse(code, len) {
		var res = 0;
		do {
			res |= code & 1;
			code >>>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >>> 1;
	}
	function bi_flush(s) {
		if (s.bi_valid === 16) {
			put_short(s, s.bi_buf);
			s.bi_buf = 0;
			s.bi_valid = 0;
		} else if (s.bi_valid >= 8) {
			s.pending_buf[s.pending++] = s.bi_buf & 255;
			s.bi_buf >>= 8;
			s.bi_valid -= 8;
		}
	}
	function gen_bitlen(s, desc) {
		var tree = desc.dyn_tree;
		var max_code = desc.max_code;
		var stree = desc.stat_desc.static_tree;
		var has_stree = desc.stat_desc.has_stree;
		var extra = desc.stat_desc.extra_bits;
		var base = desc.stat_desc.extra_base;
		var max_length = desc.stat_desc.max_length;
		var h;
		var n, m;
		var bits;
		var xbits;
		var f;
		var overflow = 0;
		for (bits = 0; bits <= MAX_BITS; bits++) s.bl_count[bits] = 0;
		tree[s.heap[s.heap_max] * 2 + 1] = 0;
		for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
			n = s.heap[h];
			bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n * 2 + 1] = bits;
			if (n > max_code) continue;
			s.bl_count[bits]++;
			xbits = 0;
			if (n >= base) xbits = extra[n - base];
			f = tree[n * 2];
			s.opt_len += f * (bits + xbits);
			if (has_stree) s.static_len += f * (stree[n * 2 + 1] + xbits);
		}
		if (overflow === 0) return;
		do {
			bits = max_length - 1;
			while (s.bl_count[bits] === 0) bits--;
			s.bl_count[bits]--;
			s.bl_count[bits + 1] += 2;
			s.bl_count[max_length]--;
			overflow -= 2;
		} while (overflow > 0);
		for (bits = max_length; bits !== 0; bits--) {
			n = s.bl_count[bits];
			while (n !== 0) {
				m = s.heap[--h];
				if (m > max_code) continue;
				if (tree[m * 2 + 1] !== bits) {
					s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
					tree[m * 2 + 1] = bits;
				}
				n--;
			}
		}
	}
	function gen_codes(tree, max_code, bl_count) {
		var next_code = new Array(MAX_BITS + 1);
		var code = 0;
		var bits;
		var n;
		for (bits = 1; bits <= MAX_BITS; bits++) next_code[bits] = code = code + bl_count[bits - 1] << 1;
		for (n = 0; n <= max_code; n++) {
			var len = tree[n * 2 + 1];
			if (len === 0) continue;
			tree[n * 2] = bi_reverse(next_code[len]++, len);
		}
	}
	function tr_static_init() {
		var n;
		var bits;
		var length;
		var code;
		var dist;
		var bl_count = new Array(MAX_BITS + 1);
		length = 0;
		for (code = 0; code < LENGTH_CODES - 1; code++) {
			base_length[code] = length;
			for (n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
		}
		_length_code[length - 1] = code;
		dist = 0;
		for (code = 0; code < 16; code++) {
			base_dist[code] = dist;
			for (n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
		}
		dist >>= 7;
		for (; code < D_CODES; code++) {
			base_dist[code] = dist << 7;
			for (n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
		}
		for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
		n = 0;
		while (n <= 143) {
			static_ltree[n * 2 + 1] = 8;
			n++;
			bl_count[8]++;
		}
		while (n <= 255) {
			static_ltree[n * 2 + 1] = 9;
			n++;
			bl_count[9]++;
		}
		while (n <= 279) {
			static_ltree[n * 2 + 1] = 7;
			n++;
			bl_count[7]++;
		}
		while (n <= 287) {
			static_ltree[n * 2 + 1] = 8;
			n++;
			bl_count[8]++;
		}
		gen_codes(static_ltree, L_CODES + 1, bl_count);
		for (n = 0; n < D_CODES; n++) {
			static_dtree[n * 2 + 1] = 5;
			static_dtree[n * 2] = bi_reverse(n, 5);
		}
		static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
		static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
		static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
	}
	function init_block(s) {
		var n;
		for (n = 0; n < L_CODES; n++) s.dyn_ltree[n * 2] = 0;
		for (n = 0; n < D_CODES; n++) s.dyn_dtree[n * 2] = 0;
		for (n = 0; n < BL_CODES; n++) s.bl_tree[n * 2] = 0;
		s.dyn_ltree[END_BLOCK * 2] = 1;
		s.opt_len = s.static_len = 0;
		s.last_lit = s.matches = 0;
	}
	function bi_windup(s) {
		if (s.bi_valid > 8) put_short(s, s.bi_buf);
		else if (s.bi_valid > 0) s.pending_buf[s.pending++] = s.bi_buf;
		s.bi_buf = 0;
		s.bi_valid = 0;
	}
	function copy_block(s, buf, len, header) {
		bi_windup(s);
		if (header) {
			put_short(s, len);
			put_short(s, ~len);
		}
		utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
		s.pending += len;
	}
	function smaller(tree, n, m, depth) {
		var _n2 = n * 2;
		var _m2 = m * 2;
		return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
	}
	function pqdownheap(s, tree, k) {
		var v = s.heap[k];
		var j = k << 1;
		while (j <= s.heap_len) {
			if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) j++;
			if (smaller(tree, v, s.heap[j], s.depth)) break;
			s.heap[k] = s.heap[j];
			k = j;
			j <<= 1;
		}
		s.heap[k] = v;
	}
	function compress_block(s, ltree, dtree) {
		var dist;
		var lc;
		var lx = 0;
		var code;
		var extra;
		if (s.last_lit !== 0) do {
			dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
			lc = s.pending_buf[s.l_buf + lx];
			lx++;
			if (dist === 0) send_code(s, lc, ltree);
			else {
				code = _length_code[lc];
				send_code(s, code + LITERALS + 1, ltree);
				extra = extra_lbits[code];
				if (extra !== 0) {
					lc -= base_length[code];
					send_bits(s, lc, extra);
				}
				dist--;
				code = d_code(dist);
				send_code(s, code, dtree);
				extra = extra_dbits[code];
				if (extra !== 0) {
					dist -= base_dist[code];
					send_bits(s, dist, extra);
				}
			}
		} while (lx < s.last_lit);
		send_code(s, END_BLOCK, ltree);
	}
	function build_tree(s, desc) {
		var tree = desc.dyn_tree;
		var stree = desc.stat_desc.static_tree;
		var has_stree = desc.stat_desc.has_stree;
		var elems = desc.stat_desc.elems;
		var n, m;
		var max_code = -1;
		var node;
		s.heap_len = 0;
		s.heap_max = HEAP_SIZE;
		for (n = 0; n < elems; n++) if (tree[n * 2] !== 0) {
			s.heap[++s.heap_len] = max_code = n;
			s.depth[n] = 0;
		} else tree[n * 2 + 1] = 0;
		while (s.heap_len < 2) {
			node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
			tree[node * 2] = 1;
			s.depth[node] = 0;
			s.opt_len--;
			if (has_stree) s.static_len -= stree[node * 2 + 1];
		}
		desc.max_code = max_code;
		for (n = s.heap_len >> 1; n >= 1; n--) pqdownheap(s, tree, n);
		node = elems;
		do {
			/*** pqremove ***/
			n = s.heap[1];
			s.heap[1] = s.heap[s.heap_len--];
			pqdownheap(s, tree, 1);
			m = s.heap[1];
			s.heap[--s.heap_max] = n;
			s.heap[--s.heap_max] = m;
			tree[node * 2] = tree[n * 2] + tree[m * 2];
			s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
			tree[n * 2 + 1] = tree[m * 2 + 1] = node;
			s.heap[1] = node++;
			pqdownheap(s, tree, 1);
		} while (s.heap_len >= 2);
		s.heap[--s.heap_max] = s.heap[1];
		gen_bitlen(s, desc);
		gen_codes(tree, max_code, s.bl_count);
	}
	function scan_tree(s, tree, max_code) {
		var n;
		var prevlen = -1;
		var curlen;
		var nextlen = tree[1];
		var count = 0;
		var max_count = 7;
		var min_count = 4;
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[(max_code + 1) * 2 + 1] = 65535;
		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen === nextlen) continue;
			else if (count < min_count) s.bl_tree[curlen * 2] += count;
			else if (curlen !== 0) {
				if (curlen !== prevlen) s.bl_tree[curlen * 2]++;
				s.bl_tree[REP_3_6 * 2]++;
			} else if (count <= 10) s.bl_tree[REPZ_3_10 * 2]++;
			else s.bl_tree[REPZ_11_138 * 2]++;
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}
	function send_tree(s, tree, max_code) {
		var n;
		var prevlen = -1;
		var curlen;
		var nextlen = tree[1];
		var count = 0;
		var max_count = 7;
		var min_count = 4;
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen === nextlen) continue;
			else if (count < min_count) do
				send_code(s, curlen, s.bl_tree);
			while (--count !== 0);
			else if (curlen !== 0) {
				if (curlen !== prevlen) {
					send_code(s, curlen, s.bl_tree);
					count--;
				}
				send_code(s, REP_3_6, s.bl_tree);
				send_bits(s, count - 3, 2);
			} else if (count <= 10) {
				send_code(s, REPZ_3_10, s.bl_tree);
				send_bits(s, count - 3, 3);
			} else {
				send_code(s, REPZ_11_138, s.bl_tree);
				send_bits(s, count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}
	function build_bl_tree(s) {
		var max_blindex;
		scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
		scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
		build_tree(s, s.bl_desc);
		for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) break;
		s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
		return max_blindex;
	}
	function send_all_trees(s, lcodes, dcodes, blcodes) {
		var rank;
		send_bits(s, lcodes - 257, 5);
		send_bits(s, dcodes - 1, 5);
		send_bits(s, blcodes - 4, 4);
		for (rank = 0; rank < blcodes; rank++) send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
		send_tree(s, s.dyn_ltree, lcodes - 1);
		send_tree(s, s.dyn_dtree, dcodes - 1);
	}
	function detect_data_type(s) {
		var black_mask = 4093624447;
		var n;
		for (n = 0; n <= 31; n++, black_mask >>>= 1) if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) return Z_BINARY;
		if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0) return Z_TEXT;
		for (n = 32; n < LITERALS; n++) if (s.dyn_ltree[n * 2] !== 0) return Z_TEXT;
		return Z_BINARY;
	}
	var static_init_done = false;
	function _tr_init(s) {
		if (!static_init_done) {
			tr_static_init();
			static_init_done = true;
		}
		s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
		s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
		s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
		s.bi_buf = 0;
		s.bi_valid = 0;
		init_block(s);
	}
	function _tr_stored_block(s, buf, stored_len, last) {
		send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
		copy_block(s, buf, stored_len, true);
	}
	function _tr_align(s) {
		send_bits(s, STATIC_TREES << 1, 3);
		send_code(s, END_BLOCK, static_ltree);
		bi_flush(s);
	}
	function _tr_flush_block(s, buf, stored_len, last) {
		var opt_lenb, static_lenb;
		var max_blindex = 0;
		if (s.level > 0) {
			if (s.strm.data_type === Z_UNKNOWN) s.strm.data_type = detect_data_type(s);
			build_tree(s, s.l_desc);
			build_tree(s, s.d_desc);
			max_blindex = build_bl_tree(s);
			opt_lenb = s.opt_len + 3 + 7 >>> 3;
			static_lenb = s.static_len + 3 + 7 >>> 3;
			if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
		} else opt_lenb = static_lenb = stored_len + 5;
		if (stored_len + 4 <= opt_lenb && buf !== -1) _tr_stored_block(s, buf, stored_len, last);
		else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
			send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
			compress_block(s, static_ltree, static_dtree);
		} else {
			send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
			send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
			compress_block(s, s.dyn_ltree, s.dyn_dtree);
		}
		init_block(s);
		if (last) bi_windup(s);
	}
	function _tr_tally(s, dist, lc) {
		s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
		s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
		s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
		s.last_lit++;
		if (dist === 0) s.dyn_ltree[lc * 2]++;
		else {
			s.matches++;
			dist--;
			s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
			s.dyn_dtree[d_code(dist) * 2]++;
		}
		return s.last_lit === s.lit_bufsize - 1;
	}
	exports._tr_init = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function adler32(adler, buf, len, pos) {
		var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
		while (len !== 0) {
			n = len > 2e3 ? 2e3 : len;
			len -= n;
			do {
				s1 = s1 + buf[pos++] | 0;
				s2 = s2 + s1 | 0;
			} while (--n);
			s1 %= 65521;
			s2 %= 65521;
		}
		return s1 | s2 << 16 | 0;
	}
	module.exports = adler32;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function makeTable() {
		var c, table = [];
		for (var n = 0; n < 256; n++) {
			c = n;
			for (var k = 0; k < 8; k++) c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
			table[n] = c;
		}
		return table;
	}
	var crcTable = makeTable();
	function crc32(crc, buf, len, pos) {
		var t = crcTable, end = pos + len;
		crc ^= -1;
		for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
		return crc ^ -1;
	}
	module.exports = crc32;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		2: "need dictionary",
		1: "stream end",
		0: "",
		"-1": "file error",
		"-2": "stream error",
		"-3": "data error",
		"-4": "insufficient memory",
		"-5": "buffer error",
		"-6": "incompatible version"
	};
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utils = require_common();
	var trees = require_trees();
	var adler32 = require_adler32();
	var crc32 = require_crc32();
	var msg = require_messages();
	var Z_NO_FLUSH = 0;
	var Z_PARTIAL_FLUSH = 1;
	var Z_FULL_FLUSH = 3;
	var Z_FINISH = 4;
	var Z_BLOCK = 5;
	var Z_OK = 0;
	var Z_STREAM_END = 1;
	var Z_STREAM_ERROR = -2;
	var Z_DATA_ERROR = -3;
	var Z_BUF_ERROR = -5;
	var Z_DEFAULT_COMPRESSION = -1;
	var Z_FILTERED = 1;
	var Z_HUFFMAN_ONLY = 2;
	var Z_RLE = 3;
	var Z_FIXED = 4;
	var Z_DEFAULT_STRATEGY = 0;
	var Z_UNKNOWN = 2;
	var Z_DEFLATED = 8;
	var MAX_MEM_LEVEL = 9;
	var MAX_WBITS = 15;
	var DEF_MEM_LEVEL = 8;
	var L_CODES = 286;
	var D_CODES = 30;
	var BL_CODES = 19;
	var HEAP_SIZE = 2 * L_CODES + 1;
	var MAX_BITS = 15;
	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
	var PRESET_DICT = 32;
	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;
	var BS_NEED_MORE = 1;
	var BS_BLOCK_DONE = 2;
	var BS_FINISH_STARTED = 3;
	var BS_FINISH_DONE = 4;
	var OS_CODE = 3;
	function err(strm, errorCode) {
		strm.msg = msg[errorCode];
		return errorCode;
	}
	function rank(f) {
		return (f << 1) - (f > 4 ? 9 : 0);
	}
	function zero(buf) {
		var len = buf.length;
		while (--len >= 0) buf[len] = 0;
	}
	function flush_pending(strm) {
		var s = strm.state;
		var len = s.pending;
		if (len > strm.avail_out) len = strm.avail_out;
		if (len === 0) return;
		utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
		strm.next_out += len;
		s.pending_out += len;
		strm.total_out += len;
		strm.avail_out -= len;
		s.pending -= len;
		if (s.pending === 0) s.pending_out = 0;
	}
	function flush_block_only(s, last) {
		trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
		s.block_start = s.strstart;
		flush_pending(s.strm);
	}
	function put_byte(s, b) {
		s.pending_buf[s.pending++] = b;
	}
	function putShortMSB(s, b) {
		s.pending_buf[s.pending++] = b >>> 8 & 255;
		s.pending_buf[s.pending++] = b & 255;
	}
	function read_buf(strm, buf, start, size) {
		var len = strm.avail_in;
		if (len > size) len = size;
		if (len === 0) return 0;
		strm.avail_in -= len;
		utils.arraySet(buf, strm.input, strm.next_in, len, start);
		if (strm.state.wrap === 1) strm.adler = adler32(strm.adler, buf, len, start);
		else if (strm.state.wrap === 2) strm.adler = crc32(strm.adler, buf, len, start);
		strm.next_in += len;
		strm.total_in += len;
		return len;
	}
	function longest_match(s, cur_match) {
		var chain_length = s.max_chain_length;
		var scan = s.strstart;
		var match;
		var len;
		var best_len = s.prev_length;
		var nice_match = s.nice_match;
		var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
		var _win = s.window;
		var wmask = s.w_mask;
		var prev = s.prev;
		var strend = s.strstart + MAX_MATCH;
		var scan_end1 = _win[scan + best_len - 1];
		var scan_end = _win[scan + best_len];
		if (s.prev_length >= s.good_match) chain_length >>= 2;
		if (nice_match > s.lookahead) nice_match = s.lookahead;
		do {
			match = cur_match;
			if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) continue;
			scan += 2;
			match++;
			do			;
while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
			len = MAX_MATCH - (strend - scan);
			scan = strend - MAX_MATCH;
			if (len > best_len) {
				s.match_start = cur_match;
				best_len = len;
				if (len >= nice_match) break;
				scan_end1 = _win[scan + best_len - 1];
				scan_end = _win[scan + best_len];
			}
		} while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
		if (best_len <= s.lookahead) return best_len;
		return s.lookahead;
	}
	function fill_window(s) {
		var _w_size = s.w_size;
		var p, n, m, more, str;
		do {
			more = s.window_size - s.lookahead - s.strstart;
			if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
				utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
				s.match_start -= _w_size;
				s.strstart -= _w_size;
				s.block_start -= _w_size;
				n = s.hash_size;
				p = n;
				do {
					m = s.head[--p];
					s.head[p] = m >= _w_size ? m - _w_size : 0;
				} while (--n);
				n = _w_size;
				p = n;
				do {
					m = s.prev[--p];
					s.prev[p] = m >= _w_size ? m - _w_size : 0;
				} while (--n);
				more += _w_size;
			}
			if (s.strm.avail_in === 0) break;
			n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
			s.lookahead += n;
			if (s.lookahead + s.insert >= MIN_MATCH) {
				str = s.strstart - s.insert;
				s.ins_h = s.window[str];
				s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
				while (s.insert) {
					s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
					s.prev[str & s.w_mask] = s.head[s.ins_h];
					s.head[s.ins_h] = str;
					str++;
					s.insert--;
					if (s.lookahead + s.insert < MIN_MATCH) break;
				}
			}
		} while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
	}
	function deflate_stored(s, flush) {
		var max_block_size = 65535;
		if (max_block_size > s.pending_buf_size - 5) max_block_size = s.pending_buf_size - 5;
		for (;;) {
			if (s.lookahead <= 1) {
				fill_window(s);
				if (s.lookahead === 0 && flush === Z_NO_FLUSH) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			s.strstart += s.lookahead;
			s.lookahead = 0;
			var max_start = s.block_start + max_block_size;
			if (s.strstart === 0 || s.strstart >= max_start) {
				s.lookahead = s.strstart - max_start;
				s.strstart = max_start;
				/*** FLUSH_BLOCK(s, 0); ***/
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
			if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
				/*** FLUSH_BLOCK(s, 0); ***/
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = 0;
		if (flush === Z_FINISH) {
			/*** FLUSH_BLOCK(s, 1); ***/
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.strstart > s.block_start) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_NEED_MORE;
	}
	function deflate_fast(s, flush) {
		var hash_head;
		var bflush;
		for (;;) {
			if (s.lookahead < MIN_LOOKAHEAD) {
				fill_window(s);
				if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			hash_head = 0;
			if (s.lookahead >= MIN_MATCH) {
				/*** INSERT_STRING(s, s.strstart, hash_head); ***/
				s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
				hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = s.strstart;
			}
			if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) s.match_length = longest_match(s, hash_head);
			if (s.match_length >= MIN_MATCH) {
				/*** _tr_tally_dist(s, s.strstart - s.match_start,
				s.match_length - MIN_MATCH, bflush); ***/
				bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
				s.lookahead -= s.match_length;
				if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
					s.match_length--;
					do {
						s.strstart++;
						/*** INSERT_STRING(s, s.strstart, hash_head); ***/
						s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
						hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
						s.head[s.ins_h] = s.strstart;
					} while (--s.match_length !== 0);
					s.strstart++;
				} else {
					s.strstart += s.match_length;
					s.match_length = 0;
					s.ins_h = s.window[s.strstart];
					s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
				}
			} else {
				/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
				bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
				s.lookahead--;
				s.strstart++;
			}
			if (bflush) {
				/*** FLUSH_BLOCK(s, 0); ***/
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
		if (flush === Z_FINISH) {
			/*** FLUSH_BLOCK(s, 1); ***/
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.last_lit) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	}
	function deflate_slow(s, flush) {
		var hash_head;
		var bflush;
		var max_insert;
		for (;;) {
			if (s.lookahead < MIN_LOOKAHEAD) {
				fill_window(s);
				if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			hash_head = 0;
			if (s.lookahead >= MIN_MATCH) {
				/*** INSERT_STRING(s, s.strstart, hash_head); ***/
				s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
				hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = s.strstart;
			}
			s.prev_length = s.match_length;
			s.prev_match = s.match_start;
			s.match_length = MIN_MATCH - 1;
			if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
				s.match_length = longest_match(s, hash_head);
				if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) s.match_length = MIN_MATCH - 1;
			}
			if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
				max_insert = s.strstart + s.lookahead - MIN_MATCH;
				/***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
				s.prev_length - MIN_MATCH, bflush);***/
				bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
				s.lookahead -= s.prev_length - 1;
				s.prev_length -= 2;
				do
					if (++s.strstart <= max_insert) {
						/*** INSERT_STRING(s, s.strstart, hash_head); ***/
						s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
						hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
						s.head[s.ins_h] = s.strstart;
					}
				while (--s.prev_length !== 0);
				s.match_available = 0;
				s.match_length = MIN_MATCH - 1;
				s.strstart++;
				if (bflush) {
					/*** FLUSH_BLOCK(s, 0); ***/
					flush_block_only(s, false);
					if (s.strm.avail_out === 0) return BS_NEED_MORE;
				}
			} else if (s.match_available) {
				/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
				bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
				if (bflush)
 /*** FLUSH_BLOCK_ONLY(s, 0) ***/
				flush_block_only(s, false);
				s.strstart++;
				s.lookahead--;
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			} else {
				s.match_available = 1;
				s.strstart++;
				s.lookahead--;
			}
		}
		if (s.match_available) {
			/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
			bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
			s.match_available = 0;
		}
		s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
		if (flush === Z_FINISH) {
			/*** FLUSH_BLOCK(s, 1); ***/
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.last_lit) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	}
	function deflate_rle(s, flush) {
		var bflush;
		var prev;
		var scan, strend;
		var _win = s.window;
		for (;;) {
			if (s.lookahead <= MAX_MATCH) {
				fill_window(s);
				if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			s.match_length = 0;
			if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
				scan = s.strstart - 1;
				prev = _win[scan];
				if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
					strend = s.strstart + MAX_MATCH;
					do					;
while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
					s.match_length = MAX_MATCH - (strend - scan);
					if (s.match_length > s.lookahead) s.match_length = s.lookahead;
				}
			}
			if (s.match_length >= MIN_MATCH) {
				/*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
				bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
				s.lookahead -= s.match_length;
				s.strstart += s.match_length;
				s.match_length = 0;
			} else {
				/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
				bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
				s.lookahead--;
				s.strstart++;
			}
			if (bflush) {
				/*** FLUSH_BLOCK(s, 0); ***/
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = 0;
		if (flush === Z_FINISH) {
			/*** FLUSH_BLOCK(s, 1); ***/
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.last_lit) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	}
	function deflate_huff(s, flush) {
		var bflush;
		for (;;) {
			if (s.lookahead === 0) {
				fill_window(s);
				if (s.lookahead === 0) {
					if (flush === Z_NO_FLUSH) return BS_NEED_MORE;
					break;
				}
			}
			s.match_length = 0;
			/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
			bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
			s.lookahead--;
			s.strstart++;
			if (bflush) {
				/*** FLUSH_BLOCK(s, 0); ***/
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = 0;
		if (flush === Z_FINISH) {
			/*** FLUSH_BLOCK(s, 1); ***/
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.last_lit) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	}
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
		this.good_length = good_length;
		this.max_lazy = max_lazy;
		this.nice_length = nice_length;
		this.max_chain = max_chain;
		this.func = func;
	}
	var configuration_table = [
		new Config(0, 0, 0, 0, deflate_stored),
		new Config(4, 4, 8, 4, deflate_fast),
		new Config(4, 5, 16, 8, deflate_fast),
		new Config(4, 6, 32, 32, deflate_fast),
		new Config(4, 4, 16, 16, deflate_slow),
		new Config(8, 16, 32, 32, deflate_slow),
		new Config(8, 16, 128, 128, deflate_slow),
		new Config(8, 32, 128, 256, deflate_slow),
		new Config(32, 128, 258, 1024, deflate_slow),
		new Config(32, 258, 258, 4096, deflate_slow)
	];
	function lm_init(s) {
		s.window_size = 2 * s.w_size;
		/*** CLEAR_HASH(s); ***/
		zero(s.head);
		s.max_lazy_match = configuration_table[s.level].max_lazy;
		s.good_match = configuration_table[s.level].good_length;
		s.nice_match = configuration_table[s.level].nice_length;
		s.max_chain_length = configuration_table[s.level].max_chain;
		s.strstart = 0;
		s.block_start = 0;
		s.lookahead = 0;
		s.insert = 0;
		s.match_length = s.prev_length = MIN_MATCH - 1;
		s.match_available = 0;
		s.ins_h = 0;
	}
	function DeflateState() {
		this.strm = null;
		this.status = 0;
		this.pending_buf = null;
		this.pending_buf_size = 0;
		this.pending_out = 0;
		this.pending = 0;
		this.wrap = 0;
		this.gzhead = null;
		this.gzindex = 0;
		this.method = Z_DEFLATED;
		this.last_flush = -1;
		this.w_size = 0;
		this.w_bits = 0;
		this.w_mask = 0;
		this.window = null;
		this.window_size = 0;
		this.prev = null;
		this.head = null;
		this.ins_h = 0;
		this.hash_size = 0;
		this.hash_bits = 0;
		this.hash_mask = 0;
		this.hash_shift = 0;
		this.block_start = 0;
		this.match_length = 0;
		this.prev_match = 0;
		this.match_available = 0;
		this.strstart = 0;
		this.match_start = 0;
		this.lookahead = 0;
		this.prev_length = 0;
		this.max_chain_length = 0;
		this.max_lazy_match = 0;
		this.level = 0;
		this.strategy = 0;
		this.good_match = 0;
		this.nice_match = 0;
		this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
		this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
		this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
		zero(this.dyn_ltree);
		zero(this.dyn_dtree);
		zero(this.bl_tree);
		this.l_desc = null;
		this.d_desc = null;
		this.bl_desc = null;
		this.bl_count = new utils.Buf16(MAX_BITS + 1);
		this.heap = new utils.Buf16(2 * L_CODES + 1);
		zero(this.heap);
		this.heap_len = 0;
		this.heap_max = 0;
		this.depth = new utils.Buf16(2 * L_CODES + 1);
		zero(this.depth);
		this.l_buf = 0;
		this.lit_bufsize = 0;
		this.last_lit = 0;
		this.d_buf = 0;
		this.opt_len = 0;
		this.static_len = 0;
		this.matches = 0;
		this.insert = 0;
		this.bi_buf = 0;
		this.bi_valid = 0;
	}
	function deflateResetKeep(strm) {
		var s;
		if (!strm || !strm.state) return err(strm, Z_STREAM_ERROR);
		strm.total_in = strm.total_out = 0;
		strm.data_type = Z_UNKNOWN;
		s = strm.state;
		s.pending = 0;
		s.pending_out = 0;
		if (s.wrap < 0) s.wrap = -s.wrap;
		s.status = s.wrap ? INIT_STATE : BUSY_STATE;
		strm.adler = s.wrap === 2 ? 0 : 1;
		s.last_flush = Z_NO_FLUSH;
		trees._tr_init(s);
		return Z_OK;
	}
	function deflateReset(strm) {
		var ret = deflateResetKeep(strm);
		if (ret === Z_OK) lm_init(strm.state);
		return ret;
	}
	function deflateSetHeader(strm, head) {
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		if (strm.state.wrap !== 2) return Z_STREAM_ERROR;
		strm.state.gzhead = head;
		return Z_OK;
	}
	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
		if (!strm) return Z_STREAM_ERROR;
		var wrap = 1;
		if (level === Z_DEFAULT_COMPRESSION) level = 6;
		if (windowBits < 0) {
			wrap = 0;
			windowBits = -windowBits;
		} else if (windowBits > 15) {
			wrap = 2;
			windowBits -= 16;
		}
		if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) return err(strm, Z_STREAM_ERROR);
		if (windowBits === 8) windowBits = 9;
		var s = new DeflateState();
		strm.state = s;
		s.strm = strm;
		s.wrap = wrap;
		s.gzhead = null;
		s.w_bits = windowBits;
		s.w_size = 1 << s.w_bits;
		s.w_mask = s.w_size - 1;
		s.hash_bits = memLevel + 7;
		s.hash_size = 1 << s.hash_bits;
		s.hash_mask = s.hash_size - 1;
		s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
		s.window = new utils.Buf8(s.w_size * 2);
		s.head = new utils.Buf16(s.hash_size);
		s.prev = new utils.Buf16(s.w_size);
		s.lit_bufsize = 1 << memLevel + 6;
		s.pending_buf_size = s.lit_bufsize * 4;
		s.pending_buf = new utils.Buf8(s.pending_buf_size);
		s.d_buf = 1 * s.lit_bufsize;
		s.l_buf = 3 * s.lit_bufsize;
		s.level = level;
		s.strategy = strategy;
		s.method = method;
		return deflateReset(strm);
	}
	function deflateInit(strm, level) {
		return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}
	function deflate(strm, flush) {
		var old_flush, s;
		var beg, val;
		if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
		s = strm.state;
		if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
		s.strm = strm;
		old_flush = s.last_flush;
		s.last_flush = flush;
		if (s.status === INIT_STATE) if (s.wrap === 2) {
			strm.adler = 0;
			put_byte(s, 31);
			put_byte(s, 139);
			put_byte(s, 8);
			if (!s.gzhead) {
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
				put_byte(s, OS_CODE);
				s.status = BUSY_STATE;
			} else {
				put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
				put_byte(s, s.gzhead.time & 255);
				put_byte(s, s.gzhead.time >> 8 & 255);
				put_byte(s, s.gzhead.time >> 16 & 255);
				put_byte(s, s.gzhead.time >> 24 & 255);
				put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
				put_byte(s, s.gzhead.os & 255);
				if (s.gzhead.extra && s.gzhead.extra.length) {
					put_byte(s, s.gzhead.extra.length & 255);
					put_byte(s, s.gzhead.extra.length >> 8 & 255);
				}
				if (s.gzhead.hcrc) strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
				s.gzindex = 0;
				s.status = EXTRA_STATE;
			}
		} else {
			var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
			var level_flags = -1;
			if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) level_flags = 0;
			else if (s.level < 6) level_flags = 1;
			else if (s.level === 6) level_flags = 2;
			else level_flags = 3;
			header |= level_flags << 6;
			if (s.strstart !== 0) header |= PRESET_DICT;
			header += 31 - header % 31;
			s.status = BUSY_STATE;
			putShortMSB(s, header);
			if (s.strstart !== 0) {
				putShortMSB(s, strm.adler >>> 16);
				putShortMSB(s, strm.adler & 65535);
			}
			strm.adler = 1;
		}
		if (s.status === EXTRA_STATE) if (s.gzhead.extra) {
			beg = s.pending;
			while (s.gzindex < (s.gzhead.extra.length & 65535)) {
				if (s.pending === s.pending_buf_size) {
					if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
					flush_pending(strm);
					beg = s.pending;
					if (s.pending === s.pending_buf_size) break;
				}
				put_byte(s, s.gzhead.extra[s.gzindex] & 255);
				s.gzindex++;
			}
			if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
			if (s.gzindex === s.gzhead.extra.length) {
				s.gzindex = 0;
				s.status = NAME_STATE;
			}
		} else s.status = NAME_STATE;
		if (s.status === NAME_STATE) if (s.gzhead.name) {
			beg = s.pending;
			do {
				if (s.pending === s.pending_buf_size) {
					if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
					flush_pending(strm);
					beg = s.pending;
					if (s.pending === s.pending_buf_size) {
						val = 1;
						break;
					}
				}
				if (s.gzindex < s.gzhead.name.length) val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
				else val = 0;
				put_byte(s, val);
			} while (val !== 0);
			if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
			if (val === 0) {
				s.gzindex = 0;
				s.status = COMMENT_STATE;
			}
		} else s.status = COMMENT_STATE;
		if (s.status === COMMENT_STATE) if (s.gzhead.comment) {
			beg = s.pending;
			do {
				if (s.pending === s.pending_buf_size) {
					if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
					flush_pending(strm);
					beg = s.pending;
					if (s.pending === s.pending_buf_size) {
						val = 1;
						break;
					}
				}
				if (s.gzindex < s.gzhead.comment.length) val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
				else val = 0;
				put_byte(s, val);
			} while (val !== 0);
			if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
			if (val === 0) s.status = HCRC_STATE;
		} else s.status = HCRC_STATE;
		if (s.status === HCRC_STATE) if (s.gzhead.hcrc) {
			if (s.pending + 2 > s.pending_buf_size) flush_pending(strm);
			if (s.pending + 2 <= s.pending_buf_size) {
				put_byte(s, strm.adler & 255);
				put_byte(s, strm.adler >> 8 & 255);
				strm.adler = 0;
				s.status = BUSY_STATE;
			}
		} else s.status = BUSY_STATE;
		if (s.pending !== 0) {
			flush_pending(strm);
			if (strm.avail_out === 0) {
				s.last_flush = -1;
				return Z_OK;
			}
		} else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) return err(strm, Z_BUF_ERROR);
		if (s.status === FINISH_STATE && strm.avail_in !== 0) return err(strm, Z_BUF_ERROR);
		if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
			var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
			if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) s.status = FINISH_STATE;
			if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
				if (strm.avail_out === 0) s.last_flush = -1;
				return Z_OK;
			}
			if (bstate === BS_BLOCK_DONE) {
				if (flush === Z_PARTIAL_FLUSH) trees._tr_align(s);
				else if (flush !== Z_BLOCK) {
					trees._tr_stored_block(s, 0, 0, false);
					if (flush === Z_FULL_FLUSH) {
						/*** CLEAR_HASH(s); ***/ zero(s.head);
						if (s.lookahead === 0) {
							s.strstart = 0;
							s.block_start = 0;
							s.insert = 0;
						}
					}
				}
				flush_pending(strm);
				if (strm.avail_out === 0) {
					s.last_flush = -1;
					return Z_OK;
				}
			}
		}
		if (flush !== Z_FINISH) return Z_OK;
		if (s.wrap <= 0) return Z_STREAM_END;
		if (s.wrap === 2) {
			put_byte(s, strm.adler & 255);
			put_byte(s, strm.adler >> 8 & 255);
			put_byte(s, strm.adler >> 16 & 255);
			put_byte(s, strm.adler >> 24 & 255);
			put_byte(s, strm.total_in & 255);
			put_byte(s, strm.total_in >> 8 & 255);
			put_byte(s, strm.total_in >> 16 & 255);
			put_byte(s, strm.total_in >> 24 & 255);
		} else {
			putShortMSB(s, strm.adler >>> 16);
			putShortMSB(s, strm.adler & 65535);
		}
		flush_pending(strm);
		if (s.wrap > 0) s.wrap = -s.wrap;
		return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}
	function deflateEnd(strm) {
		var status;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		status = strm.state.status;
		if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) return err(strm, Z_STREAM_ERROR);
		strm.state = null;
		return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}
	function deflateSetDictionary(strm, dictionary) {
		var dictLength = dictionary.length;
		var s;
		var str, n;
		var wrap;
		var avail;
		var next;
		var input;
		var tmpDict;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		s = strm.state;
		wrap = s.wrap;
		if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR;
		if (wrap === 1) strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
		s.wrap = 0;
		if (dictLength >= s.w_size) {
			if (wrap === 0) {
				/*** CLEAR_HASH(s); ***/
				zero(s.head);
				s.strstart = 0;
				s.block_start = 0;
				s.insert = 0;
			}
			tmpDict = new utils.Buf8(s.w_size);
			utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
			dictionary = tmpDict;
			dictLength = s.w_size;
		}
		avail = strm.avail_in;
		next = strm.next_in;
		input = strm.input;
		strm.avail_in = dictLength;
		strm.next_in = 0;
		strm.input = dictionary;
		fill_window(s);
		while (s.lookahead >= MIN_MATCH) {
			str = s.strstart;
			n = s.lookahead - (MIN_MATCH - 1);
			do {
				s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
				s.prev[str & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = str;
				str++;
			} while (--n);
			s.strstart = str;
			s.lookahead = MIN_MATCH - 1;
			fill_window(s);
		}
		s.strstart += s.lookahead;
		s.block_start = s.strstart;
		s.insert = s.lookahead;
		s.lookahead = 0;
		s.match_length = s.prev_length = MIN_MATCH - 1;
		s.match_available = 0;
		strm.next_in = next;
		strm.input = input;
		strm.avail_in = avail;
		s.wrap = wrap;
		return Z_OK;
	}
	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateInfo = "pako deflate (from Nodeca project)";
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/utils/strings.js
var require_strings = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utils = require_common();
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;
	try {
		String.fromCharCode.apply(null, [0]);
	} catch (__) {
		STR_APPLY_OK = false;
	}
	try {
		String.fromCharCode.apply(null, new Uint8Array(1));
	} catch (__) {
		STR_APPLY_UIA_OK = false;
	}
	var _utf8len = new utils.Buf8(256);
	for (var q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
	_utf8len[254] = _utf8len[254] = 1;
	exports.string2buf = function(str) {
		var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
		for (m_pos = 0; m_pos < str_len; m_pos++) {
			c = str.charCodeAt(m_pos);
			if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
				c2 = str.charCodeAt(m_pos + 1);
				if ((c2 & 64512) === 56320) {
					c = 65536 + (c - 55296 << 10) + (c2 - 56320);
					m_pos++;
				}
			}
			buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
		}
		buf = new utils.Buf8(buf_len);
		for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
			c = str.charCodeAt(m_pos);
			if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
				c2 = str.charCodeAt(m_pos + 1);
				if ((c2 & 64512) === 56320) {
					c = 65536 + (c - 55296 << 10) + (c2 - 56320);
					m_pos++;
				}
			}
			if (c < 128) buf[i++] = c;
			else if (c < 2048) {
				buf[i++] = 192 | c >>> 6;
				buf[i++] = 128 | c & 63;
			} else if (c < 65536) {
				buf[i++] = 224 | c >>> 12;
				buf[i++] = 128 | c >>> 6 & 63;
				buf[i++] = 128 | c & 63;
			} else {
				buf[i++] = 240 | c >>> 18;
				buf[i++] = 128 | c >>> 12 & 63;
				buf[i++] = 128 | c >>> 6 & 63;
				buf[i++] = 128 | c & 63;
			}
		}
		return buf;
	};
	function buf2binstring(buf, len) {
		if (len < 65534) {
			if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
		}
		var result = "";
		for (var i = 0; i < len; i++) result += String.fromCharCode(buf[i]);
		return result;
	}
	exports.buf2binstring = function(buf) {
		return buf2binstring(buf, buf.length);
	};
	exports.binstring2buf = function(str) {
		var buf = new utils.Buf8(str.length);
		for (var i = 0, len = buf.length; i < len; i++) buf[i] = str.charCodeAt(i);
		return buf;
	};
	exports.buf2string = function(buf, max) {
		var i, out, c, c_len;
		var len = max || buf.length;
		var utf16buf = new Array(len * 2);
		for (out = 0, i = 0; i < len;) {
			c = buf[i++];
			if (c < 128) {
				utf16buf[out++] = c;
				continue;
			}
			c_len = _utf8len[c];
			if (c_len > 4) {
				utf16buf[out++] = 65533;
				i += c_len - 1;
				continue;
			}
			c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
			while (c_len > 1 && i < len) {
				c = c << 6 | buf[i++] & 63;
				c_len--;
			}
			if (c_len > 1) {
				utf16buf[out++] = 65533;
				continue;
			}
			if (c < 65536) utf16buf[out++] = c;
			else {
				c -= 65536;
				utf16buf[out++] = 55296 | c >> 10 & 1023;
				utf16buf[out++] = 56320 | c & 1023;
			}
		}
		return buf2binstring(utf16buf, out);
	};
	exports.utf8border = function(buf, max) {
		var pos;
		max = max || buf.length;
		if (max > buf.length) max = buf.length;
		pos = max - 1;
		while (pos >= 0 && (buf[pos] & 192) === 128) pos--;
		if (pos < 0) return max;
		if (pos === 0) return max;
		return pos + _utf8len[buf[pos]] > max ? pos : max;
	};
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function ZStream() {
		this.input = null;
		this.next_in = 0;
		this.avail_in = 0;
		this.total_in = 0;
		this.output = null;
		this.next_out = 0;
		this.avail_out = 0;
		this.total_out = 0;
		this.msg = "";
		this.state = null;
		this.data_type = 2;
		this.adler = 0;
	}
	module.exports = ZStream;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/deflate.js
var require_deflate = /* @__PURE__ */ __commonJSMin(((exports) => {
	var zlib_deflate = require_deflate$1();
	var utils = require_common();
	var strings = require_strings();
	var msg = require_messages();
	var ZStream = require_zstream();
	var toString = Object.prototype.toString;
	var Z_NO_FLUSH = 0;
	var Z_FINISH = 4;
	var Z_OK = 0;
	var Z_STREAM_END = 1;
	var Z_SYNC_FLUSH = 2;
	var Z_DEFAULT_COMPRESSION = -1;
	var Z_DEFAULT_STRATEGY = 0;
	var Z_DEFLATED = 8;
	/**
	* class Deflate
	*
	* Generic JS-style wrapper for zlib calls. If you don't need
	* streaming behaviour - use more simple functions: [[deflate]],
	* [[deflateRaw]] and [[gzip]].
	**/
	/**
	* Deflate.result -> Uint8Array|Array
	*
	* Compressed result, generated by default [[Deflate#onData]]
	* and [[Deflate#onEnd]] handlers. Filled after you push last chunk
	* (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
	* push a chunk with explicit flush (call [[Deflate#push]] with
	* `Z_SYNC_FLUSH` param).
	**/
	/**
	* Deflate.err -> Number
	*
	* Error code after deflate finished. 0 (Z_OK) on success.
	* You will not need it in real life, because deflate errors
	* are possible only on wrong options or bad `onData` / `onEnd`
	* custom handlers.
	**/
	/**
	* Deflate.msg -> String
	*
	* Error message, if [[Deflate.err]] != 0
	**/
	/**
	* new Deflate(options)
	* - options (Object): zlib deflate options.
	*
	* Creates new deflator instance with specified params. Throws exception
	* on bad params. Supported options:
	*
	* - `level`
	* - `windowBits`
	* - `memLevel`
	* - `strategy`
	* - `dictionary`
	*
	* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	* for more information on these.
	*
	* Additional options, for internal needs:
	*
	* - `chunkSize` - size of generated data chunks (16K by default)
	* - `raw` (Boolean) - do raw deflate
	* - `gzip` (Boolean) - create gzip wrapper
	* - `to` (String) - if equal to 'string', then result will be "binary string"
	*    (each char code [0..255])
	* - `header` (Object) - custom header for gzip
	*   - `text` (Boolean) - true if compressed data believed to be text
	*   - `time` (Number) - modification time, unix timestamp
	*   - `os` (Number) - operation system code
	*   - `extra` (Array) - array of bytes with extra data (max 65536)
	*   - `name` (String) - file name (binary string)
	*   - `comment` (String) - comment (binary string)
	*   - `hcrc` (Boolean) - true if header crc should be added
	*
	* ##### Example:
	*
	* ```javascript
	* var pako = require('pako')
	*   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	*   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	*
	* var deflate = new pako.Deflate({ level: 3});
	*
	* deflate.push(chunk1, false);
	* deflate.push(chunk2, true);  // true -> last chunk
	*
	* if (deflate.err) { throw new Error(deflate.err); }
	*
	* console.log(deflate.result);
	* ```
	**/
	function Deflate(options) {
		if (!(this instanceof Deflate)) return new Deflate(options);
		this.options = utils.assign({
			level: Z_DEFAULT_COMPRESSION,
			method: Z_DEFLATED,
			chunkSize: 16384,
			windowBits: 15,
			memLevel: 8,
			strategy: Z_DEFAULT_STRATEGY,
			to: ""
		}, options || {});
		var opt = this.options;
		if (opt.raw && opt.windowBits > 0) opt.windowBits = -opt.windowBits;
		else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) opt.windowBits += 16;
		this.err = 0;
		this.msg = "";
		this.ended = false;
		this.chunks = [];
		this.strm = new ZStream();
		this.strm.avail_out = 0;
		var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
		if (status !== Z_OK) throw new Error(msg[status]);
		if (opt.header) zlib_deflate.deflateSetHeader(this.strm, opt.header);
		if (opt.dictionary) {
			var dict;
			if (typeof opt.dictionary === "string") dict = strings.string2buf(opt.dictionary);
			else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") dict = new Uint8Array(opt.dictionary);
			else dict = opt.dictionary;
			status = zlib_deflate.deflateSetDictionary(this.strm, dict);
			if (status !== Z_OK) throw new Error(msg[status]);
			this._dict_set = true;
		}
	}
	/**
	* Deflate#push(data[, mode]) -> Boolean
	* - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
	*   converted to utf8 byte sequence.
	* - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	*   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	*
	* Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
	* new compressed chunks. Returns `true` on success. The last data block must have
	* mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	* [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	* can use mode Z_SYNC_FLUSH, keeping the compression context.
	*
	* On fail call [[Deflate#onEnd]] with error code and return false.
	*
	* We strongly recommend to use `Uint8Array` on input for best speed (output
	* array format is detected automatically). Also, don't skip last param and always
	* use the same type in your code (boolean or number). That will improve JS speed.
	*
	* For regular `Array`-s make sure all elements are [0..255].
	*
	* ##### Example
	*
	* ```javascript
	* push(chunk, false); // push one of data chunks
	* ...
	* push(chunk, true);  // push last chunk
	* ```
	**/
	Deflate.prototype.push = function(data, mode) {
		var strm = this.strm;
		var chunkSize = this.options.chunkSize;
		var status, _mode;
		if (this.ended) return false;
		_mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
		if (typeof data === "string") strm.input = strings.string2buf(data);
		else if (toString.call(data) === "[object ArrayBuffer]") strm.input = new Uint8Array(data);
		else strm.input = data;
		strm.next_in = 0;
		strm.avail_in = strm.input.length;
		do {
			if (strm.avail_out === 0) {
				strm.output = new utils.Buf8(chunkSize);
				strm.next_out = 0;
				strm.avail_out = chunkSize;
			}
			status = zlib_deflate.deflate(strm, _mode);
			if (status !== Z_STREAM_END && status !== Z_OK) {
				this.onEnd(status);
				this.ended = true;
				return false;
			}
			if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) if (this.options.to === "string") this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
			else this.onData(utils.shrinkBuf(strm.output, strm.next_out));
		} while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
		if (_mode === Z_FINISH) {
			status = zlib_deflate.deflateEnd(this.strm);
			this.onEnd(status);
			this.ended = true;
			return status === Z_OK;
		}
		if (_mode === Z_SYNC_FLUSH) {
			this.onEnd(Z_OK);
			strm.avail_out = 0;
			return true;
		}
		return true;
	};
	/**
	* Deflate#onData(chunk) -> Void
	* - chunk (Uint8Array|Array|String): output data. Type of array depends
	*   on js engine support. When string output requested, each chunk
	*   will be string.
	*
	* By default, stores data blocks in `chunks[]` property and glue
	* those in `onEnd`. Override this handler, if you need another behaviour.
	**/
	Deflate.prototype.onData = function(chunk) {
		this.chunks.push(chunk);
	};
	/**
	* Deflate#onEnd(status) -> Void
	* - status (Number): deflate status. 0 (Z_OK) on success,
	*   other if not.
	*
	* Called once after you tell deflate that the input stream is
	* complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	* or if an error happened. By default - join collected chunks,
	* free memory and fill `results` / `err` properties.
	**/
	Deflate.prototype.onEnd = function(status) {
		if (status === Z_OK) if (this.options.to === "string") this.result = this.chunks.join("");
		else this.result = utils.flattenChunks(this.chunks);
		this.chunks = [];
		this.err = status;
		this.msg = this.strm.msg;
	};
	/**
	* deflate(data[, options]) -> Uint8Array|Array|String
	* - data (Uint8Array|Array|String): input data to compress.
	* - options (Object): zlib deflate options.
	*
	* Compress `data` with deflate algorithm and `options`.
	*
	* Supported options are:
	*
	* - level
	* - windowBits
	* - memLevel
	* - strategy
	* - dictionary
	*
	* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	* for more information on these.
	*
	* Sugar (options):
	*
	* - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	*   negative windowBits implicitly.
	* - `to` (String) - if equal to 'string', then result will be "binary string"
	*    (each char code [0..255])
	*
	* ##### Example:
	*
	* ```javascript
	* var pako = require('pako')
	*   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
	*
	* console.log(pako.deflate(data));
	* ```
	**/
	function deflate(input, options) {
		var deflator = new Deflate(options);
		deflator.push(input, true);
		if (deflator.err) throw deflator.msg || msg[deflator.err];
		return deflator.result;
	}
	/**
	* deflateRaw(data[, options]) -> Uint8Array|Array|String
	* - data (Uint8Array|Array|String): input data to compress.
	* - options (Object): zlib deflate options.
	*
	* The same as [[deflate]], but creates raw data, without wrapper
	* (header and adler32 crc).
	**/
	function deflateRaw(input, options) {
		options = options || {};
		options.raw = true;
		return deflate(input, options);
	}
	/**
	* gzip(data[, options]) -> Uint8Array|Array|String
	* - data (Uint8Array|Array|String): input data to compress.
	* - options (Object): zlib deflate options.
	*
	* The same as [[deflate]], but create gzip wrapper instead of
	* deflate one.
	**/
	function gzip(input, options) {
		options = options || {};
		options.gzip = true;
		return deflate(input, options);
	}
	exports.Deflate = Deflate;
	exports.deflate = deflate;
	exports.deflateRaw = deflateRaw;
	exports.gzip = gzip;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var BAD = 30;
	var TYPE = 12;
	module.exports = function inflate_fast(strm, start) {
		var state;
		var _in;
		var last;
		var _out;
		var beg;
		var end;
		var dmax;
		var wsize;
		var whave;
		var wnext;
		var s_window;
		var hold;
		var bits;
		var lcode;
		var dcode;
		var lmask;
		var dmask;
		var here;
		var op;
		var len;
		var dist;
		var from;
		var from_source;
		var input, output;
		state = strm.state;
		_in = strm.next_in;
		input = strm.input;
		last = _in + (strm.avail_in - 5);
		_out = strm.next_out;
		output = strm.output;
		beg = _out - (start - strm.avail_out);
		end = _out + (strm.avail_out - 257);
		dmax = state.dmax;
		wsize = state.wsize;
		whave = state.whave;
		wnext = state.wnext;
		s_window = state.window;
		hold = state.hold;
		bits = state.bits;
		lcode = state.lencode;
		dcode = state.distcode;
		lmask = (1 << state.lenbits) - 1;
		dmask = (1 << state.distbits) - 1;
		top: do {
			if (bits < 15) {
				hold += input[_in++] << bits;
				bits += 8;
				hold += input[_in++] << bits;
				bits += 8;
			}
			here = lcode[hold & lmask];
			dolen: for (;;) {
				op = here >>> 24;
				hold >>>= op;
				bits -= op;
				op = here >>> 16 & 255;
				if (op === 0) output[_out++] = here & 65535;
				else if (op & 16) {
					len = here & 65535;
					op &= 15;
					if (op) {
						if (bits < op) {
							hold += input[_in++] << bits;
							bits += 8;
						}
						len += hold & (1 << op) - 1;
						hold >>>= op;
						bits -= op;
					}
					if (bits < 15) {
						hold += input[_in++] << bits;
						bits += 8;
						hold += input[_in++] << bits;
						bits += 8;
					}
					here = dcode[hold & dmask];
					dodist: for (;;) {
						op = here >>> 24;
						hold >>>= op;
						bits -= op;
						op = here >>> 16 & 255;
						if (op & 16) {
							dist = here & 65535;
							op &= 15;
							if (bits < op) {
								hold += input[_in++] << bits;
								bits += 8;
								if (bits < op) {
									hold += input[_in++] << bits;
									bits += 8;
								}
							}
							dist += hold & (1 << op) - 1;
							if (dist > dmax) {
								strm.msg = "invalid distance too far back";
								state.mode = BAD;
								break top;
							}
							hold >>>= op;
							bits -= op;
							op = _out - beg;
							if (dist > op) {
								op = dist - op;
								if (op > whave) {
									if (state.sane) {
										strm.msg = "invalid distance too far back";
										state.mode = BAD;
										break top;
									}
								}
								from = 0;
								from_source = s_window;
								if (wnext === 0) {
									from += wsize - op;
									if (op < len) {
										len -= op;
										do
											output[_out++] = s_window[from++];
										while (--op);
										from = _out - dist;
										from_source = output;
									}
								} else if (wnext < op) {
									from += wsize + wnext - op;
									op -= wnext;
									if (op < len) {
										len -= op;
										do
											output[_out++] = s_window[from++];
										while (--op);
										from = 0;
										if (wnext < len) {
											op = wnext;
											len -= op;
											do
												output[_out++] = s_window[from++];
											while (--op);
											from = _out - dist;
											from_source = output;
										}
									}
								} else {
									from += wnext - op;
									if (op < len) {
										len -= op;
										do
											output[_out++] = s_window[from++];
										while (--op);
										from = _out - dist;
										from_source = output;
									}
								}
								while (len > 2) {
									output[_out++] = from_source[from++];
									output[_out++] = from_source[from++];
									output[_out++] = from_source[from++];
									len -= 3;
								}
								if (len) {
									output[_out++] = from_source[from++];
									if (len > 1) output[_out++] = from_source[from++];
								}
							} else {
								from = _out - dist;
								do {
									output[_out++] = output[from++];
									output[_out++] = output[from++];
									output[_out++] = output[from++];
									len -= 3;
								} while (len > 2);
								if (len) {
									output[_out++] = output[from++];
									if (len > 1) output[_out++] = output[from++];
								}
							}
						} else if ((op & 64) === 0) {
							here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
							continue dodist;
						} else {
							strm.msg = "invalid distance code";
							state.mode = BAD;
							break top;
						}
						break;
					}
				} else if ((op & 64) === 0) {
					here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
					continue dolen;
				} else if (op & 32) {
					state.mode = TYPE;
					break top;
				} else {
					strm.msg = "invalid literal/length code";
					state.mode = BAD;
					break top;
				}
				break;
			}
		} while (_in < last && _out < end);
		len = bits >> 3;
		_in -= len;
		bits -= len << 3;
		hold &= (1 << bits) - 1;
		strm.next_in = _in;
		strm.next_out = _out;
		strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
		strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
		state.hold = hold;
		state.bits = bits;
	};
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var utils = require_common();
	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	var lbase = [
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		13,
		15,
		17,
		19,
		23,
		27,
		31,
		35,
		43,
		51,
		59,
		67,
		83,
		99,
		115,
		131,
		163,
		195,
		227,
		258,
		0,
		0
	];
	var lext = [
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		17,
		17,
		17,
		17,
		18,
		18,
		18,
		18,
		19,
		19,
		19,
		19,
		20,
		20,
		20,
		20,
		21,
		21,
		21,
		21,
		16,
		72,
		78
	];
	var dbase = [
		1,
		2,
		3,
		4,
		5,
		7,
		9,
		13,
		17,
		25,
		33,
		49,
		65,
		97,
		129,
		193,
		257,
		385,
		513,
		769,
		1025,
		1537,
		2049,
		3073,
		4097,
		6145,
		8193,
		12289,
		16385,
		24577,
		0,
		0
	];
	var dext = [
		16,
		16,
		16,
		16,
		17,
		17,
		18,
		18,
		19,
		19,
		20,
		20,
		21,
		21,
		22,
		22,
		23,
		23,
		24,
		24,
		25,
		25,
		26,
		26,
		27,
		27,
		28,
		28,
		29,
		29,
		64,
		64
	];
	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
		var bits = opts.bits;
		var len = 0;
		var sym = 0;
		var min = 0, max = 0;
		var root = 0;
		var curr = 0;
		var drop = 0;
		var left = 0;
		var used = 0;
		var huff = 0;
		var incr;
		var fill;
		var low;
		var mask;
		var next;
		var base = null;
		var base_index = 0;
		var end;
		var count = new utils.Buf16(MAXBITS + 1);
		var offs = new utils.Buf16(MAXBITS + 1);
		var extra = null;
		var extra_index = 0;
		var here_bits, here_op, here_val;
		for (len = 0; len <= MAXBITS; len++) count[len] = 0;
		for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
		root = bits;
		for (max = MAXBITS; max >= 1; max--) if (count[max] !== 0) break;
		if (root > max) root = max;
		if (max === 0) {
			table[table_index++] = 20971520;
			table[table_index++] = 20971520;
			opts.bits = 1;
			return 0;
		}
		for (min = 1; min < max; min++) if (count[min] !== 0) break;
		if (root < min) root = min;
		left = 1;
		for (len = 1; len <= MAXBITS; len++) {
			left <<= 1;
			left -= count[len];
			if (left < 0) return -1;
		}
		if (left > 0 && (type === CODES || max !== 1)) return -1;
		offs[1] = 0;
		for (len = 1; len < MAXBITS; len++) offs[len + 1] = offs[len] + count[len];
		for (sym = 0; sym < codes; sym++) if (lens[lens_index + sym] !== 0) work[offs[lens[lens_index + sym]]++] = sym;
		if (type === CODES) {
			base = extra = work;
			end = 19;
		} else if (type === LENS) {
			base = lbase;
			base_index -= 257;
			extra = lext;
			extra_index -= 257;
			end = 256;
		} else {
			base = dbase;
			extra = dext;
			end = -1;
		}
		huff = 0;
		sym = 0;
		len = min;
		next = table_index;
		curr = root;
		drop = 0;
		low = -1;
		used = 1 << root;
		mask = used - 1;
		if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) return 1;
		for (;;) {
			here_bits = len - drop;
			if (work[sym] < end) {
				here_op = 0;
				here_val = work[sym];
			} else if (work[sym] > end) {
				here_op = extra[extra_index + work[sym]];
				here_val = base[base_index + work[sym]];
			} else {
				here_op = 96;
				here_val = 0;
			}
			incr = 1 << len - drop;
			fill = 1 << curr;
			min = fill;
			do {
				fill -= incr;
				table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
			} while (fill !== 0);
			incr = 1 << len - 1;
			while (huff & incr) incr >>= 1;
			if (incr !== 0) {
				huff &= incr - 1;
				huff += incr;
			} else huff = 0;
			sym++;
			if (--count[len] === 0) {
				if (len === max) break;
				len = lens[lens_index + work[sym]];
			}
			if (len > root && (huff & mask) !== low) {
				if (drop === 0) drop = root;
				next += min;
				curr = len - drop;
				left = 1 << curr;
				while (curr + drop < max) {
					left -= count[curr + drop];
					if (left <= 0) break;
					curr++;
					left <<= 1;
				}
				used += 1 << curr;
				if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) return 1;
				low = huff & mask;
				table[low] = root << 24 | curr << 16 | next - table_index | 0;
			}
		}
		if (huff !== 0) table[next + huff] = len - drop << 24 | 4194304;
		opts.bits = root;
		return 0;
	};
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utils = require_common();
	var adler32 = require_adler32();
	var crc32 = require_crc32();
	var inflate_fast = require_inffast();
	var inflate_table = require_inftrees();
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	var Z_FINISH = 4;
	var Z_BLOCK = 5;
	var Z_TREES = 6;
	var Z_OK = 0;
	var Z_STREAM_END = 1;
	var Z_NEED_DICT = 2;
	var Z_STREAM_ERROR = -2;
	var Z_DATA_ERROR = -3;
	var Z_MEM_ERROR = -4;
	var Z_BUF_ERROR = -5;
	var Z_DEFLATED = 8;
	var HEAD = 1;
	var FLAGS = 2;
	var TIME = 3;
	var OS = 4;
	var EXLEN = 5;
	var EXTRA = 6;
	var NAME = 7;
	var COMMENT = 8;
	var HCRC = 9;
	var DICTID = 10;
	var DICT = 11;
	var TYPE = 12;
	var TYPEDO = 13;
	var STORED = 14;
	var COPY_ = 15;
	var COPY = 16;
	var TABLE = 17;
	var LENLENS = 18;
	var CODELENS = 19;
	var LEN_ = 20;
	var LEN = 21;
	var LENEXT = 22;
	var DIST = 23;
	var DISTEXT = 24;
	var MATCH = 25;
	var LIT = 26;
	var CHECK = 27;
	var LENGTH = 28;
	var DONE = 29;
	var BAD = 30;
	var MEM = 31;
	var SYNC = 32;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	var DEF_WBITS = 15;
	function zswap32(q) {
		return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
	}
	function InflateState() {
		this.mode = 0;
		this.last = false;
		this.wrap = 0;
		this.havedict = false;
		this.flags = 0;
		this.dmax = 0;
		this.check = 0;
		this.total = 0;
		this.head = null;
		this.wbits = 0;
		this.wsize = 0;
		this.whave = 0;
		this.wnext = 0;
		this.window = null;
		this.hold = 0;
		this.bits = 0;
		this.length = 0;
		this.offset = 0;
		this.extra = 0;
		this.lencode = null;
		this.distcode = null;
		this.lenbits = 0;
		this.distbits = 0;
		this.ncode = 0;
		this.nlen = 0;
		this.ndist = 0;
		this.have = 0;
		this.next = null;
		this.lens = new utils.Buf16(320);
		this.work = new utils.Buf16(288);
		this.lendyn = null;
		this.distdyn = null;
		this.sane = 0;
		this.back = 0;
		this.was = 0;
	}
	function inflateResetKeep(strm) {
		var state;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		state = strm.state;
		strm.total_in = strm.total_out = state.total = 0;
		strm.msg = "";
		if (state.wrap) strm.adler = state.wrap & 1;
		state.mode = HEAD;
		state.last = 0;
		state.havedict = 0;
		state.dmax = 32768;
		state.head = null;
		state.hold = 0;
		state.bits = 0;
		state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
		state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
		state.sane = 1;
		state.back = -1;
		return Z_OK;
	}
	function inflateReset(strm) {
		var state;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		state = strm.state;
		state.wsize = 0;
		state.whave = 0;
		state.wnext = 0;
		return inflateResetKeep(strm);
	}
	function inflateReset2(strm, windowBits) {
		var wrap;
		var state;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		state = strm.state;
		if (windowBits < 0) {
			wrap = 0;
			windowBits = -windowBits;
		} else {
			wrap = (windowBits >> 4) + 1;
			if (windowBits < 48) windowBits &= 15;
		}
		if (windowBits && (windowBits < 8 || windowBits > 15)) return Z_STREAM_ERROR;
		if (state.window !== null && state.wbits !== windowBits) state.window = null;
		state.wrap = wrap;
		state.wbits = windowBits;
		return inflateReset(strm);
	}
	function inflateInit2(strm, windowBits) {
		var ret;
		var state;
		if (!strm) return Z_STREAM_ERROR;
		state = new InflateState();
		strm.state = state;
		state.window = null;
		ret = inflateReset2(strm, windowBits);
		if (ret !== Z_OK) strm.state = null;
		return ret;
	}
	function inflateInit(strm) {
		return inflateInit2(strm, DEF_WBITS);
	}
	var virgin = true;
	var lenfix, distfix;
	function fixedtables(state) {
		if (virgin) {
			var sym;
			lenfix = new utils.Buf32(512);
			distfix = new utils.Buf32(32);
			sym = 0;
			while (sym < 144) state.lens[sym++] = 8;
			while (sym < 256) state.lens[sym++] = 9;
			while (sym < 280) state.lens[sym++] = 7;
			while (sym < 288) state.lens[sym++] = 8;
			inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
			sym = 0;
			while (sym < 32) state.lens[sym++] = 5;
			inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
			virgin = false;
		}
		state.lencode = lenfix;
		state.lenbits = 9;
		state.distcode = distfix;
		state.distbits = 5;
	}
	function updatewindow(strm, src, end, copy) {
		var dist;
		var state = strm.state;
		if (state.window === null) {
			state.wsize = 1 << state.wbits;
			state.wnext = 0;
			state.whave = 0;
			state.window = new utils.Buf8(state.wsize);
		}
		if (copy >= state.wsize) {
			utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
			state.wnext = 0;
			state.whave = state.wsize;
		} else {
			dist = state.wsize - state.wnext;
			if (dist > copy) dist = copy;
			utils.arraySet(state.window, src, end - copy, dist, state.wnext);
			copy -= dist;
			if (copy) {
				utils.arraySet(state.window, src, end - copy, copy, 0);
				state.wnext = copy;
				state.whave = state.wsize;
			} else {
				state.wnext += dist;
				if (state.wnext === state.wsize) state.wnext = 0;
				if (state.whave < state.wsize) state.whave += dist;
			}
		}
		return 0;
	}
	function inflate(strm, flush) {
		var state;
		var input, output;
		var next;
		var put;
		var have, left;
		var hold;
		var bits;
		var _in, _out;
		var copy;
		var from;
		var from_source;
		var here = 0;
		var here_bits, here_op, here_val;
		var last_bits, last_op, last_val;
		var len;
		var ret;
		var hbuf = new utils.Buf8(4);
		var opts;
		var n;
		var order = [
			16,
			17,
			18,
			0,
			8,
			7,
			9,
			6,
			10,
			5,
			11,
			4,
			12,
			3,
			13,
			2,
			14,
			1,
			15
		];
		if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) return Z_STREAM_ERROR;
		state = strm.state;
		if (state.mode === TYPE) state.mode = TYPEDO;
		put = strm.next_out;
		output = strm.output;
		left = strm.avail_out;
		next = strm.next_in;
		input = strm.input;
		have = strm.avail_in;
		hold = state.hold;
		bits = state.bits;
		_in = have;
		_out = left;
		ret = Z_OK;
		inf_leave: for (;;) switch (state.mode) {
			case HEAD:
				if (state.wrap === 0) {
					state.mode = TYPEDO;
					break;
				}
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.wrap & 2 && hold === 35615) {
					state.check = 0;
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32(state.check, hbuf, 2, 0);
					hold = 0;
					bits = 0;
					state.mode = FLAGS;
					break;
				}
				state.flags = 0;
				if (state.head) state.head.done = false;
				if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
					strm.msg = "incorrect header check";
					state.mode = BAD;
					break;
				}
				if ((hold & 15) !== Z_DEFLATED) {
					strm.msg = "unknown compression method";
					state.mode = BAD;
					break;
				}
				hold >>>= 4;
				bits -= 4;
				len = (hold & 15) + 8;
				if (state.wbits === 0) state.wbits = len;
				else if (len > state.wbits) {
					strm.msg = "invalid window size";
					state.mode = BAD;
					break;
				}
				state.dmax = 1 << len;
				strm.adler = state.check = 1;
				state.mode = hold & 512 ? DICTID : TYPE;
				hold = 0;
				bits = 0;
				break;
			case FLAGS:
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.flags = hold;
				if ((state.flags & 255) !== Z_DEFLATED) {
					strm.msg = "unknown compression method";
					state.mode = BAD;
					break;
				}
				if (state.flags & 57344) {
					strm.msg = "unknown header flags set";
					state.mode = BAD;
					break;
				}
				if (state.head) state.head.text = hold >> 8 & 1;
				if (state.flags & 512) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32(state.check, hbuf, 2, 0);
				}
				hold = 0;
				bits = 0;
				state.mode = TIME;
			case TIME:
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.head) state.head.time = hold;
				if (state.flags & 512) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					hbuf[2] = hold >>> 16 & 255;
					hbuf[3] = hold >>> 24 & 255;
					state.check = crc32(state.check, hbuf, 4, 0);
				}
				hold = 0;
				bits = 0;
				state.mode = OS;
			case OS:
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.head) {
					state.head.xflags = hold & 255;
					state.head.os = hold >> 8;
				}
				if (state.flags & 512) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32(state.check, hbuf, 2, 0);
				}
				hold = 0;
				bits = 0;
				state.mode = EXLEN;
			case EXLEN:
				if (state.flags & 1024) {
					while (bits < 16) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.length = hold;
					if (state.head) state.head.extra_len = hold;
					if (state.flags & 512) {
						hbuf[0] = hold & 255;
						hbuf[1] = hold >>> 8 & 255;
						state.check = crc32(state.check, hbuf, 2, 0);
					}
					hold = 0;
					bits = 0;
				} else if (state.head) state.head.extra = null;
				state.mode = EXTRA;
			case EXTRA:
				if (state.flags & 1024) {
					copy = state.length;
					if (copy > have) copy = have;
					if (copy) {
						if (state.head) {
							len = state.head.extra_len - state.length;
							if (!state.head.extra) state.head.extra = new Array(state.head.extra_len);
							utils.arraySet(state.head.extra, input, next, copy, len);
						}
						if (state.flags & 512) state.check = crc32(state.check, input, copy, next);
						have -= copy;
						next += copy;
						state.length -= copy;
					}
					if (state.length) break inf_leave;
				}
				state.length = 0;
				state.mode = NAME;
			case NAME:
				if (state.flags & 2048) {
					if (have === 0) break inf_leave;
					copy = 0;
					do {
						len = input[next + copy++];
						if (state.head && len && state.length < 65536) state.head.name += String.fromCharCode(len);
					} while (len && copy < have);
					if (state.flags & 512) state.check = crc32(state.check, input, copy, next);
					have -= copy;
					next += copy;
					if (len) break inf_leave;
				} else if (state.head) state.head.name = null;
				state.length = 0;
				state.mode = COMMENT;
			case COMMENT:
				if (state.flags & 4096) {
					if (have === 0) break inf_leave;
					copy = 0;
					do {
						len = input[next + copy++];
						if (state.head && len && state.length < 65536) state.head.comment += String.fromCharCode(len);
					} while (len && copy < have);
					if (state.flags & 512) state.check = crc32(state.check, input, copy, next);
					have -= copy;
					next += copy;
					if (len) break inf_leave;
				} else if (state.head) state.head.comment = null;
				state.mode = HCRC;
			case HCRC:
				if (state.flags & 512) {
					while (bits < 16) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					if (hold !== (state.check & 65535)) {
						strm.msg = "header crc mismatch";
						state.mode = BAD;
						break;
					}
					hold = 0;
					bits = 0;
				}
				if (state.head) {
					state.head.hcrc = state.flags >> 9 & 1;
					state.head.done = true;
				}
				strm.adler = state.check = 0;
				state.mode = TYPE;
				break;
			case DICTID:
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				strm.adler = state.check = zswap32(hold);
				hold = 0;
				bits = 0;
				state.mode = DICT;
			case DICT:
				if (state.havedict === 0) {
					strm.next_out = put;
					strm.avail_out = left;
					strm.next_in = next;
					strm.avail_in = have;
					state.hold = hold;
					state.bits = bits;
					return Z_NEED_DICT;
				}
				strm.adler = state.check = 1;
				state.mode = TYPE;
			case TYPE: if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
			case TYPEDO:
				if (state.last) {
					hold >>>= bits & 7;
					bits -= bits & 7;
					state.mode = CHECK;
					break;
				}
				while (bits < 3) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.last = hold & 1;
				hold >>>= 1;
				bits -= 1;
				switch (hold & 3) {
					case 0:
						state.mode = STORED;
						break;
					case 1:
						fixedtables(state);
						state.mode = LEN_;
						if (flush === Z_TREES) {
							hold >>>= 2;
							bits -= 2;
							break inf_leave;
						}
						break;
					case 2:
						state.mode = TABLE;
						break;
					case 3:
						strm.msg = "invalid block type";
						state.mode = BAD;
				}
				hold >>>= 2;
				bits -= 2;
				break;
			case STORED:
				hold >>>= bits & 7;
				bits -= bits & 7;
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
					strm.msg = "invalid stored block lengths";
					state.mode = BAD;
					break;
				}
				state.length = hold & 65535;
				hold = 0;
				bits = 0;
				state.mode = COPY_;
				if (flush === Z_TREES) break inf_leave;
			case COPY_: state.mode = COPY;
			case COPY:
				copy = state.length;
				if (copy) {
					if (copy > have) copy = have;
					if (copy > left) copy = left;
					if (copy === 0) break inf_leave;
					utils.arraySet(output, input, next, copy, put);
					have -= copy;
					next += copy;
					left -= copy;
					put += copy;
					state.length -= copy;
					break;
				}
				state.mode = TYPE;
				break;
			case TABLE:
				while (bits < 14) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.nlen = (hold & 31) + 257;
				hold >>>= 5;
				bits -= 5;
				state.ndist = (hold & 31) + 1;
				hold >>>= 5;
				bits -= 5;
				state.ncode = (hold & 15) + 4;
				hold >>>= 4;
				bits -= 4;
				if (state.nlen > 286 || state.ndist > 30) {
					strm.msg = "too many length or distance symbols";
					state.mode = BAD;
					break;
				}
				state.have = 0;
				state.mode = LENLENS;
			case LENLENS:
				while (state.have < state.ncode) {
					while (bits < 3) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.lens[order[state.have++]] = hold & 7;
					hold >>>= 3;
					bits -= 3;
				}
				while (state.have < 19) state.lens[order[state.have++]] = 0;
				state.lencode = state.lendyn;
				state.lenbits = 7;
				opts = { bits: state.lenbits };
				ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
				state.lenbits = opts.bits;
				if (ret) {
					strm.msg = "invalid code lengths set";
					state.mode = BAD;
					break;
				}
				state.have = 0;
				state.mode = CODELENS;
			case CODELENS:
				while (state.have < state.nlen + state.ndist) {
					for (;;) {
						here = state.lencode[hold & (1 << state.lenbits) - 1];
						here_bits = here >>> 24;
						here_op = here >>> 16 & 255;
						here_val = here & 65535;
						if (here_bits <= bits) break;
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					if (here_val < 16) {
						hold >>>= here_bits;
						bits -= here_bits;
						state.lens[state.have++] = here_val;
					} else {
						if (here_val === 16) {
							n = here_bits + 2;
							while (bits < n) {
								if (have === 0) break inf_leave;
								have--;
								hold += input[next++] << bits;
								bits += 8;
							}
							hold >>>= here_bits;
							bits -= here_bits;
							if (state.have === 0) {
								strm.msg = "invalid bit length repeat";
								state.mode = BAD;
								break;
							}
							len = state.lens[state.have - 1];
							copy = 3 + (hold & 3);
							hold >>>= 2;
							bits -= 2;
						} else if (here_val === 17) {
							n = here_bits + 3;
							while (bits < n) {
								if (have === 0) break inf_leave;
								have--;
								hold += input[next++] << bits;
								bits += 8;
							}
							hold >>>= here_bits;
							bits -= here_bits;
							len = 0;
							copy = 3 + (hold & 7);
							hold >>>= 3;
							bits -= 3;
						} else {
							n = here_bits + 7;
							while (bits < n) {
								if (have === 0) break inf_leave;
								have--;
								hold += input[next++] << bits;
								bits += 8;
							}
							hold >>>= here_bits;
							bits -= here_bits;
							len = 0;
							copy = 11 + (hold & 127);
							hold >>>= 7;
							bits -= 7;
						}
						if (state.have + copy > state.nlen + state.ndist) {
							strm.msg = "invalid bit length repeat";
							state.mode = BAD;
							break;
						}
						while (copy--) state.lens[state.have++] = len;
					}
				}
				if (state.mode === BAD) break;
				if (state.lens[256] === 0) {
					strm.msg = "invalid code -- missing end-of-block";
					state.mode = BAD;
					break;
				}
				state.lenbits = 9;
				opts = { bits: state.lenbits };
				ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
				state.lenbits = opts.bits;
				if (ret) {
					strm.msg = "invalid literal/lengths set";
					state.mode = BAD;
					break;
				}
				state.distbits = 6;
				state.distcode = state.distdyn;
				opts = { bits: state.distbits };
				ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
				state.distbits = opts.bits;
				if (ret) {
					strm.msg = "invalid distances set";
					state.mode = BAD;
					break;
				}
				state.mode = LEN_;
				if (flush === Z_TREES) break inf_leave;
			case LEN_: state.mode = LEN;
			case LEN:
				if (have >= 6 && left >= 258) {
					strm.next_out = put;
					strm.avail_out = left;
					strm.next_in = next;
					strm.avail_in = have;
					state.hold = hold;
					state.bits = bits;
					inflate_fast(strm, _out);
					put = strm.next_out;
					output = strm.output;
					left = strm.avail_out;
					next = strm.next_in;
					input = strm.input;
					have = strm.avail_in;
					hold = state.hold;
					bits = state.bits;
					if (state.mode === TYPE) state.back = -1;
					break;
				}
				state.back = 0;
				for (;;) {
					here = state.lencode[hold & (1 << state.lenbits) - 1];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (here_op && (here_op & 240) === 0) {
					last_bits = here_bits;
					last_op = here_op;
					last_val = here_val;
					for (;;) {
						here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
						here_bits = here >>> 24;
						here_op = here >>> 16 & 255;
						here_val = here & 65535;
						if (last_bits + here_bits <= bits) break;
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					hold >>>= last_bits;
					bits -= last_bits;
					state.back += last_bits;
				}
				hold >>>= here_bits;
				bits -= here_bits;
				state.back += here_bits;
				state.length = here_val;
				if (here_op === 0) {
					state.mode = LIT;
					break;
				}
				if (here_op & 32) {
					state.back = -1;
					state.mode = TYPE;
					break;
				}
				if (here_op & 64) {
					strm.msg = "invalid literal/length code";
					state.mode = BAD;
					break;
				}
				state.extra = here_op & 15;
				state.mode = LENEXT;
			case LENEXT:
				if (state.extra) {
					n = state.extra;
					while (bits < n) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.length += hold & (1 << state.extra) - 1;
					hold >>>= state.extra;
					bits -= state.extra;
					state.back += state.extra;
				}
				state.was = state.length;
				state.mode = DIST;
			case DIST:
				for (;;) {
					here = state.distcode[hold & (1 << state.distbits) - 1];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if ((here_op & 240) === 0) {
					last_bits = here_bits;
					last_op = here_op;
					last_val = here_val;
					for (;;) {
						here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
						here_bits = here >>> 24;
						here_op = here >>> 16 & 255;
						here_val = here & 65535;
						if (last_bits + here_bits <= bits) break;
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					hold >>>= last_bits;
					bits -= last_bits;
					state.back += last_bits;
				}
				hold >>>= here_bits;
				bits -= here_bits;
				state.back += here_bits;
				if (here_op & 64) {
					strm.msg = "invalid distance code";
					state.mode = BAD;
					break;
				}
				state.offset = here_val;
				state.extra = here_op & 15;
				state.mode = DISTEXT;
			case DISTEXT:
				if (state.extra) {
					n = state.extra;
					while (bits < n) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.offset += hold & (1 << state.extra) - 1;
					hold >>>= state.extra;
					bits -= state.extra;
					state.back += state.extra;
				}
				if (state.offset > state.dmax) {
					strm.msg = "invalid distance too far back";
					state.mode = BAD;
					break;
				}
				state.mode = MATCH;
			case MATCH:
				if (left === 0) break inf_leave;
				copy = _out - left;
				if (state.offset > copy) {
					copy = state.offset - copy;
					if (copy > state.whave) {
						if (state.sane) {
							strm.msg = "invalid distance too far back";
							state.mode = BAD;
							break;
						}
					}
					if (copy > state.wnext) {
						copy -= state.wnext;
						from = state.wsize - copy;
					} else from = state.wnext - copy;
					if (copy > state.length) copy = state.length;
					from_source = state.window;
				} else {
					from_source = output;
					from = put - state.offset;
					copy = state.length;
				}
				if (copy > left) copy = left;
				left -= copy;
				state.length -= copy;
				do
					output[put++] = from_source[from++];
				while (--copy);
				if (state.length === 0) state.mode = LEN;
				break;
			case LIT:
				if (left === 0) break inf_leave;
				output[put++] = state.length;
				left--;
				state.mode = LEN;
				break;
			case CHECK:
				if (state.wrap) {
					while (bits < 32) {
						if (have === 0) break inf_leave;
						have--;
						hold |= input[next++] << bits;
						bits += 8;
					}
					_out -= left;
					strm.total_out += _out;
					state.total += _out;
					if (_out) strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
					_out = left;
					if ((state.flags ? hold : zswap32(hold)) !== state.check) {
						strm.msg = "incorrect data check";
						state.mode = BAD;
						break;
					}
					hold = 0;
					bits = 0;
				}
				state.mode = LENGTH;
			case LENGTH:
				if (state.wrap && state.flags) {
					while (bits < 32) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					if (hold !== (state.total & 4294967295)) {
						strm.msg = "incorrect length check";
						state.mode = BAD;
						break;
					}
					hold = 0;
					bits = 0;
				}
				state.mode = DONE;
			case DONE:
				ret = Z_STREAM_END;
				break inf_leave;
			case BAD:
				ret = Z_DATA_ERROR;
				break inf_leave;
			case MEM: return Z_MEM_ERROR;
			case SYNC:
			default: return Z_STREAM_ERROR;
		}
		strm.next_out = put;
		strm.avail_out = left;
		strm.next_in = next;
		strm.avail_in = have;
		state.hold = hold;
		state.bits = bits;
		if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
			if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
				state.mode = MEM;
				return Z_MEM_ERROR;
			}
		}
		_in -= strm.avail_in;
		_out -= strm.avail_out;
		strm.total_in += _in;
		strm.total_out += _out;
		state.total += _out;
		if (state.wrap && _out) strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
		strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
		if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) ret = Z_BUF_ERROR;
		return ret;
	}
	function inflateEnd(strm) {
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		var state = strm.state;
		if (state.window) state.window = null;
		strm.state = null;
		return Z_OK;
	}
	function inflateGetHeader(strm, head) {
		var state;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		state = strm.state;
		if ((state.wrap & 2) === 0) return Z_STREAM_ERROR;
		state.head = head;
		head.done = false;
		return Z_OK;
	}
	function inflateSetDictionary(strm, dictionary) {
		var dictLength = dictionary.length;
		var state;
		var dictid;
		var ret;
		if (!strm || !strm.state) return Z_STREAM_ERROR;
		state = strm.state;
		if (state.wrap !== 0 && state.mode !== DICT) return Z_STREAM_ERROR;
		if (state.mode === DICT) {
			dictid = 1;
			dictid = adler32(dictid, dictionary, dictLength, 0);
			if (dictid !== state.check) return Z_DATA_ERROR;
		}
		ret = updatewindow(strm, dictionary, dictLength, dictLength);
		if (ret) {
			state.mode = MEM;
			return Z_MEM_ERROR;
		}
		state.havedict = 1;
		return Z_OK;
	}
	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateInfo = "pako inflate (from Nodeca project)";
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		Z_NO_FLUSH: 0,
		Z_PARTIAL_FLUSH: 1,
		Z_SYNC_FLUSH: 2,
		Z_FULL_FLUSH: 3,
		Z_FINISH: 4,
		Z_BLOCK: 5,
		Z_TREES: 6,
		Z_OK: 0,
		Z_STREAM_END: 1,
		Z_NEED_DICT: 2,
		Z_ERRNO: -1,
		Z_STREAM_ERROR: -2,
		Z_DATA_ERROR: -3,
		Z_BUF_ERROR: -5,
		Z_NO_COMPRESSION: 0,
		Z_BEST_SPEED: 1,
		Z_BEST_COMPRESSION: 9,
		Z_DEFAULT_COMPRESSION: -1,
		Z_FILTERED: 1,
		Z_HUFFMAN_ONLY: 2,
		Z_RLE: 3,
		Z_FIXED: 4,
		Z_DEFAULT_STRATEGY: 0,
		Z_BINARY: 0,
		Z_TEXT: 1,
		Z_UNKNOWN: 2,
		Z_DEFLATED: 8
	};
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function GZheader() {
		this.text = 0;
		this.time = 0;
		this.xflags = 0;
		this.os = 0;
		this.extra = null;
		this.extra_len = 0;
		this.name = "";
		this.comment = "";
		this.hcrc = 0;
		this.done = false;
	}
	module.exports = GZheader;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/lib/inflate.js
var require_inflate = /* @__PURE__ */ __commonJSMin(((exports) => {
	var zlib_inflate = require_inflate$1();
	var utils = require_common();
	var strings = require_strings();
	var c = require_constants();
	var msg = require_messages();
	var ZStream = require_zstream();
	var GZheader = require_gzheader();
	var toString = Object.prototype.toString;
	/**
	* class Inflate
	*
	* Generic JS-style wrapper for zlib calls. If you don't need
	* streaming behaviour - use more simple functions: [[inflate]]
	* and [[inflateRaw]].
	**/
	/**
	* Inflate.result -> Uint8Array|Array|String
	*
	* Uncompressed result, generated by default [[Inflate#onData]]
	* and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	* (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	* push a chunk with explicit flush (call [[Inflate#push]] with
	* `Z_SYNC_FLUSH` param).
	**/
	/**
	* Inflate.err -> Number
	*
	* Error code after inflate finished. 0 (Z_OK) on success.
	* Should be checked if broken data possible.
	**/
	/**
	* Inflate.msg -> String
	*
	* Error message, if [[Inflate.err]] != 0
	**/
	/**
	* new Inflate(options)
	* - options (Object): zlib inflate options.
	*
	* Creates new inflator instance with specified params. Throws exception
	* on bad params. Supported options:
	*
	* - `windowBits`
	* - `dictionary`
	*
	* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	* for more information on these.
	*
	* Additional options, for internal needs:
	*
	* - `chunkSize` - size of generated data chunks (16K by default)
	* - `raw` (Boolean) - do raw inflate
	* - `to` (String) - if equal to 'string', then result will be converted
	*   from utf8 to utf16 (javascript) string. When string output requested,
	*   chunk length can differ from `chunkSize`, depending on content.
	*
	* By default, when no options set, autodetect deflate/gzip data format via
	* wrapper header.
	*
	* ##### Example:
	*
	* ```javascript
	* var pako = require('pako')
	*   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	*   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	*
	* var inflate = new pako.Inflate({ level: 3});
	*
	* inflate.push(chunk1, false);
	* inflate.push(chunk2, true);  // true -> last chunk
	*
	* if (inflate.err) { throw new Error(inflate.err); }
	*
	* console.log(inflate.result);
	* ```
	**/
	function Inflate(options) {
		if (!(this instanceof Inflate)) return new Inflate(options);
		this.options = utils.assign({
			chunkSize: 16384,
			windowBits: 0,
			to: ""
		}, options || {});
		var opt = this.options;
		if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
			opt.windowBits = -opt.windowBits;
			if (opt.windowBits === 0) opt.windowBits = -15;
		}
		if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) opt.windowBits += 32;
		if (opt.windowBits > 15 && opt.windowBits < 48) {
			if ((opt.windowBits & 15) === 0) opt.windowBits |= 15;
		}
		this.err = 0;
		this.msg = "";
		this.ended = false;
		this.chunks = [];
		this.strm = new ZStream();
		this.strm.avail_out = 0;
		var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
		if (status !== c.Z_OK) throw new Error(msg[status]);
		this.header = new GZheader();
		zlib_inflate.inflateGetHeader(this.strm, this.header);
		if (opt.dictionary) {
			if (typeof opt.dictionary === "string") opt.dictionary = strings.string2buf(opt.dictionary);
			else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") opt.dictionary = new Uint8Array(opt.dictionary);
			if (opt.raw) {
				status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
				if (status !== c.Z_OK) throw new Error(msg[status]);
			}
		}
	}
	/**
	* Inflate#push(data[, mode]) -> Boolean
	* - data (Uint8Array|Array|ArrayBuffer|String): input data
	* - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	*   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	*
	* Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	* new output chunks. Returns `true` on success. The last data block must have
	* mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	* [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	* can use mode Z_SYNC_FLUSH, keeping the decompression context.
	*
	* On fail call [[Inflate#onEnd]] with error code and return false.
	*
	* We strongly recommend to use `Uint8Array` on input for best speed (output
	* format is detected automatically). Also, don't skip last param and always
	* use the same type in your code (boolean or number). That will improve JS speed.
	*
	* For regular `Array`-s make sure all elements are [0..255].
	*
	* ##### Example
	*
	* ```javascript
	* push(chunk, false); // push one of data chunks
	* ...
	* push(chunk, true);  // push last chunk
	* ```
	**/
	Inflate.prototype.push = function(data, mode) {
		var strm = this.strm;
		var chunkSize = this.options.chunkSize;
		var dictionary = this.options.dictionary;
		var status, _mode;
		var next_out_utf8, tail, utf8str;
		var allowBufError = false;
		if (this.ended) return false;
		_mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
		if (typeof data === "string") strm.input = strings.binstring2buf(data);
		else if (toString.call(data) === "[object ArrayBuffer]") strm.input = new Uint8Array(data);
		else strm.input = data;
		strm.next_in = 0;
		strm.avail_in = strm.input.length;
		do {
			if (strm.avail_out === 0) {
				strm.output = new utils.Buf8(chunkSize);
				strm.next_out = 0;
				strm.avail_out = chunkSize;
			}
			status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
			if (status === c.Z_NEED_DICT && dictionary) status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
			if (status === c.Z_BUF_ERROR && allowBufError === true) {
				status = c.Z_OK;
				allowBufError = false;
			}
			if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
				this.onEnd(status);
				this.ended = true;
				return false;
			}
			if (strm.next_out) {
				if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) if (this.options.to === "string") {
					next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
					tail = strm.next_out - next_out_utf8;
					utf8str = strings.buf2string(strm.output, next_out_utf8);
					strm.next_out = tail;
					strm.avail_out = chunkSize - tail;
					if (tail) utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
					this.onData(utf8str);
				} else this.onData(utils.shrinkBuf(strm.output, strm.next_out));
			}
			if (strm.avail_in === 0 && strm.avail_out === 0) allowBufError = true;
		} while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
		if (status === c.Z_STREAM_END) _mode = c.Z_FINISH;
		if (_mode === c.Z_FINISH) {
			status = zlib_inflate.inflateEnd(this.strm);
			this.onEnd(status);
			this.ended = true;
			return status === c.Z_OK;
		}
		if (_mode === c.Z_SYNC_FLUSH) {
			this.onEnd(c.Z_OK);
			strm.avail_out = 0;
			return true;
		}
		return true;
	};
	/**
	* Inflate#onData(chunk) -> Void
	* - chunk (Uint8Array|Array|String): output data. Type of array depends
	*   on js engine support. When string output requested, each chunk
	*   will be string.
	*
	* By default, stores data blocks in `chunks[]` property and glue
	* those in `onEnd`. Override this handler, if you need another behaviour.
	**/
	Inflate.prototype.onData = function(chunk) {
		this.chunks.push(chunk);
	};
	/**
	* Inflate#onEnd(status) -> Void
	* - status (Number): inflate status. 0 (Z_OK) on success,
	*   other if not.
	*
	* Called either after you tell inflate that the input stream is
	* complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	* or if an error happened. By default - join collected chunks,
	* free memory and fill `results` / `err` properties.
	**/
	Inflate.prototype.onEnd = function(status) {
		if (status === c.Z_OK) if (this.options.to === "string") this.result = this.chunks.join("");
		else this.result = utils.flattenChunks(this.chunks);
		this.chunks = [];
		this.err = status;
		this.msg = this.strm.msg;
	};
	/**
	* inflate(data[, options]) -> Uint8Array|Array|String
	* - data (Uint8Array|Array|String): input data to decompress.
	* - options (Object): zlib inflate options.
	*
	* Decompress `data` with inflate/ungzip and `options`. Autodetect
	* format via wrapper header by default. That's why we don't provide
	* separate `ungzip` method.
	*
	* Supported options are:
	*
	* - windowBits
	*
	* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	* for more information.
	*
	* Sugar (options):
	*
	* - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	*   negative windowBits implicitly.
	* - `to` (String) - if equal to 'string', then result will be converted
	*   from utf8 to utf16 (javascript) string. When string output requested,
	*   chunk length can differ from `chunkSize`, depending on content.
	*
	*
	* ##### Example:
	*
	* ```javascript
	* var pako = require('pako')
	*   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	*   , output;
	*
	* try {
	*   output = pako.inflate(input);
	* } catch (err)
	*   console.log(err);
	* }
	* ```
	**/
	function inflate(input, options) {
		var inflator = new Inflate(options);
		inflator.push(input, true);
		if (inflator.err) throw inflator.msg || msg[inflator.err];
		return inflator.result;
	}
	/**
	* inflateRaw(data[, options]) -> Uint8Array|Array|String
	* - data (Uint8Array|Array|String): input data to decompress.
	* - options (Object): zlib inflate options.
	*
	* The same as [[inflate]], but creates raw data, without wrapper
	* (header and adler32 crc).
	**/
	function inflateRaw(input, options) {
		options = options || {};
		options.raw = true;
		return inflate(input, options);
	}
	/**
	* ungzip(data[, options]) -> Uint8Array|Array|String
	* - data (Uint8Array|Array|String): input data to decompress.
	* - options (Object): zlib inflate options.
	*
	* Just shortcut to [[inflate]], because it autodetects format
	* by header.content. Done for convenience.
	**/
	exports.Inflate = Inflate;
	exports.inflate = inflate;
	exports.inflateRaw = inflateRaw;
	exports.ungzip = inflate;
}));

//#endregion
//#region ../../node_modules/.bun/pako@1.0.11/node_modules/pako/index.js
var require_pako = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assign = require_common().assign;
	var deflate = require_deflate();
	var inflate = require_inflate();
	var constants = require_constants();
	var pako = {};
	assign(pako, deflate, inflate, constants);
	module.exports = pako;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/utility.js
var require_utility = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __read = exports && exports.__read || function(o, n) {
		var m = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m) return o;
		var i = m.call(o), r, ar = [], e;
		try {
			while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error$47) {
			e = { error: error$47 };
		} finally {
			try {
				if (r && !r.done && (m = i["return"])) m.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
		if (pack || arguments.length === 2) {
			for (var i = 0, l = from.length, ar; i < l; i++) if (ar || !(i in from)) {
				if (!ar) ar = Array.prototype.slice.call(from, 0, i);
				ar[i] = from[i];
			}
		}
		return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.notEmpty = exports.castArrayOpt = exports.isNonEmptyArray = exports.readPrivateKey = exports.inflateString = exports.base64Decode = exports.isString = exports.get = exports.uniq = exports.last = exports.flattenDeep = exports.zipObject = void 0;
	/**
	* @file utility.ts
	* @author tngan
	* @desc  Library for some common functions (e.g. de/inflation, en/decoding)
	*/
	var node_forge_1 = require_lib$4();
	var pako_1 = require_pako();
	var BASE64_STR = "base64";
	/**
	* @desc Mimic lodash.zipObject
	* @param arr1 {string[]}
	* @param arr2 {[]}
	*/
	function zipObject(arr1, arr2, skipDuplicated) {
		if (skipDuplicated === void 0) skipDuplicated = true;
		return arr1.reduce(function(res, l, i) {
			if (skipDuplicated) {
				res[l] = arr2[i];
				return res;
			}
			if (res[l] !== void 0) {
				res[l] = Array.isArray(res[l]) ? res[l].concat(arr2[i]) : [res[l]].concat(arr2[i]);
				return res;
			}
			res[l] = arr2[i];
			return res;
		}, {});
	}
	exports.zipObject = zipObject;
	/**
	* @desc Alternative to lodash.flattenDeep
	* @reference https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flattendeep
	* @param input {[]}
	*/
	function flattenDeep(input) {
		return Array.isArray(input) ? input.reduce(function(a, b) {
			return a.concat(flattenDeep(b));
		}, []) : [input];
	}
	exports.flattenDeep = flattenDeep;
	/**
	* @desc Alternative to lodash.last
	* @reference https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_last
	* @param input {[]}
	*/
	function last(input) {
		return input.slice(-1)[0];
	}
	exports.last = last;
	/**
	* @desc Alternative to lodash.uniq
	* @reference https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_uniq
	* @param input {string[]}
	*/
	function uniq(input) {
		return __spreadArray([], __read(new Set(input)), false);
	}
	exports.uniq = uniq;
	/**
	* @desc Alternative to lodash.get
	* @reference https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_get
	* @param obj
	* @param path
	* @param defaultValue
	*/
	function get(obj, path, defaultValue) {
		return path.split(".").reduce(function(a, c) {
			return a && a[c] ? a[c] : defaultValue || null;
		}, obj);
	}
	exports.get = get;
	/**
	* @desc Check if the input is string
	* @param {any} input
	*/
	function isString(input) {
		return typeof input === "string";
	}
	exports.isString = isString;
	/**
	* @desc Encode string with base64 format
	* @param  {string} message                       plain-text message
	* @return {string} base64 encoded string
	*/
	function base64Encode(message) {
		return Buffer.from(message).toString(BASE64_STR);
	}
	/**
	* @desc Decode string from base64 format
	* @param  {string} base64Message                 encoded string
	* @param  {boolean} isBytes                      determine the return value type (True: bytes False: string)
	* @return {bytes/string}  decoded bytes/string depends on isBytes, default is {string}
	*/
	function base64Decode(base64Message, isBytes) {
		var bytes = Buffer.from(base64Message, BASE64_STR);
		return Boolean(isBytes) ? bytes : bytes.toString();
	}
	exports.base64Decode = base64Decode;
	/**
	* @desc Compress the string
	* @param  {string} message
	* @return {string} compressed string
	*/
	function deflateString(message) {
		var input = Array.prototype.map.call(message, function(char) {
			return char.charCodeAt(0);
		});
		return Array.from((0, pako_1.deflate)(input, { raw: true }));
	}
	/**
	* @desc Decompress the compressed string
	* @param  {string} compressedString
	* @return {string} decompressed string
	*/
	function inflateString(compressedString) {
		var inputBuffer = Buffer.from(compressedString, BASE64_STR);
		var input = Array.prototype.map.call(inputBuffer.toString("binary"), function(char) {
			return char.charCodeAt(0);
		});
		return Array.from((0, pako_1.inflate)(input, { raw: true })).map(function(byte) {
			return String.fromCharCode(byte);
		}).join("");
	}
	exports.inflateString = inflateString;
	/**
	* @desc Abstract the normalizeCerString and normalizePemString
	* @param {buffer} File stream or string
	* @param {string} String for header and tail
	* @return {string} A formatted certificate string
	*/
	function _normalizeCerString(bin, format) {
		return bin.toString().replace(/\n/g, "").replace(/\r/g, "").replace("-----BEGIN ".concat(format, "-----"), "").replace("-----END ".concat(format, "-----"), "").replace(/ /g, "").replace(/\t/g, "");
	}
	/**
	* @desc Parse the .cer to string format without line break, header and footer
	* @param  {string} certString     declares the certificate contents
	* @return {string} certificiate in string format
	*/
	function normalizeCerString(certString) {
		return _normalizeCerString(certString, "CERTIFICATE");
	}
	/**
	* @desc Normalize the string in .pem format without line break, header and footer
	* @param  {string} pemString
	* @return {string} private key in string format
	*/
	function normalizePemString(pemString) {
		return _normalizeCerString(pemString.toString(), "RSA PRIVATE KEY");
	}
	/**
	* @desc Return the complete URL
	* @param  {object} req                   HTTP request
	* @return {string} URL
	*/
	function getFullURL(req) {
		return "".concat(req.protocol, "://").concat(req.get("host")).concat(req.originalUrl);
	}
	/**
	* @desc Parse input string, return default value if it is undefined
	* @param  {string/boolean}
	* @return {boolean}
	*/
	function parseString(str, defaultValue) {
		if (defaultValue === void 0) defaultValue = "";
		return str || defaultValue;
	}
	/**
	* @desc Override the object by another object (rtl)
	* @param  {object} default object
	* @param  {object} object applied to the default object
	* @return {object} result object
	*/
	function applyDefault(obj1, obj2) {
		return Object.assign({}, obj1, obj2);
	}
	/**
	* @desc Get public key in pem format from the certificate included in the metadata
	* @param {string} x509 certificate
	* @return {string} public key fetched from the certificate
	*/
	function getPublicKeyPemFromCertificate(x509Certificate) {
		var certDerBytes = node_forge_1.util.decode64(x509Certificate);
		var obj = node_forge_1.asn1.fromDer(certDerBytes);
		var cert = node_forge_1.pki.certificateFromAsn1(obj);
		return node_forge_1.pki.publicKeyToPem(cert.publicKey);
	}
	/**
	* @desc Read private key from pem-formatted string
	* @param {string | Buffer} keyString pem-formatted string
	* @param {string} protected passphrase of the key
	* @return {string} string in pem format
	* If passphrase is used to protect the .pem content (recommend)
	*/
	function readPrivateKey(keyString, passphrase, isOutputString) {
		return isString(passphrase) ? this.convertToString(node_forge_1.pki.privateKeyToPem(node_forge_1.pki.decryptRsaPrivateKey(String(keyString), passphrase)), isOutputString) : keyString;
	}
	exports.readPrivateKey = readPrivateKey;
	/**
	* @desc Inline syntax sugar
	*/
	function convertToString(input, isOutputString) {
		return Boolean(isOutputString) ? String(input) : input;
	}
	/**
	* @desc Check if the input is an array with non-zero size
	*/
	function isNonEmptyArray(a) {
		return Array.isArray(a) && a.length > 0;
	}
	exports.isNonEmptyArray = isNonEmptyArray;
	function castArrayOpt(a) {
		if (a === void 0) return [];
		return Array.isArray(a) ? a : [a];
	}
	exports.castArrayOpt = castArrayOpt;
	function notEmpty(value) {
		return value !== null && value !== void 0;
	}
	exports.notEmpty = notEmpty;
	var utility = {
		isString,
		base64Encode,
		base64Decode,
		deflateString,
		inflateString,
		normalizeCerString,
		normalizePemString,
		getFullURL,
		parseString,
		applyDefault,
		getPublicKeyPemFromCertificate,
		readPrivateKey,
		convertToString,
		isNonEmptyArray
	};
	exports.default = utility;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/urn.js
var require_urn = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @file urn.ts
	* @author tngan
	* @desc  Includes all keywords need in samlify
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.messageConfigurations = exports.elementsOrder = exports.wording = exports.algorithms = exports.tags = exports.namespace = exports.ParserType = exports.StatusCode = exports.MessageSignatureOrder = exports.BindingNamespace = void 0;
	(function(BindingNamespace) {
		BindingNamespace["Redirect"] = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect";
		BindingNamespace["Post"] = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST";
		BindingNamespace["SimpleSign"] = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST-SimpleSign";
		BindingNamespace["Artifact"] = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Artifact";
	})(exports.BindingNamespace || (exports.BindingNamespace = {}));
	(function(MessageSignatureOrder) {
		MessageSignatureOrder["STE"] = "sign-then-encrypt";
		MessageSignatureOrder["ETS"] = "encrypt-then-sign";
	})(exports.MessageSignatureOrder || (exports.MessageSignatureOrder = {}));
	(function(StatusCode) {
		StatusCode["Success"] = "urn:oasis:names:tc:SAML:2.0:status:Success";
		StatusCode["Requester"] = "urn:oasis:names:tc:SAML:2.0:status:Requester";
		StatusCode["Responder"] = "urn:oasis:names:tc:SAML:2.0:status:Responder";
		StatusCode["VersionMismatch"] = "urn:oasis:names:tc:SAML:2.0:status:VersionMismatch";
		StatusCode["AuthFailed"] = "urn:oasis:names:tc:SAML:2.0:status:AuthnFailed";
		StatusCode["InvalidAttrNameOrValue"] = "urn:oasis:names:tc:SAML:2.0:status:InvalidAttrNameOrValue";
		StatusCode["InvalidNameIDPolicy"] = "urn:oasis:names:tc:SAML:2.0:status:InvalidNameIDPolicy";
		StatusCode["NoAuthnContext"] = "urn:oasis:names:tc:SAML:2.0:status:NoAuthnContext";
		StatusCode["NoAvailableIDP"] = "urn:oasis:names:tc:SAML:2.0:status:NoAvailableIDP";
		StatusCode["NoPassive"] = "urn:oasis:names:tc:SAML:2.0:status:NoPassive";
		StatusCode["NoSupportedIDP"] = "urn:oasis:names:tc:SAML:2.0:status:NoSupportedIDP";
		StatusCode["PartialLogout"] = "urn:oasis:names:tc:SAML:2.0:status:PartialLogout";
		StatusCode["ProxyCountExceeded"] = "urn:oasis:names:tc:SAML:2.0:status:ProxyCountExceeded";
		StatusCode["RequestDenied"] = "urn:oasis:names:tc:SAML:2.0:status:RequestDenied";
		StatusCode["RequestUnsupported"] = "urn:oasis:names:tc:SAML:2.0:status:RequestUnsupported";
		StatusCode["RequestVersionDeprecated"] = "urn:oasis:names:tc:SAML:2.0:status:RequestVersionDeprecated";
		StatusCode["RequestVersionTooHigh"] = "urn:oasis:names:tc:SAML:2.0:status:RequestVersionTooHigh";
		StatusCode["RequestVersionTooLow"] = "urn:oasis:names:tc:SAML:2.0:status:RequestVersionTooLow";
		StatusCode["ResourceNotRecognized"] = "urn:oasis:names:tc:SAML:2.0:status:ResourceNotRecognized";
		StatusCode["TooManyResponses"] = "urn:oasis:names:tc:SAML:2.0:status:TooManyResponses";
		StatusCode["UnknownAttrProfile"] = "urn:oasis:names:tc:SAML:2.0:status:UnknownAttrProfile";
		StatusCode["UnknownPrincipal"] = "urn:oasis:names:tc:SAML:2.0:status:UnknownPrincipal";
		StatusCode["UnsupportedBinding"] = "urn:oasis:names:tc:SAML:2.0:status:UnsupportedBinding";
	})(exports.StatusCode || (exports.StatusCode = {}));
	var namespace = {
		binding: {
			redirect: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect",
			post: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST",
			simpleSign: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST-SimpleSign",
			artifact: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Artifact"
		},
		names: {
			protocol: "urn:oasis:names:tc:SAML:2.0:protocol",
			assertion: "urn:oasis:names:tc:SAML:2.0:assertion",
			metadata: "urn:oasis:names:tc:SAML:2.0:metadata",
			userLogout: "urn:oasis:names:tc:SAML:2.0:logout:user",
			adminLogout: "urn:oasis:names:tc:SAML:2.0:logout:admin"
		},
		authnContextClassRef: {
			password: "urn:oasis:names:tc:SAML:2.0:ac:classes:Password",
			passwordProtectedTransport: "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport"
		},
		format: {
			emailAddress: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress",
			persistent: "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent",
			transient: "urn:oasis:names:tc:SAML:2.0:nameid-format:transient",
			entity: "urn:oasis:names:tc:SAML:2.0:nameid-format:entity",
			unspecified: "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified",
			kerberos: "urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos",
			windowsDomainQualifiedName: "urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName",
			x509SubjectName: "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName"
		},
		statusCode: {
			success: "urn:oasis:names:tc:SAML:2.0:status:Success",
			requester: "urn:oasis:names:tc:SAML:2.0:status:Requester",
			responder: "urn:oasis:names:tc:SAML:2.0:status:Responder",
			versionMismatch: "urn:oasis:names:tc:SAML:2.0:status:VersionMismatch",
			authFailed: "urn:oasis:names:tc:SAML:2.0:status:AuthnFailed",
			invalidAttrNameOrValue: "urn:oasis:names:tc:SAML:2.0:status:InvalidAttrNameOrValue",
			invalidNameIDPolicy: "urn:oasis:names:tc:SAML:2.0:status:InvalidNameIDPolicy",
			noAuthnContext: "urn:oasis:names:tc:SAML:2.0:status:NoAuthnContext",
			noAvailableIDP: "urn:oasis:names:tc:SAML:2.0:status:NoAvailableIDP",
			noPassive: "urn:oasis:names:tc:SAML:2.0:status:NoPassive",
			noSupportedIDP: "urn:oasis:names:tc:SAML:2.0:status:NoSupportedIDP",
			partialLogout: "urn:oasis:names:tc:SAML:2.0:status:PartialLogout",
			proxyCountExceeded: "urn:oasis:names:tc:SAML:2.0:status:ProxyCountExceeded",
			requestDenied: "urn:oasis:names:tc:SAML:2.0:status:RequestDenied",
			requestUnsupported: "urn:oasis:names:tc:SAML:2.0:status:RequestUnsupported",
			requestVersionDeprecated: "urn:oasis:names:tc:SAML:2.0:status:RequestVersionDeprecated",
			requestVersionTooHigh: "urn:oasis:names:tc:SAML:2.0:status:RequestVersionTooHigh",
			requestVersionTooLow: "urn:oasis:names:tc:SAML:2.0:status:RequestVersionTooLow",
			resourceNotRecognized: "urn:oasis:names:tc:SAML:2.0:status:ResourceNotRecognized",
			tooManyResponses: "urn:oasis:names:tc:SAML:2.0:status:TooManyResponses",
			unknownAttrProfile: "urn:oasis:names:tc:SAML:2.0:status:UnknownAttrProfile",
			unknownPrincipal: "urn:oasis:names:tc:SAML:2.0:status:UnknownPrincipal",
			unsupportedBinding: "urn:oasis:names:tc:SAML:2.0:status:UnsupportedBinding"
		}
	};
	exports.namespace = namespace;
	var tags = {
		request: {
			AllowCreate: "{AllowCreate}",
			AssertionConsumerServiceURL: "{AssertionConsumerServiceURL}",
			AuthnContextClassRef: "{AuthnContextClassRef}",
			AssertionID: "{AssertionID}",
			Audience: "{Audience}",
			AuthnStatement: "{AuthnStatement}",
			AttributeStatement: "{AttributeStatement}",
			ConditionsNotBefore: "{ConditionsNotBefore}",
			ConditionsNotOnOrAfter: "{ConditionsNotOnOrAfter}",
			Destination: "{Destination}",
			EntityID: "{EntityID}",
			ID: "{ID}",
			Issuer: "{Issuer}",
			IssueInstant: "{IssueInstant}",
			InResponseTo: "{InResponseTo}",
			NameID: "{NameID}",
			NameIDFormat: "{NameIDFormat}",
			ProtocolBinding: "{ProtocolBinding}",
			SessionIndex: "{SessionIndex}",
			SubjectRecipient: "{SubjectRecipient}",
			SubjectConfirmationDataNotOnOrAfter: "{SubjectConfirmationDataNotOnOrAfter}",
			StatusCode: "{StatusCode}"
		},
		xmlTag: {
			loginRequest: "AuthnRequest",
			logoutRequest: "LogoutRequest",
			loginResponse: "Response",
			logoutResponse: "LogoutResponse"
		}
	};
	exports.tags = tags;
	var messageConfigurations = { signingOrder: {
		SIGN_THEN_ENCRYPT: "sign-then-encrypt",
		ENCRYPT_THEN_SIGN: "encrypt-then-sign"
	} };
	exports.messageConfigurations = messageConfigurations;
	var algorithms = {
		signature: {
			RSA_SHA1: "http://www.w3.org/2000/09/xmldsig#rsa-sha1",
			RSA_SHA256: "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256",
			RSA_SHA512: "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"
		},
		encryption: {
			data: {
				AES_128: "http://www.w3.org/2001/04/xmlenc#aes128-cbc",
				AES_256: "http://www.w3.org/2001/04/xmlenc#aes256-cbc",
				TRI_DEC: "http://www.w3.org/2001/04/xmlenc#tripledes-cbc",
				AES_128_GCM: "http://www.w3.org/2009/xmlenc11#aes128-gcm"
			},
			key: {
				RSA_OAEP_MGF1P: "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p",
				RSA_1_5: "http://www.w3.org/2001/04/xmlenc#rsa-1_5"
			}
		},
		digest: {
			"http://www.w3.org/2000/09/xmldsig#rsa-sha1": "http://www.w3.org/2000/09/xmldsig#sha1",
			"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256": "http://www.w3.org/2001/04/xmlenc#sha256",
			"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512": "http://www.w3.org/2001/04/xmlenc#sha512"
		}
	};
	exports.algorithms = algorithms;
	(function(ParserType) {
		ParserType["SAMLRequest"] = "SAMLRequest";
		ParserType["SAMLResponse"] = "SAMLResponse";
		ParserType["LogoutRequest"] = "LogoutRequest";
		ParserType["LogoutResponse"] = "LogoutResponse";
	})(exports.ParserType || (exports.ParserType = {}));
	var wording = {
		urlParams: {
			samlRequest: "SAMLRequest",
			samlResponse: "SAMLResponse",
			logoutRequest: "LogoutRequest",
			logoutResponse: "LogoutResponse",
			sigAlg: "SigAlg",
			signature: "Signature",
			relayState: "RelayState"
		},
		binding: {
			redirect: "redirect",
			post: "post",
			simpleSign: "simpleSign",
			artifact: "artifact"
		},
		certUse: {
			signing: "signing",
			encrypt: "encryption"
		},
		metadata: {
			sp: "metadata-sp",
			idp: "metadata-idp"
		}
	};
	exports.wording = wording;
	var elementsOrder = {
		default: [
			"KeyDescriptor",
			"NameIDFormat",
			"SingleLogoutService",
			"AssertionConsumerService"
		],
		onelogin: [
			"KeyDescriptor",
			"NameIDFormat",
			"SingleLogoutService",
			"AssertionConsumerService"
		],
		shibboleth: [
			"KeyDescriptor",
			"SingleLogoutService",
			"NameIDFormat",
			"AssertionConsumerService",
			"AttributeConsumingService"
		]
	};
	exports.elementsOrder = elementsOrder;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js
function rng() {
	if (poolPtr > rnds8Pool.length - 16) {
		crypto$1.randomFillSync(rnds8Pool);
		poolPtr = 0;
	}
	return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rnds8Pool, poolPtr;
var init_rng = __esmMin((() => {
	rnds8Pool = new Uint8Array(256);
	poolPtr = rnds8Pool.length;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esmMin((() => {
	regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid$2) {
	return typeof uuid$2 === "string" && regex_default.test(uuid$2);
}
var validate_default;
var init_validate = __esmMin((() => {
	init_regex();
	validate_default = validate;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
	const uuid$2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
	if (!validate_default(uuid$2)) throw TypeError("Stringified UUID is invalid");
	return uuid$2;
}
var byteToHex, stringify_default;
var init_stringify = __esmMin((() => {
	init_validate();
	byteToHex = [];
	for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
	stringify_default = stringify;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
	let i = buf && offset || 0;
	const b = buf || new Array(16);
	options = options || {};
	let node = options.node || _nodeId;
	let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
	if (node == null || clockseq == null) {
		const seedBytes = options.random || (options.rng || rng)();
		if (node == null) node = _nodeId = [
			seedBytes[0] | 1,
			seedBytes[1],
			seedBytes[2],
			seedBytes[3],
			seedBytes[4],
			seedBytes[5]
		];
		if (clockseq == null) clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
	}
	let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
	let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
	const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
	if (dt < 0 && options.clockseq === void 0) clockseq = clockseq + 1 & 16383;
	if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) nsecs = 0;
	if (nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
	_lastMSecs = msecs;
	_lastNSecs = nsecs;
	_clockseq = clockseq;
	msecs += 0xb1d069b5400;
	const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
	b[i++] = tl >>> 24 & 255;
	b[i++] = tl >>> 16 & 255;
	b[i++] = tl >>> 8 & 255;
	b[i++] = tl & 255;
	const tmh = msecs / 4294967296 * 1e4 & 268435455;
	b[i++] = tmh >>> 8 & 255;
	b[i++] = tmh & 255;
	b[i++] = tmh >>> 24 & 15 | 16;
	b[i++] = tmh >>> 16 & 255;
	b[i++] = clockseq >>> 8 | 128;
	b[i++] = clockseq & 255;
	for (let n = 0; n < 6; ++n) b[i + n] = node[n];
	return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esmMin((() => {
	init_rng();
	init_stringify();
	;
	;
	_lastMSecs = 0;
	_lastNSecs = 0;
	v1_default = v1;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid$2) {
	if (!validate_default(uuid$2)) throw TypeError("Invalid UUID");
	let v;
	const arr = new Uint8Array(16);
	arr[0] = (v = parseInt(uuid$2.slice(0, 8), 16)) >>> 24;
	arr[1] = v >>> 16 & 255;
	arr[2] = v >>> 8 & 255;
	arr[3] = v & 255;
	arr[4] = (v = parseInt(uuid$2.slice(9, 13), 16)) >>> 8;
	arr[5] = v & 255;
	arr[6] = (v = parseInt(uuid$2.slice(14, 18), 16)) >>> 8;
	arr[7] = v & 255;
	arr[8] = (v = parseInt(uuid$2.slice(19, 23), 16)) >>> 8;
	arr[9] = v & 255;
	arr[10] = (v = parseInt(uuid$2.slice(24, 36), 16)) / 1099511627776 & 255;
	arr[11] = v / 4294967296 & 255;
	arr[12] = v >>> 24 & 255;
	arr[13] = v >>> 16 & 255;
	arr[14] = v >>> 8 & 255;
	arr[15] = v & 255;
	return arr;
}
var parse_default;
var init_parse = __esmMin((() => {
	init_validate();
	parse_default = parse;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
	str = unescape(encodeURIComponent(str));
	const bytes = [];
	for (let i = 0; i < str.length; ++i) bytes.push(str.charCodeAt(i));
	return bytes;
}
function v35_default(name$1, version$2, hashfunc) {
	function generateUUID(value, namespace, buf, offset) {
		if (typeof value === "string") value = stringToBytes(value);
		if (typeof namespace === "string") namespace = parse_default(namespace);
		if (namespace.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
		let bytes = new Uint8Array(16 + value.length);
		bytes.set(namespace);
		bytes.set(value, namespace.length);
		bytes = hashfunc(bytes);
		bytes[6] = bytes[6] & 15 | version$2;
		bytes[8] = bytes[8] & 63 | 128;
		if (buf) {
			offset = offset || 0;
			for (let i = 0; i < 16; ++i) buf[offset + i] = bytes[i];
			return buf;
		}
		return stringify_default(bytes);
	}
	try {
		generateUUID.name = name$1;
	} catch (err) {}
	generateUUID.DNS = DNS;
	generateUUID.URL = URL$1;
	return generateUUID;
}
var DNS, URL$1;
var init_v35 = __esmMin((() => {
	init_stringify();
	init_parse();
	DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
	URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
	if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
	else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
	return crypto$1.createHash("md5").update(bytes).digest();
}
var md5_default;
var init_md5 = __esmMin((() => {
	md5_default = md5;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esmMin((() => {
	init_v35();
	init_md5();
	v3 = v35_default("v3", 48, md5_default);
	v3_default = v3;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
	options = options || {};
	const rnds = options.random || (options.rng || rng)();
	rnds[6] = rnds[6] & 15 | 64;
	rnds[8] = rnds[8] & 63 | 128;
	if (buf) {
		offset = offset || 0;
		for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
		return buf;
	}
	return stringify_default(rnds);
}
var v4_default$1;
var init_v4 = __esmMin((() => {
	init_rng();
	init_stringify();
	v4_default$1 = v4;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
	if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
	else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
	return crypto$1.createHash("sha1").update(bytes).digest();
}
var sha1_default;
var init_sha1 = __esmMin((() => {
	sha1_default = sha1;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esmMin((() => {
	init_v35();
	init_sha1();
	v5 = v35_default("v5", 80, sha1_default);
	v5_default = v5;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esmMin((() => {
	nil_default = "00000000-0000-0000-0000-000000000000";
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/version.js
function version(uuid$2) {
	if (!validate_default(uuid$2)) throw TypeError("Invalid UUID");
	return parseInt(uuid$2.substr(14, 1), 16);
}
var version_default;
var init_version = __esmMin((() => {
	init_validate();
	version_default = version;
}));

//#endregion
//#region ../../node_modules/.bun/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = /* @__PURE__ */ __exportAll({
	NIL: () => nil_default,
	parse: () => parse_default,
	stringify: () => stringify_default,
	v1: () => v1_default,
	v3: () => v3_default,
	v4: () => v4_default$1,
	v5: () => v5_default,
	validate: () => validate_default,
	version: () => version_default
});
var init_esm_node = __esmMin((() => {
	init_v1();
	init_v3();
	init_v4();
	init_v5();
	init_nil();
	init_version();
	init_validate();
	init_stringify();
	init_parse();
}));

//#endregion
//#region ../../node_modules/.bun/xpath@0.0.32/node_modules/xpath/xpath.js
var require_xpath$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function(exports$1) {
		"use strict";
		function curry(func) {
			var slice = Array.prototype.slice, totalargs = func.length, partial$1 = function(args, fn$2) {
				return function() {
					return fn$2.apply(this, args.concat(slice.call(arguments)));
				};
			}, fn$1 = function() {
				var args = slice.call(arguments);
				return args.length < totalargs ? partial$1(args, fn$1) : func.apply(this, slice.apply(arguments, [0, totalargs]));
			};
			return fn$1;
		}
		var forEach = function(f, xs) {
			for (var i = 0; i < xs.length; i += 1) f(xs[i], i, xs);
		};
		var reduce = function(f, seed, xs) {
			var acc = seed;
			forEach(function(x, i) {
				acc = f(acc, x, i);
			}, xs);
			return acc;
		};
		var map$1 = function(f, xs) {
			var mapped = new Array(xs.length);
			forEach(function(x, i) {
				mapped[i] = f(x);
			}, xs);
			return mapped;
		};
		var filter = function(f, xs) {
			var filtered = [];
			forEach(function(x, i) {
				if (f(x, i)) filtered.push(x);
			}, xs);
			return filtered;
		};
		var includes = function(values, value) {
			for (var i = 0; i < values.length; i += 1) if (values[i] === value) return true;
			return false;
		};
		function always(value) {
			return function() {
				return value;
			};
		}
		function toString(x) {
			return x.toString();
		}
		var join = function(s, xs) {
			return xs.join(s);
		};
		var wrap = function(pref, suf, str) {
			return pref + str + suf;
		};
		var prototypeConcat = Array.prototype.concat;
		var MAX_ARGUMENT_LENGTH = 32767;
		function flatten(arr) {
			var result = [];
			for (var start = 0; start < arr.length; start += MAX_ARGUMENT_LENGTH) {
				var chunk = arr.slice(start, start + MAX_ARGUMENT_LENGTH);
				result = prototypeConcat.apply(result, chunk);
			}
			return result;
		}
		function assign(target, varArgs) {
			var to = Object(target);
			for (var index = 1; index < arguments.length; index++) {
				var nextSource = arguments[index];
				if (nextSource != null) {
					for (var nextKey in nextSource) if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) to[nextKey] = nextSource[nextKey];
				}
			}
			return to;
		}
		XPathParser.prototype = /* @__PURE__ */ new Object();
		XPathParser.prototype.constructor = XPathParser;
		XPathParser.superclass = Object.prototype;
		function XPathParser() {
			this.init();
		}
		XPathParser.prototype.init = function() {
			this.reduceActions = [];
			this.reduceActions[3] = function(rhs) {
				return new OrOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[5] = function(rhs) {
				return new AndOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[7] = function(rhs) {
				return new EqualsOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[8] = function(rhs) {
				return new NotEqualOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[10] = function(rhs) {
				return new LessThanOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[11] = function(rhs) {
				return new GreaterThanOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[12] = function(rhs) {
				return new LessThanOrEqualOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[13] = function(rhs) {
				return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[15] = function(rhs) {
				return new PlusOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[16] = function(rhs) {
				return new MinusOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[18] = function(rhs) {
				return new MultiplyOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[19] = function(rhs) {
				return new DivOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[20] = function(rhs) {
				return new ModOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[22] = function(rhs) {
				return new UnaryMinusOperation(rhs[1]);
			};
			this.reduceActions[24] = function(rhs) {
				return new BarOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[25] = function(rhs) {
				return new PathExpr(void 0, void 0, rhs[0]);
			};
			this.reduceActions[27] = function(rhs) {
				rhs[0].locationPath = rhs[2];
				return rhs[0];
			};
			this.reduceActions[28] = function(rhs) {
				rhs[0].locationPath = rhs[2];
				rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
				return rhs[0];
			};
			this.reduceActions[29] = function(rhs) {
				return new PathExpr(rhs[0], [], void 0);
			};
			this.reduceActions[30] = function(rhs) {
				if (Utilities.instance_of(rhs[0], PathExpr)) {
					if (rhs[0].filterPredicates == void 0) rhs[0].filterPredicates = [];
					rhs[0].filterPredicates.push(rhs[1]);
					return rhs[0];
				} else return new PathExpr(rhs[0], [rhs[1]], void 0);
			};
			this.reduceActions[32] = function(rhs) {
				return rhs[1];
			};
			this.reduceActions[33] = function(rhs) {
				return new XString(rhs[0]);
			};
			this.reduceActions[34] = function(rhs) {
				return new XNumber(rhs[0]);
			};
			this.reduceActions[36] = function(rhs) {
				return new FunctionCall(rhs[0], []);
			};
			this.reduceActions[37] = function(rhs) {
				return new FunctionCall(rhs[0], rhs[2]);
			};
			this.reduceActions[38] = function(rhs) {
				return [rhs[0]];
			};
			this.reduceActions[39] = function(rhs) {
				rhs[2].unshift(rhs[0]);
				return rhs[2];
			};
			this.reduceActions[43] = function(rhs) {
				return new LocationPath(true, []);
			};
			this.reduceActions[44] = function(rhs) {
				rhs[1].absolute = true;
				return rhs[1];
			};
			this.reduceActions[46] = function(rhs) {
				return new LocationPath(false, [rhs[0]]);
			};
			this.reduceActions[47] = function(rhs) {
				rhs[0].steps.push(rhs[2]);
				return rhs[0];
			};
			this.reduceActions[49] = function(rhs) {
				return new Step(rhs[0], rhs[1], []);
			};
			this.reduceActions[50] = function(rhs) {
				return new Step(Step.CHILD, rhs[0], []);
			};
			this.reduceActions[51] = function(rhs) {
				return new Step(rhs[0], rhs[1], rhs[2]);
			};
			this.reduceActions[52] = function(rhs) {
				return new Step(Step.CHILD, rhs[0], rhs[1]);
			};
			this.reduceActions[54] = function(rhs) {
				return [rhs[0]];
			};
			this.reduceActions[55] = function(rhs) {
				rhs[1].unshift(rhs[0]);
				return rhs[1];
			};
			this.reduceActions[56] = function(rhs) {
				if (rhs[0] == "ancestor") return Step.ANCESTOR;
				else if (rhs[0] == "ancestor-or-self") return Step.ANCESTORORSELF;
				else if (rhs[0] == "attribute") return Step.ATTRIBUTE;
				else if (rhs[0] == "child") return Step.CHILD;
				else if (rhs[0] == "descendant") return Step.DESCENDANT;
				else if (rhs[0] == "descendant-or-self") return Step.DESCENDANTORSELF;
				else if (rhs[0] == "following") return Step.FOLLOWING;
				else if (rhs[0] == "following-sibling") return Step.FOLLOWINGSIBLING;
				else if (rhs[0] == "namespace") return Step.NAMESPACE;
				else if (rhs[0] == "parent") return Step.PARENT;
				else if (rhs[0] == "preceding") return Step.PRECEDING;
				else if (rhs[0] == "preceding-sibling") return Step.PRECEDINGSIBLING;
				else if (rhs[0] == "self") return Step.SELF;
				return -1;
			};
			this.reduceActions[57] = function(rhs) {
				return Step.ATTRIBUTE;
			};
			this.reduceActions[59] = function(rhs) {
				if (rhs[0] == "comment") return NodeTest.commentTest;
				else if (rhs[0] == "text") return NodeTest.textTest;
				else if (rhs[0] == "processing-instruction") return NodeTest.anyPiTest;
				else if (rhs[0] == "node") return NodeTest.nodeTest;
				return new NodeTest(-1, void 0);
			};
			this.reduceActions[60] = function(rhs) {
				return new NodeTest.PITest(rhs[2]);
			};
			this.reduceActions[61] = function(rhs) {
				return rhs[1];
			};
			this.reduceActions[63] = function(rhs) {
				rhs[1].absolute = true;
				rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
				return rhs[1];
			};
			this.reduceActions[64] = function(rhs) {
				rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
				rhs[0].steps.push(rhs[2]);
				return rhs[0];
			};
			this.reduceActions[65] = function(rhs) {
				return new Step(Step.SELF, NodeTest.nodeTest, []);
			};
			this.reduceActions[66] = function(rhs) {
				return new Step(Step.PARENT, NodeTest.nodeTest, []);
			};
			this.reduceActions[67] = function(rhs) {
				return new VariableReference(rhs[1]);
			};
			this.reduceActions[68] = function(rhs) {
				return NodeTest.nameTestAny;
			};
			this.reduceActions[69] = function(rhs) {
				return new NodeTest.NameTestPrefixAny(rhs[0].split(":")[0]);
			};
			this.reduceActions[70] = function(rhs) {
				return new NodeTest.NameTestQName(rhs[0]);
			};
		};
		XPathParser.actionTable = [
			" s s        sssssssss    s ss  s  ss",
			"                 s                  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"                rrrrr               ",
			" s s        sssssssss    s ss  s  ss",
			"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
			" s s        sssssssss    s ss  s  ss",
			"                            s       ",
			"                            s       ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"  s                                 ",
			"                            s       ",
			" s           s  sssss          s  s ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"a                                   ",
			"r       s                    rr  r  ",
			"r      sr                    rr  r  ",
			"r   s  rr            s       rr  r  ",
			"r   rssrr            rss     rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrrsss         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrrs  rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r  srrrrrrrr         rrrrrrs rr sr  ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"                sssss               ",
			"r  rrrrrrrrr         rrrrrrr rr sr  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             s      ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"              s                     ",
			"                             s      ",
			"                rrrrr               ",
			" s s        sssssssss    s sss s  ss",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss      ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s           s  sssss          s  s ",
			" s           s  sssss          s  s ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			" s           s  sssss          s  s ",
			" s           s  sssss          s  s ",
			"r  rrrrrrrrr         rrrrrrr rr sr  ",
			"r  rrrrrrrrr         rrrrrrr rr sr  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             s      ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             rr     ",
			"                             s      ",
			"                             rs     ",
			"r      sr                    rr  r  ",
			"r   s  rr            s       rr  r  ",
			"r   rssrr            rss     rr  r  ",
			"r   rssrr            rss     rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrrsss         rrrrr   rr  r  ",
			"r   rrrrrsss         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"                                 r  ",
			"                                 s  ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			" s s        sssssssss    s ss  s  ss",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             r      "
		];
		XPathParser.actionTableNumber = [
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"                 J                  ",
			"a  aaaaaaaaa         aaaaaaa aa  a  ",
			"                YYYYY               ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"                            N       ",
			"                            O       ",
			"e  eeeeeeeee         eeeeeee ee ee  ",
			"f  fffffffff         fffffff ff ff  ",
			"d  ddddddddd         ddddddd dd dd  ",
			"B  BBBBBBBBB         BBBBBBB BB BB  ",
			"A  AAAAAAAAA         AAAAAAA AA AA  ",
			"  P                                 ",
			"                            Q       ",
			" 1           .  +*)('          #  \" ",
			"b  bbbbbbbbb         bbbbbbb bb  b  ",
			"                                    ",
			"!       S                    !!  !  ",
			"\"      T\"                    \"\"  \"  ",
			"$   V  $$            U       $$  $  ",
			"&   &ZY&&            &XW     &&  &  ",
			")   )))))            )))\\[   ))  )  ",
			".   ....._^]         .....   ..  .  ",
			"1   11111111         11111   11  1  ",
			"5   55555555         55555`  55  5  ",
			"7   77777777         777777  77  7  ",
			"9   99999999         999999  99  9  ",
			":  c::::::::         ::::::b :: a:  ",
			"I  fIIIIIIII         IIIIIIe II  I  ",
			"=  =========         ======= == ==  ",
			"?  ?????????         ??????? ?? ??  ",
			"C  CCCCCCCCC         CCCCCCC CC CC  ",
			"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
			"M   MMMMMMMM         MMMMMM  MM  M  ",
			"N  NNNNNNNNN         NNNNNNN NN  N  ",
			"P  PPPPPPPPP         PPPPPPP PP  P  ",
			"                +*)('               ",
			"R  RRRRRRRRR         RRRRRRR RR aR  ",
			"U  UUUUUUUUU         UUUUUUU UU  U  ",
			"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
			"c  ccccccccc         ccccccc cc cc  ",
			"                             j      ",
			"L  fLLLLLLLL         LLLLLLe LL  L  ",
			"6   66666666         66666   66  6  ",
			"              k                     ",
			"                             l      ",
			"                XXXXX               ",
			" 1 0        /.-,+*)('    & %$m #  \"!",
			"_  f________         ______e __  _  ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('      %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1           .  +*)('          #  \" ",
			" 1           .  +*)('          #  \" ",
			">  >>>>>>>>>         >>>>>>> >> >>  ",
			" 1           .  +*)('          #  \" ",
			" 1           .  +*)('          #  \" ",
			"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
			"V  VVVVVVVVV         VVVVVVV VV aV  ",
			"T  TTTTTTTTT         TTTTTTT TT  T  ",
			"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
			"                                   ",
			"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
			"D  DDDDDDDDD         DDDDDDD DD DD  ",
			"                             HH     ",
			"                                   ",
			"                             F     ",
			"#      T#                    ##  #  ",
			"%   V  %%            U       %%  %  ",
			"'   'ZY''            'XW     ''  '  ",
			"(   (ZY((            (XW     ((  (  ",
			"+   +++++            +++\\[   ++  +  ",
			"*   *****            ***\\[   **  *  ",
			"-   -----            ---\\[   --  -  ",
			",   ,,,,,            ,,,\\[   ,,  ,  ",
			"0   00000_^]         00000   00  0  ",
			"/   /////_^]         /////   //  /  ",
			"2   22222222         22222   22  2  ",
			"3   33333333         33333   33  3  ",
			"4   44444444         44444   44  4  ",
			"8   88888888         888888  88  8  ",
			"                                 ^  ",
			"                                   ",
			";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
			"<  f<<<<<<<<         <<<<<<e <<  <  ",
			"O  OOOOOOOOO         OOOOOOO OO  O  ",
			"`  `````````         ``````` ``  `  ",
			"S  SSSSSSSSS         SSSSSSS SS  S  ",
			"W  WWWWWWWWW         WWWWWWW WW  W  ",
			"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
			"E  EEEEEEEEE         EEEEEEE EE EE  ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
			"                             G      "
		];
		XPathParser.gotoTable = [
			"3456789:;<=>?@ AB  CDEFGH IJ ",
			"                             ",
			"                             ",
			"                             ",
			"L456789:;<=>?@ AB  CDEFGH IJ ",
			"            M        EFGH IJ ",
			"       N;<=>?@ AB  CDEFGH IJ ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"            S        EFGH IJ ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"              e              ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                        h  J ",
			"              i          j   ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"o456789:;<=>?@ ABpqCDEFGH IJ ",
			"                             ",
			"  r6789:;<=>?@ AB  CDEFGH IJ ",
			"   s789:;<=>?@ AB  CDEFGH IJ ",
			"    t89:;<=>?@ AB  CDEFGH IJ ",
			"    u89:;<=>?@ AB  CDEFGH IJ ",
			"     v9:;<=>?@ AB  CDEFGH IJ ",
			"     w9:;<=>?@ AB  CDEFGH IJ ",
			"     x9:;<=>?@ AB  CDEFGH IJ ",
			"     y9:;<=>?@ AB  CDEFGH IJ ",
			"      z:;<=>?@ AB  CDEFGH IJ ",
			"      {:;<=>?@ AB  CDEFGH IJ ",
			"       |;<=>?@ AB  CDEFGH IJ ",
			"       };<=>?@ AB  CDEFGH IJ ",
			"       ~;<=>?@ AB  CDEFGH IJ ",
			"         =>?@ AB  CDEFGH IJ ",
			"456789:;<=>?@ AB  CDEFGH IJ",
			"                    EFGH IJ ",
			"                    EFGH IJ ",
			"                             ",
			"                      GH IJ ",
			"                      GH IJ ",
			"              i             ",
			"              i             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"o456789:;<=>?@ ABqCDEFGH IJ ",
			"                             ",
			"                             "
		];
		XPathParser.productions = [
			[
				1,
				1,
				2
			],
			[
				2,
				1,
				3
			],
			[
				3,
				1,
				4
			],
			[
				3,
				3,
				3,
				-9,
				4
			],
			[
				4,
				1,
				5
			],
			[
				4,
				3,
				4,
				-8,
				5
			],
			[
				5,
				1,
				6
			],
			[
				5,
				3,
				5,
				-22,
				6
			],
			[
				5,
				3,
				5,
				-5,
				6
			],
			[
				6,
				1,
				7
			],
			[
				6,
				3,
				6,
				-23,
				7
			],
			[
				6,
				3,
				6,
				-24,
				7
			],
			[
				6,
				3,
				6,
				-6,
				7
			],
			[
				6,
				3,
				6,
				-7,
				7
			],
			[
				7,
				1,
				8
			],
			[
				7,
				3,
				7,
				-25,
				8
			],
			[
				7,
				3,
				7,
				-26,
				8
			],
			[
				8,
				1,
				9
			],
			[
				8,
				3,
				8,
				-12,
				9
			],
			[
				8,
				3,
				8,
				-11,
				9
			],
			[
				8,
				3,
				8,
				-10,
				9
			],
			[
				9,
				1,
				10
			],
			[
				9,
				2,
				-26,
				9
			],
			[
				10,
				1,
				11
			],
			[
				10,
				3,
				10,
				-27,
				11
			],
			[
				11,
				1,
				12
			],
			[
				11,
				1,
				13
			],
			[
				11,
				3,
				13,
				-28,
				14
			],
			[
				11,
				3,
				13,
				-4,
				14
			],
			[
				13,
				1,
				15
			],
			[
				13,
				2,
				13,
				16
			],
			[
				15,
				1,
				17
			],
			[
				15,
				3,
				-29,
				2,
				-30
			],
			[
				15,
				1,
				-15
			],
			[
				15,
				1,
				-16
			],
			[
				15,
				1,
				18
			],
			[
				18,
				3,
				-13,
				-29,
				-30
			],
			[
				18,
				4,
				-13,
				-29,
				19,
				-30
			],
			[
				19,
				1,
				20
			],
			[
				19,
				3,
				20,
				-31,
				19
			],
			[
				20,
				1,
				2
			],
			[
				12,
				1,
				14
			],
			[
				12,
				1,
				21
			],
			[
				21,
				1,
				-28
			],
			[
				21,
				2,
				-28,
				14
			],
			[
				21,
				1,
				22
			],
			[
				14,
				1,
				23
			],
			[
				14,
				3,
				14,
				-28,
				23
			],
			[
				14,
				1,
				24
			],
			[
				23,
				2,
				25,
				26
			],
			[
				23,
				1,
				26
			],
			[
				23,
				3,
				25,
				26,
				27
			],
			[
				23,
				2,
				26,
				27
			],
			[
				23,
				1,
				28
			],
			[
				27,
				1,
				16
			],
			[
				27,
				2,
				16,
				27
			],
			[
				25,
				2,
				-14,
				-3
			],
			[
				25,
				1,
				-32
			],
			[
				26,
				1,
				29
			],
			[
				26,
				3,
				-20,
				-29,
				-30
			],
			[
				26,
				4,
				-21,
				-29,
				-15,
				-30
			],
			[
				16,
				3,
				-33,
				30,
				-34
			],
			[
				30,
				1,
				2
			],
			[
				22,
				2,
				-4,
				14
			],
			[
				24,
				3,
				14,
				-4,
				23
			],
			[
				28,
				1,
				-35
			],
			[
				28,
				1,
				-2
			],
			[
				17,
				2,
				-36,
				-18
			],
			[
				29,
				1,
				-17
			],
			[
				29,
				1,
				-19
			],
			[
				29,
				1,
				-18
			]
		];
		XPathParser.DOUBLEDOT = 2;
		XPathParser.DOUBLECOLON = 3;
		XPathParser.DOUBLESLASH = 4;
		XPathParser.NOTEQUAL = 5;
		XPathParser.LESSTHANOREQUAL = 6;
		XPathParser.GREATERTHANOREQUAL = 7;
		XPathParser.AND = 8;
		XPathParser.OR = 9;
		XPathParser.MOD = 10;
		XPathParser.DIV = 11;
		XPathParser.MULTIPLYOPERATOR = 12;
		XPathParser.FUNCTIONNAME = 13;
		XPathParser.AXISNAME = 14;
		XPathParser.LITERAL = 15;
		XPathParser.NUMBER = 16;
		XPathParser.ASTERISKNAMETEST = 17;
		XPathParser.QNAME = 18;
		XPathParser.NCNAMECOLONASTERISK = 19;
		XPathParser.NODETYPE = 20;
		XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
		XPathParser.EQUALS = 22;
		XPathParser.LESSTHAN = 23;
		XPathParser.GREATERTHAN = 24;
		XPathParser.PLUS = 25;
		XPathParser.MINUS = 26;
		XPathParser.BAR = 27;
		XPathParser.SLASH = 28;
		XPathParser.LEFTPARENTHESIS = 29;
		XPathParser.RIGHTPARENTHESIS = 30;
		XPathParser.COMMA = 31;
		XPathParser.AT = 32;
		XPathParser.LEFTBRACKET = 33;
		XPathParser.RIGHTBRACKET = 34;
		XPathParser.DOT = 35;
		XPathParser.DOLLAR = 36;
		XPathParser.prototype.tokenize = function(s1) {
			var types = [];
			var values = [];
			var s = s1 + "\0";
			var pos = 0;
			var c = s.charAt(pos++);
			while (1) {
				while (c == " " || c == "	" || c == "\r" || c == "\n") c = s.charAt(pos++);
				if (c == "\0" || pos >= s.length) break;
				if (c == "(") {
					types.push(XPathParser.LEFTPARENTHESIS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ")") {
					types.push(XPathParser.RIGHTPARENTHESIS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "[") {
					types.push(XPathParser.LEFTBRACKET);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "]") {
					types.push(XPathParser.RIGHTBRACKET);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "@") {
					types.push(XPathParser.AT);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ",") {
					types.push(XPathParser.COMMA);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "|") {
					types.push(XPathParser.BAR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "+") {
					types.push(XPathParser.PLUS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "-") {
					types.push(XPathParser.MINUS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "=") {
					types.push(XPathParser.EQUALS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "$") {
					types.push(XPathParser.DOLLAR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ".") {
					c = s.charAt(pos++);
					if (c == ".") {
						types.push(XPathParser.DOUBLEDOT);
						values.push("..");
						c = s.charAt(pos++);
						continue;
					}
					if (c >= "0" && c <= "9") {
						var number$3 = "." + c;
						c = s.charAt(pos++);
						while (c >= "0" && c <= "9") {
							number$3 += c;
							c = s.charAt(pos++);
						}
						types.push(XPathParser.NUMBER);
						values.push(number$3);
						continue;
					}
					types.push(XPathParser.DOT);
					values.push(".");
					continue;
				}
				if (c == "'" || c == "\"") {
					var delimiter = c;
					var literal$1 = "";
					while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
						literal$1 += c;
						pos += 1;
					}
					if (c !== delimiter) throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal$1);
					pos += 1;
					types.push(XPathParser.LITERAL);
					values.push(literal$1);
					c = s.charAt(pos++);
					continue;
				}
				if (c >= "0" && c <= "9") {
					var number$3 = c;
					c = s.charAt(pos++);
					while (c >= "0" && c <= "9") {
						number$3 += c;
						c = s.charAt(pos++);
					}
					if (c == ".") {
						if (s.charAt(pos) >= "0" && s.charAt(pos) <= "9") {
							number$3 += c;
							number$3 += s.charAt(pos++);
							c = s.charAt(pos++);
							while (c >= "0" && c <= "9") {
								number$3 += c;
								c = s.charAt(pos++);
							}
						}
					}
					types.push(XPathParser.NUMBER);
					values.push(number$3);
					continue;
				}
				if (c == "*") {
					if (types.length > 0) {
						var last = types[types.length - 1];
						if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
							types.push(XPathParser.MULTIPLYOPERATOR);
							values.push(c);
							c = s.charAt(pos++);
							continue;
						}
					}
					types.push(XPathParser.ASTERISKNAMETEST);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ":") {
					if (s.charAt(pos) == ":") {
						types.push(XPathParser.DOUBLECOLON);
						values.push("::");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
				}
				if (c == "/") {
					c = s.charAt(pos++);
					if (c == "/") {
						types.push(XPathParser.DOUBLESLASH);
						values.push("//");
						c = s.charAt(pos++);
						continue;
					}
					types.push(XPathParser.SLASH);
					values.push("/");
					continue;
				}
				if (c == "!") {
					if (s.charAt(pos) == "=") {
						types.push(XPathParser.NOTEQUAL);
						values.push("!=");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
				}
				if (c == "<") {
					if (s.charAt(pos) == "=") {
						types.push(XPathParser.LESSTHANOREQUAL);
						values.push("<=");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
					types.push(XPathParser.LESSTHAN);
					values.push("<");
					c = s.charAt(pos++);
					continue;
				}
				if (c == ">") {
					if (s.charAt(pos) == "=") {
						types.push(XPathParser.GREATERTHANOREQUAL);
						values.push(">=");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
					types.push(XPathParser.GREATERTHAN);
					values.push(">");
					c = s.charAt(pos++);
					continue;
				}
				if (c == "_" || Utilities.isLetter(c.charCodeAt(0))) {
					var name$1 = c;
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name$1 += c;
						c = s.charAt(pos++);
					}
					if (types.length > 0) {
						var last = types[types.length - 1];
						if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
							if (name$1 == "and") {
								types.push(XPathParser.AND);
								values.push(name$1);
								continue;
							}
							if (name$1 == "or") {
								types.push(XPathParser.OR);
								values.push(name$1);
								continue;
							}
							if (name$1 == "mod") {
								types.push(XPathParser.MOD);
								values.push(name$1);
								continue;
							}
							if (name$1 == "div") {
								types.push(XPathParser.DIV);
								values.push(name$1);
								continue;
							}
						}
					}
					if (c == ":") {
						if (s.charAt(pos) == "*") {
							types.push(XPathParser.NCNAMECOLONASTERISK);
							values.push(name$1 + ":*");
							pos++;
							c = s.charAt(pos++);
							continue;
						}
						if (s.charAt(pos) == "_" || Utilities.isLetter(s.charCodeAt(pos))) {
							name$1 += ":";
							c = s.charAt(pos++);
							while (Utilities.isNCNameChar(c.charCodeAt(0))) {
								name$1 += c;
								c = s.charAt(pos++);
							}
							if (c == "(") {
								types.push(XPathParser.FUNCTIONNAME);
								values.push(name$1);
								continue;
							}
							types.push(XPathParser.QNAME);
							values.push(name$1);
							continue;
						}
						if (s.charAt(pos) == ":") {
							types.push(XPathParser.AXISNAME);
							values.push(name$1);
							continue;
						}
					}
					if (c == "(") {
						if (name$1 == "comment" || name$1 == "text" || name$1 == "node") {
							types.push(XPathParser.NODETYPE);
							values.push(name$1);
							continue;
						}
						if (name$1 == "processing-instruction") {
							if (s.charAt(pos) == ")") types.push(XPathParser.NODETYPE);
							else types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
							values.push(name$1);
							continue;
						}
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name$1);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name$1);
					continue;
				}
				throw new Error("Unexpected character " + c);
			}
			types.push(1);
			values.push("[EOF]");
			return [types, values];
		};
		XPathParser.SHIFT = "s";
		XPathParser.REDUCE = "r";
		XPathParser.ACCEPT = "a";
		XPathParser.prototype.parse = function(s) {
			var types;
			var values;
			var res = this.tokenize(s);
			if (res == void 0) return;
			types = res[0];
			values = res[1];
			var tokenPos = 0;
			var state = [];
			var tokenType = [];
			var tokenValue = [];
			var s;
			var a;
			var t;
			state.push(0);
			tokenType.push(1);
			tokenValue.push("_S");
			a = types[tokenPos];
			t = values[tokenPos++];
			while (1) {
				s = state[state.length - 1];
				switch (XPathParser.actionTable[s].charAt(a - 1)) {
					case XPathParser.SHIFT:
						tokenType.push(-a);
						tokenValue.push(t);
						state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
						a = types[tokenPos];
						t = values[tokenPos++];
						break;
					case XPathParser.REDUCE:
						var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
						var rhs = [];
						for (var i = 0; i < num; i++) {
							tokenType.pop();
							rhs.unshift(tokenValue.pop());
							state.pop();
						}
						var s_ = state[state.length - 1];
						tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
						if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == void 0) tokenValue.push(rhs[0]);
						else tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
						state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
						break;
					case XPathParser.ACCEPT: return new XPath(tokenValue.pop());
					default: throw new Error("XPath parse error");
				}
			}
		};
		XPath.prototype = /* @__PURE__ */ new Object();
		XPath.prototype.constructor = XPath;
		XPath.superclass = Object.prototype;
		function XPath(e) {
			this.expression = e;
		}
		XPath.prototype.toString = function() {
			return this.expression.toString();
		};
		function setIfUnset(obj, prop, value) {
			if (!(prop in obj)) obj[prop] = value;
		}
		XPath.prototype.evaluate = function(c) {
			c.contextNode = c.expressionContextNode;
			c.contextSize = 1;
			c.contextPosition = 1;
			if (c.isHtml) {
				setIfUnset(c, "caseInsensitive", true);
				setIfUnset(c, "allowAnyNamespaceForNoPrefix", true);
			}
			setIfUnset(c, "caseInsensitive", false);
			return this.expression.evaluate(c);
		};
		XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
		XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";
		Expression.prototype = /* @__PURE__ */ new Object();
		Expression.prototype.constructor = Expression;
		Expression.superclass = Object.prototype;
		function Expression() {}
		Expression.prototype.init = function() {};
		Expression.prototype.toString = function() {
			return "<Expression>";
		};
		Expression.prototype.evaluate = function(c) {
			throw new Error("Could not evaluate expression.");
		};
		UnaryOperation.prototype = new Expression();
		UnaryOperation.prototype.constructor = UnaryOperation;
		UnaryOperation.superclass = Expression.prototype;
		function UnaryOperation(rhs) {
			if (arguments.length > 0) this.init(rhs);
		}
		UnaryOperation.prototype.init = function(rhs) {
			this.rhs = rhs;
		};
		UnaryMinusOperation.prototype = new UnaryOperation();
		UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
		UnaryMinusOperation.superclass = UnaryOperation.prototype;
		function UnaryMinusOperation(rhs) {
			if (arguments.length > 0) this.init(rhs);
		}
		UnaryMinusOperation.prototype.init = function(rhs) {
			UnaryMinusOperation.superclass.init.call(this, rhs);
		};
		UnaryMinusOperation.prototype.evaluate = function(c) {
			return this.rhs.evaluate(c).number().negate();
		};
		UnaryMinusOperation.prototype.toString = function() {
			return "-" + this.rhs.toString();
		};
		BinaryOperation.prototype = new Expression();
		BinaryOperation.prototype.constructor = BinaryOperation;
		BinaryOperation.superclass = Expression.prototype;
		function BinaryOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		BinaryOperation.prototype.init = function(lhs, rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		};
		OrOperation.prototype = new BinaryOperation();
		OrOperation.prototype.constructor = OrOperation;
		OrOperation.superclass = BinaryOperation.prototype;
		function OrOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		OrOperation.prototype.init = function(lhs, rhs) {
			OrOperation.superclass.init.call(this, lhs, rhs);
		};
		OrOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
		};
		OrOperation.prototype.evaluate = function(c) {
			var b = this.lhs.evaluate(c).bool();
			if (b.booleanValue()) return b;
			return this.rhs.evaluate(c).bool();
		};
		AndOperation.prototype = new BinaryOperation();
		AndOperation.prototype.constructor = AndOperation;
		AndOperation.superclass = BinaryOperation.prototype;
		function AndOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		AndOperation.prototype.init = function(lhs, rhs) {
			AndOperation.superclass.init.call(this, lhs, rhs);
		};
		AndOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
		};
		AndOperation.prototype.evaluate = function(c) {
			var b = this.lhs.evaluate(c).bool();
			if (!b.booleanValue()) return b;
			return this.rhs.evaluate(c).bool();
		};
		EqualsOperation.prototype = new BinaryOperation();
		EqualsOperation.prototype.constructor = EqualsOperation;
		EqualsOperation.superclass = BinaryOperation.prototype;
		function EqualsOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		EqualsOperation.prototype.init = function(lhs, rhs) {
			EqualsOperation.superclass.init.call(this, lhs, rhs);
		};
		EqualsOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
		};
		EqualsOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
		};
		NotEqualOperation.prototype = new BinaryOperation();
		NotEqualOperation.prototype.constructor = NotEqualOperation;
		NotEqualOperation.superclass = BinaryOperation.prototype;
		function NotEqualOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		NotEqualOperation.prototype.init = function(lhs, rhs) {
			NotEqualOperation.superclass.init.call(this, lhs, rhs);
		};
		NotEqualOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
		};
		NotEqualOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
		};
		LessThanOperation.prototype = new BinaryOperation();
		LessThanOperation.prototype.constructor = LessThanOperation;
		LessThanOperation.superclass = BinaryOperation.prototype;
		function LessThanOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		LessThanOperation.prototype.init = function(lhs, rhs) {
			LessThanOperation.superclass.init.call(this, lhs, rhs);
		};
		LessThanOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
		};
		LessThanOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
		};
		GreaterThanOperation.prototype = new BinaryOperation();
		GreaterThanOperation.prototype.constructor = GreaterThanOperation;
		GreaterThanOperation.superclass = BinaryOperation.prototype;
		function GreaterThanOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		GreaterThanOperation.prototype.init = function(lhs, rhs) {
			GreaterThanOperation.superclass.init.call(this, lhs, rhs);
		};
		GreaterThanOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
		};
		GreaterThanOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
		};
		LessThanOrEqualOperation.prototype = new BinaryOperation();
		LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
		LessThanOrEqualOperation.superclass = BinaryOperation.prototype;
		function LessThanOrEqualOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
			LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
		};
		LessThanOrEqualOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
		};
		LessThanOrEqualOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
		};
		GreaterThanOrEqualOperation.prototype = new BinaryOperation();
		GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
		GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;
		function GreaterThanOrEqualOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
			GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
		};
		GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
		};
		GreaterThanOrEqualOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
		};
		PlusOperation.prototype = new BinaryOperation();
		PlusOperation.prototype.constructor = PlusOperation;
		PlusOperation.superclass = BinaryOperation.prototype;
		function PlusOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		PlusOperation.prototype.init = function(lhs, rhs) {
			PlusOperation.superclass.init.call(this, lhs, rhs);
		};
		PlusOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
		};
		PlusOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
		};
		MinusOperation.prototype = new BinaryOperation();
		MinusOperation.prototype.constructor = MinusOperation;
		MinusOperation.superclass = BinaryOperation.prototype;
		function MinusOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		MinusOperation.prototype.init = function(lhs, rhs) {
			MinusOperation.superclass.init.call(this, lhs, rhs);
		};
		MinusOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
		};
		MinusOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
		};
		MultiplyOperation.prototype = new BinaryOperation();
		MultiplyOperation.prototype.constructor = MultiplyOperation;
		MultiplyOperation.superclass = BinaryOperation.prototype;
		function MultiplyOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		MultiplyOperation.prototype.init = function(lhs, rhs) {
			MultiplyOperation.superclass.init.call(this, lhs, rhs);
		};
		MultiplyOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
		};
		MultiplyOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
		};
		DivOperation.prototype = new BinaryOperation();
		DivOperation.prototype.constructor = DivOperation;
		DivOperation.superclass = BinaryOperation.prototype;
		function DivOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		DivOperation.prototype.init = function(lhs, rhs) {
			DivOperation.superclass.init.call(this, lhs, rhs);
		};
		DivOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
		};
		DivOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
		};
		ModOperation.prototype = new BinaryOperation();
		ModOperation.prototype.constructor = ModOperation;
		ModOperation.superclass = BinaryOperation.prototype;
		function ModOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		ModOperation.prototype.init = function(lhs, rhs) {
			ModOperation.superclass.init.call(this, lhs, rhs);
		};
		ModOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
		};
		ModOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
		};
		BarOperation.prototype = new BinaryOperation();
		BarOperation.prototype.constructor = BarOperation;
		BarOperation.superclass = BinaryOperation.prototype;
		function BarOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		BarOperation.prototype.init = function(lhs, rhs) {
			BarOperation.superclass.init.call(this, lhs, rhs);
		};
		BarOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
		};
		BarOperation.prototype.toString = function() {
			return map$1(toString, [this.lhs, this.rhs]).join(" | ");
		};
		PathExpr.prototype = new Expression();
		PathExpr.prototype.constructor = PathExpr;
		PathExpr.superclass = Expression.prototype;
		function PathExpr(filter$1, filterPreds, locpath) {
			if (arguments.length > 0) this.init(filter$1, filterPreds, locpath);
		}
		PathExpr.prototype.init = function(filter$1, filterPreds, locpath) {
			PathExpr.superclass.init.call(this);
			this.filter = filter$1;
			this.filterPredicates = filterPreds;
			this.locationPath = locpath;
		};
		/**
		* Returns the topmost node of the tree containing node
		*/
		function findRoot(node) {
			while (node && node.parentNode) node = node.parentNode;
			return node;
		}
		PathExpr.applyPredicates = function(predicates, c, nodes) {
			if (predicates.length === 0) return nodes;
			var ctx = c.extend({});
			return reduce(function(inNodes, pred) {
				ctx.contextSize = inNodes.length;
				return filter(function(node, i) {
					ctx.contextNode = node;
					ctx.contextPosition = i + 1;
					return PathExpr.predicateMatches(pred, ctx);
				}, inNodes);
			}, nodes, predicates);
		};
		PathExpr.getRoot = function(xpc, nodes) {
			var firstNode = nodes[0];
			if (firstNode.nodeType === 9) return firstNode;
			if (xpc.virtualRoot) return xpc.virtualRoot;
			var ownerDoc = firstNode.ownerDocument;
			if (ownerDoc) return ownerDoc;
			var n = firstNode;
			while (n.parentNode != null) n = n.parentNode;
			return n;
		};
		PathExpr.applyStep = function(step, xpc, node) {
			var newNodes = [];
			xpc.contextNode = node;
			switch (step.axis) {
				case Step.ANCESTOR:
					if (xpc.contextNode === xpc.virtualRoot) break;
					var m;
					if (xpc.contextNode.nodeType == 2) m = PathExpr.getOwnerElement(xpc.contextNode);
					else m = xpc.contextNode.parentNode;
					while (m != null) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m === xpc.virtualRoot) break;
						m = m.parentNode;
					}
					break;
				case Step.ANCESTORORSELF:
					for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 ? PathExpr.getOwnerElement(m) : m.parentNode) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m === xpc.virtualRoot) break;
					}
					break;
				case Step.ATTRIBUTE:
					var nnm = xpc.contextNode.attributes;
					if (nnm != null) for (var k = 0; k < nnm.length; k++) {
						var m = nnm.item(k);
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					}
					break;
				case Step.CHILD:
					for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.DESCENDANT:
					var st = [xpc.contextNode.firstChild];
					while (st.length > 0) for (var m = st.pop(); m != null;) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m.firstChild != null) {
							st.push(m.nextSibling);
							m = m.firstChild;
						} else m = m.nextSibling;
					}
					break;
				case Step.DESCENDANTORSELF:
					if (step.nodeTest.matches(xpc.contextNode, xpc)) newNodes.push(xpc.contextNode);
					var st = [xpc.contextNode.firstChild];
					while (st.length > 0) for (var m = st.pop(); m != null;) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m.firstChild != null) {
							st.push(m.nextSibling);
							m = m.firstChild;
						} else m = m.nextSibling;
					}
					break;
				case Step.FOLLOWING:
					if (xpc.contextNode === xpc.virtualRoot) break;
					var st = [];
					if (xpc.contextNode.firstChild != null) st.unshift(xpc.contextNode.firstChild);
					else st.unshift(xpc.contextNode.nextSibling);
					for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 && m !== xpc.virtualRoot; m = m.parentNode) st.unshift(m.nextSibling);
					do
						for (var m = st.pop(); m != null;) {
							if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
							if (m.firstChild != null) {
								st.push(m.nextSibling);
								m = m.firstChild;
							} else m = m.nextSibling;
						}
					while (st.length > 0);
					break;
				case Step.FOLLOWINGSIBLING:
					if (xpc.contextNode === xpc.virtualRoot) break;
					for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.NAMESPACE:
					var n = {};
					if (xpc.contextNode.nodeType == 1) {
						n["xml"] = XPath.XML_NAMESPACE_URI;
						n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
						for (var m = xpc.contextNode; m != null && m.nodeType == 1; m = m.parentNode) for (var k = 0; k < m.attributes.length; k++) {
							var attr = m.attributes.item(k);
							var nm = String(attr.name);
							if (nm == "xmlns") {
								if (n[""] == void 0) n[""] = attr.value;
							} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
								var pre = nm.substring(6, nm.length);
								if (n[pre] == void 0) n[pre] = attr.value;
							}
						}
						for (var pre in n) {
							var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
							if (step.nodeTest.matches(nsn, xpc)) newNodes.push(nsn);
						}
					}
					break;
				case Step.PARENT:
					m = null;
					if (xpc.contextNode !== xpc.virtualRoot) if (xpc.contextNode.nodeType == 2) m = PathExpr.getOwnerElement(xpc.contextNode);
					else m = xpc.contextNode.parentNode;
					if (m != null && step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.PRECEDING:
					var st;
					if (xpc.virtualRoot != null) st = [xpc.virtualRoot];
					else st = [findRoot(xpc.contextNode)];
					outer: while (st.length > 0) for (var m = st.pop(); m != null;) {
						if (m == xpc.contextNode) break outer;
						if (step.nodeTest.matches(m, xpc)) newNodes.unshift(m);
						if (m.firstChild != null) {
							st.push(m.nextSibling);
							m = m.firstChild;
						} else m = m.nextSibling;
					}
					break;
				case Step.PRECEDINGSIBLING:
					if (xpc.contextNode === xpc.virtualRoot) break;
					for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.SELF:
					if (step.nodeTest.matches(xpc.contextNode, xpc)) newNodes.push(xpc.contextNode);
					break;
				default:
			}
			return newNodes;
		};
		function applyStepWithPredicates(step, xpc, node) {
			return PathExpr.applyPredicates(step.predicates, xpc, PathExpr.applyStep(step, xpc, node));
		}
		function applyStepToNodes(context, nodes, step) {
			return flatten(map$1(applyStepWithPredicates.bind(null, step, context), nodes));
		}
		PathExpr.applySteps = function(steps, xpc, nodes) {
			return reduce(applyStepToNodes.bind(null, xpc), nodes, steps);
		};
		PathExpr.prototype.applyFilter = function(c, xpc) {
			if (!this.filter) return { nodes: [c.contextNode] };
			var ns = this.filter.evaluate(c);
			if (!Utilities.instance_of(ns, XNodeSet)) {
				if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
				return { nonNodes: ns };
			}
			return { nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray()) };
		};
		PathExpr.applyLocationPath = function(locationPath, xpc, nodes) {
			if (!locationPath) return nodes;
			var startNodes = locationPath.absolute ? [PathExpr.getRoot(xpc, nodes)] : nodes;
			return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
		};
		PathExpr.prototype.evaluate = function(c) {
			var xpc = assign(new XPathContext(), c);
			var filterResult = this.applyFilter(c, xpc);
			if ("nonNodes" in filterResult) return filterResult.nonNodes;
			var ns = new XNodeSet();
			ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
			return ns;
		};
		PathExpr.predicateMatches = function(pred, c) {
			var res = pred.evaluate(c);
			return Utilities.instance_of(res, XNumber) ? c.contextPosition === res.numberValue() : res.booleanValue();
		};
		PathExpr.predicateString = function(predicate) {
			return wrap("[", "]", predicate.toString());
		};
		PathExpr.predicatesString = function(predicates) {
			return join("", map$1(PathExpr.predicateString, predicates));
		};
		PathExpr.prototype.toString = function() {
			if (this.filter != void 0) {
				var filterStr = toString(this.filter);
				if (Utilities.instance_of(this.filter, XString)) return wrap("'", "'", filterStr);
				if (this.filterPredicates != void 0 && this.filterPredicates.length) return wrap("(", ")", filterStr) + PathExpr.predicatesString(this.filterPredicates);
				if (this.locationPath != void 0) return filterStr + (this.locationPath.absolute ? "" : "/") + toString(this.locationPath);
				return filterStr;
			}
			return toString(this.locationPath);
		};
		PathExpr.getOwnerElement = function(n) {
			if (n.ownerElement) return n.ownerElement;
			try {
				if (n.selectSingleNode) return n.selectSingleNode("..");
			} catch (e) {}
			var elts = (n.nodeType == 9 ? n : n.ownerDocument).getElementsByTagName("*");
			for (var i = 0; i < elts.length; i++) {
				var elt = elts.item(i);
				var nnm = elt.attributes;
				for (var j = 0; j < nnm.length; j++) if (nnm.item(j) === n) return elt;
			}
			return null;
		};
		LocationPath.prototype = /* @__PURE__ */ new Object();
		LocationPath.prototype.constructor = LocationPath;
		LocationPath.superclass = Object.prototype;
		function LocationPath(abs, steps) {
			if (arguments.length > 0) this.init(abs, steps);
		}
		LocationPath.prototype.init = function(abs, steps) {
			this.absolute = abs;
			this.steps = steps;
		};
		LocationPath.prototype.toString = function() {
			return (this.absolute ? "/" : "") + map$1(toString, this.steps).join("/");
		};
		Step.prototype = /* @__PURE__ */ new Object();
		Step.prototype.constructor = Step;
		Step.superclass = Object.prototype;
		function Step(axis, nodetest, preds) {
			if (arguments.length > 0) this.init(axis, nodetest, preds);
		}
		Step.prototype.init = function(axis, nodetest, preds) {
			this.axis = axis;
			this.nodeTest = nodetest;
			this.predicates = preds;
		};
		Step.prototype.toString = function() {
			return Step.STEPNAMES[this.axis] + "::" + this.nodeTest.toString() + PathExpr.predicatesString(this.predicates);
		};
		Step.ANCESTOR = 0;
		Step.ANCESTORORSELF = 1;
		Step.ATTRIBUTE = 2;
		Step.CHILD = 3;
		Step.DESCENDANT = 4;
		Step.DESCENDANTORSELF = 5;
		Step.FOLLOWING = 6;
		Step.FOLLOWINGSIBLING = 7;
		Step.NAMESPACE = 8;
		Step.PARENT = 9;
		Step.PRECEDING = 10;
		Step.PRECEDINGSIBLING = 11;
		Step.SELF = 12;
		Step.STEPNAMES = reduce(function(acc, x) {
			return acc[x[0]] = x[1], acc;
		}, {}, [
			[Step.ANCESTOR, "ancestor"],
			[Step.ANCESTORORSELF, "ancestor-or-self"],
			[Step.ATTRIBUTE, "attribute"],
			[Step.CHILD, "child"],
			[Step.DESCENDANT, "descendant"],
			[Step.DESCENDANTORSELF, "descendant-or-self"],
			[Step.FOLLOWING, "following"],
			[Step.FOLLOWINGSIBLING, "following-sibling"],
			[Step.NAMESPACE, "namespace"],
			[Step.PARENT, "parent"],
			[Step.PRECEDING, "preceding"],
			[Step.PRECEDINGSIBLING, "preceding-sibling"],
			[Step.SELF, "self"]
		]);
		NodeTest.prototype = /* @__PURE__ */ new Object();
		NodeTest.prototype.constructor = NodeTest;
		NodeTest.superclass = Object.prototype;
		function NodeTest(type, value) {
			if (arguments.length > 0) this.init(type, value);
		}
		NodeTest.prototype.init = function(type, value) {
			this.type = type;
			this.value = value;
		};
		NodeTest.prototype.toString = function() {
			return "<unknown nodetest type>";
		};
		NodeTest.prototype.matches = function(n, xpc) {
			console.warn("unknown node test type");
		};
		NodeTest.NAMETESTANY = 0;
		NodeTest.NAMETESTPREFIXANY = 1;
		NodeTest.NAMETESTQNAME = 2;
		NodeTest.COMMENT = 3;
		NodeTest.TEXT = 4;
		NodeTest.PI = 5;
		NodeTest.NODE = 6;
		NodeTest.isNodeType = function(types) {
			return function(node) {
				return includes(types, node.nodeType);
			};
		};
		NodeTest.makeNodeTestType = function(type, members, ctor) {
			var newType = ctor || function() {};
			newType.prototype = new NodeTest(type);
			newType.prototype.constructor = newType;
			assign(newType.prototype, members);
			return newType;
		};
		NodeTest.makeNodeTypeTest = function(type, nodeTypes, stringVal) {
			return new (NodeTest.makeNodeTestType(type, {
				matches: NodeTest.isNodeType(nodeTypes),
				toString: always(stringVal)
			}))();
		};
		NodeTest.hasPrefix = function(node) {
			return node.prefix || (node.nodeName || node.tagName).indexOf(":") !== -1;
		};
		NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
		NodeTest.nameSpaceMatches = function(prefix, xpc, n) {
			var nNamespace = n.namespaceURI || "";
			if (!prefix) return !nNamespace || xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n);
			var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);
			if (ns == null) throw new Error("Cannot resolve QName " + prefix);
			return ns === nNamespace;
		};
		NodeTest.localNameMatches = function(localName, xpc, n) {
			var nLocalName = n.localName || n.nodeName;
			return xpc.caseInsensitive ? localName.toLowerCase() === nLocalName.toLowerCase() : localName === nLocalName;
		};
		NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(NodeTest.NAMETESTPREFIXANY, {
			matches: function(n, xpc) {
				return NodeTest.isElementOrAttribute(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n);
			},
			toString: function() {
				return this.prefix + ":*";
			}
		}, function NameTestPrefixAny(prefix) {
			this.prefix = prefix;
		});
		NodeTest.NameTestQName = NodeTest.makeNodeTestType(NodeTest.NAMETESTQNAME, {
			matches: function(n, xpc) {
				return NodeTest.isNodeType([
					1,
					2,
					XPathNamespace.XPATH_NAMESPACE_NODE
				])(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n) && NodeTest.localNameMatches(this.localName, xpc, n);
			},
			toString: function() {
				return this.name;
			}
		}, function NameTestQName(name$1) {
			var nameParts = name$1.split(":");
			this.name = name$1;
			this.prefix = nameParts.length > 1 ? nameParts[0] : null;
			this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
		});
		NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
			matches: function(n, xpc) {
				return NodeTest.isNodeType([7])(n) && (n.target || n.nodeName) === this.name;
			},
			toString: function() {
				return wrap("processing-instruction(\"", "\")", this.name);
			}
		}, function(name$1) {
			this.name = name$1;
		});
		NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [
			1,
			2,
			XPathNamespace.XPATH_NAMESPACE_NODE
		], "*");
		NodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], "text()");
		NodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], "comment()");
		NodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [
			1,
			2,
			3,
			4,
			7,
			8,
			9
		], "node()");
		NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], "processing-instruction()");
		VariableReference.prototype = new Expression();
		VariableReference.prototype.constructor = VariableReference;
		VariableReference.superclass = Expression.prototype;
		function VariableReference(v) {
			if (arguments.length > 0) this.init(v);
		}
		VariableReference.prototype.init = function(v) {
			this.variable = v;
		};
		VariableReference.prototype.toString = function() {
			return "$" + this.variable;
		};
		VariableReference.prototype.evaluate = function(c) {
			var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);
			if (parts[0] == null) throw new Error("Cannot resolve QName " + fn);
			var result = c.variableResolver.getVariable(parts[1], parts[0]);
			if (!result) throw XPathException.fromMessage("Undeclared variable: " + this.toString());
			return result;
		};
		FunctionCall.prototype = new Expression();
		FunctionCall.prototype.constructor = FunctionCall;
		FunctionCall.superclass = Expression.prototype;
		function FunctionCall(fn$1, args) {
			if (arguments.length > 0) this.init(fn$1, args);
		}
		FunctionCall.prototype.init = function(fn$1, args) {
			this.functionName = fn$1;
			this.arguments = args;
		};
		FunctionCall.prototype.toString = function() {
			var s = this.functionName + "(";
			for (var i = 0; i < this.arguments.length; i++) {
				if (i > 0) s += ", ";
				s += this.arguments[i].toString();
			}
			return s + ")";
		};
		FunctionCall.prototype.evaluate = function(c) {
			var f = FunctionResolver.getFunctionFromContext(this.functionName, c);
			if (!f) throw new Error("Unknown function " + this.functionName);
			var a = [c].concat(this.arguments);
			return f.apply(c.functionResolver.thisArg, a);
		};
		var Operators = /* @__PURE__ */ new Object();
		Operators.equals = function(l, r) {
			return l.equals(r);
		};
		Operators.notequal = function(l, r) {
			return l.notequal(r);
		};
		Operators.lessthan = function(l, r) {
			return l.lessthan(r);
		};
		Operators.greaterthan = function(l, r) {
			return l.greaterthan(r);
		};
		Operators.lessthanorequal = function(l, r) {
			return l.lessthanorequal(r);
		};
		Operators.greaterthanorequal = function(l, r) {
			return l.greaterthanorequal(r);
		};
		XString.prototype = new Expression();
		XString.prototype.constructor = XString;
		XString.superclass = Expression.prototype;
		function XString(s) {
			if (arguments.length > 0) this.init(s);
		}
		XString.prototype.init = function(s) {
			this.str = String(s);
		};
		XString.prototype.toString = function() {
			return this.str;
		};
		XString.prototype.evaluate = function(c) {
			return this;
		};
		XString.prototype.string = function() {
			return this;
		};
		XString.prototype.number = function() {
			return new XNumber(this.str);
		};
		XString.prototype.bool = function() {
			return new XBoolean(this.str);
		};
		XString.prototype.nodeset = function() {
			throw new Error("Cannot convert string to nodeset");
		};
		XString.prototype.stringValue = function() {
			return this.str;
		};
		XString.prototype.numberValue = function() {
			return this.number().numberValue();
		};
		XString.prototype.booleanValue = function() {
			return this.bool().booleanValue();
		};
		XString.prototype.equals = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().equals(r);
			if (Utilities.instance_of(r, XNumber)) return this.number().equals(r);
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithString(this, Operators.equals);
			return new XBoolean(this.str == r.str);
		};
		XString.prototype.notequal = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().notequal(r);
			if (Utilities.instance_of(r, XNumber)) return this.number().notequal(r);
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithString(this, Operators.notequal);
			return new XBoolean(this.str != r.str);
		};
		XString.prototype.lessthan = function(r) {
			return this.number().lessthan(r);
		};
		XString.prototype.greaterthan = function(r) {
			return this.number().greaterthan(r);
		};
		XString.prototype.lessthanorequal = function(r) {
			return this.number().lessthanorequal(r);
		};
		XString.prototype.greaterthanorequal = function(r) {
			return this.number().greaterthanorequal(r);
		};
		XNumber.prototype = new Expression();
		XNumber.prototype.constructor = XNumber;
		XNumber.superclass = Expression.prototype;
		function XNumber(n) {
			if (arguments.length > 0) this.init(n);
		}
		XNumber.prototype.init = function(n) {
			this.num = typeof n === "string" ? this.parse(n) : Number(n);
		};
		XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;
		XNumber.prototype.parse = function(s) {
			return this.numberFormat.test(s) ? parseFloat(s) : NaN;
		};
		function padSmallNumber(numberStr) {
			var parts = numberStr.split("e-");
			var base = parts[0].replace(".", "");
			var exponent = Number(parts[1]);
			for (var i = 0; i < exponent - 1; i += 1) base = "0" + base;
			return "0." + base;
		}
		function padLargeNumber(numberStr) {
			var parts = numberStr.split("e");
			var base = parts[0].replace(".", "");
			var zerosToAppend = Number(parts[1]) + 1 - base.length;
			for (var i = 0; i < zerosToAppend; i += 1) base += "0";
			return base;
		}
		XNumber.prototype.toString = function() {
			var strValue = this.num.toString();
			if (strValue.indexOf("e-") !== -1) return padSmallNumber(strValue);
			if (strValue.indexOf("e") !== -1) return padLargeNumber(strValue);
			return strValue;
		};
		XNumber.prototype.evaluate = function(c) {
			return this;
		};
		XNumber.prototype.string = function() {
			return new XString(this.toString());
		};
		XNumber.prototype.number = function() {
			return this;
		};
		XNumber.prototype.bool = function() {
			return new XBoolean(this.num);
		};
		XNumber.prototype.nodeset = function() {
			throw new Error("Cannot convert number to nodeset");
		};
		XNumber.prototype.stringValue = function() {
			return this.string().stringValue();
		};
		XNumber.prototype.numberValue = function() {
			return this.num;
		};
		XNumber.prototype.booleanValue = function() {
			return this.bool().booleanValue();
		};
		XNumber.prototype.negate = function() {
			return new XNumber(-this.num);
		};
		XNumber.prototype.equals = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().equals(r);
			if (Utilities.instance_of(r, XString)) return this.equals(r.number());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.equals);
			return new XBoolean(this.num == r.num);
		};
		XNumber.prototype.notequal = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().notequal(r);
			if (Utilities.instance_of(r, XString)) return this.notequal(r.number());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.notequal);
			return new XBoolean(this.num != r.num);
		};
		XNumber.prototype.lessthan = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.greaterthan);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.lessthan(r.number());
			return new XBoolean(this.num < r.num);
		};
		XNumber.prototype.greaterthan = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.lessthan);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.greaterthan(r.number());
			return new XBoolean(this.num > r.num);
		};
		XNumber.prototype.lessthanorequal = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.greaterthanorequal);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.lessthanorequal(r.number());
			return new XBoolean(this.num <= r.num);
		};
		XNumber.prototype.greaterthanorequal = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.lessthanorequal);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.greaterthanorequal(r.number());
			return new XBoolean(this.num >= r.num);
		};
		XNumber.prototype.plus = function(r) {
			return new XNumber(this.num + r.num);
		};
		XNumber.prototype.minus = function(r) {
			return new XNumber(this.num - r.num);
		};
		XNumber.prototype.multiply = function(r) {
			return new XNumber(this.num * r.num);
		};
		XNumber.prototype.div = function(r) {
			return new XNumber(this.num / r.num);
		};
		XNumber.prototype.mod = function(r) {
			return new XNumber(this.num % r.num);
		};
		XBoolean.prototype = new Expression();
		XBoolean.prototype.constructor = XBoolean;
		XBoolean.superclass = Expression.prototype;
		function XBoolean(b) {
			if (arguments.length > 0) this.init(b);
		}
		XBoolean.prototype.init = function(b) {
			this.b = Boolean(b);
		};
		XBoolean.prototype.toString = function() {
			return this.b.toString();
		};
		XBoolean.prototype.evaluate = function(c) {
			return this;
		};
		XBoolean.prototype.string = function() {
			return new XString(this.b);
		};
		XBoolean.prototype.number = function() {
			return new XNumber(this.b);
		};
		XBoolean.prototype.bool = function() {
			return this;
		};
		XBoolean.prototype.nodeset = function() {
			throw new Error("Cannot convert boolean to nodeset");
		};
		XBoolean.prototype.stringValue = function() {
			return this.string().stringValue();
		};
		XBoolean.prototype.numberValue = function() {
			return this.number().numberValue();
		};
		XBoolean.prototype.booleanValue = function() {
			return this.b;
		};
		XBoolean.prototype.not = function() {
			return new XBoolean(!this.b);
		};
		XBoolean.prototype.equals = function(r) {
			if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) return this.equals(r.bool());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithBoolean(this, Operators.equals);
			return new XBoolean(this.b == r.b);
		};
		XBoolean.prototype.notequal = function(r) {
			if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) return this.notequal(r.bool());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithBoolean(this, Operators.notequal);
			return new XBoolean(this.b != r.b);
		};
		XBoolean.prototype.lessthan = function(r) {
			return this.number().lessthan(r);
		};
		XBoolean.prototype.greaterthan = function(r) {
			return this.number().greaterthan(r);
		};
		XBoolean.prototype.lessthanorequal = function(r) {
			return this.number().lessthanorequal(r);
		};
		XBoolean.prototype.greaterthanorequal = function(r) {
			return this.number().greaterthanorequal(r);
		};
		XBoolean.true_ = new XBoolean(true);
		XBoolean.false_ = new XBoolean(false);
		AVLTree.prototype = /* @__PURE__ */ new Object();
		AVLTree.prototype.constructor = AVLTree;
		AVLTree.superclass = Object.prototype;
		function AVLTree(n) {
			this.init(n);
		}
		AVLTree.prototype.init = function(n) {
			this.left = null;
			this.right = null;
			this.node = n;
			this.depth = 1;
		};
		AVLTree.prototype.balance = function() {
			var ldepth = this.left == null ? 0 : this.left.depth;
			var rdepth = this.right == null ? 0 : this.right.depth;
			if (ldepth > rdepth + 1) {
				if ((this.left.left == null ? 0 : this.left.left.depth) < (this.left.right == null ? 0 : this.left.right.depth)) this.left.rotateRR();
				this.rotateLL();
			} else if (ldepth + 1 < rdepth) {
				var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
				if ((this.right.left == null ? 0 : this.right.left.depth) > rrdepth) this.right.rotateLL();
				this.rotateRR();
			}
		};
		AVLTree.prototype.rotateLL = function() {
			var nodeBefore = this.node;
			var rightBefore = this.right;
			this.node = this.left.node;
			this.right = this.left;
			this.left = this.left.left;
			this.right.left = this.right.right;
			this.right.right = rightBefore;
			this.right.node = nodeBefore;
			this.right.updateInNewLocation();
			this.updateInNewLocation();
		};
		AVLTree.prototype.rotateRR = function() {
			var nodeBefore = this.node;
			var leftBefore = this.left;
			this.node = this.right.node;
			this.left = this.right;
			this.right = this.right.right;
			this.left.right = this.left.left;
			this.left.left = leftBefore;
			this.left.node = nodeBefore;
			this.left.updateInNewLocation();
			this.updateInNewLocation();
		};
		AVLTree.prototype.updateInNewLocation = function() {
			this.getDepthFromChildren();
		};
		AVLTree.prototype.getDepthFromChildren = function() {
			this.depth = this.node == null ? 0 : 1;
			if (this.left != null) this.depth = this.left.depth + 1;
			if (this.right != null && this.depth <= this.right.depth) this.depth = this.right.depth + 1;
		};
		function nodeOrder(n1, n2) {
			if (n1 === n2) return 0;
			if (n1.compareDocumentPosition) {
				var cpos = n1.compareDocumentPosition(n2);
				if (cpos & 1) return 1;
				if (cpos & 10) return 1;
				if (cpos & 20) return -1;
				return 0;
			}
			var d1 = 0, d2 = 0;
			for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) d1++;
			for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) d2++;
			if (d1 > d2) {
				while (d1 > d2) {
					n1 = n1.parentNode || n1.ownerElement;
					d1--;
				}
				if (n1 === n2) return 1;
			} else if (d2 > d1) {
				while (d2 > d1) {
					n2 = n2.parentNode || n2.ownerElement;
					d2--;
				}
				if (n1 === n2) return -1;
			}
			var n1Par = n1.parentNode || n1.ownerElement, n2Par = n2.parentNode || n2.ownerElement;
			while (n1Par !== n2Par) {
				n1 = n1Par;
				n2 = n2Par;
				n1Par = n1.parentNode || n1.ownerElement;
				n2Par = n2.parentNode || n2.ownerElement;
			}
			var n1isAttr = Utilities.isAttribute(n1);
			var n2isAttr = Utilities.isAttribute(n2);
			if (n1isAttr && !n2isAttr) return -1;
			if (!n1isAttr && n2isAttr) return 1;
			if (n1Par) {
				var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes, len = cn.length;
				for (var i = 0; i < len; i += 1) {
					var n = cn[i];
					if (n === n1) return -1;
					if (n === n2) return 1;
				}
			}
			throw new Error("Unexpected: could not determine node order");
		}
		AVLTree.prototype.add = function(n) {
			if (n === this.node) return false;
			var o = nodeOrder(n, this.node);
			var ret = false;
			if (o == -1) if (this.left == null) {
				this.left = new AVLTree(n);
				ret = true;
			} else {
				ret = this.left.add(n);
				if (ret) this.balance();
			}
			else if (o == 1) if (this.right == null) {
				this.right = new AVLTree(n);
				ret = true;
			} else {
				ret = this.right.add(n);
				if (ret) this.balance();
			}
			if (ret) this.getDepthFromChildren();
			return ret;
		};
		XNodeSet.prototype = new Expression();
		XNodeSet.prototype.constructor = XNodeSet;
		XNodeSet.superclass = Expression.prototype;
		function XNodeSet() {
			this.init();
		}
		XNodeSet.prototype.init = function() {
			this.tree = null;
			this.nodes = [];
			this.size = 0;
		};
		XNodeSet.prototype.toString = function() {
			var p = this.first();
			if (p == null) return "";
			return this.stringForNode(p);
		};
		XNodeSet.prototype.evaluate = function(c) {
			return this;
		};
		XNodeSet.prototype.string = function() {
			return new XString(this.toString());
		};
		XNodeSet.prototype.stringValue = function() {
			return this.toString();
		};
		XNodeSet.prototype.number = function() {
			return new XNumber(this.string());
		};
		XNodeSet.prototype.numberValue = function() {
			return Number(this.string());
		};
		XNodeSet.prototype.bool = function() {
			return new XBoolean(this.booleanValue());
		};
		XNodeSet.prototype.booleanValue = function() {
			return !!this.size;
		};
		XNodeSet.prototype.nodeset = function() {
			return this;
		};
		XNodeSet.prototype.stringForNode = function(n) {
			if (n.nodeType == 9 || n.nodeType == 1 || n.nodeType === 11) return this.stringForContainerNode(n);
			if (n.nodeType === 2) return n.value || n.nodeValue;
			if (n.isNamespaceNode) return n.namespace;
			return n.nodeValue;
		};
		XNodeSet.prototype.stringForContainerNode = function(n) {
			var s = "";
			for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
				var nt = n2.nodeType;
				if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) s += this.stringForNode(n2);
			}
			return s;
		};
		XNodeSet.prototype.buildTree = function() {
			if (!this.tree && this.nodes.length) {
				this.tree = new AVLTree(this.nodes[0]);
				for (var i = 1; i < this.nodes.length; i += 1) this.tree.add(this.nodes[i]);
			}
			return this.tree;
		};
		XNodeSet.prototype.first = function() {
			var p = this.buildTree();
			if (p == null) return null;
			while (p.left != null) p = p.left;
			return p.node;
		};
		XNodeSet.prototype.add = function(n) {
			for (var i = 0; i < this.nodes.length; i += 1) if (n === this.nodes[i]) return;
			this.tree = null;
			this.nodes.push(n);
			this.size += 1;
		};
		XNodeSet.prototype.addArray = function(ns) {
			var self$1 = this;
			forEach(function(x) {
				self$1.add(x);
			}, ns);
		};
		/**
		* Returns an array of the node set's contents in document order
		*/
		XNodeSet.prototype.toArray = function() {
			var a = [];
			this.toArrayRec(this.buildTree(), a);
			return a;
		};
		XNodeSet.prototype.toArrayRec = function(t, a) {
			if (t != null) {
				this.toArrayRec(t.left, a);
				a.push(t.node);
				this.toArrayRec(t.right, a);
			}
		};
		/**
		* Returns an array of the node set's contents in arbitrary order
		*/
		XNodeSet.prototype.toUnsortedArray = function() {
			return this.nodes.slice();
		};
		XNodeSet.prototype.compareWithString = function(r, o) {
			var a = this.toUnsortedArray();
			for (var i = 0; i < a.length; i++) {
				var n = a[i];
				var res = o(new XString(this.stringForNode(n)), r);
				if (res.booleanValue()) return res;
			}
			return new XBoolean(false);
		};
		XNodeSet.prototype.compareWithNumber = function(r, o) {
			var a = this.toUnsortedArray();
			for (var i = 0; i < a.length; i++) {
				var n = a[i];
				var res = o(new XNumber(this.stringForNode(n)), r);
				if (res.booleanValue()) return res;
			}
			return new XBoolean(false);
		};
		XNodeSet.prototype.compareWithBoolean = function(r, o) {
			return o(this.bool(), r);
		};
		XNodeSet.prototype.compareWithNodeSet = function(r, o) {
			var arr = this.toUnsortedArray();
			var oInvert = function(lop, rop) {
				return o(rop, lop);
			};
			for (var i = 0; i < arr.length; i++) {
				var l = new XString(this.stringForNode(arr[i]));
				var res = r.compareWithString(l, oInvert);
				if (res.booleanValue()) return res;
			}
			return new XBoolean(false);
		};
		XNodeSet.compareWith = curry(function(o, r) {
			if (Utilities.instance_of(r, XString)) return this.compareWithString(r, o);
			if (Utilities.instance_of(r, XNumber)) return this.compareWithNumber(r, o);
			if (Utilities.instance_of(r, XBoolean)) return this.compareWithBoolean(r, o);
			return this.compareWithNodeSet(r, o);
		});
		XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
		XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
		XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
		XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
		XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
		XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);
		XNodeSet.prototype.union = function(r) {
			var ns = new XNodeSet();
			ns.addArray(this.toUnsortedArray());
			ns.addArray(r.toUnsortedArray());
			return ns;
		};
		XPathNamespace.prototype = /* @__PURE__ */ new Object();
		XPathNamespace.prototype.constructor = XPathNamespace;
		XPathNamespace.superclass = Object.prototype;
		function XPathNamespace(pre, ns, p) {
			this.isXPathNamespace = true;
			this.ownerDocument = p.ownerDocument;
			this.nodeName = "#namespace";
			this.prefix = pre;
			this.localName = pre;
			this.namespaceURI = ns;
			this.nodeValue = ns;
			this.ownerElement = p;
			this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
		}
		XPathNamespace.prototype.toString = function() {
			return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
		};
		XPathContext.prototype = /* @__PURE__ */ new Object();
		XPathContext.prototype.constructor = XPathContext;
		XPathContext.superclass = Object.prototype;
		function XPathContext(vr, nr, fr) {
			this.variableResolver = vr != null ? vr : new VariableResolver();
			this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
			this.functionResolver = fr != null ? fr : new FunctionResolver();
		}
		XPathContext.prototype.extend = function(newProps) {
			return assign(new XPathContext(), this, newProps);
		};
		VariableResolver.prototype = /* @__PURE__ */ new Object();
		VariableResolver.prototype.constructor = VariableResolver;
		VariableResolver.superclass = Object.prototype;
		function VariableResolver() {}
		VariableResolver.prototype.getVariable = function(ln, ns) {
			return null;
		};
		FunctionResolver.prototype = /* @__PURE__ */ new Object();
		FunctionResolver.prototype.constructor = FunctionResolver;
		FunctionResolver.superclass = Object.prototype;
		function FunctionResolver(thisArg) {
			this.thisArg = thisArg != null ? thisArg : Functions;
			this.functions = /* @__PURE__ */ new Object();
			this.addStandardFunctions();
		}
		FunctionResolver.prototype.addStandardFunctions = function() {
			this.functions["{}last"] = Functions.last;
			this.functions["{}position"] = Functions.position;
			this.functions["{}count"] = Functions.count;
			this.functions["{}id"] = Functions.id;
			this.functions["{}local-name"] = Functions.localName;
			this.functions["{}namespace-uri"] = Functions.namespaceURI;
			this.functions["{}name"] = Functions.name;
			this.functions["{}string"] = Functions.string;
			this.functions["{}concat"] = Functions.concat;
			this.functions["{}starts-with"] = Functions.startsWith;
			this.functions["{}contains"] = Functions.contains;
			this.functions["{}substring-before"] = Functions.substringBefore;
			this.functions["{}substring-after"] = Functions.substringAfter;
			this.functions["{}substring"] = Functions.substring;
			this.functions["{}string-length"] = Functions.stringLength;
			this.functions["{}normalize-space"] = Functions.normalizeSpace;
			this.functions["{}translate"] = Functions.translate;
			this.functions["{}boolean"] = Functions.boolean_;
			this.functions["{}not"] = Functions.not;
			this.functions["{}true"] = Functions.true_;
			this.functions["{}false"] = Functions.false_;
			this.functions["{}lang"] = Functions.lang;
			this.functions["{}number"] = Functions.number;
			this.functions["{}sum"] = Functions.sum;
			this.functions["{}floor"] = Functions.floor;
			this.functions["{}ceiling"] = Functions.ceiling;
			this.functions["{}round"] = Functions.round;
		};
		FunctionResolver.prototype.addFunction = function(ns, ln, f) {
			this.functions["{" + ns + "}" + ln] = f;
		};
		FunctionResolver.getFunctionFromContext = function(qName, context) {
			var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);
			if (parts[0] === null) throw new Error("Cannot resolve QName " + name);
			return context.functionResolver.getFunction(parts[1], parts[0]);
		};
		FunctionResolver.prototype.getFunction = function(localName, namespace) {
			return this.functions["{" + namespace + "}" + localName];
		};
		NamespaceResolver.prototype = /* @__PURE__ */ new Object();
		NamespaceResolver.prototype.constructor = NamespaceResolver;
		NamespaceResolver.superclass = Object.prototype;
		function NamespaceResolver() {}
		NamespaceResolver.prototype.getNamespace = function(prefix, n) {
			if (prefix == "xml") return XPath.XML_NAMESPACE_URI;
			else if (prefix == "xmlns") return XPath.XMLNS_NAMESPACE_URI;
			if (n.nodeType == 9) n = n.documentElement;
			else if (n.nodeType == 2) n = PathExpr.getOwnerElement(n);
			else if (n.nodeType != 1) n = n.parentNode;
			while (n != null && n.nodeType == 1) {
				var nnm = n.attributes;
				for (var i = 0; i < nnm.length; i++) {
					var a = nnm.item(i);
					var aname = a.name || a.nodeName;
					if (aname === "xmlns" && prefix === "" || aname === "xmlns:" + prefix) return String(a.value || a.nodeValue);
				}
				n = n.parentNode;
			}
			return null;
		};
		var Functions = /* @__PURE__ */ new Object();
		Functions.last = function(c) {
			if (arguments.length != 1) throw new Error("Function last expects ()");
			return new XNumber(c.contextSize);
		};
		Functions.position = function(c) {
			if (arguments.length != 1) throw new Error("Function position expects ()");
			return new XNumber(c.contextPosition);
		};
		Functions.count = function() {
			var c = arguments[0];
			var ns;
			if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) throw new Error("Function count expects (node-set)");
			return new XNumber(ns.size);
		};
		Functions.id = function() {
			var c = arguments[0];
			var id;
			if (arguments.length != 2) throw new Error("Function id expects (object)");
			id = arguments[1].evaluate(c);
			if (Utilities.instance_of(id, XNodeSet)) id = id.toArray().join(" ");
			else id = id.stringValue();
			var ids = id.split(/[\x0d\x0a\x09\x20]+/);
			var count = 0;
			var ns = new XNodeSet();
			var doc = c.contextNode.nodeType == 9 ? c.contextNode : c.contextNode.ownerDocument;
			for (var i = 0; i < ids.length; i++) {
				var n;
				if (doc.getElementById) n = doc.getElementById(ids[i]);
				else n = Utilities.getElementById(doc, ids[i]);
				if (n != null) {
					ns.add(n);
					count++;
				}
			}
			return ns;
		};
		Functions.localName = function(c, eNode) {
			var n;
			if (arguments.length == 1) n = c.contextNode;
			else if (arguments.length == 2) n = eNode.evaluate(c).first();
			else throw new Error("Function local-name expects (node-set?)");
			if (n == null) return new XString("");
			return new XString(n.localName || n.baseName || n.target || n.nodeName || "");
		};
		Functions.namespaceURI = function() {
			var c = arguments[0];
			var n;
			if (arguments.length == 1) n = c.contextNode;
			else if (arguments.length == 2) n = arguments[1].evaluate(c).first();
			else throw new Error("Function namespace-uri expects (node-set?)");
			if (n == null) return new XString("");
			return new XString(n.namespaceURI);
		};
		Functions.name = function() {
			var c = arguments[0];
			var n;
			if (arguments.length == 1) n = c.contextNode;
			else if (arguments.length == 2) n = arguments[1].evaluate(c).first();
			else throw new Error("Function name expects (node-set?)");
			if (n == null) return new XString("");
			if (n.nodeType == 1) return new XString(n.nodeName);
			else if (n.nodeType == 2) return new XString(n.name || n.nodeName);
			else if (n.nodeType === 7) return new XString(n.target || n.nodeName);
			else if (n.localName == null) return new XString("");
			else return new XString(n.localName);
		};
		Functions.string = function() {
			var c = arguments[0];
			if (arguments.length == 1) return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
			else if (arguments.length == 2) return arguments[1].evaluate(c).string();
			throw new Error("Function string expects (object?)");
		};
		Functions.concat = function(c) {
			if (arguments.length < 3) throw new Error("Function concat expects (string, string[, string]*)");
			var s = "";
			for (var i = 1; i < arguments.length; i++) s += arguments[i].evaluate(c).stringValue();
			return new XString(s);
		};
		Functions.startsWith = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function startsWith expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			return new XBoolean(s1.substring(0, s2.length) == s2);
		};
		Functions.contains = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function contains expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			return new XBoolean(s1.indexOf(s2) !== -1);
		};
		Functions.substringBefore = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function substring-before expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			return new XString(s1.substring(0, s1.indexOf(s2)));
		};
		Functions.substringAfter = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function substring-after expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			if (s2.length == 0) return new XString(s1);
			var i = s1.indexOf(s2);
			if (i == -1) return new XString("");
			return new XString(s1.substring(i + s2.length));
		};
		Functions.substring = function() {
			var c = arguments[0];
			if (!(arguments.length == 3 || arguments.length == 4)) throw new Error("Function substring expects (string, number, number?)");
			var s = arguments[1].evaluate(c).stringValue();
			var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
			var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : void 0;
			return new XString(s.substring(n1, n2));
		};
		Functions.stringLength = function() {
			var c = arguments[0];
			var s;
			if (arguments.length == 1) s = XNodeSet.prototype.stringForNode(c.contextNode);
			else if (arguments.length == 2) s = arguments[1].evaluate(c).stringValue();
			else throw new Error("Function string-length expects (string?)");
			return new XNumber(s.length);
		};
		Functions.normalizeSpace = function() {
			var c = arguments[0];
			var s;
			if (arguments.length == 1) s = XNodeSet.prototype.stringForNode(c.contextNode);
			else if (arguments.length == 2) s = arguments[1].evaluate(c).stringValue();
			else throw new Error("Function normalize-space expects (string?)");
			var i = 0;
			var j = s.length - 1;
			while (Utilities.isSpace(s.charCodeAt(j))) j--;
			var t = "";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) i++;
			while (i <= j) if (Utilities.isSpace(s.charCodeAt(i))) {
				t += " ";
				while (i <= j && Utilities.isSpace(s.charCodeAt(i))) i++;
			} else {
				t += s.charAt(i);
				i++;
			}
			return new XString(t);
		};
		Functions.translate = function(c, eValue, eFrom, eTo) {
			if (arguments.length != 4) throw new Error("Function translate expects (string, string, string)");
			var value = eValue.evaluate(c).stringValue();
			var from = eFrom.evaluate(c).stringValue();
			var to = eTo.evaluate(c).stringValue();
			var cMap = reduce(function(acc, ch, i) {
				if (!(ch in acc)) acc[ch] = i > to.length ? "" : to[i];
				return acc;
			}, {}, from);
			return new XString(join("", map$1(function(ch) {
				return ch in cMap ? cMap[ch] : ch;
			}, value)));
		};
		Functions.boolean_ = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function boolean expects (object)");
			return arguments[1].evaluate(c).bool();
		};
		Functions.not = function(c, eValue) {
			if (arguments.length != 2) throw new Error("Function not expects (object)");
			return eValue.evaluate(c).bool().not();
		};
		Functions.true_ = function() {
			if (arguments.length != 1) throw new Error("Function true expects ()");
			return XBoolean.true_;
		};
		Functions.false_ = function() {
			if (arguments.length != 1) throw new Error("Function false expects ()");
			return XBoolean.false_;
		};
		Functions.lang = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function lang expects (string)");
			var lang;
			for (var n = c.contextNode; n != null && n.nodeType != 9; n = n.parentNode) {
				var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
				if (a != null) {
					lang = String(a);
					break;
				}
			}
			if (lang == null) return XBoolean.false_;
			var s = arguments[1].evaluate(c).stringValue();
			return new XBoolean(lang.substring(0, s.length) == s && (lang.length == s.length || lang.charAt(s.length) == "-"));
		};
		Functions.number = function() {
			var c = arguments[0];
			if (!(arguments.length == 1 || arguments.length == 2)) throw new Error("Function number expects (object?)");
			if (arguments.length == 1) return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
			return arguments[1].evaluate(c).number();
		};
		Functions.sum = function() {
			var c = arguments[0];
			var ns;
			if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) throw new Error("Function sum expects (node-set)");
			ns = ns.toUnsortedArray();
			var n = 0;
			for (var i = 0; i < ns.length; i++) n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
			return new XNumber(n);
		};
		Functions.floor = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function floor expects (number)");
			return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
		};
		Functions.ceiling = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function ceiling expects (number)");
			return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
		};
		Functions.round = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function round expects (number)");
			return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
		};
		var Utilities = /* @__PURE__ */ new Object();
		Utilities.isAttribute = function(val) {
			return val && (val.nodeType === 2 || val.ownerElement);
		};
		Utilities.splitQName = function(qn) {
			var i = qn.indexOf(":");
			if (i == -1) return [null, qn];
			return [qn.substring(0, i), qn.substring(i + 1)];
		};
		Utilities.resolveQName = function(qn, nr, n, useDefault) {
			var parts = Utilities.splitQName(qn);
			if (parts[0] != null) parts[0] = nr.getNamespace(parts[0], n);
			else if (useDefault) {
				parts[0] = nr.getNamespace("", n);
				if (parts[0] == null) parts[0] = "";
			} else parts[0] = "";
			return parts;
		};
		Utilities.isSpace = function(c) {
			return c == 9 || c == 13 || c == 10 || c == 32;
		};
		Utilities.isLetter = function(c) {
			return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 255 || c >= 256 && c <= 305 || c >= 308 && c <= 318 || c >= 321 && c <= 328 || c >= 330 && c <= 382 || c >= 384 && c <= 451 || c >= 461 && c <= 496 || c >= 500 && c <= 501 || c >= 506 && c <= 535 || c >= 592 && c <= 680 || c >= 699 && c <= 705 || c == 902 || c >= 904 && c <= 906 || c == 908 || c >= 910 && c <= 929 || c >= 931 && c <= 974 || c >= 976 && c <= 982 || c == 986 || c == 988 || c == 990 || c == 992 || c >= 994 && c <= 1011 || c >= 1025 && c <= 1036 || c >= 1038 && c <= 1103 || c >= 1105 && c <= 1116 || c >= 1118 && c <= 1153 || c >= 1168 && c <= 1220 || c >= 1223 && c <= 1224 || c >= 1227 && c <= 1228 || c >= 1232 && c <= 1259 || c >= 1262 && c <= 1269 || c >= 1272 && c <= 1273 || c >= 1329 && c <= 1366 || c == 1369 || c >= 1377 && c <= 1414 || c >= 1488 && c <= 1514 || c >= 1520 && c <= 1522 || c >= 1569 && c <= 1594 || c >= 1601 && c <= 1610 || c >= 1649 && c <= 1719 || c >= 1722 && c <= 1726 || c >= 1728 && c <= 1742 || c >= 1744 && c <= 1747 || c == 1749 || c >= 1765 && c <= 1766 || c >= 2309 && c <= 2361 || c == 2365 || c >= 2392 && c <= 2401 || c >= 2437 && c <= 2444 || c >= 2447 && c <= 2448 || c >= 2451 && c <= 2472 || c >= 2474 && c <= 2480 || c == 2482 || c >= 2486 && c <= 2489 || c >= 2524 && c <= 2525 || c >= 2527 && c <= 2529 || c >= 2544 && c <= 2545 || c >= 2565 && c <= 2570 || c >= 2575 && c <= 2576 || c >= 2579 && c <= 2600 || c >= 2602 && c <= 2608 || c >= 2610 && c <= 2611 || c >= 2613 && c <= 2614 || c >= 2616 && c <= 2617 || c >= 2649 && c <= 2652 || c == 2654 || c >= 2674 && c <= 2676 || c >= 2693 && c <= 2699 || c == 2701 || c >= 2703 && c <= 2705 || c >= 2707 && c <= 2728 || c >= 2730 && c <= 2736 || c >= 2738 && c <= 2739 || c >= 2741 && c <= 2745 || c == 2749 || c == 2784 || c >= 2821 && c <= 2828 || c >= 2831 && c <= 2832 || c >= 2835 && c <= 2856 || c >= 2858 && c <= 2864 || c >= 2866 && c <= 2867 || c >= 2870 && c <= 2873 || c == 2877 || c >= 2908 && c <= 2909 || c >= 2911 && c <= 2913 || c >= 2949 && c <= 2954 || c >= 2958 && c <= 2960 || c >= 2962 && c <= 2965 || c >= 2969 && c <= 2970 || c == 2972 || c >= 2974 && c <= 2975 || c >= 2979 && c <= 2980 || c >= 2984 && c <= 2986 || c >= 2990 && c <= 2997 || c >= 2999 && c <= 3001 || c >= 3077 && c <= 3084 || c >= 3086 && c <= 3088 || c >= 3090 && c <= 3112 || c >= 3114 && c <= 3123 || c >= 3125 && c <= 3129 || c >= 3168 && c <= 3169 || c >= 3205 && c <= 3212 || c >= 3214 && c <= 3216 || c >= 3218 && c <= 3240 || c >= 3242 && c <= 3251 || c >= 3253 && c <= 3257 || c == 3294 || c >= 3296 && c <= 3297 || c >= 3333 && c <= 3340 || c >= 3342 && c <= 3344 || c >= 3346 && c <= 3368 || c >= 3370 && c <= 3385 || c >= 3424 && c <= 3425 || c >= 3585 && c <= 3630 || c == 3632 || c >= 3634 && c <= 3635 || c >= 3648 && c <= 3653 || c >= 3713 && c <= 3714 || c == 3716 || c >= 3719 && c <= 3720 || c == 3722 || c == 3725 || c >= 3732 && c <= 3735 || c >= 3737 && c <= 3743 || c >= 3745 && c <= 3747 || c == 3749 || c == 3751 || c >= 3754 && c <= 3755 || c >= 3757 && c <= 3758 || c == 3760 || c >= 3762 && c <= 3763 || c == 3773 || c >= 3776 && c <= 3780 || c >= 3904 && c <= 3911 || c >= 3913 && c <= 3945 || c >= 4256 && c <= 4293 || c >= 4304 && c <= 4342 || c == 4352 || c >= 4354 && c <= 4355 || c >= 4357 && c <= 4359 || c == 4361 || c >= 4363 && c <= 4364 || c >= 4366 && c <= 4370 || c == 4412 || c == 4414 || c == 4416 || c == 4428 || c == 4430 || c == 4432 || c >= 4436 && c <= 4437 || c == 4441 || c >= 4447 && c <= 4449 || c == 4451 || c == 4453 || c == 4455 || c == 4457 || c >= 4461 && c <= 4462 || c >= 4466 && c <= 4467 || c == 4469 || c == 4510 || c == 4520 || c == 4523 || c >= 4526 && c <= 4527 || c >= 4535 && c <= 4536 || c == 4538 || c >= 4540 && c <= 4546 || c == 4587 || c == 4592 || c == 4601 || c >= 7680 && c <= 7835 || c >= 7840 && c <= 7929 || c >= 7936 && c <= 7957 || c >= 7960 && c <= 7965 || c >= 7968 && c <= 8005 || c >= 8008 && c <= 8013 || c >= 8016 && c <= 8023 || c == 8025 || c == 8027 || c == 8029 || c >= 8031 && c <= 8061 || c >= 8064 && c <= 8116 || c >= 8118 && c <= 8124 || c == 8126 || c >= 8130 && c <= 8132 || c >= 8134 && c <= 8140 || c >= 8144 && c <= 8147 || c >= 8150 && c <= 8155 || c >= 8160 && c <= 8172 || c >= 8178 && c <= 8180 || c >= 8182 && c <= 8188 || c == 8486 || c >= 8490 && c <= 8491 || c == 8494 || c >= 8576 && c <= 8578 || c >= 12353 && c <= 12436 || c >= 12449 && c <= 12538 || c >= 12549 && c <= 12588 || c >= 44032 && c <= 55203 || c >= 19968 && c <= 40869 || c == 12295 || c >= 12321 && c <= 12329;
		};
		Utilities.isNCNameChar = function(c) {
			return c >= 48 && c <= 57 || c >= 1632 && c <= 1641 || c >= 1776 && c <= 1785 || c >= 2406 && c <= 2415 || c >= 2534 && c <= 2543 || c >= 2662 && c <= 2671 || c >= 2790 && c <= 2799 || c >= 2918 && c <= 2927 || c >= 3047 && c <= 3055 || c >= 3174 && c <= 3183 || c >= 3302 && c <= 3311 || c >= 3430 && c <= 3439 || c >= 3664 && c <= 3673 || c >= 3792 && c <= 3801 || c >= 3872 && c <= 3881 || c == 46 || c == 45 || c == 95 || Utilities.isLetter(c) || c >= 768 && c <= 837 || c >= 864 && c <= 865 || c >= 1155 && c <= 1158 || c >= 1425 && c <= 1441 || c >= 1443 && c <= 1465 || c >= 1467 && c <= 1469 || c == 1471 || c >= 1473 && c <= 1474 || c == 1476 || c >= 1611 && c <= 1618 || c == 1648 || c >= 1750 && c <= 1756 || c >= 1757 && c <= 1759 || c >= 1760 && c <= 1764 || c >= 1767 && c <= 1768 || c >= 1770 && c <= 1773 || c >= 2305 && c <= 2307 || c == 2364 || c >= 2366 && c <= 2380 || c == 2381 || c >= 2385 && c <= 2388 || c >= 2402 && c <= 2403 || c >= 2433 && c <= 2435 || c == 2492 || c == 2494 || c == 2495 || c >= 2496 && c <= 2500 || c >= 2503 && c <= 2504 || c >= 2507 && c <= 2509 || c == 2519 || c >= 2530 && c <= 2531 || c == 2562 || c == 2620 || c == 2622 || c == 2623 || c >= 2624 && c <= 2626 || c >= 2631 && c <= 2632 || c >= 2635 && c <= 2637 || c >= 2672 && c <= 2673 || c >= 2689 && c <= 2691 || c == 2748 || c >= 2750 && c <= 2757 || c >= 2759 && c <= 2761 || c >= 2763 && c <= 2765 || c >= 2817 && c <= 2819 || c == 2876 || c >= 2878 && c <= 2883 || c >= 2887 && c <= 2888 || c >= 2891 && c <= 2893 || c >= 2902 && c <= 2903 || c >= 2946 && c <= 2947 || c >= 3006 && c <= 3010 || c >= 3014 && c <= 3016 || c >= 3018 && c <= 3021 || c == 3031 || c >= 3073 && c <= 3075 || c >= 3134 && c <= 3140 || c >= 3142 && c <= 3144 || c >= 3146 && c <= 3149 || c >= 3157 && c <= 3158 || c >= 3202 && c <= 3203 || c >= 3262 && c <= 3268 || c >= 3270 && c <= 3272 || c >= 3274 && c <= 3277 || c >= 3285 && c <= 3286 || c >= 3330 && c <= 3331 || c >= 3390 && c <= 3395 || c >= 3398 && c <= 3400 || c >= 3402 && c <= 3405 || c == 3415 || c == 3633 || c >= 3636 && c <= 3642 || c >= 3655 && c <= 3662 || c == 3761 || c >= 3764 && c <= 3769 || c >= 3771 && c <= 3772 || c >= 3784 && c <= 3789 || c >= 3864 && c <= 3865 || c == 3893 || c == 3895 || c == 3897 || c == 3902 || c == 3903 || c >= 3953 && c <= 3972 || c >= 3974 && c <= 3979 || c >= 3984 && c <= 3989 || c == 3991 || c >= 3993 && c <= 4013 || c >= 4017 && c <= 4023 || c == 4025 || c >= 8400 && c <= 8412 || c == 8417 || c >= 12330 && c <= 12335 || c == 12441 || c == 12442 || c == 183 || c == 720 || c == 721 || c == 903 || c == 1600 || c == 3654 || c == 3782 || c == 12293 || c >= 12337 && c <= 12341 || c >= 12445 && c <= 12446 || c >= 12540 && c <= 12542;
		};
		Utilities.coalesceText = function(n) {
			for (var m = n.firstChild; m != null; m = m.nextSibling) if (m.nodeType == 3 || m.nodeType == 4) {
				var s = m.nodeValue;
				var first = m;
				m = m.nextSibling;
				while (m != null && (m.nodeType == 3 || m.nodeType == 4)) {
					s += m.nodeValue;
					var del = m;
					m = m.nextSibling;
					del.parentNode.removeChild(del);
				}
				if (first.nodeType == 4) {
					var p = first.parentNode;
					if (first.nextSibling == null) {
						p.removeChild(first);
						p.appendChild(p.ownerDocument.createTextNode(s));
					} else {
						var next = first.nextSibling;
						p.removeChild(first);
						p.insertBefore(p.ownerDocument.createTextNode(s), next);
					}
				} else first.nodeValue = s;
				if (m == null) break;
			} else if (m.nodeType == 1) Utilities.coalesceText(m);
		};
		Utilities.instance_of = function(o, c) {
			while (o != null) {
				if (o.constructor === c) return true;
				if (o === Object) return false;
				o = o.constructor.superclass;
			}
			return false;
		};
		Utilities.getElementById = function(n, id) {
			if (n.nodeType == 1) {
				if (n.getAttribute("id") == id || n.getAttributeNS(null, "id") == id) return n;
			}
			for (var m = n.firstChild; m != null; m = m.nextSibling) {
				var res = Utilities.getElementById(m, id);
				if (res != null) return res;
			}
			return null;
		};
		var XPathException = (function() {
			function getMessage(code, exception) {
				var msg = exception ? ": " + exception.toString() : "";
				switch (code) {
					case XPathException$1.INVALID_EXPRESSION_ERR: return "Invalid expression" + msg;
					case XPathException$1.TYPE_ERR: return "Type error" + msg;
				}
				return null;
			}
			function XPathException$1(code, error$47, message) {
				var err = Error.call(this, getMessage(code, error$47) || message);
				err.code = code;
				err.exception = error$47;
				return err;
			}
			XPathException$1.prototype = Object.create(Error.prototype);
			XPathException$1.prototype.constructor = XPathException$1;
			XPathException$1.superclass = Error;
			XPathException$1.prototype.toString = function() {
				return this.message;
			};
			XPathException$1.fromMessage = function(message, error$47) {
				return new XPathException$1(null, error$47, message);
			};
			XPathException$1.INVALID_EXPRESSION_ERR = 51;
			XPathException$1.TYPE_ERR = 52;
			return XPathException$1;
		})();
		XPathExpression.prototype = {};
		XPathExpression.prototype.constructor = XPathExpression;
		XPathExpression.superclass = Object.prototype;
		function XPathExpression(e, r, p) {
			this.xpath = p.parse(e);
			this.context = new XPathContext();
			this.context.namespaceResolver = new XPathNSResolverWrapper(r);
		}
		XPathExpression.getOwnerDocument = function(n) {
			return n.nodeType === 9 ? n : n.ownerDocument;
		};
		XPathExpression.detectHtmlDom = function(n) {
			if (!n) return false;
			var doc = XPathExpression.getOwnerDocument(n);
			try {
				return doc.implementation.hasFeature("HTML", "2.0");
			} catch (e) {
				return true;
			}
		};
		XPathExpression.prototype.evaluate = function(n, t, res) {
			this.context.expressionContextNode = n;
			this.context.caseInsensitive = XPathExpression.detectHtmlDom(n);
			return new XPathResult(this.xpath.evaluate(this.context), t);
		};
		XPathNSResolverWrapper.prototype = {};
		XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
		XPathNSResolverWrapper.superclass = Object.prototype;
		function XPathNSResolverWrapper(r) {
			this.xpathNSResolver = r;
		}
		XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
			if (this.xpathNSResolver == null) return null;
			return this.xpathNSResolver.lookupNamespaceURI(prefix);
		};
		NodeXPathNSResolver.prototype = {};
		NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
		NodeXPathNSResolver.superclass = Object.prototype;
		function NodeXPathNSResolver(n) {
			this.node = n;
			this.namespaceResolver = new NamespaceResolver();
		}
		NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
			return this.namespaceResolver.getNamespace(prefix, this.node);
		};
		XPathResult.prototype = {};
		XPathResult.prototype.constructor = XPathResult;
		XPathResult.superclass = Object.prototype;
		function XPathResult(v, t) {
			if (t == XPathResult.ANY_TYPE) {
				if (v.constructor === XString) t = XPathResult.STRING_TYPE;
				else if (v.constructor === XNumber) t = XPathResult.NUMBER_TYPE;
				else if (v.constructor === XBoolean) t = XPathResult.BOOLEAN_TYPE;
				else if (v.constructor === XNodeSet) t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
			}
			this.resultType = t;
			switch (t) {
				case XPathResult.NUMBER_TYPE:
					this.numberValue = v.numberValue();
					return;
				case XPathResult.STRING_TYPE:
					this.stringValue = v.stringValue();
					return;
				case XPathResult.BOOLEAN_TYPE:
					this.booleanValue = v.booleanValue();
					return;
				case XPathResult.ANY_UNORDERED_NODE_TYPE:
				case XPathResult.FIRST_ORDERED_NODE_TYPE:
					if (v.constructor === XNodeSet) {
						this.singleNodeValue = v.first();
						return;
					}
					break;
				case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
				case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
					if (v.constructor === XNodeSet) {
						this.invalidIteratorState = false;
						this.nodes = v.toArray();
						this.iteratorIndex = 0;
						return;
					}
					break;
				case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
				case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
					if (v.constructor === XNodeSet) {
						this.nodes = v.toArray();
						this.snapshotLength = this.nodes.length;
						return;
					}
					break;
			}
			throw new XPathException(XPathException.TYPE_ERR);
		}
		XPathResult.prototype.iterateNext = function() {
			if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) throw new XPathException(XPathException.TYPE_ERR);
			return this.nodes[this.iteratorIndex++];
		};
		XPathResult.prototype.snapshotItem = function(i) {
			if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) throw new XPathException(XPathException.TYPE_ERR);
			return this.nodes[i];
		};
		XPathResult.ANY_TYPE = 0;
		XPathResult.NUMBER_TYPE = 1;
		XPathResult.STRING_TYPE = 2;
		XPathResult.BOOLEAN_TYPE = 3;
		XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
		XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
		XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
		XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
		XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
		XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
		function installDOM3XPathSupport(doc, p) {
			doc.createExpression = function(e, r) {
				try {
					return new XPathExpression(e, r, p);
				} catch (e$1) {
					throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e$1);
				}
			};
			doc.createNSResolver = function(n) {
				return new NodeXPathNSResolver(n);
			};
			doc.evaluate = function(e, cn, r, t, res) {
				if (t < 0 || t > 9) throw {
					code: 0,
					toString: function() {
						return "Request type not supported";
					}
				};
				return doc.createExpression(e, r, p).evaluate(cn, t, res);
			};
		}
		try {
			var shouldInstall = true;
			try {
				if (document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("XPath", null)) shouldInstall = false;
			} catch (e) {}
			if (shouldInstall) installDOM3XPathSupport(document, new XPathParser());
		} catch (e) {}
		installDOM3XPathSupport(exports$1, new XPathParser());
		(function() {
			var parser = new XPathParser();
			var defaultNSResolver = new NamespaceResolver();
			var defaultFunctionResolver = new FunctionResolver();
			var defaultVariableResolver = new VariableResolver();
			function makeNSResolverFromFunction(func) {
				return { getNamespace: function(prefix, node) {
					return func(prefix, node) || defaultNSResolver.getNamespace(prefix, node);
				} };
			}
			function makeNSResolverFromObject(obj) {
				return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
			}
			function makeNSResolverFromMap(map$2) {
				return makeNSResolverFromFunction(function(prefix) {
					return map$2[prefix];
				});
			}
			function makeNSResolver(resolver) {
				if (resolver && typeof resolver.getNamespace === "function") return makeNSResolverFromObject(resolver);
				if (typeof resolver === "function") return makeNSResolverFromFunction(resolver);
				if (typeof resolver === "object") return makeNSResolverFromMap(resolver);
				return defaultNSResolver;
			}
			/** Converts native JavaScript types to their XPath library equivalent */
			function convertValue(value) {
				if (value === null || typeof value === "undefined" || value instanceof XString || value instanceof XBoolean || value instanceof XNumber || value instanceof XNodeSet) return value;
				switch (typeof value) {
					case "string": return new XString(value);
					case "boolean": return new XBoolean(value);
					case "number": return new XNumber(value);
				}
				var ns = new XNodeSet();
				ns.addArray([].concat(value));
				return ns;
			}
			function makeEvaluator(func) {
				return function(context) {
					var args = Array.prototype.slice.call(arguments, 1).map(function(arg) {
						return arg.evaluate(context);
					});
					return convertValue(func.apply(this, [].concat(context, args)));
				};
			}
			function makeFunctionResolverFromFunction(func) {
				return { getFunction: function(name$1, namespace) {
					var found = func(name$1, namespace);
					if (found) return makeEvaluator(found);
					return defaultFunctionResolver.getFunction(name$1, namespace);
				} };
			}
			function makeFunctionResolverFromObject(obj) {
				return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
			}
			function makeFunctionResolverFromMap(map$2) {
				return makeFunctionResolverFromFunction(function(name$1) {
					return map$2[name$1];
				});
			}
			function makeFunctionResolver(resolver) {
				if (resolver && typeof resolver.getFunction === "function") return makeFunctionResolverFromObject(resolver);
				if (typeof resolver === "function") return makeFunctionResolverFromFunction(resolver);
				if (typeof resolver === "object") return makeFunctionResolverFromMap(resolver);
				return defaultFunctionResolver;
			}
			function makeVariableResolverFromFunction(func) {
				return { getVariable: function(name$1, namespace) {
					return convertValue(func(name$1, namespace));
				} };
			}
			function makeVariableResolver(resolver) {
				if (resolver) {
					if (typeof resolver.getVariable === "function") return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
					if (typeof resolver === "function") return makeVariableResolverFromFunction(resolver);
					if (typeof resolver === "object") return makeVariableResolverFromFunction(function(name$1) {
						return resolver[name$1];
					});
				}
				return defaultVariableResolver;
			}
			function copyIfPresent(prop, dest, source) {
				if (prop in source) dest[prop] = source[prop];
			}
			function makeContext(options) {
				var context = new XPathContext();
				if (options) {
					context.namespaceResolver = makeNSResolver(options.namespaces);
					context.functionResolver = makeFunctionResolver(options.functions);
					context.variableResolver = makeVariableResolver(options.variables);
					context.expressionContextNode = options.node;
					copyIfPresent("allowAnyNamespaceForNoPrefix", context, options);
					copyIfPresent("isHtml", context, options);
				} else context.namespaceResolver = defaultNSResolver;
				return context;
			}
			function evaluate(parsedExpression, options) {
				var context = makeContext(options);
				return parsedExpression.evaluate(context);
			}
			var evaluatorPrototype = {
				evaluate: function(options) {
					return evaluate(this.expression, options);
				},
				evaluateNumber: function(options) {
					return this.evaluate(options).numberValue();
				},
				evaluateString: function(options) {
					return this.evaluate(options).stringValue();
				},
				evaluateBoolean: function(options) {
					return this.evaluate(options).booleanValue();
				},
				evaluateNodeSet: function(options) {
					return this.evaluate(options).nodeset();
				},
				select: function(options) {
					return this.evaluateNodeSet(options).toArray();
				},
				select1: function(options) {
					return this.select(options)[0];
				}
			};
			function parse$3(xpath) {
				var parsed = parser.parse(xpath);
				return Object.create(evaluatorPrototype, { expression: { value: parsed } });
			}
			exports$1.parse = parse$3;
		})();
		assign(exports$1, {
			XPath,
			XPathParser,
			XPathResult,
			Step,
			PathExpr,
			NodeTest,
			LocationPath,
			OrOperation,
			AndOperation,
			BarOperation,
			EqualsOperation,
			NotEqualOperation,
			LessThanOperation,
			GreaterThanOperation,
			LessThanOrEqualOperation,
			GreaterThanOrEqualOperation,
			PlusOperation,
			MinusOperation,
			MultiplyOperation,
			DivOperation,
			ModOperation,
			UnaryMinusOperation,
			FunctionCall,
			VariableReference,
			XPathContext,
			XNodeSet,
			XBoolean,
			XString,
			XNumber,
			NamespaceResolver,
			FunctionResolver,
			VariableResolver,
			Utilities
		});
		exports$1.select = function(e, doc, single) {
			return exports$1.selectWithResolver(e, doc, null, single);
		};
		exports$1.useNamespaces = function(mappings) {
			var resolver = {
				mappings: mappings || {},
				lookupNamespaceURI: function(prefix) {
					return this.mappings[prefix];
				}
			};
			return function(e, doc, single) {
				return exports$1.selectWithResolver(e, doc, resolver, single);
			};
		};
		exports$1.selectWithResolver = function(e, doc, resolver, single) {
			var expression = new XPathExpression(e, resolver, new XPathParser());
			var type = XPathResult.ANY_TYPE;
			var result = expression.evaluate(doc, type, null);
			if (result.resultType == XPathResult.STRING_TYPE) result = result.stringValue;
			else if (result.resultType == XPathResult.NUMBER_TYPE) result = result.numberValue;
			else if (result.resultType == XPathResult.BOOLEAN_TYPE) result = result.booleanValue;
			else {
				result = result.nodes;
				if (single) result = result[0];
			}
			return result;
		};
		exports$1.select1 = function(e, doc) {
			return exports$1.select(e, doc, true);
		};
	})(typeof exports === "undefined" ? {} : exports);
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+xmldom@0.8.11/node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
	*
	* Works with anything that has a `length` property and index access properties, including NodeList.
	*
	* @template {unknown} T
	* @param {Array<T> | ({length:number, [number]: T})} list
	* @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
	* @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
	* 				allows injecting a custom implementation in tests
	* @returns {T | undefined}
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
	* @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
	*/
	function find(list, predicate, ac) {
		if (ac === void 0) ac = Array.prototype;
		if (list && typeof ac.find === "function") return ac.find.call(list, predicate);
		for (var i = 0; i < list.length; i++) if (Object.prototype.hasOwnProperty.call(list, i)) {
			var item = list[i];
			if (predicate.call(void 0, item, i, list)) return item;
		}
	}
	/**
	* "Shallow freezes" an object to render it immutable.
	* Uses `Object.freeze` if available,
	* otherwise the immutability is only in the type.
	*
	* Is used to create "enum like" objects.
	*
	* @template T
	* @param {T} object the object to freeze
	* @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
	* 				allows to inject custom object constructor for tests
	* @returns {Readonly<T>}
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
	*/
	function freeze(object$1, oc) {
		if (oc === void 0) oc = Object;
		return oc && typeof oc.freeze === "function" ? oc.freeze(object$1) : object$1;
	}
	/**
	* Since we can not rely on `Object.assign` we provide a simplified version
	* that is sufficient for our needs.
	*
	* @param {Object} target
	* @param {Object | null | undefined} source
	*
	* @returns {Object} target
	* @throws TypeError if target is not an object
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	* @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
	*/
	function assign(target, source) {
		if (target === null || typeof target !== "object") throw new TypeError("target is not an object");
		for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		return target;
	}
	/**
	* All mime types that are allowed as input to `DOMParser.parseFromString`
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
	* @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
	* @see DOMParser.prototype.parseFromString
	*/
	var MIME_TYPE = freeze({
		HTML: "text/html",
		isHTML: function(value) {
			return value === MIME_TYPE.HTML;
		},
		XML_APPLICATION: "application/xml",
		XML_TEXT: "text/xml",
		XML_XHTML_APPLICATION: "application/xhtml+xml",
		XML_SVG_IMAGE: "image/svg+xml"
	});
	/**
	* Namespaces that are used in this code base.
	*
	* @see http://www.w3.org/TR/REC-xml-names
	*/
	var NAMESPACE = freeze({
		HTML: "http://www.w3.org/1999/xhtml",
		isHTML: function(uri) {
			return uri === NAMESPACE.HTML;
		},
		SVG: "http://www.w3.org/2000/svg",
		XML: "http://www.w3.org/XML/1998/namespace",
		XMLNS: "http://www.w3.org/2000/xmlns/"
	});
	exports.assign = assign;
	exports.find = find;
	exports.freeze = freeze;
	exports.MIME_TYPE = MIME_TYPE;
	exports.NAMESPACE = NAMESPACE;
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+xmldom@0.8.11/node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = /* @__PURE__ */ __commonJSMin(((exports) => {
	var conventions = require_conventions();
	var find = conventions.find;
	var NAMESPACE = conventions.NAMESPACE;
	/**
	* A prerequisite for `[].filter`, to drop elements that are empty
	* @param {string} input
	* @returns {boolean}
	*/
	function notEmptyString(input) {
		return input !== "";
	}
	/**
	* @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
	* @see https://infra.spec.whatwg.org/#ascii-whitespace
	*
	* @param {string} input
	* @returns {string[]} (can be empty)
	*/
	function splitOnASCIIWhitespace(input) {
		return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
	}
	/**
	* Adds element as a key to current if it is not already present.
	*
	* @param {Record<string, boolean | undefined>} current
	* @param {string} element
	* @returns {Record<string, boolean | undefined>}
	*/
	function orderedSetReducer(current, element) {
		if (!current.hasOwnProperty(element)) current[element] = true;
		return current;
	}
	/**
	* @see https://infra.spec.whatwg.org/#ordered-set
	* @param {string} input
	* @returns {string[]}
	*/
	function toOrderedSet(input) {
		if (!input) return [];
		var list = splitOnASCIIWhitespace(input);
		return Object.keys(list.reduce(orderedSetReducer, {}));
	}
	/**
	* Uses `list.indexOf` to implement something like `Array.prototype.includes`,
	* which we can not rely on being available.
	*
	* @param {any[]} list
	* @returns {function(any): boolean}
	*/
	function arrayIncludes(list) {
		return function(element) {
			return list && list.indexOf(element) !== -1;
		};
	}
	function copy(src, dest) {
		for (var p in src) if (Object.prototype.hasOwnProperty.call(src, p)) dest[p] = src[p];
	}
	/**
	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
	*/
	function _extends(Class$1, Super) {
		var pt = Class$1.prototype;
		if (!(pt instanceof Super)) {
			function t() {}
			t.prototype = Super.prototype;
			t = new t();
			copy(pt, t);
			Class$1.prototype = pt = t;
		}
		if (pt.constructor != Class$1) {
			if (typeof Class$1 != "function") console.error("unknown Class:" + Class$1);
			pt.constructor = Class$1;
		}
	}
	var NodeType = {};
	var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
	var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
	var TEXT_NODE = NodeType.TEXT_NODE = 3;
	var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
	var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
	var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
	var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
	var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
	var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
	var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
	var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
	var ExceptionCode = {};
	var ExceptionMessage = {};
	ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
	ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
	var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
	ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
	ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
	ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
	ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
	var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
	ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
	var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
	ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
	ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
	ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
	ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
	ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
	/**
	* DOM Level 2
	* Object DOMException
	* @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
	* @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
	*/
	function DOMException(code, message) {
		if (message instanceof Error) var error$47 = message;
		else {
			error$47 = this;
			Error.call(this, ExceptionMessage[code]);
			this.message = ExceptionMessage[code];
			if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
		}
		error$47.code = code;
		if (message) this.message = this.message + ": " + message;
		return error$47;
	}
	DOMException.prototype = Error.prototype;
	copy(ExceptionCode, DOMException);
	/**
	* @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
	* The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
	* The items in the NodeList are accessible via an integral index, starting from 0.
	*/
	function NodeList() {}
	NodeList.prototype = {
		length: 0,
		item: function(index) {
			return index >= 0 && index < this.length ? this[index] : null;
		},
		toString: function(isHTML, nodeFilter) {
			for (var buf = [], i = 0; i < this.length; i++) serializeToString(this[i], buf, isHTML, nodeFilter);
			return buf.join("");
		},
		filter: function(predicate) {
			return Array.prototype.filter.call(this, predicate);
		},
		indexOf: function(item) {
			return Array.prototype.indexOf.call(this, item);
		}
	};
	function LiveNodeList(node, refresh) {
		this._node = node;
		this._refresh = refresh;
		_updateLiveList(this);
	}
	function _updateLiveList(list) {
		var inc = list._node._inc || list._node.ownerDocument._inc;
		if (list._inc !== inc) {
			var ls = list._refresh(list._node);
			__set__(list, "length", ls.length);
			if (!list.$$length || ls.length < list.$$length) {
				for (var i = ls.length; i in list; i++) if (Object.prototype.hasOwnProperty.call(list, i)) delete list[i];
			}
			copy(ls, list);
			list._inc = inc;
		}
	}
	LiveNodeList.prototype.item = function(i) {
		_updateLiveList(this);
		return this[i] || null;
	};
	_extends(LiveNodeList, NodeList);
	/**
	* Objects implementing the NamedNodeMap interface are used
	* to represent collections of nodes that can be accessed by name.
	* Note that NamedNodeMap does not inherit from NodeList;
	* NamedNodeMaps are not maintained in any particular order.
	* Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
	* but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
	* and does not imply that the DOM specifies an order to these Nodes.
	* NamedNodeMap objects in the DOM are live.
	* used for attributes or DocumentType entities
	*/
	function NamedNodeMap() {}
	function _findNodeIndex(list, node) {
		var i = list.length;
		while (i--) if (list[i] === node) return i;
	}
	function _addNamedNode(el, list, newAttr, oldAttr) {
		if (oldAttr) list[_findNodeIndex(list, oldAttr)] = newAttr;
		else list[list.length++] = newAttr;
		if (el) {
			newAttr.ownerElement = el;
			var doc = el.ownerDocument;
			if (doc) {
				oldAttr && _onRemoveAttribute(doc, el, oldAttr);
				_onAddAttribute(doc, el, newAttr);
			}
		}
	}
	function _removeNamedNode(el, list, attr) {
		var i = _findNodeIndex(list, attr);
		if (i >= 0) {
			var lastIndex = list.length - 1;
			while (i < lastIndex) list[i] = list[++i];
			list.length = lastIndex;
			if (el) {
				var doc = el.ownerDocument;
				if (doc) {
					_onRemoveAttribute(doc, el, attr);
					attr.ownerElement = null;
				}
			}
		} else throw new DOMException(NOT_FOUND_ERR, /* @__PURE__ */ new Error(el.tagName + "@" + attr));
	}
	NamedNodeMap.prototype = {
		length: 0,
		item: NodeList.prototype.item,
		getNamedItem: function(key) {
			var i = this.length;
			while (i--) {
				var attr = this[i];
				if (attr.nodeName == key) return attr;
			}
		},
		setNamedItem: function(attr) {
			var el = attr.ownerElement;
			if (el && el != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
			var oldAttr = this.getNamedItem(attr.nodeName);
			_addNamedNode(this._ownerElement, this, attr, oldAttr);
			return oldAttr;
		},
		setNamedItemNS: function(attr) {
			var el = attr.ownerElement, oldAttr;
			if (el && el != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
			oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
			_addNamedNode(this._ownerElement, this, attr, oldAttr);
			return oldAttr;
		},
		removeNamedItem: function(key) {
			var attr = this.getNamedItem(key);
			_removeNamedNode(this._ownerElement, this, attr);
			return attr;
		},
		removeNamedItemNS: function(namespaceURI, localName) {
			var attr = this.getNamedItemNS(namespaceURI, localName);
			_removeNamedNode(this._ownerElement, this, attr);
			return attr;
		},
		getNamedItemNS: function(namespaceURI, localName) {
			var i = this.length;
			while (i--) {
				var node = this[i];
				if (node.localName == localName && node.namespaceURI == namespaceURI) return node;
			}
			return null;
		}
	};
	/**
	* The DOMImplementation interface represents an object providing methods
	* which are not dependent on any particular document.
	* Such an object is returned by the `Document.implementation` property.
	*
	* __The individual methods describe the differences compared to the specs.__
	*
	* @constructor
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
	* @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
	* @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
	* @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
	* @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
	*/
	function DOMImplementation() {}
	DOMImplementation.prototype = {
		hasFeature: function(feature, version$2) {
			return true;
		},
		createDocument: function(namespaceURI, qualifiedName, doctype) {
			var doc = new Document();
			doc.implementation = this;
			doc.childNodes = new NodeList();
			doc.doctype = doctype || null;
			if (doctype) doc.appendChild(doctype);
			if (qualifiedName) {
				var root = doc.createElementNS(namespaceURI, qualifiedName);
				doc.appendChild(root);
			}
			return doc;
		},
		createDocumentType: function(qualifiedName, publicId, systemId) {
			var node = new DocumentType();
			node.name = qualifiedName;
			node.nodeName = qualifiedName;
			node.publicId = publicId || "";
			node.systemId = systemId || "";
			return node;
		}
	};
	/**
	* @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
	*/
	function Node() {}
	Node.prototype = {
		firstChild: null,
		lastChild: null,
		previousSibling: null,
		nextSibling: null,
		attributes: null,
		parentNode: null,
		childNodes: null,
		ownerDocument: null,
		nodeValue: null,
		namespaceURI: null,
		prefix: null,
		localName: null,
		insertBefore: function(newChild, refChild) {
			return _insertBefore(this, newChild, refChild);
		},
		replaceChild: function(newChild, oldChild) {
			_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
			if (oldChild) this.removeChild(oldChild);
		},
		removeChild: function(oldChild) {
			return _removeChild(this, oldChild);
		},
		appendChild: function(newChild) {
			return this.insertBefore(newChild, null);
		},
		hasChildNodes: function() {
			return this.firstChild != null;
		},
		cloneNode: function(deep) {
			return cloneNode(this.ownerDocument || this, this, deep);
		},
		normalize: function() {
			var child = this.firstChild;
			while (child) {
				var next = child.nextSibling;
				if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
					this.removeChild(next);
					child.appendData(next.data);
				} else {
					child.normalize();
					child = next;
				}
			}
		},
		isSupported: function(feature, version$2) {
			return this.ownerDocument.implementation.hasFeature(feature, version$2);
		},
		hasAttributes: function() {
			return this.attributes.length > 0;
		},
		lookupPrefix: function(namespaceURI) {
			var el = this;
			while (el) {
				var map$1 = el._nsMap;
				if (map$1) {
					for (var n in map$1) if (Object.prototype.hasOwnProperty.call(map$1, n) && map$1[n] === namespaceURI) return n;
				}
				el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
			}
			return null;
		},
		lookupNamespaceURI: function(prefix) {
			var el = this;
			while (el) {
				var map$1 = el._nsMap;
				if (map$1) {
					if (Object.prototype.hasOwnProperty.call(map$1, prefix)) return map$1[prefix];
				}
				el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
			}
			return null;
		},
		isDefaultNamespace: function(namespaceURI) {
			return this.lookupPrefix(namespaceURI) == null;
		}
	};
	function _xmlEncoder(c) {
		return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == "\"" && "&quot;" || "&#" + c.charCodeAt() + ";";
	}
	copy(NodeType, Node);
	copy(NodeType, Node.prototype);
	/**
	* @param callback return true for continue,false for break
	* @return boolean true: break visit;
	*/
	function _visitNode(node, callback$1) {
		if (callback$1(node)) return true;
		if (node = node.firstChild) do
			if (_visitNode(node, callback$1)) return true;
		while (node = node.nextSibling);
	}
	function Document() {
		this.ownerDocument = this;
	}
	function _onAddAttribute(doc, el, newAttr) {
		doc && doc._inc++;
		if (newAttr.namespaceURI === NAMESPACE.XMLNS) el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
	}
	function _onRemoveAttribute(doc, el, newAttr, remove) {
		doc && doc._inc++;
		if (newAttr.namespaceURI === NAMESPACE.XMLNS) delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
	}
	/**
	* Updates `el.childNodes`, updating the indexed items and it's `length`.
	* Passing `newChild` means it will be appended.
	* Otherwise it's assumed that an item has been removed,
	* and `el.firstNode` and it's `.nextSibling` are used
	* to walk the current list of child nodes.
	*
	* @param {Document} doc
	* @param {Node} el
	* @param {Node} [newChild]
	* @private
	*/
	function _onUpdateChild(doc, el, newChild) {
		if (doc && doc._inc) {
			doc._inc++;
			var cs = el.childNodes;
			if (newChild) cs[cs.length++] = newChild;
			else {
				var child = el.firstChild;
				var i = 0;
				while (child) {
					cs[i++] = child;
					child = child.nextSibling;
				}
				cs.length = i;
				delete cs[cs.length];
			}
		}
	}
	/**
	* Removes the connections between `parentNode` and `child`
	* and any existing `child.previousSibling` or `child.nextSibling`.
	*
	* @see https://github.com/xmldom/xmldom/issues/135
	* @see https://github.com/xmldom/xmldom/issues/145
	*
	* @param {Node} parentNode
	* @param {Node} child
	* @returns {Node} the child that was removed.
	* @private
	*/
	function _removeChild(parentNode, child) {
		var previous = child.previousSibling;
		var next = child.nextSibling;
		if (previous) previous.nextSibling = next;
		else parentNode.firstChild = next;
		if (next) next.previousSibling = previous;
		else parentNode.lastChild = previous;
		child.parentNode = null;
		child.previousSibling = null;
		child.nextSibling = null;
		_onUpdateChild(parentNode.ownerDocument, parentNode);
		return child;
	}
	/**
	* Returns `true` if `node` can be a parent for insertion.
	* @param {Node} node
	* @returns {boolean}
	*/
	function hasValidParentNodeType(node) {
		return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
	}
	/**
	* Returns `true` if `node` can be inserted according to it's `nodeType`.
	* @param {Node} node
	* @returns {boolean}
	*/
	function hasInsertableNodeType(node) {
		return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
	}
	/**
	* Returns true if `node` is a DOCTYPE node
	* @param {Node} node
	* @returns {boolean}
	*/
	function isDocTypeNode(node) {
		return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
	}
	/**
	* Returns true if the node is an element
	* @param {Node} node
	* @returns {boolean}
	*/
	function isElementNode(node) {
		return node && node.nodeType === Node.ELEMENT_NODE;
	}
	/**
	* Returns true if `node` is a text node
	* @param {Node} node
	* @returns {boolean}
	*/
	function isTextNode(node) {
		return node && node.nodeType === Node.TEXT_NODE;
	}
	/**
	* Check if en element node can be inserted before `child`, or at the end if child is falsy,
	* according to the presence and position of a doctype node on the same level.
	*
	* @param {Document} doc The document node
	* @param {Node} child the node that would become the nextSibling if the element would be inserted
	* @returns {boolean} `true` if an element can be inserted before child
	* @private
	* https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	*/
	function isElementInsertionPossible(doc, child) {
		var parentChildNodes = doc.childNodes || [];
		if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) return false;
		var docTypeNode = find(parentChildNodes, isDocTypeNode);
		return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
	}
	/**
	* Check if en element node can be inserted before `child`, or at the end if child is falsy,
	* according to the presence and position of a doctype node on the same level.
	*
	* @param {Node} doc The document node
	* @param {Node} child the node that would become the nextSibling if the element would be inserted
	* @returns {boolean} `true` if an element can be inserted before child
	* @private
	* https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	*/
	function isElementReplacementPossible(doc, child) {
		var parentChildNodes = doc.childNodes || [];
		function hasElementChildThatIsNotChild(node) {
			return isElementNode(node) && node !== child;
		}
		if (find(parentChildNodes, hasElementChildThatIsNotChild)) return false;
		var docTypeNode = find(parentChildNodes, isDocTypeNode);
		return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
	}
	/**
	* @private
	* Steps 1-5 of the checks before inserting and before replacing a child are the same.
	*
	* @param {Node} parent the parent node to insert `node` into
	* @param {Node} node the node to insert
	* @param {Node=} child the node that should become the `nextSibling` of `node`
	* @returns {Node}
	* @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	* @throws DOMException if `child` is provided but is not a child of `parent`.
	* @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	* @see https://dom.spec.whatwg.org/#concept-node-replace
	*/
	function assertPreInsertionValidity1to5(parent, node, child) {
		if (!hasValidParentNodeType(parent)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
		if (child && child.parentNode !== parent) throw new DOMException(NOT_FOUND_ERR, "child not in parent");
		if (!hasInsertableNodeType(node) || isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
	}
	/**
	* @private
	* Step 6 of the checks before inserting and before replacing a child are different.
	*
	* @param {Document} parent the parent node to insert `node` into
	* @param {Node} node the node to insert
	* @param {Node | undefined} child the node that should become the `nextSibling` of `node`
	* @returns {Node}
	* @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	* @throws DOMException if `child` is provided but is not a child of `parent`.
	* @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	* @see https://dom.spec.whatwg.org/#concept-node-replace
	*/
	function assertPreInsertionValidityInDocument(parent, node, child) {
		var parentChildNodes = parent.childNodes || [];
		var nodeChildNodes = node.childNodes || [];
		if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
			var nodeChildElements = nodeChildNodes.filter(isElementNode);
			if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
			if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
		}
		if (isElementNode(node)) {
			if (!isElementInsertionPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
		}
		if (isDocTypeNode(node)) {
			if (find(parentChildNodes, isDocTypeNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
			var parentElementChild = find(parentChildNodes, isElementNode);
			if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
			if (!child && parentElementChild) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
		}
	}
	/**
	* @private
	* Step 6 of the checks before inserting and before replacing a child are different.
	*
	* @param {Document} parent the parent node to insert `node` into
	* @param {Node} node the node to insert
	* @param {Node | undefined} child the node that should become the `nextSibling` of `node`
	* @returns {Node}
	* @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	* @throws DOMException if `child` is provided but is not a child of `parent`.
	* @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	* @see https://dom.spec.whatwg.org/#concept-node-replace
	*/
	function assertPreReplacementValidityInDocument(parent, node, child) {
		var parentChildNodes = parent.childNodes || [];
		var nodeChildNodes = node.childNodes || [];
		if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
			var nodeChildElements = nodeChildNodes.filter(isElementNode);
			if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
			if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
		}
		if (isElementNode(node)) {
			if (!isElementReplacementPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
		}
		if (isDocTypeNode(node)) {
			function hasDoctypeChildThatIsNotChild(node$1) {
				return isDocTypeNode(node$1) && node$1 !== child;
			}
			if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
			var parentElementChild = find(parentChildNodes, isElementNode);
			if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
		}
	}
	/**
	* @private
	* @param {Node} parent the parent node to insert `node` into
	* @param {Node} node the node to insert
	* @param {Node=} child the node that should become the `nextSibling` of `node`
	* @returns {Node}
	* @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	* @throws DOMException if `child` is provided but is not a child of `parent`.
	* @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	*/
	function _insertBefore(parent, node, child, _inDocumentAssertion) {
		assertPreInsertionValidity1to5(parent, node, child);
		if (parent.nodeType === Node.DOCUMENT_NODE) (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
		var cp = node.parentNode;
		if (cp) cp.removeChild(node);
		if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
			var newFirst = node.firstChild;
			if (newFirst == null) return node;
			var newLast = node.lastChild;
		} else newFirst = newLast = node;
		var pre = child ? child.previousSibling : parent.lastChild;
		newFirst.previousSibling = pre;
		newLast.nextSibling = child;
		if (pre) pre.nextSibling = newFirst;
		else parent.firstChild = newFirst;
		if (child == null) parent.lastChild = newLast;
		else child.previousSibling = newLast;
		do {
			newFirst.parentNode = parent;
			var targetDoc = parent.ownerDocument || parent;
			_updateOwnerDocument(newFirst, targetDoc);
		} while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
		_onUpdateChild(parent.ownerDocument || parent, parent);
		if (node.nodeType == DOCUMENT_FRAGMENT_NODE) node.firstChild = node.lastChild = null;
		return node;
	}
	/**
	* Recursively updates the ownerDocument property for a node and all its descendants
	* @param {Node} node
	* @param {Document} newOwnerDocument
	* @private
	*/
	function _updateOwnerDocument(node, newOwnerDocument) {
		if (node.ownerDocument === newOwnerDocument) return;
		node.ownerDocument = newOwnerDocument;
		if (node.nodeType === ELEMENT_NODE && node.attributes) for (var i = 0; i < node.attributes.length; i++) {
			var attr = node.attributes.item(i);
			if (attr) attr.ownerDocument = newOwnerDocument;
		}
		var child = node.firstChild;
		while (child) {
			_updateOwnerDocument(child, newOwnerDocument);
			child = child.nextSibling;
		}
	}
	/**
	* Appends `newChild` to `parentNode`.
	* If `newChild` is already connected to a `parentNode` it is first removed from it.
	*
	* @see https://github.com/xmldom/xmldom/issues/135
	* @see https://github.com/xmldom/xmldom/issues/145
	* @param {Node} parentNode
	* @param {Node} newChild
	* @returns {Node}
	* @private
	*/
	function _appendSingleChild(parentNode, newChild) {
		if (newChild.parentNode) newChild.parentNode.removeChild(newChild);
		newChild.parentNode = parentNode;
		newChild.previousSibling = parentNode.lastChild;
		newChild.nextSibling = null;
		if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild;
		else parentNode.firstChild = newChild;
		parentNode.lastChild = newChild;
		_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
		_updateOwnerDocument(newChild, parentNode.ownerDocument || parentNode);
		return newChild;
	}
	Document.prototype = {
		nodeName: "#document",
		nodeType: DOCUMENT_NODE,
		doctype: null,
		documentElement: null,
		_inc: 1,
		insertBefore: function(newChild, refChild) {
			if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
				var child = newChild.firstChild;
				while (child) {
					var next = child.nextSibling;
					this.insertBefore(child, refChild);
					child = next;
				}
				return newChild;
			}
			_insertBefore(this, newChild, refChild);
			_updateOwnerDocument(newChild, this);
			if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) this.documentElement = newChild;
			return newChild;
		},
		removeChild: function(oldChild) {
			if (this.documentElement == oldChild) this.documentElement = null;
			return _removeChild(this, oldChild);
		},
		replaceChild: function(newChild, oldChild) {
			_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
			_updateOwnerDocument(newChild, this);
			if (oldChild) this.removeChild(oldChild);
			if (isElementNode(newChild)) this.documentElement = newChild;
		},
		importNode: function(importedNode, deep) {
			return importNode(this, importedNode, deep);
		},
		getElementById: function(id) {
			var rtv = null;
			_visitNode(this.documentElement, function(node) {
				if (node.nodeType == ELEMENT_NODE) {
					if (node.getAttribute("id") == id) {
						rtv = node;
						return true;
					}
				}
			});
			return rtv;
		},
		getElementsByClassName: function(classNames) {
			var classNamesSet = toOrderedSet(classNames);
			return new LiveNodeList(this, function(base) {
				var ls = [];
				if (classNamesSet.length > 0) _visitNode(base.documentElement, function(node) {
					if (node !== base && node.nodeType === ELEMENT_NODE) {
						var nodeClassNames = node.getAttribute("class");
						if (nodeClassNames) {
							var matches = classNames === nodeClassNames;
							if (!matches) {
								var nodeClassNamesSet = toOrderedSet(nodeClassNames);
								matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
							}
							if (matches) ls.push(node);
						}
					}
				});
				return ls;
			});
		},
		createElement: function(tagName) {
			var node = new Element();
			node.ownerDocument = this;
			node.nodeName = tagName;
			node.tagName = tagName;
			node.localName = tagName;
			node.childNodes = new NodeList();
			var attrs = node.attributes = new NamedNodeMap();
			attrs._ownerElement = node;
			return node;
		},
		createDocumentFragment: function() {
			var node = new DocumentFragment();
			node.ownerDocument = this;
			node.childNodes = new NodeList();
			return node;
		},
		createTextNode: function(data) {
			var node = new Text();
			node.ownerDocument = this;
			node.appendData(data);
			return node;
		},
		createComment: function(data) {
			var node = new Comment();
			node.ownerDocument = this;
			node.appendData(data);
			return node;
		},
		createCDATASection: function(data) {
			var node = new CDATASection();
			node.ownerDocument = this;
			node.appendData(data);
			return node;
		},
		createProcessingInstruction: function(target, data) {
			var node = new ProcessingInstruction();
			node.ownerDocument = this;
			node.tagName = node.nodeName = node.target = target;
			node.nodeValue = node.data = data;
			return node;
		},
		createAttribute: function(name$1) {
			var node = new Attr();
			node.ownerDocument = this;
			node.name = name$1;
			node.nodeName = name$1;
			node.localName = name$1;
			node.specified = true;
			return node;
		},
		createEntityReference: function(name$1) {
			var node = new EntityReference();
			node.ownerDocument = this;
			node.nodeName = name$1;
			return node;
		},
		createElementNS: function(namespaceURI, qualifiedName) {
			var node = new Element();
			var pl = qualifiedName.split(":");
			var attrs = node.attributes = new NamedNodeMap();
			node.childNodes = new NodeList();
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.tagName = qualifiedName;
			node.namespaceURI = namespaceURI;
			if (pl.length == 2) {
				node.prefix = pl[0];
				node.localName = pl[1];
			} else node.localName = qualifiedName;
			attrs._ownerElement = node;
			return node;
		},
		createAttributeNS: function(namespaceURI, qualifiedName) {
			var node = new Attr();
			var pl = qualifiedName.split(":");
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.name = qualifiedName;
			node.namespaceURI = namespaceURI;
			node.specified = true;
			if (pl.length == 2) {
				node.prefix = pl[0];
				node.localName = pl[1];
			} else node.localName = qualifiedName;
			return node;
		}
	};
	_extends(Document, Node);
	function Element() {
		this._nsMap = {};
	}
	Element.prototype = {
		nodeType: ELEMENT_NODE,
		hasAttribute: function(name$1) {
			return this.getAttributeNode(name$1) != null;
		},
		getAttribute: function(name$1) {
			var attr = this.getAttributeNode(name$1);
			return attr && attr.value || "";
		},
		getAttributeNode: function(name$1) {
			return this.attributes.getNamedItem(name$1);
		},
		setAttribute: function(name$1, value) {
			var attr = this.ownerDocument.createAttribute(name$1);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr);
		},
		removeAttribute: function(name$1) {
			var attr = this.getAttributeNode(name$1);
			attr && this.removeAttributeNode(attr);
		},
		appendChild: function(newChild) {
			if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) return this.insertBefore(newChild, null);
			else return _appendSingleChild(this, newChild);
		},
		setAttributeNode: function(newAttr) {
			return this.attributes.setNamedItem(newAttr);
		},
		setAttributeNodeNS: function(newAttr) {
			return this.attributes.setNamedItemNS(newAttr);
		},
		removeAttributeNode: function(oldAttr) {
			return this.attributes.removeNamedItem(oldAttr.nodeName);
		},
		removeAttributeNS: function(namespaceURI, localName) {
			var old = this.getAttributeNodeNS(namespaceURI, localName);
			old && this.removeAttributeNode(old);
		},
		hasAttributeNS: function(namespaceURI, localName) {
			return this.getAttributeNodeNS(namespaceURI, localName) != null;
		},
		getAttributeNS: function(namespaceURI, localName) {
			var attr = this.getAttributeNodeNS(namespaceURI, localName);
			return attr && attr.value || "";
		},
		setAttributeNS: function(namespaceURI, qualifiedName, value) {
			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr);
		},
		getAttributeNodeNS: function(namespaceURI, localName) {
			return this.attributes.getNamedItemNS(namespaceURI, localName);
		},
		getElementsByTagName: function(tagName) {
			return new LiveNodeList(this, function(base) {
				var ls = [];
				_visitNode(base, function(node) {
					if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) ls.push(node);
				});
				return ls;
			});
		},
		getElementsByTagNameNS: function(namespaceURI, localName) {
			return new LiveNodeList(this, function(base) {
				var ls = [];
				_visitNode(base, function(node) {
					if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) ls.push(node);
				});
				return ls;
			});
		}
	};
	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
	_extends(Element, Node);
	function Attr() {}
	Attr.prototype.nodeType = ATTRIBUTE_NODE;
	_extends(Attr, Node);
	function CharacterData() {}
	CharacterData.prototype = {
		data: "",
		substringData: function(offset, count) {
			return this.data.substring(offset, offset + count);
		},
		appendData: function(text) {
			text = this.data + text;
			this.nodeValue = this.data = text;
			this.length = text.length;
		},
		insertData: function(offset, text) {
			this.replaceData(offset, 0, text);
		},
		appendChild: function(newChild) {
			throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
		},
		deleteData: function(offset, count) {
			this.replaceData(offset, count, "");
		},
		replaceData: function(offset, count, text) {
			var start = this.data.substring(0, offset);
			var end = this.data.substring(offset + count);
			text = start + text + end;
			this.nodeValue = this.data = text;
			this.length = text.length;
		}
	};
	_extends(CharacterData, Node);
	function Text() {}
	Text.prototype = {
		nodeName: "#text",
		nodeType: TEXT_NODE,
		splitText: function(offset) {
			var text = this.data;
			var newText = text.substring(offset);
			text = text.substring(0, offset);
			this.data = this.nodeValue = text;
			this.length = text.length;
			var newNode = this.ownerDocument.createTextNode(newText);
			if (this.parentNode) this.parentNode.insertBefore(newNode, this.nextSibling);
			return newNode;
		}
	};
	_extends(Text, CharacterData);
	function Comment() {}
	Comment.prototype = {
		nodeName: "#comment",
		nodeType: COMMENT_NODE
	};
	_extends(Comment, CharacterData);
	function CDATASection() {}
	CDATASection.prototype = {
		nodeName: "#cdata-section",
		nodeType: CDATA_SECTION_NODE
	};
	_extends(CDATASection, CharacterData);
	function DocumentType() {}
	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
	_extends(DocumentType, Node);
	function Notation() {}
	Notation.prototype.nodeType = NOTATION_NODE;
	_extends(Notation, Node);
	function Entity() {}
	Entity.prototype.nodeType = ENTITY_NODE;
	_extends(Entity, Node);
	function EntityReference() {}
	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
	_extends(EntityReference, Node);
	function DocumentFragment() {}
	DocumentFragment.prototype.nodeName = "#document-fragment";
	DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
	_extends(DocumentFragment, Node);
	function ProcessingInstruction() {}
	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
	_extends(ProcessingInstruction, Node);
	function XMLSerializer() {}
	XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
		return nodeSerializeToString.call(node, isHtml, nodeFilter);
	};
	Node.prototype.toString = nodeSerializeToString;
	function nodeSerializeToString(isHtml, nodeFilter) {
		var buf = [];
		var refNode = this.nodeType == 9 && this.documentElement || this;
		var prefix = refNode.prefix;
		var uri = refNode.namespaceURI;
		if (uri && prefix == null) {
			var prefix = refNode.lookupPrefix(uri);
			if (prefix == null) var visibleNamespaces = [{
				namespace: uri,
				prefix: null
			}];
		}
		serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
		return buf.join("");
	}
	function needNamespaceDefine(node, isHTML, visibleNamespaces) {
		var prefix = node.prefix || "";
		var uri = node.namespaceURI;
		if (!uri) return false;
		if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) return false;
		var i = visibleNamespaces.length;
		while (i--) {
			var ns = visibleNamespaces[i];
			if (ns.prefix === prefix) return ns.namespace !== uri;
		}
		return true;
	}
	/**
	* Well-formed constraint: No < in Attribute Values
	* > The replacement text of any entity referred to directly or indirectly
	* > in an attribute value must not contain a <.
	* @see https://www.w3.org/TR/xml11/#CleanAttrVals
	* @see https://www.w3.org/TR/xml11/#NT-AttValue
	*
	* Literal whitespace other than space that appear in attribute values
	* are serialized as their entity references, so they will be preserved.
	* (In contrast to whitespace literals in the input which are normalized to spaces)
	* @see https://www.w3.org/TR/xml11/#AVNormalize
	* @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
	*/
	function addSerializedAttribute(buf, qualifiedName, value) {
		buf.push(" ", qualifiedName, "=\"", value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), "\"");
	}
	function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
		if (!visibleNamespaces) visibleNamespaces = [];
		if (nodeFilter) {
			node = nodeFilter(node);
			if (node) {
				if (typeof node == "string") {
					buf.push(node);
					return;
				}
			} else return;
		}
		switch (node.nodeType) {
			case ELEMENT_NODE:
				var attrs = node.attributes;
				var len = attrs.length;
				var child = node.firstChild;
				var nodeName = node.tagName;
				isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
				var prefixedNodeName = nodeName;
				if (!isHTML && !node.prefix && node.namespaceURI) {
					var defaultNS;
					for (var ai = 0; ai < attrs.length; ai++) if (attrs.item(ai).name === "xmlns") {
						defaultNS = attrs.item(ai).value;
						break;
					}
					if (!defaultNS) for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
							defaultNS = namespace.namespace;
							break;
						}
					}
					if (defaultNS !== node.namespaceURI) for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.namespace === node.namespaceURI) {
							if (namespace.prefix) prefixedNodeName = namespace.prefix + ":" + nodeName;
							break;
						}
					}
				}
				buf.push("<", prefixedNodeName);
				for (var i = 0; i < len; i++) {
					var attr = attrs.item(i);
					if (attr.prefix == "xmlns") visibleNamespaces.push({
						prefix: attr.localName,
						namespace: attr.value
					});
					else if (attr.nodeName == "xmlns") visibleNamespaces.push({
						prefix: "",
						namespace: attr.value
					});
				}
				for (var i = 0; i < len; i++) {
					var attr = attrs.item(i);
					if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
						var prefix = attr.prefix || "";
						var uri = attr.namespaceURI;
						addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
						visibleNamespaces.push({
							prefix,
							namespace: uri
						});
					}
					serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
				}
				if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
					var prefix = node.prefix || "";
					var uri = node.namespaceURI;
					addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
					visibleNamespaces.push({
						prefix,
						namespace: uri
					});
				}
				if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
					buf.push(">");
					if (isHTML && /^script$/i.test(nodeName)) while (child) {
						if (child.data) buf.push(child.data);
						else serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
						child = child.nextSibling;
					}
					else while (child) {
						serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
						child = child.nextSibling;
					}
					buf.push("</", prefixedNodeName, ">");
				} else buf.push("/>");
				return;
			case DOCUMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var child = node.firstChild;
				while (child) {
					serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					child = child.nextSibling;
				}
				return;
			case ATTRIBUTE_NODE: return addSerializedAttribute(buf, node.name, node.value);
			case TEXT_NODE:
 /**
			* The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
			* except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
			* If they are needed elsewhere, they must be escaped using either numeric character references or the strings
			* `&amp;` and `&lt;` respectively.
			* The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
			* be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
			* when that string is not marking the end of a CDATA section.
			*
			* In the content of elements, character data is any string of characters
			* which does not contain the start-delimiter of any markup
			* and does not include the CDATA-section-close delimiter, `]]>`.
			*
			* @see https://www.w3.org/TR/xml/#NT-CharData
			* @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
			*/
			return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
			case CDATA_SECTION_NODE: return buf.push("<![CDATA[", node.data, "]]>");
			case COMMENT_NODE: return buf.push("<!--", node.data, "-->");
			case DOCUMENT_TYPE_NODE:
				var pubid = node.publicId;
				var sysid = node.systemId;
				buf.push("<!DOCTYPE ", node.name);
				if (pubid) {
					buf.push(" PUBLIC ", pubid);
					if (sysid && sysid != ".") buf.push(" ", sysid);
					buf.push(">");
				} else if (sysid && sysid != ".") buf.push(" SYSTEM ", sysid, ">");
				else {
					var sub = node.internalSubset;
					if (sub) buf.push(" [", sub, "]");
					buf.push(">");
				}
				return;
			case PROCESSING_INSTRUCTION_NODE: return buf.push("<?", node.target, " ", node.data, "?>");
			case ENTITY_REFERENCE_NODE: return buf.push("&", node.nodeName, ";");
			default: buf.push("??", node.nodeName);
		}
	}
	function importNode(doc, node, deep) {
		var node2;
		switch (node.nodeType) {
			case ELEMENT_NODE:
				node2 = node.cloneNode(false);
				node2.ownerDocument = doc;
			case DOCUMENT_FRAGMENT_NODE: break;
			case ATTRIBUTE_NODE:
				deep = true;
				break;
		}
		if (!node2) node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		node2.parentNode = null;
		if (deep) {
			var child = node.firstChild;
			while (child) {
				node2.appendChild(importNode(doc, child, deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	function cloneNode(doc, node, deep) {
		var node2 = new node.constructor();
		for (var n in node) if (Object.prototype.hasOwnProperty.call(node, n)) {
			var v = node[n];
			if (typeof v != "object") {
				if (v != node2[n]) node2[n] = v;
			}
		}
		if (node.childNodes) node2.childNodes = new NodeList();
		node2.ownerDocument = doc;
		switch (node2.nodeType) {
			case ELEMENT_NODE:
				var attrs = node.attributes;
				var attrs2 = node2.attributes = new NamedNodeMap();
				var len = attrs.length;
				attrs2._ownerElement = node2;
				for (var i = 0; i < len; i++) node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
				break;
			case ATTRIBUTE_NODE: deep = true;
		}
		if (deep) {
			var child = node.firstChild;
			while (child) {
				node2.appendChild(cloneNode(doc, child, deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	function __set__(object$1, key, value) {
		object$1[key] = value;
	}
	try {
		if (Object.defineProperty) {
			Object.defineProperty(LiveNodeList.prototype, "length", { get: function() {
				_updateLiveList(this);
				return this.$$length;
			} });
			Object.defineProperty(Node.prototype, "textContent", {
				get: function() {
					return getTextContent(this);
				},
				set: function(data) {
					switch (this.nodeType) {
						case ELEMENT_NODE:
						case DOCUMENT_FRAGMENT_NODE:
							while (this.firstChild) this.removeChild(this.firstChild);
							if (data || String(data)) this.appendChild(this.ownerDocument.createTextNode(data));
							break;
						default:
							this.data = data;
							this.value = data;
							this.nodeValue = data;
					}
				}
			});
			function getTextContent(node) {
				switch (node.nodeType) {
					case ELEMENT_NODE:
					case DOCUMENT_FRAGMENT_NODE:
						var buf = [];
						node = node.firstChild;
						while (node) {
							if (node.nodeType !== 7 && node.nodeType !== 8) buf.push(getTextContent(node));
							node = node.nextSibling;
						}
						return buf.join("");
					default: return node.nodeValue;
				}
			}
			__set__ = function(object$1, key, value) {
				object$1["$$" + key] = value;
			};
		}
	} catch (e) {}
	exports.DocumentType = DocumentType;
	exports.DOMException = DOMException;
	exports.DOMImplementation = DOMImplementation;
	exports.Element = Element;
	exports.Node = Node;
	exports.NodeList = NodeList;
	exports.XMLSerializer = XMLSerializer;
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+xmldom@0.8.11/node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = /* @__PURE__ */ __commonJSMin(((exports) => {
	var freeze = require_conventions().freeze;
	/**
	* The entities that are predefined in every XML document.
	*
	* @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
	* @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
	* @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
	*/
	exports.XML_ENTITIES = freeze({
		amp: "&",
		apos: "'",
		gt: ">",
		lt: "<",
		quot: "\""
	});
	/**
	* A map of all entities that are detected in an HTML document.
	* They contain all entries from `XML_ENTITIES`.
	*
	* @see XML_ENTITIES
	* @see DOMParser.parseFromString
	* @see DOMImplementation.prototype.createHTMLDocument
	* @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
	* @see https://html.spec.whatwg.org/entities.json JSON
	* @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
	* @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
	* @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
	* @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
	*/
	exports.HTML_ENTITIES = freeze({
		Aacute: "",
		aacute: "",
		Abreve: "",
		abreve: "",
		ac: "",
		acd: "",
		acE: "",
		Acirc: "",
		acirc: "",
		acute: "",
		Acy: "",
		acy: "",
		AElig: "",
		aelig: "",
		af: "",
		Afr: "",
		afr: "",
		Agrave: "",
		agrave: "",
		alefsym: "",
		aleph: "",
		Alpha: "",
		alpha: "",
		Amacr: "",
		amacr: "",
		amalg: "",
		AMP: "&",
		amp: "&",
		And: "",
		and: "",
		andand: "",
		andd: "",
		andslope: "",
		andv: "",
		ang: "",
		ange: "",
		angle: "",
		angmsd: "",
		angmsdaa: "",
		angmsdab: "",
		angmsdac: "",
		angmsdad: "",
		angmsdae: "",
		angmsdaf: "",
		angmsdag: "",
		angmsdah: "",
		angrt: "",
		angrtvb: "",
		angrtvbd: "",
		angsph: "",
		angst: "",
		angzarr: "",
		Aogon: "",
		aogon: "",
		Aopf: "",
		aopf: "",
		ap: "",
		apacir: "",
		apE: "",
		ape: "",
		apid: "",
		apos: "'",
		ApplyFunction: "",
		approx: "",
		approxeq: "",
		Aring: "",
		aring: "",
		Ascr: "",
		ascr: "",
		Assign: "",
		ast: "*",
		asymp: "",
		asympeq: "",
		Atilde: "",
		atilde: "",
		Auml: "",
		auml: "",
		awconint: "",
		awint: "",
		backcong: "",
		backepsilon: "",
		backprime: "",
		backsim: "",
		backsimeq: "",
		Backslash: "",
		Barv: "",
		barvee: "",
		Barwed: "",
		barwed: "",
		barwedge: "",
		bbrk: "",
		bbrktbrk: "",
		bcong: "",
		Bcy: "",
		bcy: "",
		bdquo: "",
		becaus: "",
		Because: "",
		because: "",
		bemptyv: "",
		bepsi: "",
		bernou: "",
		Bernoullis: "",
		Beta: "",
		beta: "",
		beth: "",
		between: "",
		Bfr: "",
		bfr: "",
		bigcap: "",
		bigcirc: "",
		bigcup: "",
		bigodot: "",
		bigoplus: "",
		bigotimes: "",
		bigsqcup: "",
		bigstar: "",
		bigtriangledown: "",
		bigtriangleup: "",
		biguplus: "",
		bigvee: "",
		bigwedge: "",
		bkarow: "",
		blacklozenge: "",
		blacksquare: "",
		blacktriangle: "",
		blacktriangledown: "",
		blacktriangleleft: "",
		blacktriangleright: "",
		blank: "",
		blk12: "",
		blk14: "",
		blk34: "",
		block: "",
		bne: "=",
		bnequiv: "",
		bNot: "",
		bnot: "",
		Bopf: "",
		bopf: "",
		bot: "",
		bottom: "",
		bowtie: "",
		boxbox: "",
		boxDL: "",
		boxDl: "",
		boxdL: "",
		boxdl: "",
		boxDR: "",
		boxDr: "",
		boxdR: "",
		boxdr: "",
		boxH: "",
		boxh: "",
		boxHD: "",
		boxHd: "",
		boxhD: "",
		boxhd: "",
		boxHU: "",
		boxHu: "",
		boxhU: "",
		boxhu: "",
		boxminus: "",
		boxplus: "",
		boxtimes: "",
		boxUL: "",
		boxUl: "",
		boxuL: "",
		boxul: "",
		boxUR: "",
		boxUr: "",
		boxuR: "",
		boxur: "",
		boxV: "",
		boxv: "",
		boxVH: "",
		boxVh: "",
		boxvH: "",
		boxvh: "",
		boxVL: "",
		boxVl: "",
		boxvL: "",
		boxvl: "",
		boxVR: "",
		boxVr: "",
		boxvR: "",
		boxvr: "",
		bprime: "",
		Breve: "",
		breve: "",
		brvbar: "",
		Bscr: "",
		bscr: "",
		bsemi: "",
		bsim: "",
		bsime: "",
		bsol: "\\",
		bsolb: "",
		bsolhsub: "",
		bull: "",
		bullet: "",
		bump: "",
		bumpE: "",
		bumpe: "",
		Bumpeq: "",
		bumpeq: "",
		Cacute: "",
		cacute: "",
		Cap: "",
		cap: "",
		capand: "",
		capbrcup: "",
		capcap: "",
		capcup: "",
		capdot: "",
		CapitalDifferentialD: "",
		caps: "",
		caret: "",
		caron: "",
		Cayleys: "",
		ccaps: "",
		Ccaron: "",
		ccaron: "",
		Ccedil: "",
		ccedil: "",
		Ccirc: "",
		ccirc: "",
		Cconint: "",
		ccups: "",
		ccupssm: "",
		Cdot: "",
		cdot: "",
		cedil: "",
		Cedilla: "",
		cemptyv: "",
		cent: "",
		CenterDot: "",
		centerdot: "",
		Cfr: "",
		cfr: "",
		CHcy: "",
		chcy: "",
		check: "",
		checkmark: "",
		Chi: "",
		chi: "",
		cir: "",
		circ: "",
		circeq: "",
		circlearrowleft: "",
		circlearrowright: "",
		circledast: "",
		circledcirc: "",
		circleddash: "",
		CircleDot: "",
		circledR: "",
		circledS: "",
		CircleMinus: "",
		CirclePlus: "",
		CircleTimes: "",
		cirE: "",
		cire: "",
		cirfnint: "",
		cirmid: "",
		cirscir: "",
		ClockwiseContourIntegral: "",
		CloseCurlyDoubleQuote: "",
		CloseCurlyQuote: "",
		clubs: "",
		clubsuit: "",
		Colon: "",
		colon: ":",
		Colone: "",
		colone: "",
		coloneq: "",
		comma: ",",
		commat: "@",
		comp: "",
		compfn: "",
		complement: "",
		complexes: "",
		cong: "",
		congdot: "",
		Congruent: "",
		Conint: "",
		conint: "",
		ContourIntegral: "",
		Copf: "",
		copf: "",
		coprod: "",
		Coproduct: "",
		COPY: "",
		copy: "",
		copysr: "",
		CounterClockwiseContourIntegral: "",
		crarr: "",
		Cross: "",
		cross: "",
		Cscr: "",
		cscr: "",
		csub: "",
		csube: "",
		csup: "",
		csupe: "",
		ctdot: "",
		cudarrl: "",
		cudarrr: "",
		cuepr: "",
		cuesc: "",
		cularr: "",
		cularrp: "",
		Cup: "",
		cup: "",
		cupbrcap: "",
		CupCap: "",
		cupcap: "",
		cupcup: "",
		cupdot: "",
		cupor: "",
		cups: "",
		curarr: "",
		curarrm: "",
		curlyeqprec: "",
		curlyeqsucc: "",
		curlyvee: "",
		curlywedge: "",
		curren: "",
		curvearrowleft: "",
		curvearrowright: "",
		cuvee: "",
		cuwed: "",
		cwconint: "",
		cwint: "",
		cylcty: "",
		Dagger: "",
		dagger: "",
		daleth: "",
		Darr: "",
		dArr: "",
		darr: "",
		dash: "",
		Dashv: "",
		dashv: "",
		dbkarow: "",
		dblac: "",
		Dcaron: "",
		dcaron: "",
		Dcy: "",
		dcy: "",
		DD: "",
		dd: "",
		ddagger: "",
		ddarr: "",
		DDotrahd: "",
		ddotseq: "",
		deg: "",
		Del: "",
		Delta: "",
		delta: "",
		demptyv: "",
		dfisht: "",
		Dfr: "",
		dfr: "",
		dHar: "",
		dharl: "",
		dharr: "",
		DiacriticalAcute: "",
		DiacriticalDot: "",
		DiacriticalDoubleAcute: "",
		DiacriticalGrave: "`",
		DiacriticalTilde: "",
		diam: "",
		Diamond: "",
		diamond: "",
		diamondsuit: "",
		diams: "",
		die: "",
		DifferentialD: "",
		digamma: "",
		disin: "",
		div: "",
		divide: "",
		divideontimes: "",
		divonx: "",
		DJcy: "",
		djcy: "",
		dlcorn: "",
		dlcrop: "",
		dollar: "$",
		Dopf: "",
		dopf: "",
		Dot: "",
		dot: "",
		DotDot: "",
		doteq: "",
		doteqdot: "",
		DotEqual: "",
		dotminus: "",
		dotplus: "",
		dotsquare: "",
		doublebarwedge: "",
		DoubleContourIntegral: "",
		DoubleDot: "",
		DoubleDownArrow: "",
		DoubleLeftArrow: "",
		DoubleLeftRightArrow: "",
		DoubleLeftTee: "",
		DoubleLongLeftArrow: "",
		DoubleLongLeftRightArrow: "",
		DoubleLongRightArrow: "",
		DoubleRightArrow: "",
		DoubleRightTee: "",
		DoubleUpArrow: "",
		DoubleUpDownArrow: "",
		DoubleVerticalBar: "",
		DownArrow: "",
		Downarrow: "",
		downarrow: "",
		DownArrowBar: "",
		DownArrowUpArrow: "",
		DownBreve: "",
		downdownarrows: "",
		downharpoonleft: "",
		downharpoonright: "",
		DownLeftRightVector: "",
		DownLeftTeeVector: "",
		DownLeftVector: "",
		DownLeftVectorBar: "",
		DownRightTeeVector: "",
		DownRightVector: "",
		DownRightVectorBar: "",
		DownTee: "",
		DownTeeArrow: "",
		drbkarow: "",
		drcorn: "",
		drcrop: "",
		Dscr: "",
		dscr: "",
		DScy: "",
		dscy: "",
		dsol: "",
		Dstrok: "",
		dstrok: "",
		dtdot: "",
		dtri: "",
		dtrif: "",
		duarr: "",
		duhar: "",
		dwangle: "",
		DZcy: "",
		dzcy: "",
		dzigrarr: "",
		Eacute: "",
		eacute: "",
		easter: "",
		Ecaron: "",
		ecaron: "",
		ecir: "",
		Ecirc: "",
		ecirc: "",
		ecolon: "",
		Ecy: "",
		ecy: "",
		eDDot: "",
		Edot: "",
		eDot: "",
		edot: "",
		ee: "",
		efDot: "",
		Efr: "",
		efr: "",
		eg: "",
		Egrave: "",
		egrave: "",
		egs: "",
		egsdot: "",
		el: "",
		Element: "",
		elinters: "",
		ell: "",
		els: "",
		elsdot: "",
		Emacr: "",
		emacr: "",
		empty: "",
		emptyset: "",
		EmptySmallSquare: "",
		emptyv: "",
		EmptyVerySmallSquare: "",
		emsp: "",
		emsp13: "",
		emsp14: "",
		ENG: "",
		eng: "",
		ensp: "",
		Eogon: "",
		eogon: "",
		Eopf: "",
		eopf: "",
		epar: "",
		eparsl: "",
		eplus: "",
		epsi: "",
		Epsilon: "",
		epsilon: "",
		epsiv: "",
		eqcirc: "",
		eqcolon: "",
		eqsim: "",
		eqslantgtr: "",
		eqslantless: "",
		Equal: "",
		equals: "=",
		EqualTilde: "",
		equest: "",
		Equilibrium: "",
		equiv: "",
		equivDD: "",
		eqvparsl: "",
		erarr: "",
		erDot: "",
		Escr: "",
		escr: "",
		esdot: "",
		Esim: "",
		esim: "",
		Eta: "",
		eta: "",
		ETH: "",
		eth: "",
		Euml: "",
		euml: "",
		euro: "",
		excl: "!",
		exist: "",
		Exists: "",
		expectation: "",
		ExponentialE: "",
		exponentiale: "",
		fallingdotseq: "",
		Fcy: "",
		fcy: "",
		female: "",
		ffilig: "",
		fflig: "",
		ffllig: "",
		Ffr: "",
		ffr: "",
		filig: "",
		FilledSmallSquare: "",
		FilledVerySmallSquare: "",
		fjlig: "fj",
		flat: "",
		fllig: "",
		fltns: "",
		fnof: "",
		Fopf: "",
		fopf: "",
		ForAll: "",
		forall: "",
		fork: "",
		forkv: "",
		Fouriertrf: "",
		fpartint: "",
		frac12: "",
		frac13: "",
		frac14: "",
		frac15: "",
		frac16: "",
		frac18: "",
		frac23: "",
		frac25: "",
		frac34: "",
		frac35: "",
		frac38: "",
		frac45: "",
		frac56: "",
		frac58: "",
		frac78: "",
		frasl: "",
		frown: "",
		Fscr: "",
		fscr: "",
		gacute: "",
		Gamma: "",
		gamma: "",
		Gammad: "",
		gammad: "",
		gap: "",
		Gbreve: "",
		gbreve: "",
		Gcedil: "",
		Gcirc: "",
		gcirc: "",
		Gcy: "",
		gcy: "",
		Gdot: "",
		gdot: "",
		gE: "",
		ge: "",
		gEl: "",
		gel: "",
		geq: "",
		geqq: "",
		geqslant: "",
		ges: "",
		gescc: "",
		gesdot: "",
		gesdoto: "",
		gesdotol: "",
		gesl: "",
		gesles: "",
		Gfr: "",
		gfr: "",
		Gg: "",
		gg: "",
		ggg: "",
		gimel: "",
		GJcy: "",
		gjcy: "",
		gl: "",
		gla: "",
		glE: "",
		glj: "",
		gnap: "",
		gnapprox: "",
		gnE: "",
		gne: "",
		gneq: "",
		gneqq: "",
		gnsim: "",
		Gopf: "",
		gopf: "",
		grave: "`",
		GreaterEqual: "",
		GreaterEqualLess: "",
		GreaterFullEqual: "",
		GreaterGreater: "",
		GreaterLess: "",
		GreaterSlantEqual: "",
		GreaterTilde: "",
		Gscr: "",
		gscr: "",
		gsim: "",
		gsime: "",
		gsiml: "",
		Gt: "",
		GT: ">",
		gt: ">",
		gtcc: "",
		gtcir: "",
		gtdot: "",
		gtlPar: "",
		gtquest: "",
		gtrapprox: "",
		gtrarr: "",
		gtrdot: "",
		gtreqless: "",
		gtreqqless: "",
		gtrless: "",
		gtrsim: "",
		gvertneqq: "",
		gvnE: "",
		Hacek: "",
		hairsp: "",
		half: "",
		hamilt: "",
		HARDcy: "",
		hardcy: "",
		hArr: "",
		harr: "",
		harrcir: "",
		harrw: "",
		Hat: "^",
		hbar: "",
		Hcirc: "",
		hcirc: "",
		hearts: "",
		heartsuit: "",
		hellip: "",
		hercon: "",
		Hfr: "",
		hfr: "",
		HilbertSpace: "",
		hksearow: "",
		hkswarow: "",
		hoarr: "",
		homtht: "",
		hookleftarrow: "",
		hookrightarrow: "",
		Hopf: "",
		hopf: "",
		horbar: "",
		HorizontalLine: "",
		Hscr: "",
		hscr: "",
		hslash: "",
		Hstrok: "",
		hstrok: "",
		HumpDownHump: "",
		HumpEqual: "",
		hybull: "",
		hyphen: "",
		Iacute: "",
		iacute: "",
		ic: "",
		Icirc: "",
		icirc: "",
		Icy: "",
		icy: "",
		Idot: "",
		IEcy: "",
		iecy: "",
		iexcl: "",
		iff: "",
		Ifr: "",
		ifr: "",
		Igrave: "",
		igrave: "",
		ii: "",
		iiiint: "",
		iiint: "",
		iinfin: "",
		iiota: "",
		IJlig: "",
		ijlig: "",
		Im: "",
		Imacr: "",
		imacr: "",
		image: "",
		ImaginaryI: "",
		imagline: "",
		imagpart: "",
		imath: "",
		imof: "",
		imped: "",
		Implies: "",
		in: "",
		incare: "",
		infin: "",
		infintie: "",
		inodot: "",
		Int: "",
		int: "",
		intcal: "",
		integers: "",
		Integral: "",
		intercal: "",
		Intersection: "",
		intlarhk: "",
		intprod: "",
		InvisibleComma: "",
		InvisibleTimes: "",
		IOcy: "",
		iocy: "",
		Iogon: "",
		iogon: "",
		Iopf: "",
		iopf: "",
		Iota: "",
		iota: "",
		iprod: "",
		iquest: "",
		Iscr: "",
		iscr: "",
		isin: "",
		isindot: "",
		isinE: "",
		isins: "",
		isinsv: "",
		isinv: "",
		it: "",
		Itilde: "",
		itilde: "",
		Iukcy: "",
		iukcy: "",
		Iuml: "",
		iuml: "",
		Jcirc: "",
		jcirc: "",
		Jcy: "",
		jcy: "",
		Jfr: "",
		jfr: "",
		jmath: "",
		Jopf: "",
		jopf: "",
		Jscr: "",
		jscr: "",
		Jsercy: "",
		jsercy: "",
		Jukcy: "",
		jukcy: "",
		Kappa: "",
		kappa: "",
		kappav: "",
		Kcedil: "",
		kcedil: "",
		Kcy: "",
		kcy: "",
		Kfr: "",
		kfr: "",
		kgreen: "",
		KHcy: "",
		khcy: "",
		KJcy: "",
		kjcy: "",
		Kopf: "",
		kopf: "",
		Kscr: "",
		kscr: "",
		lAarr: "",
		Lacute: "",
		lacute: "",
		laemptyv: "",
		lagran: "",
		Lambda: "",
		lambda: "",
		Lang: "",
		lang: "",
		langd: "",
		langle: "",
		lap: "",
		Laplacetrf: "",
		laquo: "",
		Larr: "",
		lArr: "",
		larr: "",
		larrb: "",
		larrbfs: "",
		larrfs: "",
		larrhk: "",
		larrlp: "",
		larrpl: "",
		larrsim: "",
		larrtl: "",
		lat: "",
		lAtail: "",
		latail: "",
		late: "",
		lates: "",
		lBarr: "",
		lbarr: "",
		lbbrk: "",
		lbrace: "{",
		lbrack: "[",
		lbrke: "",
		lbrksld: "",
		lbrkslu: "",
		Lcaron: "",
		lcaron: "",
		Lcedil: "",
		lcedil: "",
		lceil: "",
		lcub: "{",
		Lcy: "",
		lcy: "",
		ldca: "",
		ldquo: "",
		ldquor: "",
		ldrdhar: "",
		ldrushar: "",
		ldsh: "",
		lE: "",
		le: "",
		LeftAngleBracket: "",
		LeftArrow: "",
		Leftarrow: "",
		leftarrow: "",
		LeftArrowBar: "",
		LeftArrowRightArrow: "",
		leftarrowtail: "",
		LeftCeiling: "",
		LeftDoubleBracket: "",
		LeftDownTeeVector: "",
		LeftDownVector: "",
		LeftDownVectorBar: "",
		LeftFloor: "",
		leftharpoondown: "",
		leftharpoonup: "",
		leftleftarrows: "",
		LeftRightArrow: "",
		Leftrightarrow: "",
		leftrightarrow: "",
		leftrightarrows: "",
		leftrightharpoons: "",
		leftrightsquigarrow: "",
		LeftRightVector: "",
		LeftTee: "",
		LeftTeeArrow: "",
		LeftTeeVector: "",
		leftthreetimes: "",
		LeftTriangle: "",
		LeftTriangleBar: "",
		LeftTriangleEqual: "",
		LeftUpDownVector: "",
		LeftUpTeeVector: "",
		LeftUpVector: "",
		LeftUpVectorBar: "",
		LeftVector: "",
		LeftVectorBar: "",
		lEg: "",
		leg: "",
		leq: "",
		leqq: "",
		leqslant: "",
		les: "",
		lescc: "",
		lesdot: "",
		lesdoto: "",
		lesdotor: "",
		lesg: "",
		lesges: "",
		lessapprox: "",
		lessdot: "",
		lesseqgtr: "",
		lesseqqgtr: "",
		LessEqualGreater: "",
		LessFullEqual: "",
		LessGreater: "",
		lessgtr: "",
		LessLess: "",
		lesssim: "",
		LessSlantEqual: "",
		LessTilde: "",
		lfisht: "",
		lfloor: "",
		Lfr: "",
		lfr: "",
		lg: "",
		lgE: "",
		lHar: "",
		lhard: "",
		lharu: "",
		lharul: "",
		lhblk: "",
		LJcy: "",
		ljcy: "",
		Ll: "",
		ll: "",
		llarr: "",
		llcorner: "",
		Lleftarrow: "",
		llhard: "",
		lltri: "",
		Lmidot: "",
		lmidot: "",
		lmoust: "",
		lmoustache: "",
		lnap: "",
		lnapprox: "",
		lnE: "",
		lne: "",
		lneq: "",
		lneqq: "",
		lnsim: "",
		loang: "",
		loarr: "",
		lobrk: "",
		LongLeftArrow: "",
		Longleftarrow: "",
		longleftarrow: "",
		LongLeftRightArrow: "",
		Longleftrightarrow: "",
		longleftrightarrow: "",
		longmapsto: "",
		LongRightArrow: "",
		Longrightarrow: "",
		longrightarrow: "",
		looparrowleft: "",
		looparrowright: "",
		lopar: "",
		Lopf: "",
		lopf: "",
		loplus: "",
		lotimes: "",
		lowast: "",
		lowbar: "_",
		LowerLeftArrow: "",
		LowerRightArrow: "",
		loz: "",
		lozenge: "",
		lozf: "",
		lpar: "(",
		lparlt: "",
		lrarr: "",
		lrcorner: "",
		lrhar: "",
		lrhard: "",
		lrm: "",
		lrtri: "",
		lsaquo: "",
		Lscr: "",
		lscr: "",
		Lsh: "",
		lsh: "",
		lsim: "",
		lsime: "",
		lsimg: "",
		lsqb: "[",
		lsquo: "",
		lsquor: "",
		Lstrok: "",
		lstrok: "",
		Lt: "",
		LT: "<",
		lt: "<",
		ltcc: "",
		ltcir: "",
		ltdot: "",
		lthree: "",
		ltimes: "",
		ltlarr: "",
		ltquest: "",
		ltri: "",
		ltrie: "",
		ltrif: "",
		ltrPar: "",
		lurdshar: "",
		luruhar: "",
		lvertneqq: "",
		lvnE: "",
		macr: "",
		male: "",
		malt: "",
		maltese: "",
		Map: "",
		map: "",
		mapsto: "",
		mapstodown: "",
		mapstoleft: "",
		mapstoup: "",
		marker: "",
		mcomma: "",
		Mcy: "",
		mcy: "",
		mdash: "",
		mDDot: "",
		measuredangle: "",
		MediumSpace: "",
		Mellintrf: "",
		Mfr: "",
		mfr: "",
		mho: "",
		micro: "",
		mid: "",
		midast: "*",
		midcir: "",
		middot: "",
		minus: "",
		minusb: "",
		minusd: "",
		minusdu: "",
		MinusPlus: "",
		mlcp: "",
		mldr: "",
		mnplus: "",
		models: "",
		Mopf: "",
		mopf: "",
		mp: "",
		Mscr: "",
		mscr: "",
		mstpos: "",
		Mu: "",
		mu: "",
		multimap: "",
		mumap: "",
		nabla: "",
		Nacute: "",
		nacute: "",
		nang: "",
		nap: "",
		napE: "",
		napid: "",
		napos: "",
		napprox: "",
		natur: "",
		natural: "",
		naturals: "",
		nbsp: "\xA0",
		nbump: "",
		nbumpe: "",
		ncap: "",
		Ncaron: "",
		ncaron: "",
		Ncedil: "",
		ncedil: "",
		ncong: "",
		ncongdot: "",
		ncup: "",
		Ncy: "",
		ncy: "",
		ndash: "",
		ne: "",
		nearhk: "",
		neArr: "",
		nearr: "",
		nearrow: "",
		nedot: "",
		NegativeMediumSpace: "",
		NegativeThickSpace: "",
		NegativeThinSpace: "",
		NegativeVeryThinSpace: "",
		nequiv: "",
		nesear: "",
		nesim: "",
		NestedGreaterGreater: "",
		NestedLessLess: "",
		NewLine: "\n",
		nexist: "",
		nexists: "",
		Nfr: "",
		nfr: "",
		ngE: "",
		nge: "",
		ngeq: "",
		ngeqq: "",
		ngeqslant: "",
		nges: "",
		nGg: "",
		ngsim: "",
		nGt: "",
		ngt: "",
		ngtr: "",
		nGtv: "",
		nhArr: "",
		nharr: "",
		nhpar: "",
		ni: "",
		nis: "",
		nisd: "",
		niv: "",
		NJcy: "",
		njcy: "",
		nlArr: "",
		nlarr: "",
		nldr: "",
		nlE: "",
		nle: "",
		nLeftarrow: "",
		nleftarrow: "",
		nLeftrightarrow: "",
		nleftrightarrow: "",
		nleq: "",
		nleqq: "",
		nleqslant: "",
		nles: "",
		nless: "",
		nLl: "",
		nlsim: "",
		nLt: "",
		nlt: "",
		nltri: "",
		nltrie: "",
		nLtv: "",
		nmid: "",
		NoBreak: "",
		NonBreakingSpace: "\xA0",
		Nopf: "",
		nopf: "",
		Not: "",
		not: "",
		NotCongruent: "",
		NotCupCap: "",
		NotDoubleVerticalBar: "",
		NotElement: "",
		NotEqual: "",
		NotEqualTilde: "",
		NotExists: "",
		NotGreater: "",
		NotGreaterEqual: "",
		NotGreaterFullEqual: "",
		NotGreaterGreater: "",
		NotGreaterLess: "",
		NotGreaterSlantEqual: "",
		NotGreaterTilde: "",
		NotHumpDownHump: "",
		NotHumpEqual: "",
		notin: "",
		notindot: "",
		notinE: "",
		notinva: "",
		notinvb: "",
		notinvc: "",
		NotLeftTriangle: "",
		NotLeftTriangleBar: "",
		NotLeftTriangleEqual: "",
		NotLess: "",
		NotLessEqual: "",
		NotLessGreater: "",
		NotLessLess: "",
		NotLessSlantEqual: "",
		NotLessTilde: "",
		NotNestedGreaterGreater: "",
		NotNestedLessLess: "",
		notni: "",
		notniva: "",
		notnivb: "",
		notnivc: "",
		NotPrecedes: "",
		NotPrecedesEqual: "",
		NotPrecedesSlantEqual: "",
		NotReverseElement: "",
		NotRightTriangle: "",
		NotRightTriangleBar: "",
		NotRightTriangleEqual: "",
		NotSquareSubset: "",
		NotSquareSubsetEqual: "",
		NotSquareSuperset: "",
		NotSquareSupersetEqual: "",
		NotSubset: "",
		NotSubsetEqual: "",
		NotSucceeds: "",
		NotSucceedsEqual: "",
		NotSucceedsSlantEqual: "",
		NotSucceedsTilde: "",
		NotSuperset: "",
		NotSupersetEqual: "",
		NotTilde: "",
		NotTildeEqual: "",
		NotTildeFullEqual: "",
		NotTildeTilde: "",
		NotVerticalBar: "",
		npar: "",
		nparallel: "",
		nparsl: "",
		npart: "",
		npolint: "",
		npr: "",
		nprcue: "",
		npre: "",
		nprec: "",
		npreceq: "",
		nrArr: "",
		nrarr: "",
		nrarrc: "",
		nrarrw: "",
		nRightarrow: "",
		nrightarrow: "",
		nrtri: "",
		nrtrie: "",
		nsc: "",
		nsccue: "",
		nsce: "",
		Nscr: "",
		nscr: "",
		nshortmid: "",
		nshortparallel: "",
		nsim: "",
		nsime: "",
		nsimeq: "",
		nsmid: "",
		nspar: "",
		nsqsube: "",
		nsqsupe: "",
		nsub: "",
		nsubE: "",
		nsube: "",
		nsubset: "",
		nsubseteq: "",
		nsubseteqq: "",
		nsucc: "",
		nsucceq: "",
		nsup: "",
		nsupE: "",
		nsupe: "",
		nsupset: "",
		nsupseteq: "",
		nsupseteqq: "",
		ntgl: "",
		Ntilde: "",
		ntilde: "",
		ntlg: "",
		ntriangleleft: "",
		ntrianglelefteq: "",
		ntriangleright: "",
		ntrianglerighteq: "",
		Nu: "",
		nu: "",
		num: "#",
		numero: "",
		numsp: "",
		nvap: "",
		nVDash: "",
		nVdash: "",
		nvDash: "",
		nvdash: "",
		nvge: "",
		nvgt: ">",
		nvHarr: "",
		nvinfin: "",
		nvlArr: "",
		nvle: "",
		nvlt: "<",
		nvltrie: "",
		nvrArr: "",
		nvrtrie: "",
		nvsim: "",
		nwarhk: "",
		nwArr: "",
		nwarr: "",
		nwarrow: "",
		nwnear: "",
		Oacute: "",
		oacute: "",
		oast: "",
		ocir: "",
		Ocirc: "",
		ocirc: "",
		Ocy: "",
		ocy: "",
		odash: "",
		Odblac: "",
		odblac: "",
		odiv: "",
		odot: "",
		odsold: "",
		OElig: "",
		oelig: "",
		ofcir: "",
		Ofr: "",
		ofr: "",
		ogon: "",
		Ograve: "",
		ograve: "",
		ogt: "",
		ohbar: "",
		ohm: "",
		oint: "",
		olarr: "",
		olcir: "",
		olcross: "",
		oline: "",
		olt: "",
		Omacr: "",
		omacr: "",
		Omega: "",
		omega: "",
		Omicron: "",
		omicron: "",
		omid: "",
		ominus: "",
		Oopf: "",
		oopf: "",
		opar: "",
		OpenCurlyDoubleQuote: "",
		OpenCurlyQuote: "",
		operp: "",
		oplus: "",
		Or: "",
		or: "",
		orarr: "",
		ord: "",
		order: "",
		orderof: "",
		ordf: "",
		ordm: "",
		origof: "",
		oror: "",
		orslope: "",
		orv: "",
		oS: "",
		Oscr: "",
		oscr: "",
		Oslash: "",
		oslash: "",
		osol: "",
		Otilde: "",
		otilde: "",
		Otimes: "",
		otimes: "",
		otimesas: "",
		Ouml: "",
		ouml: "",
		ovbar: "",
		OverBar: "",
		OverBrace: "",
		OverBracket: "",
		OverParenthesis: "",
		par: "",
		para: "",
		parallel: "",
		parsim: "",
		parsl: "",
		part: "",
		PartialD: "",
		Pcy: "",
		pcy: "",
		percnt: "%",
		period: ".",
		permil: "",
		perp: "",
		pertenk: "",
		Pfr: "",
		pfr: "",
		Phi: "",
		phi: "",
		phiv: "",
		phmmat: "",
		phone: "",
		Pi: "",
		pi: "",
		pitchfork: "",
		piv: "",
		planck: "",
		planckh: "",
		plankv: "",
		plus: "+",
		plusacir: "",
		plusb: "",
		pluscir: "",
		plusdo: "",
		plusdu: "",
		pluse: "",
		PlusMinus: "",
		plusmn: "",
		plussim: "",
		plustwo: "",
		pm: "",
		Poincareplane: "",
		pointint: "",
		Popf: "",
		popf: "",
		pound: "",
		Pr: "",
		pr: "",
		prap: "",
		prcue: "",
		prE: "",
		pre: "",
		prec: "",
		precapprox: "",
		preccurlyeq: "",
		Precedes: "",
		PrecedesEqual: "",
		PrecedesSlantEqual: "",
		PrecedesTilde: "",
		preceq: "",
		precnapprox: "",
		precneqq: "",
		precnsim: "",
		precsim: "",
		Prime: "",
		prime: "",
		primes: "",
		prnap: "",
		prnE: "",
		prnsim: "",
		prod: "",
		Product: "",
		profalar: "",
		profline: "",
		profsurf: "",
		prop: "",
		Proportion: "",
		Proportional: "",
		propto: "",
		prsim: "",
		prurel: "",
		Pscr: "",
		pscr: "",
		Psi: "",
		psi: "",
		puncsp: "",
		Qfr: "",
		qfr: "",
		qint: "",
		Qopf: "",
		qopf: "",
		qprime: "",
		Qscr: "",
		qscr: "",
		quaternions: "",
		quatint: "",
		quest: "?",
		questeq: "",
		QUOT: "\"",
		quot: "\"",
		rAarr: "",
		race: "",
		Racute: "",
		racute: "",
		radic: "",
		raemptyv: "",
		Rang: "",
		rang: "",
		rangd: "",
		range: "",
		rangle: "",
		raquo: "",
		Rarr: "",
		rArr: "",
		rarr: "",
		rarrap: "",
		rarrb: "",
		rarrbfs: "",
		rarrc: "",
		rarrfs: "",
		rarrhk: "",
		rarrlp: "",
		rarrpl: "",
		rarrsim: "",
		Rarrtl: "",
		rarrtl: "",
		rarrw: "",
		rAtail: "",
		ratail: "",
		ratio: "",
		rationals: "",
		RBarr: "",
		rBarr: "",
		rbarr: "",
		rbbrk: "",
		rbrace: "}",
		rbrack: "]",
		rbrke: "",
		rbrksld: "",
		rbrkslu: "",
		Rcaron: "",
		rcaron: "",
		Rcedil: "",
		rcedil: "",
		rceil: "",
		rcub: "}",
		Rcy: "",
		rcy: "",
		rdca: "",
		rdldhar: "",
		rdquo: "",
		rdquor: "",
		rdsh: "",
		Re: "",
		real: "",
		realine: "",
		realpart: "",
		reals: "",
		rect: "",
		REG: "",
		reg: "",
		ReverseElement: "",
		ReverseEquilibrium: "",
		ReverseUpEquilibrium: "",
		rfisht: "",
		rfloor: "",
		Rfr: "",
		rfr: "",
		rHar: "",
		rhard: "",
		rharu: "",
		rharul: "",
		Rho: "",
		rho: "",
		rhov: "",
		RightAngleBracket: "",
		RightArrow: "",
		Rightarrow: "",
		rightarrow: "",
		RightArrowBar: "",
		RightArrowLeftArrow: "",
		rightarrowtail: "",
		RightCeiling: "",
		RightDoubleBracket: "",
		RightDownTeeVector: "",
		RightDownVector: "",
		RightDownVectorBar: "",
		RightFloor: "",
		rightharpoondown: "",
		rightharpoonup: "",
		rightleftarrows: "",
		rightleftharpoons: "",
		rightrightarrows: "",
		rightsquigarrow: "",
		RightTee: "",
		RightTeeArrow: "",
		RightTeeVector: "",
		rightthreetimes: "",
		RightTriangle: "",
		RightTriangleBar: "",
		RightTriangleEqual: "",
		RightUpDownVector: "",
		RightUpTeeVector: "",
		RightUpVector: "",
		RightUpVectorBar: "",
		RightVector: "",
		RightVectorBar: "",
		ring: "",
		risingdotseq: "",
		rlarr: "",
		rlhar: "",
		rlm: "",
		rmoust: "",
		rmoustache: "",
		rnmid: "",
		roang: "",
		roarr: "",
		robrk: "",
		ropar: "",
		Ropf: "",
		ropf: "",
		roplus: "",
		rotimes: "",
		RoundImplies: "",
		rpar: ")",
		rpargt: "",
		rppolint: "",
		rrarr: "",
		Rrightarrow: "",
		rsaquo: "",
		Rscr: "",
		rscr: "",
		Rsh: "",
		rsh: "",
		rsqb: "]",
		rsquo: "",
		rsquor: "",
		rthree: "",
		rtimes: "",
		rtri: "",
		rtrie: "",
		rtrif: "",
		rtriltri: "",
		RuleDelayed: "",
		ruluhar: "",
		rx: "",
		Sacute: "",
		sacute: "",
		sbquo: "",
		Sc: "",
		sc: "",
		scap: "",
		Scaron: "",
		scaron: "",
		sccue: "",
		scE: "",
		sce: "",
		Scedil: "",
		scedil: "",
		Scirc: "",
		scirc: "",
		scnap: "",
		scnE: "",
		scnsim: "",
		scpolint: "",
		scsim: "",
		Scy: "",
		scy: "",
		sdot: "",
		sdotb: "",
		sdote: "",
		searhk: "",
		seArr: "",
		searr: "",
		searrow: "",
		sect: "",
		semi: ";",
		seswar: "",
		setminus: "",
		setmn: "",
		sext: "",
		Sfr: "",
		sfr: "",
		sfrown: "",
		sharp: "",
		SHCHcy: "",
		shchcy: "",
		SHcy: "",
		shcy: "",
		ShortDownArrow: "",
		ShortLeftArrow: "",
		shortmid: "",
		shortparallel: "",
		ShortRightArrow: "",
		ShortUpArrow: "",
		shy: "",
		Sigma: "",
		sigma: "",
		sigmaf: "",
		sigmav: "",
		sim: "",
		simdot: "",
		sime: "",
		simeq: "",
		simg: "",
		simgE: "",
		siml: "",
		simlE: "",
		simne: "",
		simplus: "",
		simrarr: "",
		slarr: "",
		SmallCircle: "",
		smallsetminus: "",
		smashp: "",
		smeparsl: "",
		smid: "",
		smile: "",
		smt: "",
		smte: "",
		smtes: "",
		SOFTcy: "",
		softcy: "",
		sol: "/",
		solb: "",
		solbar: "",
		Sopf: "",
		sopf: "",
		spades: "",
		spadesuit: "",
		spar: "",
		sqcap: "",
		sqcaps: "",
		sqcup: "",
		sqcups: "",
		Sqrt: "",
		sqsub: "",
		sqsube: "",
		sqsubset: "",
		sqsubseteq: "",
		sqsup: "",
		sqsupe: "",
		sqsupset: "",
		sqsupseteq: "",
		squ: "",
		Square: "",
		square: "",
		SquareIntersection: "",
		SquareSubset: "",
		SquareSubsetEqual: "",
		SquareSuperset: "",
		SquareSupersetEqual: "",
		SquareUnion: "",
		squarf: "",
		squf: "",
		srarr: "",
		Sscr: "",
		sscr: "",
		ssetmn: "",
		ssmile: "",
		sstarf: "",
		Star: "",
		star: "",
		starf: "",
		straightepsilon: "",
		straightphi: "",
		strns: "",
		Sub: "",
		sub: "",
		subdot: "",
		subE: "",
		sube: "",
		subedot: "",
		submult: "",
		subnE: "",
		subne: "",
		subplus: "",
		subrarr: "",
		Subset: "",
		subset: "",
		subseteq: "",
		subseteqq: "",
		SubsetEqual: "",
		subsetneq: "",
		subsetneqq: "",
		subsim: "",
		subsub: "",
		subsup: "",
		succ: "",
		succapprox: "",
		succcurlyeq: "",
		Succeeds: "",
		SucceedsEqual: "",
		SucceedsSlantEqual: "",
		SucceedsTilde: "",
		succeq: "",
		succnapprox: "",
		succneqq: "",
		succnsim: "",
		succsim: "",
		SuchThat: "",
		Sum: "",
		sum: "",
		sung: "",
		Sup: "",
		sup: "",
		sup1: "",
		sup2: "",
		sup3: "",
		supdot: "",
		supdsub: "",
		supE: "",
		supe: "",
		supedot: "",
		Superset: "",
		SupersetEqual: "",
		suphsol: "",
		suphsub: "",
		suplarr: "",
		supmult: "",
		supnE: "",
		supne: "",
		supplus: "",
		Supset: "",
		supset: "",
		supseteq: "",
		supseteqq: "",
		supsetneq: "",
		supsetneqq: "",
		supsim: "",
		supsub: "",
		supsup: "",
		swarhk: "",
		swArr: "",
		swarr: "",
		swarrow: "",
		swnwar: "",
		szlig: "",
		Tab: "	",
		target: "",
		Tau: "",
		tau: "",
		tbrk: "",
		Tcaron: "",
		tcaron: "",
		Tcedil: "",
		tcedil: "",
		Tcy: "",
		tcy: "",
		tdot: "",
		telrec: "",
		Tfr: "",
		tfr: "",
		there4: "",
		Therefore: "",
		therefore: "",
		Theta: "",
		theta: "",
		thetasym: "",
		thetav: "",
		thickapprox: "",
		thicksim: "",
		ThickSpace: "",
		thinsp: "",
		ThinSpace: "",
		thkap: "",
		thksim: "",
		THORN: "",
		thorn: "",
		Tilde: "",
		tilde: "",
		TildeEqual: "",
		TildeFullEqual: "",
		TildeTilde: "",
		times: "",
		timesb: "",
		timesbar: "",
		timesd: "",
		tint: "",
		toea: "",
		top: "",
		topbot: "",
		topcir: "",
		Topf: "",
		topf: "",
		topfork: "",
		tosa: "",
		tprime: "",
		TRADE: "",
		trade: "",
		triangle: "",
		triangledown: "",
		triangleleft: "",
		trianglelefteq: "",
		triangleq: "",
		triangleright: "",
		trianglerighteq: "",
		tridot: "",
		trie: "",
		triminus: "",
		TripleDot: "",
		triplus: "",
		trisb: "",
		tritime: "",
		trpezium: "",
		Tscr: "",
		tscr: "",
		TScy: "",
		tscy: "",
		TSHcy: "",
		tshcy: "",
		Tstrok: "",
		tstrok: "",
		twixt: "",
		twoheadleftarrow: "",
		twoheadrightarrow: "",
		Uacute: "",
		uacute: "",
		Uarr: "",
		uArr: "",
		uarr: "",
		Uarrocir: "",
		Ubrcy: "",
		ubrcy: "",
		Ubreve: "",
		ubreve: "",
		Ucirc: "",
		ucirc: "",
		Ucy: "",
		ucy: "",
		udarr: "",
		Udblac: "",
		udblac: "",
		udhar: "",
		ufisht: "",
		Ufr: "",
		ufr: "",
		Ugrave: "",
		ugrave: "",
		uHar: "",
		uharl: "",
		uharr: "",
		uhblk: "",
		ulcorn: "",
		ulcorner: "",
		ulcrop: "",
		ultri: "",
		Umacr: "",
		umacr: "",
		uml: "",
		UnderBar: "_",
		UnderBrace: "",
		UnderBracket: "",
		UnderParenthesis: "",
		Union: "",
		UnionPlus: "",
		Uogon: "",
		uogon: "",
		Uopf: "",
		uopf: "",
		UpArrow: "",
		Uparrow: "",
		uparrow: "",
		UpArrowBar: "",
		UpArrowDownArrow: "",
		UpDownArrow: "",
		Updownarrow: "",
		updownarrow: "",
		UpEquilibrium: "",
		upharpoonleft: "",
		upharpoonright: "",
		uplus: "",
		UpperLeftArrow: "",
		UpperRightArrow: "",
		Upsi: "",
		upsi: "",
		upsih: "",
		Upsilon: "",
		upsilon: "",
		UpTee: "",
		UpTeeArrow: "",
		upuparrows: "",
		urcorn: "",
		urcorner: "",
		urcrop: "",
		Uring: "",
		uring: "",
		urtri: "",
		Uscr: "",
		uscr: "",
		utdot: "",
		Utilde: "",
		utilde: "",
		utri: "",
		utrif: "",
		uuarr: "",
		Uuml: "",
		uuml: "",
		uwangle: "",
		vangrt: "",
		varepsilon: "",
		varkappa: "",
		varnothing: "",
		varphi: "",
		varpi: "",
		varpropto: "",
		vArr: "",
		varr: "",
		varrho: "",
		varsigma: "",
		varsubsetneq: "",
		varsubsetneqq: "",
		varsupsetneq: "",
		varsupsetneqq: "",
		vartheta: "",
		vartriangleleft: "",
		vartriangleright: "",
		Vbar: "",
		vBar: "",
		vBarv: "",
		Vcy: "",
		vcy: "",
		VDash: "",
		Vdash: "",
		vDash: "",
		vdash: "",
		Vdashl: "",
		Vee: "",
		vee: "",
		veebar: "",
		veeeq: "",
		vellip: "",
		Verbar: "",
		verbar: "|",
		Vert: "",
		vert: "|",
		VerticalBar: "",
		VerticalLine: "|",
		VerticalSeparator: "",
		VerticalTilde: "",
		VeryThinSpace: "",
		Vfr: "",
		vfr: "",
		vltri: "",
		vnsub: "",
		vnsup: "",
		Vopf: "",
		vopf: "",
		vprop: "",
		vrtri: "",
		Vscr: "",
		vscr: "",
		vsubnE: "",
		vsubne: "",
		vsupnE: "",
		vsupne: "",
		Vvdash: "",
		vzigzag: "",
		Wcirc: "",
		wcirc: "",
		wedbar: "",
		Wedge: "",
		wedge: "",
		wedgeq: "",
		weierp: "",
		Wfr: "",
		wfr: "",
		Wopf: "",
		wopf: "",
		wp: "",
		wr: "",
		wreath: "",
		Wscr: "",
		wscr: "",
		xcap: "",
		xcirc: "",
		xcup: "",
		xdtri: "",
		Xfr: "",
		xfr: "",
		xhArr: "",
		xharr: "",
		Xi: "",
		xi: "",
		xlArr: "",
		xlarr: "",
		xmap: "",
		xnis: "",
		xodot: "",
		Xopf: "",
		xopf: "",
		xoplus: "",
		xotime: "",
		xrArr: "",
		xrarr: "",
		Xscr: "",
		xscr: "",
		xsqcup: "",
		xuplus: "",
		xutri: "",
		xvee: "",
		xwedge: "",
		Yacute: "",
		yacute: "",
		YAcy: "",
		yacy: "",
		Ycirc: "",
		ycirc: "",
		Ycy: "",
		ycy: "",
		yen: "",
		Yfr: "",
		yfr: "",
		YIcy: "",
		yicy: "",
		Yopf: "",
		yopf: "",
		Yscr: "",
		yscr: "",
		YUcy: "",
		yucy: "",
		Yuml: "",
		yuml: "",
		Zacute: "",
		zacute: "",
		Zcaron: "",
		zcaron: "",
		Zcy: "",
		zcy: "",
		Zdot: "",
		zdot: "",
		zeetrf: "",
		ZeroWidthSpace: "",
		Zeta: "",
		zeta: "",
		Zfr: "",
		zfr: "",
		ZHcy: "",
		zhcy: "",
		zigrarr: "",
		Zopf: "",
		zopf: "",
		Zscr: "",
		zscr: "",
		zwj: "",
		zwnj: ""
	});
	/**
	* @deprecated use `HTML_ENTITIES` instead
	* @see HTML_ENTITIES
	*/
	exports.entityMap = exports.HTML_ENTITIES;
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+xmldom@0.8.11/node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = /* @__PURE__ */ __commonJSMin(((exports) => {
	var NAMESPACE = require_conventions().NAMESPACE;
	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
	var nameChar = /* @__PURE__ */ new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
	var tagNamePattern = /* @__PURE__ */ new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
	var S_TAG = 0;
	var S_ATTR = 1;
	var S_ATTR_SPACE = 2;
	var S_EQ = 3;
	var S_ATTR_NOQUOT_VALUE = 4;
	var S_ATTR_END = 5;
	var S_TAG_SPACE = 6;
	var S_TAG_CLOSE = 7;
	/**
	* Creates an error that will not be caught by XMLReader aka the SAX parser.
	*
	* @param {string} message
	* @param {any?} locator Optional, can provide details about the location in the source
	* @constructor
	*/
	function ParseError(message, locator) {
		this.message = message;
		this.locator = locator;
		if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
	}
	ParseError.prototype = /* @__PURE__ */ new Error();
	ParseError.prototype.name = ParseError.name;
	function XMLReader() {}
	XMLReader.prototype = { parse: function(source, defaultNSMap, entityMap) {
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap, defaultNSMap = {});
		parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
		domBuilder.endDocument();
	} };
	function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
		function fixedFromCharCode(code) {
			if (code > 65535) {
				code -= 65536;
				var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
				return String.fromCharCode(surrogate1, surrogate2);
			} else return String.fromCharCode(code);
		}
		function entityReplacer(a$1) {
			var k = a$1.slice(1, -1);
			if (Object.hasOwnProperty.call(entityMap, k)) return entityMap[k];
			else if (k.charAt(0) === "#") return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
			else {
				errorHandler.error("entity not found:" + a$1);
				return a$1;
			}
		}
		function appendText(end$1) {
			if (end$1 > start) {
				var xt = source.substring(start, end$1).replace(/&#?\w+;/g, entityReplacer);
				locator && position(start);
				domBuilder.characters(xt, 0, end$1 - start);
				start = end$1;
			}
		}
		function position(p, m) {
			while (p >= lineEnd && (m = linePattern.exec(source))) {
				lineStart = m.index;
				lineEnd = lineStart + m[0].length;
				locator.lineNumber++;
			}
			locator.columnNumber = p - lineStart + 1;
		}
		var lineStart = 0;
		var lineEnd = 0;
		var linePattern = /.*(?:\r\n?|\n)|.*$/g;
		var locator = domBuilder.locator;
		var parseStack = [{ currentNSMap: defaultNSMapCopy }];
		var closeMap = {};
		var start = 0;
		while (true) {
			try {
				var tagStart = source.indexOf("<", start);
				if (tagStart < 0) {
					if (!source.substr(start).match(/^\s*$/)) {
						var doc = domBuilder.doc;
						var text = doc.createTextNode(source.substr(start));
						doc.appendChild(text);
						domBuilder.currentElement = text;
					}
					return;
				}
				if (tagStart > start) appendText(tagStart);
				switch (source.charAt(tagStart + 1)) {
					case "/":
						var end = source.indexOf(">", tagStart + 3);
						var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
						var config$1 = parseStack.pop();
						if (end < 0) {
							tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
							errorHandler.error("end tag name: " + tagName + " is not complete:" + config$1.tagName);
							end = tagStart + 1 + tagName.length;
						} else if (tagName.match(/\s</)) {
							tagName = tagName.replace(/[\s<].*/, "");
							errorHandler.error("end tag name: " + tagName + " maybe not complete");
							end = tagStart + 1 + tagName.length;
						}
						var localNSMap = config$1.localNSMap;
						var endMatch = config$1.tagName == tagName;
						if (endMatch || config$1.tagName && config$1.tagName.toLowerCase() == tagName.toLowerCase()) {
							domBuilder.endElement(config$1.uri, config$1.localName, tagName);
							if (localNSMap) {
								for (var prefix in localNSMap) if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) domBuilder.endPrefixMapping(prefix);
							}
							if (!endMatch) errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config$1.tagName);
						} else parseStack.push(config$1);
						end++;
						break;
					case "?":
						locator && position(tagStart);
						end = parseInstruction(source, tagStart, domBuilder);
						break;
					case "!":
						locator && position(tagStart);
						end = parseDCC(source, tagStart, domBuilder, errorHandler);
						break;
					default:
						locator && position(tagStart);
						var el = new ElementAttributes();
						var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
						var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
						var len = el.length;
						if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
							el.closed = true;
							if (!entityMap.nbsp) errorHandler.warning("unclosed xml attribute");
						}
						if (locator && len) {
							var locator2 = copyLocator(locator, {});
							for (var i = 0; i < len; i++) {
								var a = el[i];
								position(a.offset);
								a.locator = copyLocator(locator, {});
							}
							domBuilder.locator = locator2;
							if (appendElement(el, domBuilder, currentNSMap)) parseStack.push(el);
							domBuilder.locator = locator;
						} else if (appendElement(el, domBuilder, currentNSMap)) parseStack.push(el);
						if (NAMESPACE.isHTML(el.uri) && !el.closed) end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
						else end++;
				}
			} catch (e) {
				if (e instanceof ParseError) throw e;
				errorHandler.error("element parse error: " + e);
				end = -1;
			}
			if (end > start) start = end;
			else appendText(Math.max(tagStart, start) + 1);
		}
	}
	function copyLocator(f, t) {
		t.lineNumber = f.lineNumber;
		t.columnNumber = f.columnNumber;
		return t;
	}
	/**
	* @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
	* @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	*/
	function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
		/**
		* @param {string} qname
		* @param {string} value
		* @param {number} startIndex
		*/
		function addAttribute(qname, value$1, startIndex) {
			if (el.attributeNames.hasOwnProperty(qname)) errorHandler.fatalError("Attribute " + qname + " redefined");
			el.addValue(qname, value$1.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer), startIndex);
		}
		var attrName;
		var value;
		var p = ++start;
		var s = S_TAG;
		while (true) {
			var c = source.charAt(p);
			switch (c) {
				case "=":
					if (s === S_ATTR) {
						attrName = source.slice(start, p);
						s = S_EQ;
					} else if (s === S_ATTR_SPACE) s = S_EQ;
					else throw new Error("attribute equal must after attrName");
					break;
				case "'":
				case "\"":
					if (s === S_EQ || s === S_ATTR) {
						if (s === S_ATTR) {
							errorHandler.warning("attribute value must after \"=\"");
							attrName = source.slice(start, p);
						}
						start = p + 1;
						p = source.indexOf(c, start);
						if (p > 0) {
							value = source.slice(start, p);
							addAttribute(attrName, value, start - 1);
							s = S_ATTR_END;
						} else throw new Error("attribute value no end '" + c + "' match");
					} else if (s == S_ATTR_NOQUOT_VALUE) {
						value = source.slice(start, p);
						addAttribute(attrName, value, start);
						errorHandler.warning("attribute \"" + attrName + "\" missed start quot(" + c + ")!!");
						start = p + 1;
						s = S_ATTR_END;
					} else throw new Error("attribute value must after \"=\"");
					break;
				case "/":
					switch (s) {
						case S_TAG: el.setTagName(source.slice(start, p));
						case S_ATTR_END:
						case S_TAG_SPACE:
						case S_TAG_CLOSE:
							s = S_TAG_CLOSE;
							el.closed = true;
						case S_ATTR_NOQUOT_VALUE:
						case S_ATTR: break;
						case S_ATTR_SPACE:
							el.closed = true;
							break;
						default: throw new Error("attribute invalid close char('/')");
					}
					break;
				case "":
					errorHandler.error("unexpected end of input");
					if (s == S_TAG) el.setTagName(source.slice(start, p));
					return p;
				case ">":
					switch (s) {
						case S_TAG: el.setTagName(source.slice(start, p));
						case S_ATTR_END:
						case S_TAG_SPACE:
						case S_TAG_CLOSE: break;
						case S_ATTR_NOQUOT_VALUE:
						case S_ATTR:
							value = source.slice(start, p);
							if (value.slice(-1) === "/") {
								el.closed = true;
								value = value.slice(0, -1);
							}
						case S_ATTR_SPACE:
							if (s === S_ATTR_SPACE) value = attrName;
							if (s == S_ATTR_NOQUOT_VALUE) {
								errorHandler.warning("attribute \"" + value + "\" missed quot(\")!");
								addAttribute(attrName, value, start);
							} else {
								if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) errorHandler.warning("attribute \"" + value + "\" missed value!! \"" + value + "\" instead!!");
								addAttribute(value, value, start);
							}
							break;
						case S_EQ: throw new Error("attribute value missed!!");
					}
					return p;
				case "": c = " ";
				default: if (c <= " ") switch (s) {
					case S_TAG:
						el.setTagName(source.slice(start, p));
						s = S_TAG_SPACE;
						break;
					case S_ATTR:
						attrName = source.slice(start, p);
						s = S_ATTR_SPACE;
						break;
					case S_ATTR_NOQUOT_VALUE:
						var value = source.slice(start, p);
						errorHandler.warning("attribute \"" + value + "\" missed quot(\")!!");
						addAttribute(attrName, value, start);
					case S_ATTR_END:
						s = S_TAG_SPACE;
						break;
				}
				else switch (s) {
					case S_ATTR_SPACE:
						el.tagName;
						if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) errorHandler.warning("attribute \"" + attrName + "\" missed value!! \"" + attrName + "\" instead2!!");
						addAttribute(attrName, attrName, start);
						start = p;
						s = S_ATTR;
						break;
					case S_ATTR_END: errorHandler.warning("attribute space is required\"" + attrName + "\"!!");
					case S_TAG_SPACE:
						s = S_ATTR;
						start = p;
						break;
					case S_EQ:
						s = S_ATTR_NOQUOT_VALUE;
						start = p;
						break;
					case S_TAG_CLOSE: throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
			p++;
		}
	}
	/**
	* @return true if has new namespace define
	*/
	function appendElement(el, domBuilder, currentNSMap) {
		var tagName = el.tagName;
		var localNSMap = null;
		var i = el.length;
		while (i--) {
			var a = el[i];
			var qName = a.qName;
			var value = a.value;
			var nsp = qName.indexOf(":");
			if (nsp > 0) {
				var prefix = a.prefix = qName.slice(0, nsp);
				var localName = qName.slice(nsp + 1);
				var nsPrefix = prefix === "xmlns" && localName;
			} else {
				localName = qName;
				prefix = null;
				nsPrefix = qName === "xmlns" && "";
			}
			a.localName = localName;
			if (nsPrefix !== false) {
				if (localNSMap == null) {
					localNSMap = {};
					_copy(currentNSMap, currentNSMap = {});
				}
				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
				a.uri = NAMESPACE.XMLNS;
				domBuilder.startPrefixMapping(nsPrefix, value);
			}
		}
		var i = el.length;
		while (i--) {
			a = el[i];
			var prefix = a.prefix;
			if (prefix) {
				if (prefix === "xml") a.uri = NAMESPACE.XML;
				if (prefix !== "xmlns") a.uri = currentNSMap[prefix || ""];
			}
		}
		var nsp = tagName.indexOf(":");
		if (nsp > 0) {
			prefix = el.prefix = tagName.slice(0, nsp);
			localName = el.localName = tagName.slice(nsp + 1);
		} else {
			prefix = null;
			localName = el.localName = tagName;
		}
		var ns = el.uri = currentNSMap[prefix || ""];
		domBuilder.startElement(ns, localName, tagName, el);
		if (el.closed) {
			domBuilder.endElement(ns, localName, tagName);
			if (localNSMap) {
				for (prefix in localNSMap) if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) domBuilder.endPrefixMapping(prefix);
			}
		} else {
			el.currentNSMap = currentNSMap;
			el.localNSMap = localNSMap;
			return true;
		}
	}
	function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
		if (/^(?:script|textarea)$/i.test(tagName)) {
			var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
			var text = source.substring(elStartEnd + 1, elEndStart);
			if (/[&<]/.test(text)) {
				if (/^script$/i.test(tagName)) {
					domBuilder.characters(text, 0, text.length);
					return elEndStart;
				}
				text = text.replace(/&#?\w+;/g, entityReplacer);
				domBuilder.characters(text, 0, text.length);
				return elEndStart;
			}
		}
		return elStartEnd + 1;
	}
	function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
		var pos = closeMap[tagName];
		if (pos == null) {
			pos = source.lastIndexOf("</" + tagName + ">");
			if (pos < elStartEnd) pos = source.lastIndexOf("</" + tagName);
			closeMap[tagName] = pos;
		}
		return pos < elStartEnd;
	}
	function _copy(source, target) {
		for (var n in source) if (Object.prototype.hasOwnProperty.call(source, n)) target[n] = source[n];
	}
	function parseDCC(source, start, domBuilder, errorHandler) {
		switch (source.charAt(start + 2)) {
			case "-": if (source.charAt(start + 3) === "-") {
				var end = source.indexOf("-->", start + 4);
				if (end > start) {
					domBuilder.comment(source, start + 4, end - start - 4);
					return end + 3;
				} else {
					errorHandler.error("Unclosed comment");
					return -1;
				}
			} else return -1;
			default:
				if (source.substr(start + 3, 6) == "CDATA[") {
					var end = source.indexOf("]]>", start + 9);
					domBuilder.startCDATA();
					domBuilder.characters(source, start + 9, end - start - 9);
					domBuilder.endCDATA();
					return end + 3;
				}
				var matchs = split(source, start);
				var len = matchs.length;
				if (len > 1 && /!doctype/i.test(matchs[0][0])) {
					var name$1 = matchs[1][0];
					var pubid = false;
					var sysid = false;
					if (len > 3) {
						if (/^public$/i.test(matchs[2][0])) {
							pubid = matchs[3][0];
							sysid = len > 4 && matchs[4][0];
						} else if (/^system$/i.test(matchs[2][0])) sysid = matchs[3][0];
					}
					var lastMatch = matchs[len - 1];
					domBuilder.startDTD(name$1, pubid, sysid);
					domBuilder.endDTD();
					return lastMatch.index + lastMatch[0].length;
				}
		}
		return -1;
	}
	function parseInstruction(source, start, domBuilder) {
		var end = source.indexOf("?>", start);
		if (end) {
			var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
			if (match) {
				match[0].length;
				domBuilder.processingInstruction(match[1], match[2]);
				return end + 2;
			} else return -1;
		}
		return -1;
	}
	function ElementAttributes() {
		this.attributeNames = {};
	}
	ElementAttributes.prototype = {
		setTagName: function(tagName) {
			if (!tagNamePattern.test(tagName)) throw new Error("invalid tagName:" + tagName);
			this.tagName = tagName;
		},
		addValue: function(qName, value, offset) {
			if (!tagNamePattern.test(qName)) throw new Error("invalid attribute:" + qName);
			this.attributeNames[qName] = this.length;
			this[this.length++] = {
				qName,
				value,
				offset
			};
		},
		length: 0,
		getLocalName: function(i) {
			return this[i].localName;
		},
		getLocator: function(i) {
			return this[i].locator;
		},
		getQName: function(i) {
			return this[i].qName;
		},
		getURI: function(i) {
			return this[i].uri;
		},
		getValue: function(i) {
			return this[i].value;
		}
	};
	function split(source, start) {
		var match;
		var buf = [];
		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
		reg.lastIndex = start;
		reg.exec(source);
		while (match = reg.exec(source)) {
			buf.push(match);
			if (match[1]) return buf;
		}
	}
	exports.XMLReader = XMLReader;
	exports.ParseError = ParseError;
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+xmldom@0.8.11/node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = /* @__PURE__ */ __commonJSMin(((exports) => {
	var conventions = require_conventions();
	var dom = require_dom();
	var entities = require_entities();
	var sax = require_sax();
	var DOMImplementation = dom.DOMImplementation;
	var NAMESPACE = conventions.NAMESPACE;
	var ParseError = sax.ParseError;
	var XMLReader = sax.XMLReader;
	/**
	* Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
	*
	* > XML parsed entities are often stored in computer files which,
	* > for editing convenience, are organized into lines.
	* > These lines are typically separated by some combination
	* > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
	* >
	* > To simplify the tasks of applications, the XML processor must behave
	* > as if it normalized all line breaks in external parsed entities (including the document entity)
	* > on input, before parsing, by translating all of the following to a single #xA character:
	* >
	* > 1. the two-character sequence #xD #xA
	* > 2. the two-character sequence #xD #x85
	* > 3. the single character #x85
	* > 4. the single character #x2028
	* > 5. any #xD character that is not immediately followed by #xA or #x85.
	*
	* @param {string} input
	* @returns {string}
	*/
	function normalizeLineEndings(input) {
		return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
	}
	/**
	* @typedef Locator
	* @property {number} [columnNumber]
	* @property {number} [lineNumber]
	*/
	/**
	* @typedef DOMParserOptions
	* @property {DOMHandler} [domBuilder]
	* @property {Function} [errorHandler]
	* @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
	* 						defaults to `normalizeLineEndings`
	* @property {Locator} [locator]
	* @property {Record<string, string>} [xmlns]
	*
	* @see normalizeLineEndings
	*/
	/**
	* The DOMParser interface provides the ability to parse XML or HTML source code
	* from a string into a DOM `Document`.
	*
	* _xmldom is different from the spec in that it allows an `options` parameter,
	* to override the default behavior._
	*
	* @param {DOMParserOptions} [options]
	* @constructor
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
	* @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
	*/
	function DOMParser(options) {
		this.options = options || { locator: {} };
	}
	DOMParser.prototype.parseFromString = function(source, mimeType) {
		var options = this.options;
		var sax = new XMLReader();
		var domBuilder = options.domBuilder || new DOMHandler();
		var errorHandler = options.errorHandler;
		var locator = options.locator;
		var defaultNSMap = options.xmlns || {};
		var isHTML = /\/x?html?$/.test(mimeType);
		var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
		if (locator) domBuilder.setDocumentLocator(locator);
		sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
		sax.domBuilder = options.domBuilder || domBuilder;
		if (isHTML) defaultNSMap[""] = NAMESPACE.HTML;
		defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
		var normalize = options.normalizeLineEndings || normalizeLineEndings;
		if (source && typeof source === "string") sax.parse(normalize(source), defaultNSMap, entityMap);
		else sax.errorHandler.error("invalid doc source");
		return domBuilder.doc;
	};
	function buildErrorHandler(errorImpl, domBuilder, locator) {
		if (!errorImpl) {
			if (domBuilder instanceof DOMHandler) return domBuilder;
			errorImpl = domBuilder;
		}
		var errorHandler = {};
		var isCallback = errorImpl instanceof Function;
		locator = locator || {};
		function build(key) {
			var fn$1 = errorImpl[key];
			if (!fn$1 && isCallback) fn$1 = errorImpl.length == 2 ? function(msg) {
				errorImpl(key, msg);
			} : errorImpl;
			errorHandler[key] = fn$1 && function(msg) {
				fn$1("[xmldom " + key + "]	" + msg + _locator(locator));
			} || function() {};
		}
		build("warning");
		build("error");
		build("fatalError");
		return errorHandler;
	}
	/**
	* +ContentHandler+ErrorHandler
	* +LexicalHandler+EntityResolver2
	* -DeclHandler-DTDHandler
	*
	* DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
	* DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
	* @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
	*/
	function DOMHandler() {
		this.cdata = false;
	}
	function position(locator, node) {
		node.lineNumber = locator.lineNumber;
		node.columnNumber = locator.columnNumber;
	}
	/**
	* @see org.xml.sax.ContentHandler#startDocument
	* @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	*/
	DOMHandler.prototype = {
		startDocument: function() {
			this.doc = new DOMImplementation().createDocument(null, null, null);
			if (this.locator) this.doc.documentURI = this.locator.systemId;
		},
		startElement: function(namespaceURI, localName, qName, attrs) {
			var doc = this.doc;
			var el = doc.createElementNS(namespaceURI, qName || localName);
			var len = attrs.length;
			appendElement(this, el);
			this.currentElement = el;
			this.locator && position(this.locator, el);
			for (var i = 0; i < len; i++) {
				var namespaceURI = attrs.getURI(i);
				var value = attrs.getValue(i);
				var qName = attrs.getQName(i);
				var attr = doc.createAttributeNS(namespaceURI, qName);
				this.locator && position(attrs.getLocator(i), attr);
				attr.value = attr.nodeValue = value;
				el.setAttributeNode(attr);
			}
		},
		endElement: function(namespaceURI, localName, qName) {
			var current = this.currentElement;
			current.tagName;
			this.currentElement = current.parentNode;
		},
		startPrefixMapping: function(prefix, uri) {},
		endPrefixMapping: function(prefix) {},
		processingInstruction: function(target, data) {
			var ins = this.doc.createProcessingInstruction(target, data);
			this.locator && position(this.locator, ins);
			appendElement(this, ins);
		},
		ignorableWhitespace: function(ch, start, length) {},
		characters: function(chars, start, length) {
			chars = _toString.apply(this, arguments);
			if (chars) {
				if (this.cdata) var charNode = this.doc.createCDATASection(chars);
				else var charNode = this.doc.createTextNode(chars);
				if (this.currentElement) this.currentElement.appendChild(charNode);
				else if (/^\s*$/.test(chars)) this.doc.appendChild(charNode);
				this.locator && position(this.locator, charNode);
			}
		},
		skippedEntity: function(name$1) {},
		endDocument: function() {
			this.doc.normalize();
		},
		setDocumentLocator: function(locator) {
			if (this.locator = locator) locator.lineNumber = 0;
		},
		comment: function(chars, start, length) {
			chars = _toString.apply(this, arguments);
			var comm = this.doc.createComment(chars);
			this.locator && position(this.locator, comm);
			appendElement(this, comm);
		},
		startCDATA: function() {
			this.cdata = true;
		},
		endCDATA: function() {
			this.cdata = false;
		},
		startDTD: function(name$1, publicId, systemId) {
			var impl = this.doc.implementation;
			if (impl && impl.createDocumentType) {
				var dt = impl.createDocumentType(name$1, publicId, systemId);
				this.locator && position(this.locator, dt);
				appendElement(this, dt);
				this.doc.doctype = dt;
			}
		},
		warning: function(error$47) {
			console.warn("[xmldom warning]	" + error$47, _locator(this.locator));
		},
		error: function(error$47) {
			console.error("[xmldom error]	" + error$47, _locator(this.locator));
		},
		fatalError: function(error$47) {
			throw new ParseError(error$47, this.locator);
		}
	};
	function _locator(l) {
		if (l) return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
	}
	function _toString(chars, start, length) {
		if (typeof chars == "string") return chars.substr(start, length);
		else {
			if (chars.length >= start + length || start) return new java.lang.String(chars, start, length) + "";
			return chars;
		}
	}
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
		DOMHandler.prototype[key] = function() {
			return null;
		};
	});
	function appendElement(hander, node) {
		if (!hander.currentElement) hander.doc.appendChild(node);
		else hander.currentElement.appendChild(node);
	}
	exports.__DOMHandler = DOMHandler;
	exports.normalizeLineEndings = normalizeLineEndings;
	exports.DOMParser = DOMParser;
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+xmldom@0.8.11/node_modules/@xmldom/xmldom/lib/index.js
var require_lib$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var dom = require_dom();
	exports.DOMImplementation = dom.DOMImplementation;
	exports.XMLSerializer = dom.XMLSerializer;
	exports.DOMParser = require_dom_parser().DOMParser;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/api.js
var require_api = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.setDOMParserOptions = exports.setSchemaValidator = exports.getContext = void 0;
	var xmldom_1 = require_lib$3();
	var context = {
		validate: void 0,
		dom: new xmldom_1.DOMParser()
	};
	function getContext() {
		return context;
	}
	exports.getContext = getContext;
	function setSchemaValidator(params) {
		if (typeof params.validate !== "function") throw new Error("validate must be a callback function having one argument as xml input");
		context.validate = params.validate;
	}
	exports.setSchemaValidator = setSchemaValidator;
	function setDOMParserOptions(options) {
		if (options === void 0) options = {};
		context.dom = new xmldom_1.DOMParser(options);
	}
	exports.setDOMParserOptions = setDOMParserOptions;
}));

//#endregion
//#region ../../node_modules/.bun/camelcase@6.3.0/node_modules/camelcase/index.js
var require_camelcase = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const UPPERCASE = /[\p{Lu}]/u;
	const LOWERCASE = /[\p{Ll}]/u;
	const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
	const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
	const SEPARATORS = /[_.\- ]+/;
	const LEADING_SEPARATORS = /* @__PURE__ */ new RegExp("^" + SEPARATORS.source);
	const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
	const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
	const preserveCamelCase = (string$3, toLowerCase, toUpperCase) => {
		let isLastCharLower = false;
		let isLastCharUpper = false;
		let isLastLastCharUpper = false;
		for (let i = 0; i < string$3.length; i++) {
			const character = string$3[i];
			if (isLastCharLower && UPPERCASE.test(character)) {
				string$3 = string$3.slice(0, i) + "-" + string$3.slice(i);
				isLastCharLower = false;
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = true;
				i++;
			} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
				string$3 = string$3.slice(0, i - 1) + "-" + string$3.slice(i - 1);
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = false;
				isLastCharLower = true;
			} else {
				isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
			}
		}
		return string$3;
	};
	const preserveConsecutiveUppercase = (input, toLowerCase) => {
		LEADING_CAPITAL.lastIndex = 0;
		return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
	};
	const postProcess = (input, toUpperCase) => {
		SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
		NUMBERS_AND_IDENTIFIER.lastIndex = 0;
		return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
	};
	const camelCase = (input, options) => {
		if (!(typeof input === "string" || Array.isArray(input))) throw new TypeError("Expected the input to be `string | string[]`");
		options = {
			pascalCase: false,
			preserveConsecutiveUppercase: false,
			...options
		};
		if (Array.isArray(input)) input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
		else input = input.trim();
		if (input.length === 0) return "";
		const toLowerCase = options.locale === false ? (string$3) => string$3.toLowerCase() : (string$3) => string$3.toLocaleLowerCase(options.locale);
		const toUpperCase = options.locale === false ? (string$3) => string$3.toUpperCase() : (string$3) => string$3.toLocaleUpperCase(options.locale);
		if (input.length === 1) return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
		if (input !== toLowerCase(input)) input = preserveCamelCase(input, toLowerCase, toUpperCase);
		input = input.replace(LEADING_SEPARATORS, "");
		if (options.preserveConsecutiveUppercase) input = preserveConsecutiveUppercase(input, toLowerCase);
		else input = toLowerCase(input);
		if (options.pascalCase) input = toUpperCase(input.charAt(0)) + input.slice(1);
		return postProcess(input, toUpperCase);
	};
	module.exports = camelCase;
	module.exports.default = camelCase;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/extractor.js
var require_extractor = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extract = exports.logoutResponseFields = exports.logoutRequestFields = exports.loginResponseFields = exports.logoutResponseStatusFields = exports.loginResponseStatusFields = exports.loginRequestFields = void 0;
	var xpath_1 = require_xpath$1();
	var utility_1 = require_utility();
	var api_1 = require_api();
	var camelcase_1 = __importDefault(require_camelcase());
	function buildAbsoluteXPath(paths$1) {
		return paths$1.reduce(function(currentPath, name$1) {
			var appendedPath = currentPath;
			var isWildcard = name$1.startsWith("~");
			if (isWildcard) {
				var pathName = name$1.replace("~", "");
				appendedPath = currentPath + "/*[contains(local-name(), '".concat(pathName, "')]");
			}
			if (!isWildcard) appendedPath = currentPath + "/*[local-name(.)='".concat(name$1, "']");
			return appendedPath;
		}, "");
	}
	function buildAttributeXPath(attributes) {
		if (attributes.length === 0) return "/text()";
		if (attributes.length === 1) return "/@".concat(attributes[0]);
		var filters = attributes.map(function(attribute) {
			return "name()='".concat(attribute, "'");
		}).join(" or ");
		return "/@*[".concat(filters, "]");
	}
	exports.loginRequestFields = [
		{
			key: "request",
			localPath: ["AuthnRequest"],
			attributes: [
				"ID",
				"IssueInstant",
				"Destination",
				"AssertionConsumerServiceURL"
			]
		},
		{
			key: "issuer",
			localPath: ["AuthnRequest", "Issuer"],
			attributes: []
		},
		{
			key: "nameIDPolicy",
			localPath: ["AuthnRequest", "NameIDPolicy"],
			attributes: ["Format", "AllowCreate"]
		},
		{
			key: "authnContextClassRef",
			localPath: ["AuthnRequest", "AuthnContextClassRef"],
			attributes: []
		},
		{
			key: "signature",
			localPath: ["AuthnRequest", "Signature"],
			attributes: [],
			context: true
		}
	];
	exports.loginResponseStatusFields = [{
		key: "top",
		localPath: [
			"Response",
			"Status",
			"StatusCode"
		],
		attributes: ["Value"]
	}, {
		key: "second",
		localPath: [
			"Response",
			"Status",
			"StatusCode",
			"StatusCode"
		],
		attributes: ["Value"]
	}];
	exports.logoutResponseStatusFields = [{
		key: "top",
		localPath: [
			"LogoutResponse",
			"Status",
			"StatusCode"
		],
		attributes: ["Value"]
	}, {
		key: "second",
		localPath: [
			"LogoutResponse",
			"Status",
			"StatusCode",
			"StatusCode"
		],
		attributes: ["Value"]
	}];
	var loginResponseFields = function(assertion) {
		return [
			{
				key: "conditions",
				localPath: ["Assertion", "Conditions"],
				attributes: ["NotBefore", "NotOnOrAfter"],
				shortcut: assertion
			},
			{
				key: "response",
				localPath: ["Response"],
				attributes: [
					"ID",
					"IssueInstant",
					"Destination",
					"InResponseTo"
				]
			},
			{
				key: "audience",
				localPath: [
					"Assertion",
					"Conditions",
					"AudienceRestriction",
					"Audience"
				],
				attributes: [],
				shortcut: assertion
			},
			{
				key: "issuer",
				localPath: ["Assertion", "Issuer"],
				attributes: [],
				shortcut: assertion
			},
			{
				key: "nameID",
				localPath: [
					"Assertion",
					"Subject",
					"NameID"
				],
				attributes: [],
				shortcut: assertion
			},
			{
				key: "sessionIndex",
				localPath: ["Assertion", "AuthnStatement"],
				attributes: [
					"AuthnInstant",
					"SessionNotOnOrAfter",
					"SessionIndex"
				],
				shortcut: assertion
			},
			{
				key: "attributes",
				localPath: [
					"Assertion",
					"AttributeStatement",
					"Attribute"
				],
				index: ["Name"],
				attributePath: ["AttributeValue"],
				attributes: [],
				shortcut: assertion
			}
		];
	};
	exports.loginResponseFields = loginResponseFields;
	exports.logoutRequestFields = [
		{
			key: "request",
			localPath: ["LogoutRequest"],
			attributes: [
				"ID",
				"IssueInstant",
				"Destination"
			]
		},
		{
			key: "issuer",
			localPath: ["LogoutRequest", "Issuer"],
			attributes: []
		},
		{
			key: "nameID",
			localPath: ["LogoutRequest", "NameID"],
			attributes: []
		},
		{
			key: "sessionIndex",
			localPath: ["LogoutRequest", "SessionIndex"],
			attributes: []
		},
		{
			key: "signature",
			localPath: ["LogoutRequest", "Signature"],
			attributes: [],
			context: true
		}
	];
	exports.logoutResponseFields = [
		{
			key: "response",
			localPath: ["LogoutResponse"],
			attributes: [
				"ID",
				"Destination",
				"InResponseTo"
			]
		},
		{
			key: "issuer",
			localPath: ["LogoutResponse", "Issuer"],
			attributes: []
		},
		{
			key: "signature",
			localPath: ["LogoutResponse", "Signature"],
			attributes: [],
			context: true
		}
	];
	function extract(context, fields) {
		var dom = (0, api_1.getContext)().dom;
		var rootDoc = dom.parseFromString(context);
		return fields.reduce(function(result, field) {
			var _a$1, _b, _c, _d, _e, _f;
			var key = field.key;
			var localPath = field.localPath;
			var attributes = field.attributes;
			var isEntire = field.context;
			var shortcut = field.shortcut;
			var index = field.index;
			var attributePath = field.attributePath;
			var targetDoc = rootDoc;
			if (shortcut) targetDoc = dom.parseFromString(shortcut);
			if (localPath.every(function(path) {
				return Array.isArray(path);
			})) {
				var multiXPaths = localPath.map(function(path) {
					return "".concat(buildAbsoluteXPath(path), "/text()");
				}).join(" | ");
				return __assign(__assign({}, result), (_a$1 = {}, _a$1[key] = (0, utility_1.uniq)((0, xpath_1.select)(multiXPaths, targetDoc).map(function(n) {
					return n.nodeValue;
				}).filter(utility_1.notEmpty)), _a$1));
			}
			var baseXPath = buildAbsoluteXPath(localPath);
			var attributeXPath = buildAttributeXPath(attributes);
			if (index && attributePath) {
				var indexPath = buildAttributeXPath(index);
				var fullLocalXPath = "".concat(baseXPath).concat(indexPath);
				var parentNodes = (0, xpath_1.select)(baseXPath, targetDoc);
				var parentAttributes = (0, xpath_1.select)(fullLocalXPath, targetDoc).map(function(n) {
					return n.value;
				});
				var childXPath = buildAbsoluteXPath([(0, utility_1.last)(localPath)].concat(attributePath));
				var childAttributeXPath = buildAttributeXPath(attributes);
				var fullChildXPath_1 = "".concat(childXPath).concat(childAttributeXPath);
				var childAttributes = parentNodes.map(function(node$1) {
					var nodeDoc = dom.parseFromString(node$1.toString());
					if (attributes.length === 0) {
						var childValues = (0, xpath_1.select)(fullChildXPath_1, nodeDoc).map(function(n) {
							return n.nodeValue;
						});
						if (childValues.length === 1) return childValues[0];
						return childValues;
					}
					if (attributes.length > 0) {
						var childValues = (0, xpath_1.select)(fullChildXPath_1, nodeDoc).map(function(n) {
							return n.value;
						});
						if (childValues.length === 1) return childValues[0];
						return childValues;
					}
					return null;
				});
				var obj = (0, utility_1.zipObject)(parentAttributes, childAttributes, false);
				return __assign(__assign({}, result), (_b = {}, _b[key] = obj, _b));
			}
			if (isEntire) {
				var node = (0, xpath_1.select)(baseXPath, targetDoc);
				var value = null;
				if (node.length === 1) value = node[0].toString();
				if (node.length > 1) value = node.map(function(n) {
					return n.toString();
				});
				return __assign(__assign({}, result), (_c = {}, _c[key] = value, _c));
			}
			if (attributes.length > 1) {
				var baseNode = (0, xpath_1.select)(baseXPath, targetDoc).map(function(n) {
					return n.toString();
				});
				var childXPath_1 = "".concat(buildAbsoluteXPath([(0, utility_1.last)(localPath)])).concat(attributeXPath);
				var attributeValues = baseNode.map(function(node$1) {
					var nodeDoc = dom.parseFromString(node$1);
					return (0, xpath_1.select)(childXPath_1, nodeDoc).reduce(function(r, n) {
						r[(0, camelcase_1.default)(n.name, { locale: "en-us" })] = n.value;
						return r;
					}, {});
				});
				return __assign(__assign({}, result), (_d = {}, _d[key] = attributeValues.length === 1 ? attributeValues[0] : attributeValues, _d));
			}
			if (attributes.length === 1) {
				var fullPath = "".concat(baseXPath).concat(attributeXPath);
				var attributeValues = (0, xpath_1.select)(fullPath, targetDoc).map(function(n) {
					return n.value;
				});
				return __assign(__assign({}, result), (_e = {}, _e[key] = attributeValues[0], _e));
			}
			if (attributes.length === 0) {
				var attributeValue = null;
				var node = (0, xpath_1.select)(baseXPath, targetDoc);
				if (node.length === 1) {
					var fullPath = "string(".concat(baseXPath).concat(attributeXPath, ")");
					attributeValue = (0, xpath_1.select)(fullPath, targetDoc);
				}
				if (node.length > 1) attributeValue = node.filter(function(n) {
					return n.firstChild;
				}).map(function(n) {
					return n.firstChild.nodeValue;
				});
				return __assign(__assign({}, result), (_f = {}, _f[key] = attributeValue, _f));
			}
			return result;
		}, {});
	}
	exports.extract = extract;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/metadata.js
var require_metadata = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* @file metadata.ts
	* @author tngan
	* @desc An abstraction for metadata of identity provider and service provider
	*/
	var fs$1 = __importStar(__require("fs"));
	var urn_1 = require_urn();
	var extractor_1 = require_extractor();
	var utility_1 = require_utility();
	var Metadata = function() {
		/**
		* @param  {string | Buffer} xml
		* @param  {object} extraParse for custom metadata extractor
		*/
		function Metadata(xml, extraParse) {
			if (extraParse === void 0) extraParse = [];
			this.xmlString = xml.toString();
			this.meta = (0, extractor_1.extract)(this.xmlString, extraParse.concat([
				{
					key: "entityDescriptor",
					localPath: ["EntityDescriptor"],
					attributes: [],
					context: true
				},
				{
					key: "entityID",
					localPath: ["EntityDescriptor"],
					attributes: ["entityID"]
				},
				{
					key: "sharedCertificate",
					localPath: [
						"EntityDescriptor",
						"~SSODescriptor",
						"KeyDescriptor",
						"KeyInfo",
						"X509Data",
						"X509Certificate"
					],
					attributes: []
				},
				{
					key: "certificate",
					localPath: [
						"EntityDescriptor",
						"~SSODescriptor",
						"KeyDescriptor"
					],
					index: ["use"],
					attributePath: [
						"KeyInfo",
						"X509Data",
						"X509Certificate"
					],
					attributes: []
				},
				{
					key: "singleLogoutService",
					localPath: [
						"EntityDescriptor",
						"~SSODescriptor",
						"SingleLogoutService"
					],
					attributes: ["Binding", "Location"]
				},
				{
					key: "nameIDFormat",
					localPath: [
						"EntityDescriptor",
						"~SSODescriptor",
						"NameIDFormat"
					],
					attributes: []
				}
			]));
			var sharedCertificate = this.meta.sharedCertificate;
			if (typeof sharedCertificate === "string") {
				this.meta.certificate = {
					signing: sharedCertificate,
					encryption: sharedCertificate
				};
				delete this.meta.sharedCertificate;
			}
			if (Array.isArray(this.meta.entityDescriptor) && this.meta.entityDescriptor.length > 1) throw new Error("ERR_MULTIPLE_METADATA_ENTITYDESCRIPTOR");
		}
		/**
		* @desc Get the metadata in xml format
		* @return {string} metadata in xml format
		*/
		Metadata.prototype.getMetadata = function() {
			return this.xmlString;
		};
		/**
		* @desc Export the metadata to specific file
		* @param {string} exportFile is the output file path
		*/
		Metadata.prototype.exportMetadata = function(exportFile) {
			fs$1.writeFileSync(exportFile, this.xmlString);
		};
		/**
		* @desc Get the entityID in metadata
		* @return {string} entityID
		*/
		Metadata.prototype.getEntityID = function() {
			return this.meta.entityID;
		};
		/**
		* @desc Get the x509 certificate declared in entity metadata
		* @param  {string} use declares the type of certificate
		* @return {string} certificate in string format
		*/
		Metadata.prototype.getX509Certificate = function(use) {
			return this.meta.certificate[use] || null;
		};
		/**
		* @desc Get the support NameID format declared in entity metadata
		* @return {array} support NameID format
		*/
		Metadata.prototype.getNameIDFormat = function() {
			return this.meta.nameIDFormat;
		};
		/**
		* @desc Get the entity endpoint for single logout service
		* @param  {string} binding e.g. redirect, post
		* @return {string/object} location
		*/
		Metadata.prototype.getSingleLogoutService = function(binding) {
			if (binding && (0, utility_1.isString)(binding)) {
				var bindType_1 = urn_1.namespace.binding[binding];
				var singleLogoutService = this.meta.singleLogoutService;
				if (!(singleLogoutService instanceof Array)) singleLogoutService = [singleLogoutService];
				var service = singleLogoutService.find(function(obj) {
					return obj.binding === bindType_1;
				});
				if (service) return service.location;
			}
			return this.meta.singleLogoutService;
		};
		/**
		* @desc Get the support bindings
		* @param  {[string]} services
		* @return {[string]} support bindings
		*/
		Metadata.prototype.getSupportBindings = function(services) {
			var supportBindings = [];
			if (services) supportBindings = services.reduce(function(acc, service) {
				var supportBinding = Object.keys(service)[0];
				return acc.push(supportBinding);
			}, []);
			return supportBindings;
		};
		return Metadata;
	}();
	exports.default = Metadata;
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/utils.js
var require_utils$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	__require("crypto");
	/**
	* Break string str each maxLen symbols
	* @param str
	* @param maxLen
	* @returns {string}
	*/
	module.exports.linebrk = function(str, maxLen) {
		var res = "";
		var i = 0;
		while (i + maxLen < str.length) {
			res += str.substring(i, i + maxLen) + "\n";
			i += maxLen;
		}
		return res + str.substring(i, str.length);
	};
	module.exports.detectEnvironment = function() {
		if (typeof window !== "undefined" && window && !(process && process.title === "node")) return "browser";
		return "node";
	};
	/**
	* Trying get a 32-bit unsigned integer from the partial buffer
	* @param buffer
	* @param offset
	* @returns {Number}
	*/
	module.exports.get32IntFromBuffer = function(buffer$1, offset) {
		offset = offset || 0;
		var size = 0;
		if ((size = buffer$1.length - offset) > 0) if (size >= 4) return buffer$1.readUIntBE(offset, size);
		else {
			var res = 0;
			for (var i = offset + size, d = 0; i > offset; i--, d += 2) res += buffer$1[i - 1] * Math.pow(16, d);
			return res;
		}
		else return NaN;
	};
	module.exports._ = {
		isObject: function(value) {
			var type = typeof value;
			return !!value && (type == "object" || type == "function");
		},
		isString: function(value) {
			return typeof value == "string" || value instanceof String;
		},
		isNumber: function(value) {
			return typeof value == "number" || !isNaN(parseFloat(value)) && isFinite(value);
		},
		omit: function(obj, removeProp) {
			var newObj = {};
			for (var prop in obj) {
				if (!obj.hasOwnProperty(prop) || prop === removeProp) continue;
				newObj[prop] = obj[prop];
			}
			return newObj;
		}
	};
	/**
	* Strips everything around the opening and closing lines, including the lines
	* themselves.
	*/
	module.exports.trimSurroundingText = function(data, opening, closing) {
		var trimStartIndex = 0;
		var trimEndIndex = data.length;
		var openingBoundaryIndex = data.indexOf(opening);
		if (openingBoundaryIndex >= 0) trimStartIndex = openingBoundaryIndex + opening.length;
		var closingBoundaryIndex = data.indexOf(closing, openingBoundaryIndex);
		if (closingBoundaryIndex >= 0) trimEndIndex = closingBoundaryIndex;
		return data.substring(trimStartIndex, trimEndIndex);
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/libs/jsbn.js
var require_jsbn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var crypt$4 = __require("crypto");
	var _ = require_utils$2()._;
	var dbits;
	function BigInteger(a, b) {
		if (a != null) if ("number" == typeof a) this.fromNumber(a, b);
		else if (Buffer.isBuffer(a)) this.fromBuffer(a);
		else if (b == null && "string" != typeof a) this.fromByteArray(a);
		else this.fromString(a, b);
	}
	function nbi() {
		return new BigInteger(null);
	}
	function am3(i, x, w, j, c, n) {
		var xl = x & 16383, xh = x >> 14;
		while (--n >= 0) {
			var l = this[i] & 16383;
			var h = this[i++] >> 14;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 16383) << 14) + w[j] + c;
			c = (l >> 28) + (m >> 14) + xh * h;
			w[j++] = l & 268435455;
		}
		return c;
	}
	BigInteger.prototype.am = am3;
	dbits = 28;
	BigInteger.prototype.DB = dbits;
	BigInteger.prototype.DM = (1 << dbits) - 1;
	BigInteger.prototype.DV = 1 << dbits;
	var BI_FP = 52;
	BigInteger.prototype.FV = Math.pow(2, BI_FP);
	BigInteger.prototype.F1 = BI_FP - dbits;
	BigInteger.prototype.F2 = 2 * dbits - BI_FP;
	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	var BI_RC = new Array();
	var rr = "0".charCodeAt(0), vv;
	for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	rr = "a".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	rr = "A".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	function int2char(n) {
		return BI_RM.charAt(n);
	}
	function intAt(s, i) {
		var c = BI_RC[s.charCodeAt(i)];
		return c == null ? -1 : c;
	}
	function bnpCopyTo(r) {
		for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
		r.t = this.t;
		r.s = this.s;
	}
	function bnpFromInt(x) {
		this.t = 1;
		this.s = x < 0 ? -1 : 0;
		if (x > 0) this[0] = x;
		else if (x < -1) this[0] = x + DV;
		else this.t = 0;
	}
	function nbv(i) {
		var r = nbi();
		r.fromInt(i);
		return r;
	}
	function bnpFromString(data, radix, unsigned) {
		var k;
		switch (radix) {
			case 2:
				k = 1;
				break;
			case 4:
				k = 2;
				break;
			case 8:
				k = 3;
				break;
			case 16:
				k = 4;
				break;
			case 32:
				k = 5;
				break;
			case 256:
				k = 8;
				break;
			default:
				this.fromRadix(data, radix);
				return;
		}
		this.t = 0;
		this.s = 0;
		var i = data.length;
		var mi = false;
		var sh = 0;
		while (--i >= 0) {
			var x = k == 8 ? data[i] & 255 : intAt(data, i);
			if (x < 0) {
				if (data.charAt(i) == "-") mi = true;
				continue;
			}
			mi = false;
			if (sh === 0) this[this.t++] = x;
			else if (sh + k > this.DB) {
				this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
				this[this.t++] = x >> this.DB - sh;
			} else this[this.t - 1] |= x << sh;
			sh += k;
			if (sh >= this.DB) sh -= this.DB;
		}
		if (!unsigned && k == 8 && (data[0] & 128) != 0) {
			this.s = -1;
			if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
		}
		this.clamp();
		if (mi) BigInteger.ZERO.subTo(this, this);
	}
	function bnpFromByteArray(a, unsigned) {
		this.fromString(a, 256, unsigned);
	}
	function bnpFromBuffer(a) {
		this.fromString(a, 256, true);
	}
	function bnpClamp() {
		var c = this.s & this.DM;
		while (this.t > 0 && this[this.t - 1] == c) --this.t;
	}
	function bnToString(b) {
		if (this.s < 0) return "-" + this.negate().toString(b);
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else return this.toRadix(b);
		var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
		var p = this.DB - i * this.DB % k;
		if (i-- > 0) {
			if (p < this.DB && (d = this[i] >> p) > 0) {
				m = true;
				r = int2char(d);
			}
			while (i >= 0) {
				if (p < k) {
					d = (this[i] & (1 << p) - 1) << k - p;
					d |= this[--i] >> (p += this.DB - k);
				} else {
					d = this[i] >> (p -= k) & km;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if (d > 0) m = true;
				if (m) r += int2char(d);
			}
		}
		return m ? r : "0";
	}
	function bnNegate() {
		var r = nbi();
		BigInteger.ZERO.subTo(this, r);
		return r;
	}
	function bnAbs() {
		return this.s < 0 ? this.negate() : this;
	}
	function bnCompareTo(a) {
		var r = this.s - a.s;
		if (r != 0) return r;
		var i = this.t;
		r = i - a.t;
		if (r != 0) return this.s < 0 ? -r : r;
		while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
		return 0;
	}
	function nbits(x) {
		var r = 1, t;
		if ((t = x >>> 16) != 0) {
			x = t;
			r += 16;
		}
		if ((t = x >> 8) != 0) {
			x = t;
			r += 8;
		}
		if ((t = x >> 4) != 0) {
			x = t;
			r += 4;
		}
		if ((t = x >> 2) != 0) {
			x = t;
			r += 2;
		}
		if ((t = x >> 1) != 0) {
			x = t;
			r += 1;
		}
		return r;
	}
	function bnBitLength() {
		if (this.t <= 0) return 0;
		return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
	}
	function bnpDLShiftTo(n, r) {
		var i;
		for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
		for (i = n - 1; i >= 0; --i) r[i] = 0;
		r.t = this.t + n;
		r.s = this.s;
	}
	function bnpDRShiftTo(n, r) {
		for (var i = n; i < this.t; ++i) r[i - n] = this[i];
		r.t = Math.max(this.t - n, 0);
		r.s = this.s;
	}
	function bnpLShiftTo(n, r) {
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << cbs) - 1;
		var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
		for (i = this.t - 1; i >= 0; --i) {
			r[i + ds + 1] = this[i] >> cbs | c;
			c = (this[i] & bm) << bs;
		}
		for (i = ds - 1; i >= 0; --i) r[i] = 0;
		r[ds] = c;
		r.t = this.t + ds + 1;
		r.s = this.s;
		r.clamp();
	}
	function bnpRShiftTo(n, r) {
		r.s = this.s;
		var ds = Math.floor(n / this.DB);
		if (ds >= this.t) {
			r.t = 0;
			return;
		}
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << bs) - 1;
		r[0] = this[ds] >> bs;
		for (var i = ds + 1; i < this.t; ++i) {
			r[i - ds - 1] |= (this[i] & bm) << cbs;
			r[i - ds] = this[i] >> bs;
		}
		if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
		r.t = this.t - ds;
		r.clamp();
	}
	function bnpSubTo(a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this[i] - a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c -= a.s;
			while (i < this.t) {
				c += this[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c -= a[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c -= a.s;
		}
		r.s = c < 0 ? -1 : 0;
		if (c < -1) r[i++] = this.DV + c;
		else if (c > 0) r[i++] = c;
		r.t = i;
		r.clamp();
	}
	function bnpMultiplyTo(a, r) {
		var x = this.abs(), y = a.abs();
		var i = x.t;
		r.t = i + y.t;
		while (--i >= 0) r[i] = 0;
		for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
		r.s = 0;
		r.clamp();
		if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
	}
	function bnpSquareTo(r) {
		var x = this.abs();
		var i = r.t = 2 * x.t;
		while (--i >= 0) r[i] = 0;
		for (i = 0; i < x.t - 1; ++i) {
			var c = x.am(i, x[i], r, 2 * i, 0, 1);
			if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
				r[i + x.t] -= x.DV;
				r[i + x.t + 1] = 1;
			}
		}
		if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
		r.s = 0;
		r.clamp();
	}
	function bnpDivRemTo(m, q, r) {
		var pm = m.abs();
		if (pm.t <= 0) return;
		var pt = this.abs();
		if (pt.t < pm.t) {
			if (q != null) q.fromInt(0);
			if (r != null) this.copyTo(r);
			return;
		}
		if (r == null) r = nbi();
		var y = nbi(), ts = this.s, ms = m.s;
		var nsh = this.DB - nbits(pm[pm.t - 1]);
		if (nsh > 0) {
			pm.lShiftTo(nsh, y);
			pt.lShiftTo(nsh, r);
		} else {
			pm.copyTo(y);
			pt.copyTo(r);
		}
		var ys = y.t;
		var y0 = y[ys - 1];
		if (y0 === 0) return;
		var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
		var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
		var i = r.t, j = i - ys, t = q == null ? nbi() : q;
		y.dlShiftTo(j, t);
		if (r.compareTo(t) >= 0) {
			r[r.t++] = 1;
			r.subTo(t, r);
		}
		BigInteger.ONE.dlShiftTo(ys, t);
		t.subTo(y, y);
		while (y.t < ys) y[y.t++] = 0;
		while (--j >= 0) {
			var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
			if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
				y.dlShiftTo(j, t);
				r.subTo(t, r);
				while (r[i] < --qd) r.subTo(t, r);
			}
		}
		if (q != null) {
			r.drShiftTo(ys, q);
			if (ts != ms) BigInteger.ZERO.subTo(q, q);
		}
		r.t = ys;
		r.clamp();
		if (nsh > 0) r.rShiftTo(nsh, r);
		if (ts < 0) BigInteger.ZERO.subTo(r, r);
	}
	function bnMod(a) {
		var r = nbi();
		this.abs().divRemTo(a, null, r);
		if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
		return r;
	}
	function Classic(m) {
		this.m = m;
	}
	function cConvert(x) {
		if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
		else return x;
	}
	function cRevert(x) {
		return x;
	}
	function cReduce(x) {
		x.divRemTo(this.m, null, x);
	}
	function cMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	function cSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	Classic.prototype.convert = cConvert;
	Classic.prototype.revert = cRevert;
	Classic.prototype.reduce = cReduce;
	Classic.prototype.mulTo = cMulTo;
	Classic.prototype.sqrTo = cSqrTo;
	function bnpInvDigit() {
		if (this.t < 1) return 0;
		var x = this[0];
		if ((x & 1) === 0) return 0;
		var y = x & 3;
		y = y * (2 - (x & 15) * y) & 15;
		y = y * (2 - (x & 255) * y) & 255;
		y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
		y = y * (2 - x * y % this.DV) % this.DV;
		return y > 0 ? this.DV - y : -y;
	}
	function Montgomery(m) {
		this.m = m;
		this.mp = m.invDigit();
		this.mpl = this.mp & 32767;
		this.mph = this.mp >> 15;
		this.um = (1 << m.DB - 15) - 1;
		this.mt2 = 2 * m.t;
	}
	function montConvert(x) {
		var r = nbi();
		x.abs().dlShiftTo(this.m.t, r);
		r.divRemTo(this.m, null, r);
		if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
		return r;
	}
	function montRevert(x) {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	}
	function montReduce(x) {
		while (x.t <= this.mt2) x[x.t++] = 0;
		for (var i = 0; i < this.m.t; ++i) {
			var j = x[i] & 32767;
			var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
			j = i + this.m.t;
			x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
			while (x[j] >= x.DV) {
				x[j] -= x.DV;
				x[++j]++;
			}
		}
		x.clamp();
		x.drShiftTo(this.m.t, x);
		if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	}
	function montSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	function montMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	Montgomery.prototype.convert = montConvert;
	Montgomery.prototype.revert = montRevert;
	Montgomery.prototype.reduce = montReduce;
	Montgomery.prototype.mulTo = montMulTo;
	Montgomery.prototype.sqrTo = montSqrTo;
	function bnpIsEven() {
		return (this.t > 0 ? this[0] & 1 : this.s) === 0;
	}
	function bnpExp(e, z$1) {
		if (e > 4294967295 || e < 1) return BigInteger.ONE;
		var r = nbi(), r2 = nbi(), g = z$1.convert(this), i = nbits(e) - 1;
		g.copyTo(r);
		while (--i >= 0) {
			z$1.sqrTo(r, r2);
			if ((e & 1 << i) > 0) z$1.mulTo(r2, g, r);
			else {
				var t = r;
				r = r2;
				r2 = t;
			}
		}
		return z$1.revert(r);
	}
	function bnModPowInt(e, m) {
		var z$1;
		if (e < 256 || m.isEven()) z$1 = new Classic(m);
		else z$1 = new Montgomery(m);
		return this.exp(e, z$1);
	}
	function bnClone() {
		var r = nbi();
		this.copyTo(r);
		return r;
	}
	function bnIntValue() {
		if (this.s < 0) {
			if (this.t == 1) return this[0] - this.DV;
			else if (this.t === 0) return -1;
		} else if (this.t == 1) return this[0];
		else if (this.t === 0) return 0;
		return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
	}
	function bnByteValue() {
		return this.t == 0 ? this.s : this[0] << 24 >> 24;
	}
	function bnShortValue() {
		return this.t == 0 ? this.s : this[0] << 16 >> 16;
	}
	function bnpChunkSize(r) {
		return Math.floor(Math.LN2 * this.DB / Math.log(r));
	}
	function bnSigNum() {
		if (this.s < 0) return -1;
		else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
		else return 1;
	}
	function bnpToRadix(b) {
		if (b == null) b = 10;
		if (this.signum() === 0 || b < 2 || b > 36) return "0";
		var cs = this.chunkSize(b);
		var a = Math.pow(b, cs);
		var d = nbv(a), y = nbi(), z$1 = nbi(), r = "";
		this.divRemTo(d, y, z$1);
		while (y.signum() > 0) {
			r = (a + z$1.intValue()).toString(b).substr(1) + r;
			y.divRemTo(d, y, z$1);
		}
		return z$1.intValue().toString(b) + r;
	}
	function bnpFromRadix(s, b) {
		this.fromInt(0);
		if (b == null) b = 10;
		var cs = this.chunkSize(b);
		var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
		for (var i = 0; i < s.length; ++i) {
			var x = intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-" && this.signum() === 0) mi = true;
				continue;
			}
			w = b * w + x;
			if (++j >= cs) {
				this.dMultiply(d);
				this.dAddOffset(w, 0);
				j = 0;
				w = 0;
			}
		}
		if (j > 0) {
			this.dMultiply(Math.pow(b, j));
			this.dAddOffset(w, 0);
		}
		if (mi) BigInteger.ZERO.subTo(this, this);
	}
	function bnpFromNumber(a, b) {
		if ("number" == typeof b) if (a < 2) this.fromInt(1);
		else {
			this.fromNumber(a);
			if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
			if (this.isEven()) this.dAddOffset(1, 0);
			while (!this.isProbablePrime(b)) {
				this.dAddOffset(2, 0);
				if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
			}
		}
		else {
			var x = crypt$4.randomBytes((a >> 3) + 1);
			var t = a & 7;
			if (t > 0) x[0] &= (1 << t) - 1;
			else x[0] = 0;
			this.fromByteArray(x);
		}
	}
	function bnToByteArray() {
		var i = this.t, r = new Array();
		r[0] = this.s;
		var p = this.DB - i * this.DB % 8, d, k = 0;
		if (i-- > 0) {
			if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;
			while (i >= 0) {
				if (p < 8) {
					d = (this[i] & (1 << p) - 1) << 8 - p;
					d |= this[--i] >> (p += this.DB - 8);
				} else {
					d = this[i] >> (p -= 8) & 255;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if ((d & 128) != 0) d |= -256;
				if (k === 0 && (this.s & 128) != (d & 128)) ++k;
				if (k > 0 || d != this.s) r[k++] = d;
			}
		}
		return r;
	}
	/**
	* return Buffer object
	* @param trim {boolean} slice buffer if first element == 0
	* @returns {Buffer}
	*/
	function bnToBuffer(trimOrSize) {
		var res = Buffer.from(this.toByteArray());
		if (trimOrSize === true && res[0] === 0) res = res.slice(1);
		else if (_.isNumber(trimOrSize)) {
			if (res.length > trimOrSize) {
				for (var i = 0; i < res.length - trimOrSize; i++) if (res[i] !== 0) return null;
				return res.slice(res.length - trimOrSize);
			} else if (res.length < trimOrSize) {
				var padded = Buffer.alloc(trimOrSize);
				padded.fill(0, 0, trimOrSize - res.length);
				res.copy(padded, trimOrSize - res.length);
				return padded;
			}
		}
		return res;
	}
	function bnEquals(a) {
		return this.compareTo(a) == 0;
	}
	function bnMin(a) {
		return this.compareTo(a) < 0 ? this : a;
	}
	function bnMax(a) {
		return this.compareTo(a) > 0 ? this : a;
	}
	function bnpBitwiseTo(a, op, r) {
		var i, f, m = Math.min(a.t, this.t);
		for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
		if (a.t < this.t) {
			f = a.s & this.DM;
			for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
			r.t = this.t;
		} else {
			f = this.s & this.DM;
			for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
			r.t = a.t;
		}
		r.s = op(this.s, a.s);
		r.clamp();
	}
	function op_and(x, y) {
		return x & y;
	}
	function bnAnd(a) {
		var r = nbi();
		this.bitwiseTo(a, op_and, r);
		return r;
	}
	function op_or(x, y) {
		return x | y;
	}
	function bnOr(a) {
		var r = nbi();
		this.bitwiseTo(a, op_or, r);
		return r;
	}
	function op_xor(x, y) {
		return x ^ y;
	}
	function bnXor(a) {
		var r = nbi();
		this.bitwiseTo(a, op_xor, r);
		return r;
	}
	function op_andnot(x, y) {
		return x & ~y;
	}
	function bnAndNot(a) {
		var r = nbi();
		this.bitwiseTo(a, op_andnot, r);
		return r;
	}
	function bnNot() {
		var r = nbi();
		for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
		r.t = this.t;
		r.s = ~this.s;
		return r;
	}
	function bnShiftLeft(n) {
		var r = nbi();
		if (n < 0) this.rShiftTo(-n, r);
		else this.lShiftTo(n, r);
		return r;
	}
	function bnShiftRight(n) {
		var r = nbi();
		if (n < 0) this.lShiftTo(-n, r);
		else this.rShiftTo(n, r);
		return r;
	}
	function lbit(x) {
		if (x === 0) return -1;
		var r = 0;
		if ((x & 65535) === 0) {
			x >>= 16;
			r += 16;
		}
		if ((x & 255) === 0) {
			x >>= 8;
			r += 8;
		}
		if ((x & 15) === 0) {
			x >>= 4;
			r += 4;
		}
		if ((x & 3) === 0) {
			x >>= 2;
			r += 2;
		}
		if ((x & 1) === 0) ++r;
		return r;
	}
	function bnGetLowestSetBit() {
		for (var i = 0; i < this.t; ++i) if (this[i] != 0) return i * this.DB + lbit(this[i]);
		if (this.s < 0) return this.t * this.DB;
		return -1;
	}
	function cbit(x) {
		var r = 0;
		while (x != 0) {
			x &= x - 1;
			++r;
		}
		return r;
	}
	function bnBitCount() {
		var r = 0, x = this.s & this.DM;
		for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
		return r;
	}
	function bnTestBit(n) {
		var j = Math.floor(n / this.DB);
		if (j >= this.t) return this.s != 0;
		return (this[j] & 1 << n % this.DB) != 0;
	}
	function bnpChangeBit(n, op) {
		var r = BigInteger.ONE.shiftLeft(n);
		this.bitwiseTo(r, op, r);
		return r;
	}
	function bnSetBit(n) {
		return this.changeBit(n, op_or);
	}
	function bnClearBit(n) {
		return this.changeBit(n, op_andnot);
	}
	function bnFlipBit(n) {
		return this.changeBit(n, op_xor);
	}
	function bnpAddTo(a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this[i] + a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c += a.s;
			while (i < this.t) {
				c += this[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c += a[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += a.s;
		}
		r.s = c < 0 ? -1 : 0;
		if (c > 0) r[i++] = c;
		else if (c < -1) r[i++] = this.DV + c;
		r.t = i;
		r.clamp();
	}
	function bnAdd(a) {
		var r = nbi();
		this.addTo(a, r);
		return r;
	}
	function bnSubtract(a) {
		var r = nbi();
		this.subTo(a, r);
		return r;
	}
	function bnMultiply(a) {
		var r = nbi();
		this.multiplyTo(a, r);
		return r;
	}
	function bnSquare() {
		var r = nbi();
		this.squareTo(r);
		return r;
	}
	function bnDivide(a) {
		var r = nbi();
		this.divRemTo(a, r, null);
		return r;
	}
	function bnRemainder(a) {
		var r = nbi();
		this.divRemTo(a, null, r);
		return r;
	}
	function bnDivideAndRemainder(a) {
		var q = nbi(), r = nbi();
		this.divRemTo(a, q, r);
		return new Array(q, r);
	}
	function bnpDMultiply(n) {
		this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
		++this.t;
		this.clamp();
	}
	function bnpDAddOffset(n, w) {
		if (n === 0) return;
		while (this.t <= w) this[this.t++] = 0;
		this[w] += n;
		while (this[w] >= this.DV) {
			this[w] -= this.DV;
			if (++w >= this.t) this[this.t++] = 0;
			++this[w];
		}
	}
	function NullExp() {}
	function nNop(x) {
		return x;
	}
	function nMulTo(x, y, r) {
		x.multiplyTo(y, r);
	}
	function nSqrTo(x, r) {
		x.squareTo(r);
	}
	NullExp.prototype.convert = nNop;
	NullExp.prototype.revert = nNop;
	NullExp.prototype.mulTo = nMulTo;
	NullExp.prototype.sqrTo = nSqrTo;
	function bnPow(e) {
		return this.exp(e, new NullExp());
	}
	function bnpMultiplyLowerTo(a, n, r) {
		var i = Math.min(this.t + a.t, n);
		r.s = 0;
		r.t = i;
		while (i > 0) r[--i] = 0;
		var j;
		for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
		for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
		r.clamp();
	}
	function bnpMultiplyUpperTo(a, n, r) {
		--n;
		var i = r.t = this.t + a.t - n;
		r.s = 0;
		while (--i >= 0) r[i] = 0;
		for (i = Math.max(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
		r.clamp();
		r.drShiftTo(1, r);
	}
	function Barrett(m) {
		this.r2 = nbi();
		this.q3 = nbi();
		BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
		this.mu = this.r2.divide(m);
		this.m = m;
	}
	function barrettConvert(x) {
		if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
		else if (x.compareTo(this.m) < 0) return x;
		else {
			var r = nbi();
			x.copyTo(r);
			this.reduce(r);
			return r;
		}
	}
	function barrettRevert(x) {
		return x;
	}
	function barrettReduce(x) {
		x.drShiftTo(this.m.t - 1, this.r2);
		if (x.t > this.m.t + 1) {
			x.t = this.m.t + 1;
			x.clamp();
		}
		this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
		this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
		while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
		x.subTo(this.r2, x);
		while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	}
	function barrettSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	function barrettMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	Barrett.prototype.convert = barrettConvert;
	Barrett.prototype.revert = barrettRevert;
	Barrett.prototype.reduce = barrettReduce;
	Barrett.prototype.mulTo = barrettMulTo;
	Barrett.prototype.sqrTo = barrettSqrTo;
	function bnModPow(e, m) {
		var i = e.bitLength(), k, r = nbv(1), z$1;
		if (i <= 0) return r;
		else if (i < 18) k = 1;
		else if (i < 48) k = 3;
		else if (i < 144) k = 4;
		else if (i < 768) k = 5;
		else k = 6;
		if (i < 8) z$1 = new Classic(m);
		else if (m.isEven()) z$1 = new Barrett(m);
		else z$1 = new Montgomery(m);
		var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
		g[1] = z$1.convert(this);
		if (k > 1) {
			var g2 = nbi();
			z$1.sqrTo(g[1], g2);
			while (n <= km) {
				g[n] = nbi();
				z$1.mulTo(g2, g[n - 2], g[n]);
				n += 2;
			}
		}
		var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
		i = nbits(e[j]) - 1;
		while (j >= 0) {
			if (i >= k1) w = e[j] >> i - k1 & km;
			else {
				w = (e[j] & (1 << i + 1) - 1) << k1 - i;
				if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
			}
			n = k;
			while ((w & 1) === 0) {
				w >>= 1;
				--n;
			}
			if ((i -= n) < 0) {
				i += this.DB;
				--j;
			}
			if (is1) {
				g[w].copyTo(r);
				is1 = false;
			} else {
				while (n > 1) {
					z$1.sqrTo(r, r2);
					z$1.sqrTo(r2, r);
					n -= 2;
				}
				if (n > 0) z$1.sqrTo(r, r2);
				else {
					t = r;
					r = r2;
					r2 = t;
				}
				z$1.mulTo(r2, g[w], r);
			}
			while (j >= 0 && (e[j] & 1 << i) === 0) {
				z$1.sqrTo(r, r2);
				t = r;
				r = r2;
				r2 = t;
				if (--i < 0) {
					i = this.DB - 1;
					--j;
				}
			}
		}
		return z$1.revert(r);
	}
	function bnGCD(a) {
		var x = this.s < 0 ? this.negate() : this.clone();
		var y = a.s < 0 ? a.negate() : a.clone();
		if (x.compareTo(y) < 0) {
			var t = x;
			x = y;
			y = t;
		}
		var i = x.getLowestSetBit(), g = y.getLowestSetBit();
		if (g < 0) return x;
		if (i < g) g = i;
		if (g > 0) {
			x.rShiftTo(g, x);
			y.rShiftTo(g, y);
		}
		while (x.signum() > 0) {
			if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
			if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
			if (x.compareTo(y) >= 0) {
				x.subTo(y, x);
				x.rShiftTo(1, x);
			} else {
				y.subTo(x, y);
				y.rShiftTo(1, y);
			}
		}
		if (g > 0) y.lShiftTo(g, y);
		return y;
	}
	function bnpModInt(n) {
		if (n <= 0) return 0;
		var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
		if (this.t > 0) if (d === 0) r = this[0] % n;
		else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
		return r;
	}
	function bnModInverse(m) {
		var ac = m.isEven();
		if (this.isEven() && ac || m.signum() === 0) return BigInteger.ZERO;
		var u = m.clone(), v = this.clone();
		var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
		while (u.signum() != 0) {
			while (u.isEven()) {
				u.rShiftTo(1, u);
				if (ac) {
					if (!a.isEven() || !b.isEven()) {
						a.addTo(this, a);
						b.subTo(m, b);
					}
					a.rShiftTo(1, a);
				} else if (!b.isEven()) b.subTo(m, b);
				b.rShiftTo(1, b);
			}
			while (v.isEven()) {
				v.rShiftTo(1, v);
				if (ac) {
					if (!c.isEven() || !d.isEven()) {
						c.addTo(this, c);
						d.subTo(m, d);
					}
					c.rShiftTo(1, c);
				} else if (!d.isEven()) d.subTo(m, d);
				d.rShiftTo(1, d);
			}
			if (u.compareTo(v) >= 0) {
				u.subTo(v, u);
				if (ac) a.subTo(c, a);
				b.subTo(d, b);
			} else {
				v.subTo(u, v);
				if (ac) c.subTo(a, c);
				d.subTo(b, d);
			}
		}
		if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
		if (d.compareTo(m) >= 0) return d.subtract(m);
		if (d.signum() < 0) d.addTo(m, d);
		else return d;
		if (d.signum() < 0) return d.add(m);
		else return d;
	}
	var lowprimes = [
		2,
		3,
		5,
		7,
		11,
		13,
		17,
		19,
		23,
		29,
		31,
		37,
		41,
		43,
		47,
		53,
		59,
		61,
		67,
		71,
		73,
		79,
		83,
		89,
		97,
		101,
		103,
		107,
		109,
		113,
		127,
		131,
		137,
		139,
		149,
		151,
		157,
		163,
		167,
		173,
		179,
		181,
		191,
		193,
		197,
		199,
		211,
		223,
		227,
		229,
		233,
		239,
		241,
		251,
		257,
		263,
		269,
		271,
		277,
		281,
		283,
		293,
		307,
		311,
		313,
		317,
		331,
		337,
		347,
		349,
		353,
		359,
		367,
		373,
		379,
		383,
		389,
		397,
		401,
		409,
		419,
		421,
		431,
		433,
		439,
		443,
		449,
		457,
		461,
		463,
		467,
		479,
		487,
		491,
		499,
		503,
		509,
		521,
		523,
		541,
		547,
		557,
		563,
		569,
		571,
		577,
		587,
		593,
		599,
		601,
		607,
		613,
		617,
		619,
		631,
		641,
		643,
		647,
		653,
		659,
		661,
		673,
		677,
		683,
		691,
		701,
		709,
		719,
		727,
		733,
		739,
		743,
		751,
		757,
		761,
		769,
		773,
		787,
		797,
		809,
		811,
		821,
		823,
		827,
		829,
		839,
		853,
		857,
		859,
		863,
		877,
		881,
		883,
		887,
		907,
		911,
		919,
		929,
		937,
		941,
		947,
		953,
		967,
		971,
		977,
		983,
		991,
		997
	];
	var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
	function bnIsProbablePrime(t) {
		var i, x = this.abs();
		if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
			for (i = 0; i < lowprimes.length; ++i) if (x[0] == lowprimes[i]) return true;
			return false;
		}
		if (x.isEven()) return false;
		i = 1;
		while (i < lowprimes.length) {
			var m = lowprimes[i], j = i + 1;
			while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
			m = x.modInt(m);
			while (i < j) if (m % lowprimes[i++] === 0) return false;
		}
		return x.millerRabin(t);
	}
	function bnpMillerRabin(t) {
		var n1 = this.subtract(BigInteger.ONE);
		var k = n1.getLowestSetBit();
		if (k <= 0) return false;
		var r = n1.shiftRight(k);
		t = t + 1 >> 1;
		if (t > lowprimes.length) t = lowprimes.length;
		var a = nbi();
		for (var i = 0; i < t; ++i) {
			a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
			var y = a.modPow(r, this);
			if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
				var j = 1;
				while (j++ < k && y.compareTo(n1) != 0) {
					y = y.modPowInt(2, this);
					if (y.compareTo(BigInteger.ONE) === 0) return false;
				}
				if (y.compareTo(n1) != 0) return false;
			}
		}
		return true;
	}
	BigInteger.prototype.copyTo = bnpCopyTo;
	BigInteger.prototype.fromInt = bnpFromInt;
	BigInteger.prototype.fromString = bnpFromString;
	BigInteger.prototype.fromByteArray = bnpFromByteArray;
	BigInteger.prototype.fromBuffer = bnpFromBuffer;
	BigInteger.prototype.clamp = bnpClamp;
	BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	BigInteger.prototype.lShiftTo = bnpLShiftTo;
	BigInteger.prototype.rShiftTo = bnpRShiftTo;
	BigInteger.prototype.subTo = bnpSubTo;
	BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	BigInteger.prototype.squareTo = bnpSquareTo;
	BigInteger.prototype.divRemTo = bnpDivRemTo;
	BigInteger.prototype.invDigit = bnpInvDigit;
	BigInteger.prototype.isEven = bnpIsEven;
	BigInteger.prototype.exp = bnpExp;
	BigInteger.prototype.chunkSize = bnpChunkSize;
	BigInteger.prototype.toRadix = bnpToRadix;
	BigInteger.prototype.fromRadix = bnpFromRadix;
	BigInteger.prototype.fromNumber = bnpFromNumber;
	BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	BigInteger.prototype.changeBit = bnpChangeBit;
	BigInteger.prototype.addTo = bnpAddTo;
	BigInteger.prototype.dMultiply = bnpDMultiply;
	BigInteger.prototype.dAddOffset = bnpDAddOffset;
	BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	BigInteger.prototype.modInt = bnpModInt;
	BigInteger.prototype.millerRabin = bnpMillerRabin;
	BigInteger.prototype.toString = bnToString;
	BigInteger.prototype.negate = bnNegate;
	BigInteger.prototype.abs = bnAbs;
	BigInteger.prototype.compareTo = bnCompareTo;
	BigInteger.prototype.bitLength = bnBitLength;
	BigInteger.prototype.mod = bnMod;
	BigInteger.prototype.modPowInt = bnModPowInt;
	BigInteger.prototype.clone = bnClone;
	BigInteger.prototype.intValue = bnIntValue;
	BigInteger.prototype.byteValue = bnByteValue;
	BigInteger.prototype.shortValue = bnShortValue;
	BigInteger.prototype.signum = bnSigNum;
	BigInteger.prototype.toByteArray = bnToByteArray;
	BigInteger.prototype.toBuffer = bnToBuffer;
	BigInteger.prototype.equals = bnEquals;
	BigInteger.prototype.min = bnMin;
	BigInteger.prototype.max = bnMax;
	BigInteger.prototype.and = bnAnd;
	BigInteger.prototype.or = bnOr;
	BigInteger.prototype.xor = bnXor;
	BigInteger.prototype.andNot = bnAndNot;
	BigInteger.prototype.not = bnNot;
	BigInteger.prototype.shiftLeft = bnShiftLeft;
	BigInteger.prototype.shiftRight = bnShiftRight;
	BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	BigInteger.prototype.bitCount = bnBitCount;
	BigInteger.prototype.testBit = bnTestBit;
	BigInteger.prototype.setBit = bnSetBit;
	BigInteger.prototype.clearBit = bnClearBit;
	BigInteger.prototype.flipBit = bnFlipBit;
	BigInteger.prototype.add = bnAdd;
	BigInteger.prototype.subtract = bnSubtract;
	BigInteger.prototype.multiply = bnMultiply;
	BigInteger.prototype.divide = bnDivide;
	BigInteger.prototype.remainder = bnRemainder;
	BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	BigInteger.prototype.modPow = bnModPow;
	BigInteger.prototype.modInverse = bnModInverse;
	BigInteger.prototype.pow = bnPow;
	BigInteger.prototype.gcd = bnGCD;
	BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	BigInteger.int2char = int2char;
	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);
	BigInteger.prototype.square = bnSquare;
	module.exports = BigInteger;
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/schemes/pkcs1.js
var require_pkcs1$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* PKCS1 padding and signature scheme
	*/
	var BigInteger = require_jsbn();
	var crypt$3 = __require("crypto");
	var constants$3 = __require("constants");
	var SIGN_INFO_HEAD = {
		md2: Buffer.from("3020300c06082a864886f70d020205000410", "hex"),
		md5: Buffer.from("3020300c06082a864886f70d020505000410", "hex"),
		sha1: Buffer.from("3021300906052b0e03021a05000414", "hex"),
		sha224: Buffer.from("302d300d06096086480165030402040500041c", "hex"),
		sha256: Buffer.from("3031300d060960864801650304020105000420", "hex"),
		sha384: Buffer.from("3041300d060960864801650304020205000430", "hex"),
		sha512: Buffer.from("3051300d060960864801650304020305000440", "hex"),
		ripemd160: Buffer.from("3021300906052b2403020105000414", "hex"),
		rmd160: Buffer.from("3021300906052b2403020105000414", "hex")
	};
	var SIGN_ALG_TO_HASH_ALIASES = { "ripemd160": "rmd160" };
	var DEFAULT_HASH_FUNCTION = "sha256";
	module.exports = {
		isEncryption: true,
		isSignature: true
	};
	module.exports.makeScheme = function(key, options) {
		function Scheme(key$1, options$1) {
			this.key = key$1;
			this.options = options$1;
		}
		Scheme.prototype.maxMessageLength = function() {
			if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants$3.RSA_NO_PADDING) return this.key.encryptedDataLength;
			return this.key.encryptedDataLength - 11;
		};
		/**
		* Pad input Buffer to encryptedDataLength bytes, and return Buffer.from
		* alg: PKCS#1
		* @param buffer
		* @returns {Buffer}
		*/
		Scheme.prototype.encPad = function(buffer$1, options$1) {
			options$1 = options$1 || {};
			var filled;
			if (buffer$1.length > this.key.maxMessageLength) throw new Error("Message too long for RSA (n=" + this.key.encryptedDataLength + ", l=" + buffer$1.length + ")");
			if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants$3.RSA_NO_PADDING) {
				filled = Buffer.alloc(this.key.maxMessageLength - buffer$1.length);
				filled.fill(0);
				return Buffer.concat([filled, buffer$1]);
			}
			if (options$1.type === 1) {
				filled = Buffer.alloc(this.key.encryptedDataLength - buffer$1.length - 1);
				filled.fill(255, 0, filled.length - 1);
				filled[0] = 1;
				filled[filled.length - 1] = 0;
				return Buffer.concat([filled, buffer$1]);
			} else {
				filled = Buffer.alloc(this.key.encryptedDataLength - buffer$1.length);
				filled[0] = 0;
				filled[1] = 2;
				var rand = crypt$3.randomBytes(filled.length - 3);
				for (var i = 0; i < rand.length; i++) {
					var r = rand[i];
					while (r === 0) r = crypt$3.randomBytes(1)[0];
					filled[i + 2] = r;
				}
				filled[filled.length - 1] = 0;
				return Buffer.concat([filled, buffer$1]);
			}
		};
		/**
		* Unpad input Buffer and, if valid, return the Buffer object
		* alg: PKCS#1 (type 2, random)
		* @param buffer
		* @returns {Buffer}
		*/
		Scheme.prototype.encUnPad = function(buffer$1, options$1) {
			options$1 = options$1 || {};
			var i = 0;
			if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants$3.RSA_NO_PADDING) {
				var unPad;
				if (typeof buffer$1.lastIndexOf == "function") unPad = buffer$1.slice(buffer$1.lastIndexOf("\0") + 1, buffer$1.length);
				else unPad = buffer$1.slice(String.prototype.lastIndexOf.call(buffer$1, "\0") + 1, buffer$1.length);
				return unPad;
			}
			if (buffer$1.length < 4) return null;
			if (options$1.type === 1) {
				if (buffer$1[0] !== 0 || buffer$1[1] !== 1) return null;
				i = 3;
				while (buffer$1[i] !== 0) if (buffer$1[i] != 255 || ++i >= buffer$1.length) return null;
			} else {
				if (buffer$1[0] !== 0 || buffer$1[1] !== 2) return null;
				i = 3;
				while (buffer$1[i] !== 0) if (++i >= buffer$1.length) return null;
			}
			return buffer$1.slice(i + 1, buffer$1.length);
		};
		Scheme.prototype.sign = function(buffer$1) {
			var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
			if (this.options.environment === "browser") {
				hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;
				var hasher = crypt$3.createHash(hashAlgorithm);
				hasher.update(buffer$1);
				var hash$1 = this.pkcs1pad(hasher.digest(), hashAlgorithm);
				return this.key.$doPrivate(new BigInteger(hash$1)).toBuffer(this.key.encryptedDataLength);
			} else {
				var signer = crypt$3.createSign("RSA-" + hashAlgorithm.toUpperCase());
				signer.update(buffer$1);
				return signer.sign(this.options.rsaUtils.exportKey("private"));
			}
		};
		Scheme.prototype.verify = function(buffer$1, signature, signature_encoding) {
			if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants$3.RSA_NO_PADDING) return false;
			var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
			if (this.options.environment === "browser") {
				hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;
				if (signature_encoding) signature = Buffer.from(signature, signature_encoding);
				var hasher = crypt$3.createHash(hashAlgorithm);
				hasher.update(buffer$1);
				var hash$1 = this.pkcs1pad(hasher.digest(), hashAlgorithm);
				return this.key.$doPublic(new BigInteger(signature)).toBuffer().toString("hex") == hash$1.toString("hex");
			} else {
				var verifier = crypt$3.createVerify("RSA-" + hashAlgorithm.toUpperCase());
				verifier.update(buffer$1);
				return verifier.verify(this.options.rsaUtils.exportKey("public"), signature, signature_encoding);
			}
		};
		/**
		* PKCS#1 zero pad input buffer to max data length
		* @param hashBuf
		* @param hashAlgorithm
		* @returns {*}
		*/
		Scheme.prototype.pkcs0pad = function(buffer$1) {
			var filled = Buffer.alloc(this.key.maxMessageLength - buffer$1.length);
			filled.fill(0);
			return Buffer.concat([filled, buffer$1]);
		};
		Scheme.prototype.pkcs0unpad = function(buffer$1) {
			var unPad;
			if (typeof buffer$1.lastIndexOf == "function") unPad = buffer$1.slice(buffer$1.lastIndexOf("\0") + 1, buffer$1.length);
			else unPad = buffer$1.slice(String.prototype.lastIndexOf.call(buffer$1, "\0") + 1, buffer$1.length);
			return unPad;
		};
		/**
		* PKCS#1 pad input buffer to max data length
		* @param hashBuf
		* @param hashAlgorithm
		* @returns {*}
		*/
		Scheme.prototype.pkcs1pad = function(hashBuf, hashAlgorithm) {
			var digest = SIGN_INFO_HEAD[hashAlgorithm];
			if (!digest) throw Error("Unsupported hash algorithm");
			var data = Buffer.concat([digest, hashBuf]);
			if (data.length + 10 > this.key.encryptedDataLength) throw Error("Key is too short for signing algorithm (" + hashAlgorithm + ")");
			var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);
			filled.fill(255, 0, filled.length - 1);
			filled[0] = 1;
			filled[filled.length - 1] = 0;
			return Buffer.concat([filled, data]);
		};
		return new Scheme(key, options);
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/schemes/oaep.js
var require_oaep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require_jsbn();
	var crypt$2 = __require("crypto");
	module.exports = {
		isEncryption: true,
		isSignature: false
	};
	module.exports.digestLength = {
		md4: 16,
		md5: 16,
		ripemd160: 20,
		rmd160: 20,
		sha1: 20,
		sha224: 28,
		sha256: 32,
		sha384: 48,
		sha512: 64
	};
	var DEFAULT_HASH_FUNCTION = "sha1";
	module.exports.eme_oaep_mgf1 = function(seed, maskLength, hashFunction) {
		hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
		var hLen = module.exports.digestLength[hashFunction];
		var count = Math.ceil(maskLength / hLen);
		var T = Buffer.alloc(hLen * count);
		var c = Buffer.alloc(4);
		for (var i = 0; i < count; ++i) {
			var hash$1 = crypt$2.createHash(hashFunction);
			hash$1.update(seed);
			c.writeUInt32BE(i, 0);
			hash$1.update(c);
			hash$1.digest().copy(T, i * hLen);
		}
		return T.slice(0, maskLength);
	};
	module.exports.makeScheme = function(key, options) {
		function Scheme(key$1, options$1) {
			this.key = key$1;
			this.options = options$1;
		}
		Scheme.prototype.maxMessageLength = function() {
			return this.key.encryptedDataLength - 2 * module.exports.digestLength[this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION] - 2;
		};
		/**
		* Pad input
		* alg: PKCS1_OAEP
		*
		* https://tools.ietf.org/html/rfc3447#section-7.1.1
		*/
		Scheme.prototype.encPad = function(buffer$1) {
			var hash$1 = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
			var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;
			var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);
			var emLen = this.key.encryptedDataLength;
			var hLen = module.exports.digestLength[hash$1];
			if (buffer$1.length > emLen - 2 * hLen - 2) throw new Error("Message is too long to encode into an encoded message with a length of " + emLen + " bytes, increaseemLen to fix this error (minimum value for given parameters and options: " + (emLen - 2 * hLen - 2) + ")");
			var lHash = crypt$2.createHash(hash$1);
			lHash.update(label);
			lHash = lHash.digest();
			var PS = Buffer.alloc(emLen - buffer$1.length - 2 * hLen - 1);
			PS.fill(0);
			PS[PS.length - 1] = 1;
			var DB = Buffer.concat([
				lHash,
				PS,
				buffer$1
			]);
			var seed = crypt$2.randomBytes(hLen);
			var mask = mgf(seed, DB.length, hash$1);
			for (var i = 0; i < DB.length; i++) DB[i] ^= mask[i];
			mask = mgf(DB, hLen, hash$1);
			for (i = 0; i < seed.length; i++) seed[i] ^= mask[i];
			var em = Buffer.alloc(1 + seed.length + DB.length);
			em[0] = 0;
			seed.copy(em, 1);
			DB.copy(em, 1 + seed.length);
			return em;
		};
		/**
		* Unpad input
		* alg: PKCS1_OAEP
		*
		* Note: This method works within the buffer given and modifies the values. It also returns a slice of the EM as the return Message.
		* If the implementation requires that the EM parameter be unmodified then the implementation should pass in a clone of the EM buffer.
		*
		* https://tools.ietf.org/html/rfc3447#section-7.1.2
		*/
		Scheme.prototype.encUnPad = function(buffer$1) {
			var hash$1 = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
			var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;
			var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);
			var hLen = module.exports.digestLength[hash$1];
			if (buffer$1.length < 2 * hLen + 2) throw new Error("Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message");
			var seed = buffer$1.slice(1, hLen + 1);
			var DB = buffer$1.slice(1 + hLen);
			var mask = mgf(DB, hLen, hash$1);
			for (var i = 0; i < seed.length; i++) seed[i] ^= mask[i];
			mask = mgf(seed, DB.length, hash$1);
			for (i = 0; i < DB.length; i++) DB[i] ^= mask[i];
			var lHash = crypt$2.createHash(hash$1);
			lHash.update(label);
			lHash = lHash.digest();
			if (DB.slice(0, hLen).toString("hex") != lHash.toString("hex")) throw new Error("Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.");
			i = hLen;
			while (DB[i++] === 0 && i < DB.length);
			if (DB[i - 1] != 1) throw new Error("Error decoding message, there is no padding message separator byte");
			return DB.slice(i);
		};
		return new Scheme(key, options);
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/schemes/pss.js
var require_pss = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* PSS signature scheme
	*/
	var BigInteger = require_jsbn();
	var crypt$1 = __require("crypto");
	module.exports = {
		isEncryption: false,
		isSignature: true
	};
	var DEFAULT_HASH_FUNCTION = "sha1";
	var DEFAULT_SALT_LENGTH = 20;
	module.exports.makeScheme = function(key, options) {
		var OAEP = require_schemes().pkcs1_oaep;
		/**
		* @param key
		* @param options
		* options    [Object]    An object that contains the following keys that specify certain options for encoding.
		*  >signingSchemeOptions
		*     >hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = "sha1")
		*     >mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)
		*     >sLen    [uint]        The length of the salt to generate. (default = 20)
		* @constructor
		*/
		function Scheme(key$1, options$1) {
			this.key = key$1;
			this.options = options$1;
		}
		Scheme.prototype.sign = function(buffer$1) {
			var mHash = crypt$1.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);
			mHash.update(buffer$1);
			var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);
			return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);
		};
		Scheme.prototype.verify = function(buffer$1, signature, signature_encoding) {
			if (signature_encoding) signature = Buffer.from(signature, signature_encoding);
			signature = new BigInteger(signature);
			var emLen = Math.ceil((this.key.keySize - 1) / 8);
			var m = this.key.$doPublic(signature).toBuffer(emLen);
			var mHash = crypt$1.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);
			mHash.update(buffer$1);
			return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);
		};
		Scheme.prototype.emsa_pss_encode = function(mHash, emBits) {
			var hash$1 = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
			var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;
			var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;
			var hLen = OAEP.digestLength[hash$1];
			var emLen = Math.ceil(emBits / 8);
			if (emLen < hLen + sLen + 2) throw new Error("Output length passed to emBits(" + emBits + ") is too small for the options specified(" + hash$1 + ", " + sLen + "). To fix this issue increase the value of emBits. (minimum size: " + (8 * hLen + 8 * sLen + 9) + ")");
			var salt = crypt$1.randomBytes(sLen);
			var Mapostrophe = Buffer.alloc(8 + hLen + sLen);
			Mapostrophe.fill(0, 0, 8);
			mHash.copy(Mapostrophe, 8);
			salt.copy(Mapostrophe, 8 + mHash.length);
			var H = crypt$1.createHash(hash$1);
			H.update(Mapostrophe);
			H = H.digest();
			var PS = Buffer.alloc(emLen - salt.length - hLen - 2);
			PS.fill(0);
			var DB = Buffer.alloc(PS.length + 1 + salt.length);
			PS.copy(DB);
			DB[PS.length] = 1;
			salt.copy(DB, PS.length + 1);
			var dbMask = mgf(H, DB.length, hash$1);
			var maskedDB = Buffer.alloc(DB.length);
			for (var i = 0; i < dbMask.length; i++) maskedDB[i] = DB[i] ^ dbMask[i];
			var bits = 8 * emLen - emBits;
			var mask = 255 ^ 255 >> 8 - bits << 8 - bits;
			maskedDB[0] = maskedDB[0] & mask;
			var EM = Buffer.alloc(maskedDB.length + H.length + 1);
			maskedDB.copy(EM, 0);
			H.copy(EM, maskedDB.length);
			EM[EM.length - 1] = 188;
			return EM;
		};
		Scheme.prototype.emsa_pss_verify = function(mHash, EM, emBits) {
			var hash$1 = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
			var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;
			var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;
			var hLen = OAEP.digestLength[hash$1];
			var emLen = Math.ceil(emBits / 8);
			if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 188) return false;
			var DB = Buffer.alloc(emLen - hLen - 1);
			EM.copy(DB, 0, 0, emLen - hLen - 1);
			var mask = 0;
			for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) mask |= 1 << 7 - i;
			if ((DB[0] & mask) !== 0) return false;
			var H = EM.slice(emLen - hLen - 1, emLen - 1);
			var dbMask = mgf(H, DB.length, hash$1);
			for (i = 0; i < DB.length; i++) DB[i] ^= dbMask[i];
			bits = 8 * emLen - emBits;
			mask = 255 ^ 255 >> 8 - bits << 8 - bits;
			DB[0] = DB[0] & mask;
			for (i = 0; DB[i] === 0 && i < DB.length; i++);
			if (DB[i] != 1) return false;
			var salt = DB.slice(DB.length - sLen);
			var Mapostrophe = Buffer.alloc(8 + hLen + sLen);
			Mapostrophe.fill(0, 0, 8);
			mHash.copy(Mapostrophe, 8);
			salt.copy(Mapostrophe, 8 + mHash.length);
			var Hapostrophe = crypt$1.createHash(hash$1);
			Hapostrophe.update(Mapostrophe);
			Hapostrophe = Hapostrophe.digest();
			return H.toString("hex") === Hapostrophe.toString("hex");
		};
		return new Scheme(key, options);
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/schemes/schemes.js
var require_schemes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		pkcs1: require_pkcs1$1(),
		pkcs1_oaep: require_oaep(),
		pss: require_pss(),
		isEncryption: function(scheme) {
			return module.exports[scheme] && module.exports[scheme].isEncryption;
		},
		isSignature: function(scheme) {
			return module.exports[scheme] && module.exports[scheme].isSignature;
		}
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/encryptEngines/js.js
var require_js = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var BigInteger = require_jsbn();
	var schemes = require_schemes();
	module.exports = function(keyPair, options) {
		var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);
		return {
			encrypt: function(buffer$1, usePrivate) {
				var m, c;
				if (usePrivate) {
					m = new BigInteger(pkcs1Scheme.encPad(buffer$1, { type: 1 }));
					c = keyPair.$doPrivate(m);
				} else {
					m = new BigInteger(keyPair.encryptionScheme.encPad(buffer$1));
					c = keyPair.$doPublic(m);
				}
				return c.toBuffer(keyPair.encryptedDataLength);
			},
			decrypt: function(buffer$1, usePublic) {
				var m, c = new BigInteger(buffer$1);
				if (usePublic) {
					m = keyPair.$doPublic(c);
					return pkcs1Scheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength), { type: 1 });
				} else {
					m = keyPair.$doPrivate(c);
					return keyPair.encryptionScheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength));
				}
			}
		};
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/encryptEngines/io.js
var require_io = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var crypto$6 = __require("crypto");
	var constants$2 = __require("constants");
	var schemes = require_schemes();
	module.exports = function(keyPair, options) {
		var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);
		return {
			encrypt: function(buffer$1, usePrivate) {
				var padding;
				if (usePrivate) {
					padding = constants$2.RSA_PKCS1_PADDING;
					if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) padding = options.encryptionSchemeOptions.padding;
					return crypto$6.privateEncrypt({
						key: options.rsaUtils.exportKey("private"),
						padding
					}, buffer$1);
				} else {
					padding = constants$2.RSA_PKCS1_OAEP_PADDING;
					if (options.encryptionScheme === "pkcs1") padding = constants$2.RSA_PKCS1_PADDING;
					if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) padding = options.encryptionSchemeOptions.padding;
					var data = buffer$1;
					if (padding === constants$2.RSA_NO_PADDING) data = pkcs1Scheme.pkcs0pad(buffer$1);
					return crypto$6.publicEncrypt({
						key: options.rsaUtils.exportKey("public"),
						padding
					}, data);
				}
			},
			decrypt: function(buffer$1, usePublic) {
				var padding;
				if (usePublic) {
					padding = constants$2.RSA_PKCS1_PADDING;
					if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) padding = options.encryptionSchemeOptions.padding;
					return crypto$6.publicDecrypt({
						key: options.rsaUtils.exportKey("public"),
						padding
					}, buffer$1);
				} else {
					padding = constants$2.RSA_PKCS1_OAEP_PADDING;
					if (options.encryptionScheme === "pkcs1") padding = constants$2.RSA_PKCS1_PADDING;
					if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) padding = options.encryptionSchemeOptions.padding;
					var res = crypto$6.privateDecrypt({
						key: options.rsaUtils.exportKey("private"),
						padding
					}, buffer$1);
					if (padding === constants$2.RSA_NO_PADDING) return pkcs1Scheme.pkcs0unpad(res);
					return res;
				}
			}
		};
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/encryptEngines/node12.js
var require_node12 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var crypto$5 = __require("crypto");
	var constants$1 = __require("constants");
	var schemes = require_schemes();
	module.exports = function(keyPair, options) {
		var jsEngine = require_js()(keyPair, options);
		var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);
		return {
			encrypt: function(buffer$1, usePrivate) {
				if (usePrivate) return jsEngine.encrypt(buffer$1, usePrivate);
				var padding = constants$1.RSA_PKCS1_OAEP_PADDING;
				if (options.encryptionScheme === "pkcs1") padding = constants$1.RSA_PKCS1_PADDING;
				if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) padding = options.encryptionSchemeOptions.padding;
				var data = buffer$1;
				if (padding === constants$1.RSA_NO_PADDING) data = pkcs1Scheme.pkcs0pad(buffer$1);
				return crypto$5.publicEncrypt({
					key: options.rsaUtils.exportKey("public"),
					padding
				}, data);
			},
			decrypt: function(buffer$1, usePublic) {
				if (usePublic) return jsEngine.decrypt(buffer$1, usePublic);
				var padding = constants$1.RSA_PKCS1_OAEP_PADDING;
				if (options.encryptionScheme === "pkcs1") padding = constants$1.RSA_PKCS1_PADDING;
				if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) padding = options.encryptionSchemeOptions.padding;
				var res = crypto$5.privateDecrypt({
					key: options.rsaUtils.exportKey("private"),
					padding
				}, buffer$1);
				if (padding === constants$1.RSA_NO_PADDING) return pkcs1Scheme.pkcs0unpad(res);
				return res;
			}
		};
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/encryptEngines/encryptEngines.js
var require_encryptEngines = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var crypt = __require("crypto");
	module.exports = { getEngine: function(keyPair, options) {
		var engine = require_js();
		if (options.environment === "node") {
			if (typeof crypt.publicEncrypt === "function" && typeof crypt.privateDecrypt === "function") if (typeof crypt.privateEncrypt === "function" && typeof crypt.publicDecrypt === "function") engine = require_io();
			else engine = require_node12();
		}
		return engine(keyPair, options);
	} };
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/libs/rsa.js
var require_rsa = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var _ = require_utils$2()._;
	__require("crypto");
	var BigInteger = require_jsbn();
	var utils = require_utils$2();
	var schemes = require_schemes();
	var encryptEngines = require_encryptEngines();
	exports.BigInteger = BigInteger;
	module.exports.Key = (function() {
		/**
		* RSA key constructor
		*
		* n - modulus
		* e - publicExponent
		* d - privateExponent
		* p - prime1
		* q - prime2
		* dmp1 - exponent1 -- d mod (p1)
		* dmq1 - exponent2 -- d mod (q-1)
		* coeff - coefficient -- (inverse of q) mod p
		*/
		function RSAKey() {
			this.n = null;
			this.e = 0;
			this.d = null;
			this.p = null;
			this.q = null;
			this.dmp1 = null;
			this.dmq1 = null;
			this.coeff = null;
		}
		RSAKey.prototype.setOptions = function(options) {
			var signingSchemeProvider = schemes[options.signingScheme];
			var encryptionSchemeProvider = schemes[options.encryptionScheme];
			if (signingSchemeProvider === encryptionSchemeProvider) this.signingScheme = this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);
			else {
				this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);
				this.signingScheme = signingSchemeProvider.makeScheme(this, options);
			}
			this.encryptEngine = encryptEngines.getEngine(this, options);
		};
		/**
		* Generate a new random private key B bits long, using public expt E
		* @param B
		* @param E
		*/
		RSAKey.prototype.generate = function(B, E) {
			var qs = B >> 1;
			this.e = parseInt(E, 16);
			var ee = new BigInteger(E, 16);
			while (true) {
				while (true) {
					this.p = new BigInteger(B - qs, 1);
					if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.p.isProbablePrime(10)) break;
				}
				while (true) {
					this.q = new BigInteger(qs, 1);
					if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.q.isProbablePrime(10)) break;
				}
				if (this.p.compareTo(this.q) <= 0) {
					var t = this.p;
					this.p = this.q;
					this.q = t;
				}
				var p1 = this.p.subtract(BigInteger.ONE);
				var q1 = this.q.subtract(BigInteger.ONE);
				var phi = p1.multiply(q1);
				if (phi.gcd(ee).compareTo(BigInteger.ONE) === 0) {
					this.n = this.p.multiply(this.q);
					if (this.n.bitLength() < B) continue;
					this.d = ee.modInverse(phi);
					this.dmp1 = this.d.mod(p1);
					this.dmq1 = this.d.mod(q1);
					this.coeff = this.q.modInverse(this.p);
					break;
				}
			}
			this.$$recalculateCache();
		};
		/**
		* Set the private key fields N, e, d and CRT params from buffers
		*
		* @param N
		* @param E
		* @param D
		* @param P
		* @param Q
		* @param DP
		* @param DQ
		* @param C
		*/
		RSAKey.prototype.setPrivate = function(N, E, D, P, Q, DP, DQ, C) {
			if (N && E && D && N.length > 0 && (_.isNumber(E) || E.length > 0) && D.length > 0) {
				this.n = new BigInteger(N);
				this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);
				this.d = new BigInteger(D);
				if (P && Q && DP && DQ && C) {
					this.p = new BigInteger(P);
					this.q = new BigInteger(Q);
					this.dmp1 = new BigInteger(DP);
					this.dmq1 = new BigInteger(DQ);
					this.coeff = new BigInteger(C);
				}
				this.$$recalculateCache();
			} else throw Error("Invalid RSA private key");
		};
		/**
		* Set the public key fields N and e from hex strings
		* @param N
		* @param E
		*/
		RSAKey.prototype.setPublic = function(N, E) {
			if (N && E && N.length > 0 && (_.isNumber(E) || E.length > 0)) {
				this.n = new BigInteger(N);
				this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);
				this.$$recalculateCache();
			} else throw Error("Invalid RSA public key");
		};
		/**
		* private
		* Perform raw private operation on "x": return x^d (mod n)
		*
		* @param x
		* @returns {*}
		*/
		RSAKey.prototype.$doPrivate = function(x) {
			if (this.p || this.q) return x.modPow(this.d, this.n);
			var xp = x.mod(this.p).modPow(this.dmp1, this.p);
			var xq = x.mod(this.q).modPow(this.dmq1, this.q);
			while (xp.compareTo(xq) < 0) xp = xp.add(this.p);
			return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
		};
		/**
		* private
		* Perform raw public operation on "x": return x^e (mod n)
		*
		* @param x
		* @returns {*}
		*/
		RSAKey.prototype.$doPublic = function(x) {
			return x.modPowInt(this.e, this.n);
		};
		/**
		* Return the PKCS#1 RSA encryption of buffer
		* @param buffer {Buffer}
		* @returns {Buffer}
		*/
		RSAKey.prototype.encrypt = function(buffer$1, usePrivate) {
			var buffers = [];
			var results = [];
			var bufferSize = buffer$1.length;
			var buffersCount = Math.ceil(bufferSize / this.maxMessageLength) || 1;
			var dividedSize = Math.ceil(bufferSize / buffersCount || 1);
			if (buffersCount == 1) buffers.push(buffer$1);
			else for (var bufNum = 0; bufNum < buffersCount; bufNum++) buffers.push(buffer$1.slice(bufNum * dividedSize, (bufNum + 1) * dividedSize));
			for (var i = 0; i < buffers.length; i++) results.push(this.encryptEngine.encrypt(buffers[i], usePrivate));
			return Buffer.concat(results);
		};
		/**
		* Return the PKCS#1 RSA decryption of buffer
		* @param buffer {Buffer}
		* @returns {Buffer}
		*/
		RSAKey.prototype.decrypt = function(buffer$1, usePublic) {
			if (buffer$1.length % this.encryptedDataLength > 0) throw Error("Incorrect data or key");
			var result = [];
			var offset = 0;
			var length = 0;
			var buffersCount = buffer$1.length / this.encryptedDataLength;
			for (var i = 0; i < buffersCount; i++) {
				offset = i * this.encryptedDataLength;
				length = offset + this.encryptedDataLength;
				result.push(this.encryptEngine.decrypt(buffer$1.slice(offset, Math.min(length, buffer$1.length)), usePublic));
			}
			return Buffer.concat(result);
		};
		RSAKey.prototype.sign = function(buffer$1) {
			return this.signingScheme.sign.apply(this.signingScheme, arguments);
		};
		RSAKey.prototype.verify = function(buffer$1, signature, signature_encoding) {
			return this.signingScheme.verify.apply(this.signingScheme, arguments);
		};
		/**
		* Check if key pair contains private key
		*/
		RSAKey.prototype.isPrivate = function() {
			return this.n && this.e && this.d && true || false;
		};
		/**
		* Check if key pair contains public key
		* @param strict {boolean} - public key only, return false if have private exponent
		*/
		RSAKey.prototype.isPublic = function(strict) {
			return this.n && this.e && !(strict && this.d) || false;
		};
		Object.defineProperty(RSAKey.prototype, "keySize", { get: function() {
			return this.cache.keyBitLength;
		} });
		Object.defineProperty(RSAKey.prototype, "encryptedDataLength", { get: function() {
			return this.cache.keyByteLength;
		} });
		Object.defineProperty(RSAKey.prototype, "maxMessageLength", { get: function() {
			return this.encryptionScheme.maxMessageLength();
		} });
		/**
		* Caching key data
		*/
		RSAKey.prototype.$$recalculateCache = function() {
			this.cache = this.cache || {};
			this.cache.keyBitLength = this.n.bitLength();
			this.cache.keyByteLength = this.cache.keyBitLength + 6 >> 3;
		};
		return RSAKey;
	})();
}));

//#endregion
//#region ../../node_modules/.bun/asn1@0.2.6/node_modules/asn1/lib/ber/errors.js
var require_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = { newInvalidAsn1Error: function(msg) {
		var e = /* @__PURE__ */ new Error();
		e.name = "InvalidAsn1Error";
		e.message = msg || "";
		return e;
	} };
}));

//#endregion
//#region ../../node_modules/.bun/asn1@0.2.6/node_modules/asn1/lib/ber/types.js
var require_types$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		EOC: 0,
		Boolean: 1,
		Integer: 2,
		BitString: 3,
		OctetString: 4,
		Null: 5,
		OID: 6,
		ObjectDescriptor: 7,
		External: 8,
		Real: 9,
		Enumeration: 10,
		PDV: 11,
		Utf8String: 12,
		RelativeOID: 13,
		Sequence: 16,
		Set: 17,
		NumericString: 18,
		PrintableString: 19,
		T61String: 20,
		VideotexString: 21,
		IA5String: 22,
		UTCTime: 23,
		GeneralizedTime: 24,
		GraphicString: 25,
		VisibleString: 26,
		GeneralString: 28,
		UniversalString: 29,
		CharacterString: 30,
		BMPString: 31,
		Constructor: 32,
		Context: 128
	};
}));

//#endregion
//#region ../../node_modules/.bun/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var buffer = __require("buffer");
	var Buffer = buffer.Buffer;
	var safer = {};
	var key;
	for (key in buffer) {
		if (!buffer.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer) {
		if (!Buffer.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer[key];
	}
	safer.Buffer.prototype = Buffer.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	module.exports = safer;
}));

//#endregion
//#region ../../node_modules/.bun/asn1@0.2.6/node_modules/asn1/lib/ber/reader.js
var require_reader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$1 = __require("assert");
	var Buffer = require_safer().Buffer;
	var ASN1 = require_types$1();
	var newInvalidAsn1Error = require_errors().newInvalidAsn1Error;
	function Reader(data) {
		if (!data || !Buffer.isBuffer(data)) throw new TypeError("data must be a node Buffer");
		this._buf = data;
		this._size = data.length;
		this._len = 0;
		this._offset = 0;
	}
	Object.defineProperty(Reader.prototype, "length", {
		enumerable: true,
		get: function() {
			return this._len;
		}
	});
	Object.defineProperty(Reader.prototype, "offset", {
		enumerable: true,
		get: function() {
			return this._offset;
		}
	});
	Object.defineProperty(Reader.prototype, "remain", { get: function() {
		return this._size - this._offset;
	} });
	Object.defineProperty(Reader.prototype, "buffer", { get: function() {
		return this._buf.slice(this._offset);
	} });
	/**
	* Reads a single byte and advances offset; you can pass in `true` to make this
	* a "peek" operation (i.e., get the byte, but don't advance the offset).
	*
	* @param {Boolean} peek true means don't move offset.
	* @return {Number} the next byte, null if not enough data.
	*/
	Reader.prototype.readByte = function(peek) {
		if (this._size - this._offset < 1) return null;
		var b = this._buf[this._offset] & 255;
		if (!peek) this._offset += 1;
		return b;
	};
	Reader.prototype.peek = function() {
		return this.readByte(true);
	};
	/**
	* Reads a (potentially) variable length off the BER buffer.  This call is
	* not really meant to be called directly, as callers have to manipulate
	* the internal buffer afterwards.
	*
	* As a result of this call, you can call `Reader.length`, until the
	* next thing called that does a readLength.
	*
	* @return {Number} the amount of offset to advance the buffer.
	* @throws {InvalidAsn1Error} on bad ASN.1
	*/
	Reader.prototype.readLength = function(offset) {
		if (offset === void 0) offset = this._offset;
		if (offset >= this._size) return null;
		var lenB = this._buf[offset++] & 255;
		if (lenB === null) return null;
		if ((lenB & 128) === 128) {
			lenB &= 127;
			if (lenB === 0) throw newInvalidAsn1Error("Indefinite length not supported");
			if (lenB > 4) throw newInvalidAsn1Error("encoding too long");
			if (this._size - offset < lenB) return null;
			this._len = 0;
			for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (this._buf[offset++] & 255);
		} else this._len = lenB;
		return offset;
	};
	/**
	* Parses the next sequence in this BER buffer.
	*
	* To get the length of the sequence, call `Reader.length`.
	*
	* @return {Number} the sequence's tag.
	*/
	Reader.prototype.readSequence = function(tag) {
		var seq = this.peek();
		if (seq === null) return null;
		if (tag !== void 0 && tag !== seq) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
		var o = this.readLength(this._offset + 1);
		if (o === null) return null;
		this._offset = o;
		return seq;
	};
	Reader.prototype.readInt = function() {
		return this._readTag(ASN1.Integer);
	};
	Reader.prototype.readBoolean = function() {
		return this._readTag(ASN1.Boolean) === 0 ? false : true;
	};
	Reader.prototype.readEnumeration = function() {
		return this._readTag(ASN1.Enumeration);
	};
	Reader.prototype.readString = function(tag, retbuf) {
		if (!tag) tag = ASN1.OctetString;
		var b = this.peek();
		if (b === null) return null;
		if (b !== tag) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
		var o = this.readLength(this._offset + 1);
		if (o === null) return null;
		if (this.length > this._size - o) return null;
		this._offset = o;
		if (this.length === 0) return retbuf ? Buffer.alloc(0) : "";
		var str = this._buf.slice(this._offset, this._offset + this.length);
		this._offset += this.length;
		return retbuf ? str : str.toString("utf8");
	};
	Reader.prototype.readOID = function(tag) {
		if (!tag) tag = ASN1.OID;
		var b = this.readString(tag, true);
		if (b === null) return null;
		var values = [];
		var value = 0;
		for (var i = 0; i < b.length; i++) {
			var byte = b[i] & 255;
			value <<= 7;
			value += byte & 127;
			if ((byte & 128) === 0) {
				values.push(value);
				value = 0;
			}
		}
		value = values.shift();
		values.unshift(value % 40);
		values.unshift(value / 40 >> 0);
		return values.join(".");
	};
	Reader.prototype._readTag = function(tag) {
		assert$1.ok(tag !== void 0);
		var b = this.peek();
		if (b === null) return null;
		if (b !== tag) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
		var o = this.readLength(this._offset + 1);
		if (o === null) return null;
		if (this.length > 4) throw newInvalidAsn1Error("Integer too long: " + this.length);
		if (this.length > this._size - o) return null;
		this._offset = o;
		var fb = this._buf[this._offset];
		var value = 0;
		for (var i = 0; i < this.length; i++) {
			value <<= 8;
			value |= this._buf[this._offset++] & 255;
		}
		if ((fb & 128) === 128 && i !== 4) value -= 1 << i * 8;
		return value >> 0;
	};
	module.exports = Reader;
}));

//#endregion
//#region ../../node_modules/.bun/asn1@0.2.6/node_modules/asn1/lib/ber/writer.js
var require_writer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert = __require("assert");
	var Buffer = require_safer().Buffer;
	var ASN1 = require_types$1();
	var newInvalidAsn1Error = require_errors().newInvalidAsn1Error;
	var DEFAULT_OPTS = {
		size: 1024,
		growthFactor: 8
	};
	function merge(from, to) {
		assert.ok(from);
		assert.equal(typeof from, "object");
		assert.ok(to);
		assert.equal(typeof to, "object");
		Object.getOwnPropertyNames(from).forEach(function(key) {
			if (to[key]) return;
			var value = Object.getOwnPropertyDescriptor(from, key);
			Object.defineProperty(to, key, value);
		});
		return to;
	}
	function Writer(options) {
		options = merge(DEFAULT_OPTS, options || {});
		this._buf = Buffer.alloc(options.size || 1024);
		this._size = this._buf.length;
		this._offset = 0;
		this._options = options;
		this._seq = [];
	}
	Object.defineProperty(Writer.prototype, "buffer", { get: function() {
		if (this._seq.length) throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
		return this._buf.slice(0, this._offset);
	} });
	Writer.prototype.writeByte = function(b) {
		if (typeof b !== "number") throw new TypeError("argument must be a Number");
		this._ensure(1);
		this._buf[this._offset++] = b;
	};
	Writer.prototype.writeInt = function(i, tag) {
		if (typeof i !== "number") throw new TypeError("argument must be a Number");
		if (typeof tag !== "number") tag = ASN1.Integer;
		var sz = 4;
		while (((i & 4286578688) === 0 || (i & 4286578688) === -8388608) && sz > 1) {
			sz--;
			i <<= 8;
		}
		if (sz > 4) throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
		this._ensure(2 + sz);
		this._buf[this._offset++] = tag;
		this._buf[this._offset++] = sz;
		while (sz-- > 0) {
			this._buf[this._offset++] = (i & 4278190080) >>> 24;
			i <<= 8;
		}
	};
	Writer.prototype.writeNull = function() {
		this.writeByte(ASN1.Null);
		this.writeByte(0);
	};
	Writer.prototype.writeEnumeration = function(i, tag) {
		if (typeof i !== "number") throw new TypeError("argument must be a Number");
		if (typeof tag !== "number") tag = ASN1.Enumeration;
		return this.writeInt(i, tag);
	};
	Writer.prototype.writeBoolean = function(b, tag) {
		if (typeof b !== "boolean") throw new TypeError("argument must be a Boolean");
		if (typeof tag !== "number") tag = ASN1.Boolean;
		this._ensure(3);
		this._buf[this._offset++] = tag;
		this._buf[this._offset++] = 1;
		this._buf[this._offset++] = b ? 255 : 0;
	};
	Writer.prototype.writeString = function(s, tag) {
		if (typeof s !== "string") throw new TypeError("argument must be a string (was: " + typeof s + ")");
		if (typeof tag !== "number") tag = ASN1.OctetString;
		var len = Buffer.byteLength(s);
		this.writeByte(tag);
		this.writeLength(len);
		if (len) {
			this._ensure(len);
			this._buf.write(s, this._offset);
			this._offset += len;
		}
	};
	Writer.prototype.writeBuffer = function(buf, tag) {
		if (typeof tag !== "number") throw new TypeError("tag must be a number");
		if (!Buffer.isBuffer(buf)) throw new TypeError("argument must be a buffer");
		this.writeByte(tag);
		this.writeLength(buf.length);
		this._ensure(buf.length);
		buf.copy(this._buf, this._offset, 0, buf.length);
		this._offset += buf.length;
	};
	Writer.prototype.writeStringArray = function(strings) {
		if (!strings instanceof Array) throw new TypeError("argument must be an Array[String]");
		var self$1 = this;
		strings.forEach(function(s) {
			self$1.writeString(s);
		});
	};
	Writer.prototype.writeOID = function(s, tag) {
		if (typeof s !== "string") throw new TypeError("argument must be a string");
		if (typeof tag !== "number") tag = ASN1.OID;
		if (!/^([0-9]+\.){3,}[0-9]+$/.test(s)) throw new Error("argument is not a valid OID string");
		function encodeOctet(bytes$1, octet) {
			if (octet < 128) bytes$1.push(octet);
			else if (octet < 16384) {
				bytes$1.push(octet >>> 7 | 128);
				bytes$1.push(octet & 127);
			} else if (octet < 2097152) {
				bytes$1.push(octet >>> 14 | 128);
				bytes$1.push((octet >>> 7 | 128) & 255);
				bytes$1.push(octet & 127);
			} else if (octet < 268435456) {
				bytes$1.push(octet >>> 21 | 128);
				bytes$1.push((octet >>> 14 | 128) & 255);
				bytes$1.push((octet >>> 7 | 128) & 255);
				bytes$1.push(octet & 127);
			} else {
				bytes$1.push((octet >>> 28 | 128) & 255);
				bytes$1.push((octet >>> 21 | 128) & 255);
				bytes$1.push((octet >>> 14 | 128) & 255);
				bytes$1.push((octet >>> 7 | 128) & 255);
				bytes$1.push(octet & 127);
			}
		}
		var tmp = s.split(".");
		var bytes = [];
		bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
		tmp.slice(2).forEach(function(b) {
			encodeOctet(bytes, parseInt(b, 10));
		});
		var self$1 = this;
		this._ensure(2 + bytes.length);
		this.writeByte(tag);
		this.writeLength(bytes.length);
		bytes.forEach(function(b) {
			self$1.writeByte(b);
		});
	};
	Writer.prototype.writeLength = function(len) {
		if (typeof len !== "number") throw new TypeError("argument must be a Number");
		this._ensure(4);
		if (len <= 127) this._buf[this._offset++] = len;
		else if (len <= 255) {
			this._buf[this._offset++] = 129;
			this._buf[this._offset++] = len;
		} else if (len <= 65535) {
			this._buf[this._offset++] = 130;
			this._buf[this._offset++] = len >> 8;
			this._buf[this._offset++] = len;
		} else if (len <= 16777215) {
			this._buf[this._offset++] = 131;
			this._buf[this._offset++] = len >> 16;
			this._buf[this._offset++] = len >> 8;
			this._buf[this._offset++] = len;
		} else throw newInvalidAsn1Error("Length too long (> 4 bytes)");
	};
	Writer.prototype.startSequence = function(tag) {
		if (typeof tag !== "number") tag = ASN1.Sequence | ASN1.Constructor;
		this.writeByte(tag);
		this._seq.push(this._offset);
		this._ensure(3);
		this._offset += 3;
	};
	Writer.prototype.endSequence = function() {
		var seq = this._seq.pop();
		var start = seq + 3;
		var len = this._offset - start;
		if (len <= 127) {
			this._shift(start, len, -2);
			this._buf[seq] = len;
		} else if (len <= 255) {
			this._shift(start, len, -1);
			this._buf[seq] = 129;
			this._buf[seq + 1] = len;
		} else if (len <= 65535) {
			this._buf[seq] = 130;
			this._buf[seq + 1] = len >> 8;
			this._buf[seq + 2] = len;
		} else if (len <= 16777215) {
			this._shift(start, len, 1);
			this._buf[seq] = 131;
			this._buf[seq + 1] = len >> 16;
			this._buf[seq + 2] = len >> 8;
			this._buf[seq + 3] = len;
		} else throw newInvalidAsn1Error("Sequence too long");
	};
	Writer.prototype._shift = function(start, len, shift) {
		assert.ok(start !== void 0);
		assert.ok(len !== void 0);
		assert.ok(shift);
		this._buf.copy(this._buf, start + shift, start, start + len);
		this._offset += shift;
	};
	Writer.prototype._ensure = function(len) {
		assert.ok(len);
		if (this._size - this._offset < len) {
			var sz = this._size * this._options.growthFactor;
			if (sz - this._offset < len) sz += len;
			var buf = Buffer.alloc(sz);
			this._buf.copy(buf, 0, 0, this._offset);
			this._buf = buf;
			this._size = sz;
		}
	};
	module.exports = Writer;
}));

//#endregion
//#region ../../node_modules/.bun/asn1@0.2.6/node_modules/asn1/lib/ber/index.js
var require_ber = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var errors = require_errors();
	var types = require_types$1();
	var Reader = require_reader();
	var Writer = require_writer();
	module.exports = {
		Reader,
		Writer
	};
	for (var t in types) if (types.hasOwnProperty(t)) module.exports[t] = types[t];
	for (var e in errors) if (errors.hasOwnProperty(e)) module.exports[e] = errors[e];
}));

//#endregion
//#region ../../node_modules/.bun/asn1@0.2.6/node_modules/asn1/lib/index.js
var require_lib$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Ber = require_ber();
	module.exports = {
		Ber,
		BerReader: Ber.Reader,
		BerWriter: Ber.Writer
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/formats/pkcs1.js
var require_pkcs1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ber = require_lib$2().Ber;
	var _ = require_utils$2()._;
	var utils = require_utils$2();
	const PRIVATE_OPENING_BOUNDARY = "-----BEGIN RSA PRIVATE KEY-----";
	const PRIVATE_CLOSING_BOUNDARY = "-----END RSA PRIVATE KEY-----";
	const PUBLIC_OPENING_BOUNDARY = "-----BEGIN RSA PUBLIC KEY-----";
	const PUBLIC_CLOSING_BOUNDARY = "-----END RSA PUBLIC KEY-----";
	module.exports = {
		privateExport: function(key, options) {
			options = options || {};
			var n = key.n.toBuffer();
			var d = key.d.toBuffer();
			var p = key.p.toBuffer();
			var q = key.q.toBuffer();
			var dmp1 = key.dmp1.toBuffer();
			var dmq1 = key.dmq1.toBuffer();
			var coeff = key.coeff.toBuffer();
			var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512;
			var writer = new ber.Writer({ size: length });
			writer.startSequence();
			writer.writeInt(0);
			writer.writeBuffer(n, 2);
			writer.writeInt(key.e);
			writer.writeBuffer(d, 2);
			writer.writeBuffer(p, 2);
			writer.writeBuffer(q, 2);
			writer.writeBuffer(dmp1, 2);
			writer.writeBuffer(dmq1, 2);
			writer.writeBuffer(coeff, 2);
			writer.endSequence();
			if (options.type === "der") return writer.buffer;
			else return PRIVATE_OPENING_BOUNDARY + "\n" + utils.linebrk(writer.buffer.toString("base64"), 64) + "\n-----END RSA PRIVATE KEY-----";
		},
		privateImport: function(key, data, options) {
			options = options || {};
			var buffer$1;
			if (options.type !== "der") {
				if (Buffer.isBuffer(data)) data = data.toString("utf8");
				if (_.isString(data)) {
					var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\s+|\n\r|\n|\r$/gm, "");
					buffer$1 = Buffer.from(pem, "base64");
				} else throw Error("Unsupported key format");
			} else if (Buffer.isBuffer(data)) buffer$1 = data;
			else throw Error("Unsupported key format");
			var reader = new ber.Reader(buffer$1);
			reader.readSequence();
			reader.readString(2, true);
			key.setPrivate(reader.readString(2, true), reader.readString(2, true), reader.readString(2, true), reader.readString(2, true), reader.readString(2, true), reader.readString(2, true), reader.readString(2, true), reader.readString(2, true));
		},
		publicExport: function(key, options) {
			options = options || {};
			var n = key.n.toBuffer();
			var length = n.length + 512;
			var bodyWriter = new ber.Writer({ size: length });
			bodyWriter.startSequence();
			bodyWriter.writeBuffer(n, 2);
			bodyWriter.writeInt(key.e);
			bodyWriter.endSequence();
			if (options.type === "der") return bodyWriter.buffer;
			else return PUBLIC_OPENING_BOUNDARY + "\n" + utils.linebrk(bodyWriter.buffer.toString("base64"), 64) + "\n-----END RSA PUBLIC KEY-----";
		},
		publicImport: function(key, data, options) {
			options = options || {};
			var buffer$1;
			if (options.type !== "der") {
				if (Buffer.isBuffer(data)) data = data.toString("utf8");
				if (_.isString(data)) {
					var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\s+|\n\r|\n|\r$/gm, "");
					buffer$1 = Buffer.from(pem, "base64");
				}
			} else if (Buffer.isBuffer(data)) buffer$1 = data;
			else throw Error("Unsupported key format");
			var body = new ber.Reader(buffer$1);
			body.readSequence();
			key.setPublic(body.readString(2, true), body.readString(2, true));
		},
		autoImport: function(key, data) {
			if (/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(data)) {
				module.exports.privateImport(key, data);
				return true;
			}
			if (/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(data)) {
				module.exports.publicImport(key, data);
				return true;
			}
			return false;
		}
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/formats/pkcs8.js
var require_pkcs8 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ber = require_lib$2().Ber;
	var _ = require_utils$2()._;
	var PUBLIC_RSA_OID = "1.2.840.113549.1.1.1";
	var utils = require_utils$2();
	const PRIVATE_OPENING_BOUNDARY = "-----BEGIN PRIVATE KEY-----";
	const PRIVATE_CLOSING_BOUNDARY = "-----END PRIVATE KEY-----";
	const PUBLIC_OPENING_BOUNDARY = "-----BEGIN PUBLIC KEY-----";
	const PUBLIC_CLOSING_BOUNDARY = "-----END PUBLIC KEY-----";
	module.exports = {
		privateExport: function(key, options) {
			options = options || {};
			var n = key.n.toBuffer();
			var d = key.d.toBuffer();
			var p = key.p.toBuffer();
			var q = key.q.toBuffer();
			var dmp1 = key.dmp1.toBuffer();
			var dmq1 = key.dmq1.toBuffer();
			var coeff = key.coeff.toBuffer();
			var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512;
			var bodyWriter = new ber.Writer({ size: length });
			bodyWriter.startSequence();
			bodyWriter.writeInt(0);
			bodyWriter.writeBuffer(n, 2);
			bodyWriter.writeInt(key.e);
			bodyWriter.writeBuffer(d, 2);
			bodyWriter.writeBuffer(p, 2);
			bodyWriter.writeBuffer(q, 2);
			bodyWriter.writeBuffer(dmp1, 2);
			bodyWriter.writeBuffer(dmq1, 2);
			bodyWriter.writeBuffer(coeff, 2);
			bodyWriter.endSequence();
			var writer = new ber.Writer({ size: length });
			writer.startSequence();
			writer.writeInt(0);
			writer.startSequence();
			writer.writeOID(PUBLIC_RSA_OID);
			writer.writeNull();
			writer.endSequence();
			writer.writeBuffer(bodyWriter.buffer, 4);
			writer.endSequence();
			if (options.type === "der") return writer.buffer;
			else return PRIVATE_OPENING_BOUNDARY + "\n" + utils.linebrk(writer.buffer.toString("base64"), 64) + "\n-----END PRIVATE KEY-----";
		},
		privateImport: function(key, data, options) {
			options = options || {};
			var buffer$1;
			if (options.type !== "der") {
				if (Buffer.isBuffer(data)) data = data.toString("utf8");
				if (_.isString(data)) {
					var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace("-----END PRIVATE KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
					buffer$1 = Buffer.from(pem, "base64");
				} else throw Error("Unsupported key format");
			} else if (Buffer.isBuffer(data)) buffer$1 = data;
			else throw Error("Unsupported key format");
			var reader = new ber.Reader(buffer$1);
			reader.readSequence();
			reader.readInt(0);
			if (new ber.Reader(reader.readString(48, true)).readOID(6, true) !== PUBLIC_RSA_OID) throw Error("Invalid Public key format");
			var body = new ber.Reader(reader.readString(4, true));
			body.readSequence();
			body.readString(2, true);
			key.setPrivate(body.readString(2, true), body.readString(2, true), body.readString(2, true), body.readString(2, true), body.readString(2, true), body.readString(2, true), body.readString(2, true), body.readString(2, true));
		},
		publicExport: function(key, options) {
			options = options || {};
			var n = key.n.toBuffer();
			var length = n.length + 512;
			var bodyWriter = new ber.Writer({ size: length });
			bodyWriter.writeByte(0);
			bodyWriter.startSequence();
			bodyWriter.writeBuffer(n, 2);
			bodyWriter.writeInt(key.e);
			bodyWriter.endSequence();
			var writer = new ber.Writer({ size: length });
			writer.startSequence();
			writer.startSequence();
			writer.writeOID(PUBLIC_RSA_OID);
			writer.writeNull();
			writer.endSequence();
			writer.writeBuffer(bodyWriter.buffer, 3);
			writer.endSequence();
			if (options.type === "der") return writer.buffer;
			else return PUBLIC_OPENING_BOUNDARY + "\n" + utils.linebrk(writer.buffer.toString("base64"), 64) + "\n-----END PUBLIC KEY-----";
		},
		publicImport: function(key, data, options) {
			options = options || {};
			var buffer$1;
			if (options.type !== "der") {
				if (Buffer.isBuffer(data)) data = data.toString("utf8");
				if (_.isString(data)) {
					var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\s+|\n\r|\n|\r$/gm, "");
					buffer$1 = Buffer.from(pem, "base64");
				}
			} else if (Buffer.isBuffer(data)) buffer$1 = data;
			else throw Error("Unsupported key format");
			var reader = new ber.Reader(buffer$1);
			reader.readSequence();
			if (new ber.Reader(reader.readString(48, true)).readOID(6, true) !== PUBLIC_RSA_OID) throw Error("Invalid Public key format");
			var body = new ber.Reader(reader.readString(3, true));
			body.readByte();
			body.readSequence();
			key.setPublic(body.readString(2, true), body.readString(2, true));
		},
		autoImport: function(key, data) {
			if (/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(data)) {
				module.exports.privateImport(key, data);
				return true;
			}
			if (/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(data)) {
				module.exports.publicImport(key, data);
				return true;
			}
			return false;
		}
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/formats/components.js
var require_components = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require_utils$2()._;
	require_utils$2();
	module.exports = {
		privateExport: function(key, options) {
			return {
				n: key.n.toBuffer(),
				e: key.e,
				d: key.d.toBuffer(),
				p: key.p.toBuffer(),
				q: key.q.toBuffer(),
				dmp1: key.dmp1.toBuffer(),
				dmq1: key.dmq1.toBuffer(),
				coeff: key.coeff.toBuffer()
			};
		},
		privateImport: function(key, data, options) {
			if (data.n && data.e && data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) key.setPrivate(data.n, data.e, data.d, data.p, data.q, data.dmp1, data.dmq1, data.coeff);
			else throw Error("Invalid key data");
		},
		publicExport: function(key, options) {
			return {
				n: key.n.toBuffer(),
				e: key.e
			};
		},
		publicImport: function(key, data, options) {
			if (data.n && data.e) key.setPublic(data.n, data.e);
			else throw Error("Invalid key data");
		},
		autoImport: function(key, data) {
			if (data.n && data.e) if (data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {
				module.exports.privateImport(key, data);
				return true;
			} else {
				module.exports.publicImport(key, data);
				return true;
			}
			return false;
		}
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/formats/openssh.js
var require_openssh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var _ = require_utils$2()._;
	var utils = require_utils$2();
	var BigInteger = require_jsbn();
	const PRIVATE_OPENING_BOUNDARY = "-----BEGIN OPENSSH PRIVATE KEY-----";
	const PRIVATE_CLOSING_BOUNDARY = "-----END OPENSSH PRIVATE KEY-----";
	module.exports = {
		privateExport: function(key, options) {
			const nbuf = key.n.toBuffer();
			let ebuf = Buffer.alloc(4);
			ebuf.writeUInt32BE(key.e, 0);
			while (ebuf[0] === 0) ebuf = ebuf.slice(1);
			const dbuf = key.d.toBuffer();
			const coeffbuf = key.coeff.toBuffer();
			const pbuf = key.p.toBuffer();
			const qbuf = key.q.toBuffer();
			let commentbuf;
			if (typeof key.sshcomment !== "undefined") commentbuf = Buffer.from(key.sshcomment);
			else commentbuf = Buffer.from([]);
			const pubkeyLength = 15 + ebuf.byteLength + 4 + nbuf.byteLength;
			const privateKeyLength = 23 + nbuf.byteLength + 4 + ebuf.byteLength + 4 + dbuf.byteLength + 4 + coeffbuf.byteLength + 4 + pbuf.byteLength + 4 + qbuf.byteLength + 4 + commentbuf.byteLength;
			let length = 43 + pubkeyLength + 4 + privateKeyLength;
			const paddingLength = Math.ceil(privateKeyLength / 8) * 8 - privateKeyLength;
			length += paddingLength;
			const buf = Buffer.alloc(length);
			const writer = {
				buf,
				off: 0
			};
			buf.write("openssh-key-v1", "utf8");
			buf.writeUInt8(0, 14);
			writer.off += 15;
			writeOpenSSHKeyString(writer, Buffer.from("none"));
			writeOpenSSHKeyString(writer, Buffer.from("none"));
			writeOpenSSHKeyString(writer, Buffer.from(""));
			writer.off = writer.buf.writeUInt32BE(1, writer.off);
			writer.off = writer.buf.writeUInt32BE(pubkeyLength, writer.off);
			writeOpenSSHKeyString(writer, Buffer.from("ssh-rsa"));
			writeOpenSSHKeyString(writer, ebuf);
			writeOpenSSHKeyString(writer, nbuf);
			writer.off = writer.buf.writeUInt32BE(length - 47 - pubkeyLength, writer.off);
			writer.off += 8;
			writeOpenSSHKeyString(writer, Buffer.from("ssh-rsa"));
			writeOpenSSHKeyString(writer, nbuf);
			writeOpenSSHKeyString(writer, ebuf);
			writeOpenSSHKeyString(writer, dbuf);
			writeOpenSSHKeyString(writer, coeffbuf);
			writeOpenSSHKeyString(writer, pbuf);
			writeOpenSSHKeyString(writer, qbuf);
			writeOpenSSHKeyString(writer, commentbuf);
			let pad = 1;
			while (writer.off < length) writer.off = writer.buf.writeUInt8(pad++, writer.off);
			if (options.type === "der") return writer.buf;
			else return PRIVATE_OPENING_BOUNDARY + "\n" + utils.linebrk(buf.toString("base64"), 70) + "\n-----END OPENSSH PRIVATE KEY-----\n";
		},
		privateImport: function(key, data, options) {
			options = options || {};
			var buffer$1;
			if (options.type !== "der") {
				if (Buffer.isBuffer(data)) data = data.toString("utf8");
				if (_.isString(data)) {
					var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\s+|\n\r|\n|\r$/gm, "");
					buffer$1 = Buffer.from(pem, "base64");
				} else throw Error("Unsupported key format");
			} else if (Buffer.isBuffer(data)) buffer$1 = data;
			else throw Error("Unsupported key format");
			const reader = {
				buf: buffer$1,
				off: 0
			};
			if (buffer$1.slice(0, 14).toString("ascii") !== "openssh-key-v1") throw "Invalid file format.";
			reader.off += 15;
			if (readOpenSSHKeyString(reader).toString("ascii") !== "none") throw Error("Unsupported key type");
			if (readOpenSSHKeyString(reader).toString("ascii") !== "none") throw Error("Unsupported key type");
			if (readOpenSSHKeyString(reader).toString("ascii") !== "") throw Error("Unsupported key type");
			reader.off += 4;
			reader.off += 4;
			if (readOpenSSHKeyString(reader).toString("ascii") !== "ssh-rsa") throw Error("Unsupported key type");
			readOpenSSHKeyString(reader);
			readOpenSSHKeyString(reader);
			reader.off += 12;
			if (readOpenSSHKeyString(reader).toString("ascii") !== "ssh-rsa") throw Error("Unsupported key type");
			const n = readOpenSSHKeyString(reader);
			const e = readOpenSSHKeyString(reader);
			const d = readOpenSSHKeyString(reader);
			const coeff = readOpenSSHKeyString(reader);
			const p = readOpenSSHKeyString(reader);
			const q = readOpenSSHKeyString(reader);
			const dint = new BigInteger(d);
			const qint = new BigInteger(q);
			const pint = new BigInteger(p);
			const dp = dint.mod(pint.subtract(BigInteger.ONE));
			const dq = dint.mod(qint.subtract(BigInteger.ONE));
			key.setPrivate(n, e, d, p, q, dp.toBuffer(), dq.toBuffer(), coeff);
			key.sshcomment = readOpenSSHKeyString(reader).toString("ascii");
		},
		publicExport: function(key, options) {
			let ebuf = Buffer.alloc(4);
			ebuf.writeUInt32BE(key.e, 0);
			while (ebuf[0] === 0) ebuf = ebuf.slice(1);
			const nbuf = key.n.toBuffer();
			const buf = Buffer.alloc(ebuf.byteLength + 4 + nbuf.byteLength + 4 + 7 + 4);
			const writer = {
				buf,
				off: 0
			};
			writeOpenSSHKeyString(writer, Buffer.from("ssh-rsa"));
			writeOpenSSHKeyString(writer, ebuf);
			writeOpenSSHKeyString(writer, nbuf);
			let comment = key.sshcomment || "";
			if (options.type === "der") return writer.buf;
			else return "ssh-rsa " + buf.toString("base64") + " " + comment + "\n";
		},
		publicImport: function(key, data, options) {
			options = options || {};
			var buffer$1;
			if (options.type !== "der") {
				if (Buffer.isBuffer(data)) data = data.toString("utf8");
				if (_.isString(data)) {
					if (data.substring(0, 8) !== "ssh-rsa ") throw Error("Unsupported key format");
					let pemEnd = data.indexOf(" ", 8);
					if (pemEnd === -1) pemEnd = data.length;
					else key.sshcomment = data.substring(pemEnd + 1).replace(/\s+|\n\r|\n|\r$/gm, "");
					const pem = data.substring(8, pemEnd).replace(/\s+|\n\r|\n|\r$/gm, "");
					buffer$1 = Buffer.from(pem, "base64");
				} else throw Error("Unsupported key format");
			} else if (Buffer.isBuffer(data)) buffer$1 = data;
			else throw Error("Unsupported key format");
			const reader = {
				buf: buffer$1,
				off: 0
			};
			const type = readOpenSSHKeyString(reader).toString("ascii");
			if (type !== "ssh-rsa") throw Error("Invalid key type: " + type);
			const e = readOpenSSHKeyString(reader);
			const n = readOpenSSHKeyString(reader);
			key.setPublic(n, e);
		},
		autoImport: function(key, data) {
			if (/^[\S\s]*-----BEGIN OPENSSH PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END OPENSSH PRIVATE KEY-----[\S\s]*$/g.test(data)) {
				module.exports.privateImport(key, data);
				return true;
			}
			if (/^[\S\s]*ssh-rsa \s*(?=(([A-Za-z0-9+/=]+\s*)+))\1[\S\s]*$/g.test(data)) {
				module.exports.publicImport(key, data);
				return true;
			}
			return false;
		}
	};
	function readOpenSSHKeyString(reader) {
		const len = reader.buf.readInt32BE(reader.off);
		reader.off += 4;
		const res = reader.buf.slice(reader.off, reader.off + len);
		reader.off += len;
		return res;
	}
	function writeOpenSSHKeyString(writer, data) {
		writer.buf.writeInt32BE(data.byteLength, writer.off);
		writer.off += 4;
		writer.off += data.copy(writer.buf, writer.off);
	}
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/formats/formats.js
var require_formats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require_utils$2()._;
	function formatParse(format) {
		format = format.split("-");
		var keyType = "private";
		var keyOpt = { type: "default" };
		for (var i = 1; i < format.length; i++) if (format[i]) switch (format[i]) {
			case "public":
				keyType = format[i];
				break;
			case "private":
				keyType = format[i];
				break;
			case "pem":
				keyOpt.type = format[i];
				break;
			case "der":
				keyOpt.type = format[i];
				break;
		}
		return {
			scheme: format[0],
			keyType,
			keyOpt
		};
	}
	module.exports = {
		pkcs1: require_pkcs1(),
		pkcs8: require_pkcs8(),
		components: require_components(),
		openssh: require_openssh(),
		isPrivateExport: function(format) {
			return module.exports[format] && typeof module.exports[format].privateExport === "function";
		},
		isPrivateImport: function(format) {
			return module.exports[format] && typeof module.exports[format].privateImport === "function";
		},
		isPublicExport: function(format) {
			return module.exports[format] && typeof module.exports[format].publicExport === "function";
		},
		isPublicImport: function(format) {
			return module.exports[format] && typeof module.exports[format].publicImport === "function";
		},
		detectAndImport: function(key, data, format) {
			if (format === void 0) {
				for (var scheme in module.exports) if (typeof module.exports[scheme].autoImport === "function" && module.exports[scheme].autoImport(key, data)) return true;
			} else if (format) {
				var fmt = formatParse(format);
				if (module.exports[fmt.scheme]) if (fmt.keyType === "private") module.exports[fmt.scheme].privateImport(key, data, fmt.keyOpt);
				else module.exports[fmt.scheme].publicImport(key, data, fmt.keyOpt);
				else throw Error("Unsupported key format");
			}
			return false;
		},
		detectAndExport: function(key, format) {
			if (format) {
				var fmt = formatParse(format);
				if (module.exports[fmt.scheme]) if (fmt.keyType === "private") {
					if (!key.isPrivate()) throw Error("This is not private key");
					return module.exports[fmt.scheme].privateExport(key, fmt.keyOpt);
				} else {
					if (!key.isPublic()) throw Error("This is not public key");
					return module.exports[fmt.scheme].publicExport(key, fmt.keyOpt);
				}
				else throw Error("Unsupported key format");
			}
		}
	};
}));

//#endregion
//#region ../../node_modules/.bun/node-rsa@1.1.1/node_modules/node-rsa/src/NodeRSA.js
var require_NodeRSA = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* RSA library for Node.js
	*
	* Author: rzcoder
	* License MIT
	*/
	var constants = __require("constants");
	var rsa = require_rsa();
	__require("crypto");
	require_lib$2().Ber;
	var _ = require_utils$2()._;
	var utils = require_utils$2();
	var schemes = require_schemes();
	var formats = require_formats();
	if (typeof constants.RSA_NO_PADDING === "undefined") constants.RSA_NO_PADDING = 3;
	module.exports = (function() {
		var SUPPORTED_HASH_ALGORITHMS = {
			node10: [
				"md4",
				"md5",
				"ripemd160",
				"sha1",
				"sha224",
				"sha256",
				"sha384",
				"sha512"
			],
			node: [
				"md4",
				"md5",
				"ripemd160",
				"sha1",
				"sha224",
				"sha256",
				"sha384",
				"sha512"
			],
			iojs: [
				"md4",
				"md5",
				"ripemd160",
				"sha1",
				"sha224",
				"sha256",
				"sha384",
				"sha512"
			],
			browser: [
				"md5",
				"ripemd160",
				"sha1",
				"sha256",
				"sha512"
			]
		};
		var DEFAULT_ENCRYPTION_SCHEME = "pkcs1_oaep";
		var DEFAULT_SIGNING_SCHEME = "pkcs1";
		var DEFAULT_EXPORT_FORMAT = "private";
		var EXPORT_FORMAT_ALIASES = {
			"private": "pkcs1-private-pem",
			"private-der": "pkcs1-private-der",
			"public": "pkcs8-public-pem",
			"public-der": "pkcs8-public-der"
		};
		/**
		* @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}
		* @constructor
		*/
		function NodeRSA(key, format, options) {
			if (!(this instanceof NodeRSA)) return new NodeRSA(key, format, options);
			if (_.isObject(format)) {
				options = format;
				format = void 0;
			}
			this.$options = {
				signingScheme: DEFAULT_SIGNING_SCHEME,
				signingSchemeOptions: {
					hash: "sha256",
					saltLength: null
				},
				encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,
				encryptionSchemeOptions: {
					hash: "sha1",
					label: null
				},
				environment: utils.detectEnvironment(),
				rsaUtils: this
			};
			this.keyPair = new rsa.Key();
			this.$cache = {};
			if (Buffer.isBuffer(key) || _.isString(key)) this.importKey(key, format);
			else if (_.isObject(key)) this.generateKeyPair(key.b, key.e);
			this.setOptions(options);
		}
		/**
		* Set and validate options for key instance
		* @param options
		*/
		NodeRSA.prototype.setOptions = function(options) {
			options = options || {};
			if (options.environment) this.$options.environment = options.environment;
			if (options.signingScheme) {
				if (_.isString(options.signingScheme)) {
					var signingScheme = options.signingScheme.toLowerCase().split("-");
					if (signingScheme.length == 1) if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {
						this.$options.signingSchemeOptions = { hash: signingScheme[0] };
						this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;
					} else {
						this.$options.signingScheme = signingScheme[0];
						this.$options.signingSchemeOptions = { hash: null };
					}
					else {
						this.$options.signingSchemeOptions = { hash: signingScheme[1] };
						this.$options.signingScheme = signingScheme[0];
					}
				} else if (_.isObject(options.signingScheme)) {
					this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;
					this.$options.signingSchemeOptions = _.omit(options.signingScheme, "scheme");
				}
				if (!schemes.isSignature(this.$options.signingScheme)) throw Error("Unsupported signing scheme");
				if (this.$options.signingSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
			}
			if (options.encryptionScheme) {
				if (_.isString(options.encryptionScheme)) {
					this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();
					this.$options.encryptionSchemeOptions = {};
				} else if (_.isObject(options.encryptionScheme)) {
					this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;
					this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, "scheme");
				}
				if (!schemes.isEncryption(this.$options.encryptionScheme)) throw Error("Unsupported encryption scheme");
				if (this.$options.encryptionSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
			}
			this.keyPair.setOptions(this.$options);
		};
		/**
		* Generate private/public keys pair
		*
		* @param bits {int} length key in bits. Default 2048.
		* @param exp {int} public exponent. Default 65537.
		* @returns {NodeRSA}
		*/
		NodeRSA.prototype.generateKeyPair = function(bits, exp) {
			bits = bits || 2048;
			exp = exp || 65537;
			if (bits % 8 !== 0) throw Error("Key size must be a multiple of 8.");
			this.keyPair.generate(bits, exp.toString(16));
			this.$cache = {};
			return this;
		};
		/**
		* Importing key
		* @param keyData {string|buffer|Object}
		* @param format {string}
		*/
		NodeRSA.prototype.importKey = function(keyData, format) {
			if (!keyData) throw Error("Empty key given");
			if (format) format = EXPORT_FORMAT_ALIASES[format] || format;
			if (!formats.detectAndImport(this.keyPair, keyData, format) && format === void 0) throw Error("Key format must be specified");
			this.$cache = {};
			return this;
		};
		/**
		* Exporting key
		* @param [format] {string}
		*/
		NodeRSA.prototype.exportKey = function(format) {
			format = format || DEFAULT_EXPORT_FORMAT;
			format = EXPORT_FORMAT_ALIASES[format] || format;
			if (!this.$cache[format]) this.$cache[format] = formats.detectAndExport(this.keyPair, format);
			return this.$cache[format];
		};
		/**
		* Check if key pair contains private key
		*/
		NodeRSA.prototype.isPrivate = function() {
			return this.keyPair.isPrivate();
		};
		/**
		* Check if key pair contains public key
		* @param [strict] {boolean} - public key only, return false if have private exponent
		*/
		NodeRSA.prototype.isPublic = function(strict) {
			return this.keyPair.isPublic(strict);
		};
		/**
		* Check if key pair doesn't contains any data
		*/
		NodeRSA.prototype.isEmpty = function(strict) {
			return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);
		};
		/**
		* Encrypting data method with public key
		*
		* @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.
		* @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.
		* @param source_encoding {string} - optional. Encoding for given string. Default utf8.
		* @returns {string|Buffer}
		*/
		NodeRSA.prototype.encrypt = function(buffer$1, encoding, source_encoding) {
			return this.$$encryptKey(false, buffer$1, encoding, source_encoding);
		};
		/**
		* Decrypting data method with private key
		*
		* @param buffer {Buffer} - buffer for decrypting
		* @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type
		* @returns {Buffer|object|string}
		*/
		NodeRSA.prototype.decrypt = function(buffer$1, encoding) {
			return this.$$decryptKey(false, buffer$1, encoding);
		};
		/**
		* Encrypting data method with private key
		*
		* Parameters same as `encrypt` method
		*/
		NodeRSA.prototype.encryptPrivate = function(buffer$1, encoding, source_encoding) {
			return this.$$encryptKey(true, buffer$1, encoding, source_encoding);
		};
		/**
		* Decrypting data method with public key
		*
		* Parameters same as `decrypt` method
		*/
		NodeRSA.prototype.decryptPublic = function(buffer$1, encoding) {
			return this.$$decryptKey(true, buffer$1, encoding);
		};
		/**
		* Encrypting data method with custom key
		*/
		NodeRSA.prototype.$$encryptKey = function(usePrivate, buffer$1, encoding, source_encoding) {
			try {
				var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer$1, source_encoding), usePrivate);
				if (encoding == "buffer" || !encoding) return res;
				else return res.toString(encoding);
			} catch (e) {
				throw Error("Error during encryption. Original error: " + e);
			}
		};
		/**
		* Decrypting data method with custom key
		*/
		NodeRSA.prototype.$$decryptKey = function(usePublic, buffer$1, encoding) {
			try {
				buffer$1 = _.isString(buffer$1) ? Buffer.from(buffer$1, "base64") : buffer$1;
				var res = this.keyPair.decrypt(buffer$1, usePublic);
				if (res === null) throw Error("Key decrypt method returns null.");
				return this.$getDecryptedData(res, encoding);
			} catch (e) {
				throw Error("Error during decryption (probably incorrect key). Original error: " + e);
			}
		};
		/**
		*  Signing data
		*
		* @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.
		* @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.
		* @param source_encoding {string} - optional. Encoding for given string. Default utf8.
		* @returns {string|Buffer}
		*/
		NodeRSA.prototype.sign = function(buffer$1, encoding, source_encoding) {
			if (!this.isPrivate()) throw Error("This is not private key");
			var res = this.keyPair.sign(this.$getDataForEncrypt(buffer$1, source_encoding));
			if (encoding && encoding != "buffer") res = res.toString(encoding);
			return res;
		};
		/**
		*  Verifying signed data
		*
		* @param buffer - signed data
		* @param signature
		* @param source_encoding {string} - optional. Encoding for given string. Default utf8.
		* @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.
		* @returns {*}
		*/
		NodeRSA.prototype.verify = function(buffer$1, signature, source_encoding, signature_encoding) {
			if (!this.isPublic()) throw Error("This is not public key");
			signature_encoding = !signature_encoding || signature_encoding == "buffer" ? null : signature_encoding;
			return this.keyPair.verify(this.$getDataForEncrypt(buffer$1, source_encoding), signature, signature_encoding);
		};
		/**
		* Returns key size in bits
		* @returns {int}
		*/
		NodeRSA.prototype.getKeySize = function() {
			return this.keyPair.keySize;
		};
		/**
		* Returns max message length in bytes (for 1 chunk) depending on current encryption scheme
		* @returns {int}
		*/
		NodeRSA.prototype.getMaxMessageSize = function() {
			return this.keyPair.maxMessageLength;
		};
		/**
		* Preparing given data for encrypting/signing. Just make new/return Buffer object.
		*
		* @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.
		* @param encoding {string} - optional. Encoding for given string. Default utf8.
		* @returns {Buffer}
		*/
		NodeRSA.prototype.$getDataForEncrypt = function(buffer$1, encoding) {
			if (_.isString(buffer$1) || _.isNumber(buffer$1)) return Buffer.from("" + buffer$1, encoding || "utf8");
			else if (Buffer.isBuffer(buffer$1)) return buffer$1;
			else if (_.isObject(buffer$1)) return Buffer.from(JSON.stringify(buffer$1));
			else throw Error("Unexpected data type");
		};
		/**
		*
		* @param buffer {Buffer} - decrypted data.
		* @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.
		* @returns {*}
		*/
		NodeRSA.prototype.$getDecryptedData = function(buffer$1, encoding) {
			encoding = encoding || "buffer";
			if (encoding == "buffer") return buffer$1;
			else if (encoding == "json") return JSON.parse(buffer$1.toString());
			else return buffer$1.toString(encoding);
		};
		return NodeRSA;
	})();
}));

//#endregion
//#region ../../node_modules/.bun/xpath@0.0.33/node_modules/xpath/xpath.js
var require_xpath = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function(exports$1) {
		"use strict";
		function curry(func) {
			var slice = Array.prototype.slice, totalargs = func.length, partial$1 = function(args, fn$2) {
				return function() {
					return fn$2.apply(this, args.concat(slice.call(arguments)));
				};
			}, fn$1 = function() {
				var args = slice.call(arguments);
				return args.length < totalargs ? partial$1(args, fn$1) : func.apply(this, slice.apply(arguments, [0, totalargs]));
			};
			return fn$1;
		}
		var forEach = function(f, xs) {
			for (var i = 0; i < xs.length; i += 1) f(xs[i], i, xs);
		};
		var reduce = function(f, seed, xs) {
			var acc = seed;
			forEach(function(x, i) {
				acc = f(acc, x, i);
			}, xs);
			return acc;
		};
		var map$1 = function(f, xs) {
			var mapped = new Array(xs.length);
			forEach(function(x, i) {
				mapped[i] = f(x);
			}, xs);
			return mapped;
		};
		var filter = function(f, xs) {
			var filtered = [];
			forEach(function(x, i) {
				if (f(x, i)) filtered.push(x);
			}, xs);
			return filtered;
		};
		var includes = function(values, value) {
			for (var i = 0; i < values.length; i += 1) if (values[i] === value) return true;
			return false;
		};
		function always(value) {
			return function() {
				return value;
			};
		}
		function toString(x) {
			return x.toString();
		}
		var join = function(s, xs) {
			return xs.join(s);
		};
		var wrap = function(pref, suf, str) {
			return pref + str + suf;
		};
		var prototypeConcat = Array.prototype.concat;
		var MAX_ARGUMENT_LENGTH = 32767;
		function flatten(arr) {
			var result = [];
			for (var start = 0; start < arr.length; start += MAX_ARGUMENT_LENGTH) {
				var chunk = arr.slice(start, start + MAX_ARGUMENT_LENGTH);
				result = prototypeConcat.apply(result, chunk);
			}
			return result;
		}
		function assign(target, varArgs) {
			var to = Object(target);
			for (var index = 1; index < arguments.length; index++) {
				var nextSource = arguments[index];
				if (nextSource != null) {
					for (var nextKey in nextSource) if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) to[nextKey] = nextSource[nextKey];
				}
			}
			return to;
		}
		var NodeTypes = {
			ELEMENT_NODE: 1,
			ATTRIBUTE_NODE: 2,
			TEXT_NODE: 3,
			CDATA_SECTION_NODE: 4,
			PROCESSING_INSTRUCTION_NODE: 7,
			COMMENT_NODE: 8,
			DOCUMENT_NODE: 9,
			DOCUMENT_TYPE_NODE: 10,
			DOCUMENT_FRAGMENT_NODE: 11
		};
		XPathParser.prototype = /* @__PURE__ */ new Object();
		XPathParser.prototype.constructor = XPathParser;
		XPathParser.superclass = Object.prototype;
		function XPathParser() {
			this.init();
		}
		XPathParser.prototype.init = function() {
			this.reduceActions = [];
			this.reduceActions[3] = function(rhs) {
				return new OrOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[5] = function(rhs) {
				return new AndOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[7] = function(rhs) {
				return new EqualsOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[8] = function(rhs) {
				return new NotEqualOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[10] = function(rhs) {
				return new LessThanOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[11] = function(rhs) {
				return new GreaterThanOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[12] = function(rhs) {
				return new LessThanOrEqualOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[13] = function(rhs) {
				return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[15] = function(rhs) {
				return new PlusOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[16] = function(rhs) {
				return new MinusOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[18] = function(rhs) {
				return new MultiplyOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[19] = function(rhs) {
				return new DivOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[20] = function(rhs) {
				return new ModOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[22] = function(rhs) {
				return new UnaryMinusOperation(rhs[1]);
			};
			this.reduceActions[24] = function(rhs) {
				return new BarOperation(rhs[0], rhs[2]);
			};
			this.reduceActions[25] = function(rhs) {
				return new PathExpr(void 0, void 0, rhs[0]);
			};
			this.reduceActions[27] = function(rhs) {
				rhs[0].locationPath = rhs[2];
				return rhs[0];
			};
			this.reduceActions[28] = function(rhs) {
				rhs[0].locationPath = rhs[2];
				rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
				return rhs[0];
			};
			this.reduceActions[29] = function(rhs) {
				return new PathExpr(rhs[0], [], void 0);
			};
			this.reduceActions[30] = function(rhs) {
				if (Utilities.instance_of(rhs[0], PathExpr)) {
					if (rhs[0].filterPredicates == void 0) rhs[0].filterPredicates = [];
					rhs[0].filterPredicates.push(rhs[1]);
					return rhs[0];
				} else return new PathExpr(rhs[0], [rhs[1]], void 0);
			};
			this.reduceActions[32] = function(rhs) {
				return rhs[1];
			};
			this.reduceActions[33] = function(rhs) {
				return new XString(rhs[0]);
			};
			this.reduceActions[34] = function(rhs) {
				return new XNumber(rhs[0]);
			};
			this.reduceActions[36] = function(rhs) {
				return new FunctionCall(rhs[0], []);
			};
			this.reduceActions[37] = function(rhs) {
				return new FunctionCall(rhs[0], rhs[2]);
			};
			this.reduceActions[38] = function(rhs) {
				return [rhs[0]];
			};
			this.reduceActions[39] = function(rhs) {
				rhs[2].unshift(rhs[0]);
				return rhs[2];
			};
			this.reduceActions[43] = function(rhs) {
				return new LocationPath(true, []);
			};
			this.reduceActions[44] = function(rhs) {
				rhs[1].absolute = true;
				return rhs[1];
			};
			this.reduceActions[46] = function(rhs) {
				return new LocationPath(false, [rhs[0]]);
			};
			this.reduceActions[47] = function(rhs) {
				rhs[0].steps.push(rhs[2]);
				return rhs[0];
			};
			this.reduceActions[49] = function(rhs) {
				return new Step(rhs[0], rhs[1], []);
			};
			this.reduceActions[50] = function(rhs) {
				return new Step(Step.CHILD, rhs[0], []);
			};
			this.reduceActions[51] = function(rhs) {
				return new Step(rhs[0], rhs[1], rhs[2]);
			};
			this.reduceActions[52] = function(rhs) {
				return new Step(Step.CHILD, rhs[0], rhs[1]);
			};
			this.reduceActions[54] = function(rhs) {
				return [rhs[0]];
			};
			this.reduceActions[55] = function(rhs) {
				rhs[1].unshift(rhs[0]);
				return rhs[1];
			};
			this.reduceActions[56] = function(rhs) {
				if (rhs[0] == "ancestor") return Step.ANCESTOR;
				else if (rhs[0] == "ancestor-or-self") return Step.ANCESTORORSELF;
				else if (rhs[0] == "attribute") return Step.ATTRIBUTE;
				else if (rhs[0] == "child") return Step.CHILD;
				else if (rhs[0] == "descendant") return Step.DESCENDANT;
				else if (rhs[0] == "descendant-or-self") return Step.DESCENDANTORSELF;
				else if (rhs[0] == "following") return Step.FOLLOWING;
				else if (rhs[0] == "following-sibling") return Step.FOLLOWINGSIBLING;
				else if (rhs[0] == "namespace") return Step.NAMESPACE;
				else if (rhs[0] == "parent") return Step.PARENT;
				else if (rhs[0] == "preceding") return Step.PRECEDING;
				else if (rhs[0] == "preceding-sibling") return Step.PRECEDINGSIBLING;
				else if (rhs[0] == "self") return Step.SELF;
				return -1;
			};
			this.reduceActions[57] = function(rhs) {
				return Step.ATTRIBUTE;
			};
			this.reduceActions[59] = function(rhs) {
				if (rhs[0] == "comment") return NodeTest.commentTest;
				else if (rhs[0] == "text") return NodeTest.textTest;
				else if (rhs[0] == "processing-instruction") return NodeTest.anyPiTest;
				else if (rhs[0] == "node") return NodeTest.nodeTest;
				return new NodeTest(-1, void 0);
			};
			this.reduceActions[60] = function(rhs) {
				return new NodeTest.PITest(rhs[2]);
			};
			this.reduceActions[61] = function(rhs) {
				return rhs[1];
			};
			this.reduceActions[63] = function(rhs) {
				rhs[1].absolute = true;
				rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
				return rhs[1];
			};
			this.reduceActions[64] = function(rhs) {
				rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
				rhs[0].steps.push(rhs[2]);
				return rhs[0];
			};
			this.reduceActions[65] = function(rhs) {
				return new Step(Step.SELF, NodeTest.nodeTest, []);
			};
			this.reduceActions[66] = function(rhs) {
				return new Step(Step.PARENT, NodeTest.nodeTest, []);
			};
			this.reduceActions[67] = function(rhs) {
				return new VariableReference(rhs[1]);
			};
			this.reduceActions[68] = function(rhs) {
				return NodeTest.nameTestAny;
			};
			this.reduceActions[69] = function(rhs) {
				return new NodeTest.NameTestPrefixAny(rhs[0].split(":")[0]);
			};
			this.reduceActions[70] = function(rhs) {
				return new NodeTest.NameTestQName(rhs[0]);
			};
		};
		XPathParser.actionTable = [
			" s s        sssssssss    s ss  s  ss",
			"                 s                  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"                rrrrr               ",
			" s s        sssssssss    s ss  s  ss",
			"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
			" s s        sssssssss    s ss  s  ss",
			"                            s       ",
			"                            s       ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"  s                                 ",
			"                            s       ",
			" s           s  sssss          s  s ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"a                                   ",
			"r       s                    rr  r  ",
			"r      sr                    rr  r  ",
			"r   s  rr            s       rr  r  ",
			"r   rssrr            rss     rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrrsss         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrrs  rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r  srrrrrrrr         rrrrrrs rr sr  ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"                sssss               ",
			"r  rrrrrrrrr         rrrrrrr rr sr  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             s      ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"              s                     ",
			"                             s      ",
			"                rrrrr               ",
			" s s        sssssssss    s sss s  ss",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s s        sssssssss      ss  s  ss",
			" s s        sssssssss    s ss  s  ss",
			" s           s  sssss          s  s ",
			" s           s  sssss          s  s ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			" s           s  sssss          s  s ",
			" s           s  sssss          s  s ",
			"r  rrrrrrrrr         rrrrrrr rr sr  ",
			"r  rrrrrrrrr         rrrrrrr rr sr  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             s      ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             rr     ",
			"                             s      ",
			"                             rs     ",
			"r      sr                    rr  r  ",
			"r   s  rr            s       rr  r  ",
			"r   rssrr            rss     rr  r  ",
			"r   rssrr            rss     rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrr            rrrss   rr  r  ",
			"r   rrrrrsss         rrrrr   rr  r  ",
			"r   rrrrrsss         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrr   rr  r  ",
			"r   rrrrrrrr         rrrrrr  rr  r  ",
			"                                 r  ",
			"                                 s  ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r  srrrrrrrr         rrrrrrs rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr  r  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			" s s        sssssssss    s ss  s  ss",
			"r  rrrrrrrrr         rrrrrrr rr rr  ",
			"                             r      "
		];
		XPathParser.actionTableNumber = [
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"                 J                  ",
			"a  aaaaaaaaa         aaaaaaa aa  a  ",
			"                YYYYY               ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"                            N       ",
			"                            O       ",
			"e  eeeeeeeee         eeeeeee ee ee  ",
			"f  fffffffff         fffffff ff ff  ",
			"d  ddddddddd         ddddddd dd dd  ",
			"B  BBBBBBBBB         BBBBBBB BB BB  ",
			"A  AAAAAAAAA         AAAAAAA AA AA  ",
			"  P                                 ",
			"                            Q       ",
			" 1           .  +*)('          #  \" ",
			"b  bbbbbbbbb         bbbbbbb bb  b  ",
			"                                    ",
			"!       S                    !!  !  ",
			"\"      T\"                    \"\"  \"  ",
			"$   V  $$            U       $$  $  ",
			"&   &ZY&&            &XW     &&  &  ",
			")   )))))            )))\\[   ))  )  ",
			".   ....._^]         .....   ..  .  ",
			"1   11111111         11111   11  1  ",
			"5   55555555         55555`  55  5  ",
			"7   77777777         777777  77  7  ",
			"9   99999999         999999  99  9  ",
			":  c::::::::         ::::::b :: a:  ",
			"I  fIIIIIIII         IIIIIIe II  I  ",
			"=  =========         ======= == ==  ",
			"?  ?????????         ??????? ?? ??  ",
			"C  CCCCCCCCC         CCCCCCC CC CC  ",
			"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
			"M   MMMMMMMM         MMMMMM  MM  M  ",
			"N  NNNNNNNNN         NNNNNNN NN  N  ",
			"P  PPPPPPPPP         PPPPPPP PP  P  ",
			"                +*)('               ",
			"R  RRRRRRRRR         RRRRRRR RR aR  ",
			"U  UUUUUUUUU         UUUUUUU UU  U  ",
			"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
			"c  ccccccccc         ccccccc cc cc  ",
			"                             j      ",
			"L  fLLLLLLLL         LLLLLLe LL  L  ",
			"6   66666666         66666   66  6  ",
			"              k                     ",
			"                             l      ",
			"                XXXXX               ",
			" 1 0        /.-,+*)('    & %$m #  \"!",
			"_  f________         ______e __  _  ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1 0        /.-,+*)('      %$  #  \"!",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			" 1           .  +*)('          #  \" ",
			" 1           .  +*)('          #  \" ",
			">  >>>>>>>>>         >>>>>>> >> >>  ",
			" 1           .  +*)('          #  \" ",
			" 1           .  +*)('          #  \" ",
			"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
			"V  VVVVVVVVV         VVVVVVV VV aV  ",
			"T  TTTTTTTTT         TTTTTTT TT  T  ",
			"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
			"                                   ",
			"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
			"D  DDDDDDDDD         DDDDDDD DD DD  ",
			"                             HH     ",
			"                                   ",
			"                             F     ",
			"#      T#                    ##  #  ",
			"%   V  %%            U       %%  %  ",
			"'   'ZY''            'XW     ''  '  ",
			"(   (ZY((            (XW     ((  (  ",
			"+   +++++            +++\\[   ++  +  ",
			"*   *****            ***\\[   **  *  ",
			"-   -----            ---\\[   --  -  ",
			",   ,,,,,            ,,,\\[   ,,  ,  ",
			"0   00000_^]         00000   00  0  ",
			"/   /////_^]         /////   //  /  ",
			"2   22222222         22222   22  2  ",
			"3   33333333         33333   33  3  ",
			"4   44444444         44444   44  4  ",
			"8   88888888         888888  88  8  ",
			"                                 ^  ",
			"                                   ",
			";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
			"<  f<<<<<<<<         <<<<<<e <<  <  ",
			"O  OOOOOOOOO         OOOOOOO OO  O  ",
			"`  `````````         ``````` ``  `  ",
			"S  SSSSSSSSS         SSSSSSS SS  S  ",
			"W  WWWWWWWWW         WWWWWWW WW  W  ",
			"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
			"E  EEEEEEEEE         EEEEEEE EE EE  ",
			" 1 0        /.-,+*)('    & %$  #  \"!",
			"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
			"                             G      "
		];
		XPathParser.gotoTable = [
			"3456789:;<=>?@ AB  CDEFGH IJ ",
			"                             ",
			"                             ",
			"                             ",
			"L456789:;<=>?@ AB  CDEFGH IJ ",
			"            M        EFGH IJ ",
			"       N;<=>?@ AB  CDEFGH IJ ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"            S        EFGH IJ ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"              e              ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                        h  J ",
			"              i          j   ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"o456789:;<=>?@ ABpqCDEFGH IJ ",
			"                             ",
			"  r6789:;<=>?@ AB  CDEFGH IJ ",
			"   s789:;<=>?@ AB  CDEFGH IJ ",
			"    t89:;<=>?@ AB  CDEFGH IJ ",
			"    u89:;<=>?@ AB  CDEFGH IJ ",
			"     v9:;<=>?@ AB  CDEFGH IJ ",
			"     w9:;<=>?@ AB  CDEFGH IJ ",
			"     x9:;<=>?@ AB  CDEFGH IJ ",
			"     y9:;<=>?@ AB  CDEFGH IJ ",
			"      z:;<=>?@ AB  CDEFGH IJ ",
			"      {:;<=>?@ AB  CDEFGH IJ ",
			"       |;<=>?@ AB  CDEFGH IJ ",
			"       };<=>?@ AB  CDEFGH IJ ",
			"       ~;<=>?@ AB  CDEFGH IJ ",
			"         =>?@ AB  CDEFGH IJ ",
			"456789:;<=>?@ AB  CDEFGH IJ",
			"                    EFGH IJ ",
			"                    EFGH IJ ",
			"                             ",
			"                      GH IJ ",
			"                      GH IJ ",
			"              i             ",
			"              i             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"                             ",
			"o456789:;<=>?@ ABqCDEFGH IJ ",
			"                             ",
			"                             "
		];
		XPathParser.productions = [
			[
				1,
				1,
				2
			],
			[
				2,
				1,
				3
			],
			[
				3,
				1,
				4
			],
			[
				3,
				3,
				3,
				-9,
				4
			],
			[
				4,
				1,
				5
			],
			[
				4,
				3,
				4,
				-8,
				5
			],
			[
				5,
				1,
				6
			],
			[
				5,
				3,
				5,
				-22,
				6
			],
			[
				5,
				3,
				5,
				-5,
				6
			],
			[
				6,
				1,
				7
			],
			[
				6,
				3,
				6,
				-23,
				7
			],
			[
				6,
				3,
				6,
				-24,
				7
			],
			[
				6,
				3,
				6,
				-6,
				7
			],
			[
				6,
				3,
				6,
				-7,
				7
			],
			[
				7,
				1,
				8
			],
			[
				7,
				3,
				7,
				-25,
				8
			],
			[
				7,
				3,
				7,
				-26,
				8
			],
			[
				8,
				1,
				9
			],
			[
				8,
				3,
				8,
				-12,
				9
			],
			[
				8,
				3,
				8,
				-11,
				9
			],
			[
				8,
				3,
				8,
				-10,
				9
			],
			[
				9,
				1,
				10
			],
			[
				9,
				2,
				-26,
				9
			],
			[
				10,
				1,
				11
			],
			[
				10,
				3,
				10,
				-27,
				11
			],
			[
				11,
				1,
				12
			],
			[
				11,
				1,
				13
			],
			[
				11,
				3,
				13,
				-28,
				14
			],
			[
				11,
				3,
				13,
				-4,
				14
			],
			[
				13,
				1,
				15
			],
			[
				13,
				2,
				13,
				16
			],
			[
				15,
				1,
				17
			],
			[
				15,
				3,
				-29,
				2,
				-30
			],
			[
				15,
				1,
				-15
			],
			[
				15,
				1,
				-16
			],
			[
				15,
				1,
				18
			],
			[
				18,
				3,
				-13,
				-29,
				-30
			],
			[
				18,
				4,
				-13,
				-29,
				19,
				-30
			],
			[
				19,
				1,
				20
			],
			[
				19,
				3,
				20,
				-31,
				19
			],
			[
				20,
				1,
				2
			],
			[
				12,
				1,
				14
			],
			[
				12,
				1,
				21
			],
			[
				21,
				1,
				-28
			],
			[
				21,
				2,
				-28,
				14
			],
			[
				21,
				1,
				22
			],
			[
				14,
				1,
				23
			],
			[
				14,
				3,
				14,
				-28,
				23
			],
			[
				14,
				1,
				24
			],
			[
				23,
				2,
				25,
				26
			],
			[
				23,
				1,
				26
			],
			[
				23,
				3,
				25,
				26,
				27
			],
			[
				23,
				2,
				26,
				27
			],
			[
				23,
				1,
				28
			],
			[
				27,
				1,
				16
			],
			[
				27,
				2,
				16,
				27
			],
			[
				25,
				2,
				-14,
				-3
			],
			[
				25,
				1,
				-32
			],
			[
				26,
				1,
				29
			],
			[
				26,
				3,
				-20,
				-29,
				-30
			],
			[
				26,
				4,
				-21,
				-29,
				-15,
				-30
			],
			[
				16,
				3,
				-33,
				30,
				-34
			],
			[
				30,
				1,
				2
			],
			[
				22,
				2,
				-4,
				14
			],
			[
				24,
				3,
				14,
				-4,
				23
			],
			[
				28,
				1,
				-35
			],
			[
				28,
				1,
				-2
			],
			[
				17,
				2,
				-36,
				-18
			],
			[
				29,
				1,
				-17
			],
			[
				29,
				1,
				-19
			],
			[
				29,
				1,
				-18
			]
		];
		XPathParser.DOUBLEDOT = 2;
		XPathParser.DOUBLECOLON = 3;
		XPathParser.DOUBLESLASH = 4;
		XPathParser.NOTEQUAL = 5;
		XPathParser.LESSTHANOREQUAL = 6;
		XPathParser.GREATERTHANOREQUAL = 7;
		XPathParser.AND = 8;
		XPathParser.OR = 9;
		XPathParser.MOD = 10;
		XPathParser.DIV = 11;
		XPathParser.MULTIPLYOPERATOR = 12;
		XPathParser.FUNCTIONNAME = 13;
		XPathParser.AXISNAME = 14;
		XPathParser.LITERAL = 15;
		XPathParser.NUMBER = 16;
		XPathParser.ASTERISKNAMETEST = 17;
		XPathParser.QNAME = 18;
		XPathParser.NCNAMECOLONASTERISK = 19;
		XPathParser.NODETYPE = 20;
		XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
		XPathParser.EQUALS = 22;
		XPathParser.LESSTHAN = 23;
		XPathParser.GREATERTHAN = 24;
		XPathParser.PLUS = 25;
		XPathParser.MINUS = 26;
		XPathParser.BAR = 27;
		XPathParser.SLASH = 28;
		XPathParser.LEFTPARENTHESIS = 29;
		XPathParser.RIGHTPARENTHESIS = 30;
		XPathParser.COMMA = 31;
		XPathParser.AT = 32;
		XPathParser.LEFTBRACKET = 33;
		XPathParser.RIGHTBRACKET = 34;
		XPathParser.DOT = 35;
		XPathParser.DOLLAR = 36;
		XPathParser.prototype.tokenize = function(s1) {
			var types = [];
			var values = [];
			var s = s1 + "\0";
			var pos = 0;
			var c = s.charAt(pos++);
			while (1) {
				while (c == " " || c == "	" || c == "\r" || c == "\n") c = s.charAt(pos++);
				if (c == "\0" || pos >= s.length) break;
				if (c == "(") {
					types.push(XPathParser.LEFTPARENTHESIS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ")") {
					types.push(XPathParser.RIGHTPARENTHESIS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "[") {
					types.push(XPathParser.LEFTBRACKET);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "]") {
					types.push(XPathParser.RIGHTBRACKET);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "@") {
					types.push(XPathParser.AT);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ",") {
					types.push(XPathParser.COMMA);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "|") {
					types.push(XPathParser.BAR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "+") {
					types.push(XPathParser.PLUS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "-") {
					types.push(XPathParser.MINUS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "=") {
					types.push(XPathParser.EQUALS);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == "$") {
					types.push(XPathParser.DOLLAR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ".") {
					c = s.charAt(pos++);
					if (c == ".") {
						types.push(XPathParser.DOUBLEDOT);
						values.push("..");
						c = s.charAt(pos++);
						continue;
					}
					if (c >= "0" && c <= "9") {
						var number$3 = "." + c;
						c = s.charAt(pos++);
						while (c >= "0" && c <= "9") {
							number$3 += c;
							c = s.charAt(pos++);
						}
						types.push(XPathParser.NUMBER);
						values.push(number$3);
						continue;
					}
					types.push(XPathParser.DOT);
					values.push(".");
					continue;
				}
				if (c == "'" || c == "\"") {
					var delimiter = c;
					var literal$1 = "";
					while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
						literal$1 += c;
						pos += 1;
					}
					if (c !== delimiter) throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal$1);
					pos += 1;
					types.push(XPathParser.LITERAL);
					values.push(literal$1);
					c = s.charAt(pos++);
					continue;
				}
				if (c >= "0" && c <= "9") {
					var number$3 = c;
					c = s.charAt(pos++);
					while (c >= "0" && c <= "9") {
						number$3 += c;
						c = s.charAt(pos++);
					}
					if (c == ".") {
						if (s.charAt(pos) >= "0" && s.charAt(pos) <= "9") {
							number$3 += c;
							number$3 += s.charAt(pos++);
							c = s.charAt(pos++);
							while (c >= "0" && c <= "9") {
								number$3 += c;
								c = s.charAt(pos++);
							}
						}
					}
					types.push(XPathParser.NUMBER);
					values.push(number$3);
					continue;
				}
				if (c == "*") {
					if (types.length > 0) {
						var last = types[types.length - 1];
						if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
							types.push(XPathParser.MULTIPLYOPERATOR);
							values.push(c);
							c = s.charAt(pos++);
							continue;
						}
					}
					types.push(XPathParser.ASTERISKNAMETEST);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
				if (c == ":") {
					if (s.charAt(pos) == ":") {
						types.push(XPathParser.DOUBLECOLON);
						values.push("::");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
				}
				if (c == "/") {
					c = s.charAt(pos++);
					if (c == "/") {
						types.push(XPathParser.DOUBLESLASH);
						values.push("//");
						c = s.charAt(pos++);
						continue;
					}
					types.push(XPathParser.SLASH);
					values.push("/");
					continue;
				}
				if (c == "!") {
					if (s.charAt(pos) == "=") {
						types.push(XPathParser.NOTEQUAL);
						values.push("!=");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
				}
				if (c == "<") {
					if (s.charAt(pos) == "=") {
						types.push(XPathParser.LESSTHANOREQUAL);
						values.push("<=");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
					types.push(XPathParser.LESSTHAN);
					values.push("<");
					c = s.charAt(pos++);
					continue;
				}
				if (c == ">") {
					if (s.charAt(pos) == "=") {
						types.push(XPathParser.GREATERTHANOREQUAL);
						values.push(">=");
						pos++;
						c = s.charAt(pos++);
						continue;
					}
					types.push(XPathParser.GREATERTHAN);
					values.push(">");
					c = s.charAt(pos++);
					continue;
				}
				if (c == "_" || Utilities.isLetter(c.charCodeAt(0))) {
					var name$1 = c;
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name$1 += c;
						c = s.charAt(pos++);
					}
					if (types.length > 0) {
						var last = types[types.length - 1];
						if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
							if (name$1 == "and") {
								types.push(XPathParser.AND);
								values.push(name$1);
								continue;
							}
							if (name$1 == "or") {
								types.push(XPathParser.OR);
								values.push(name$1);
								continue;
							}
							if (name$1 == "mod") {
								types.push(XPathParser.MOD);
								values.push(name$1);
								continue;
							}
							if (name$1 == "div") {
								types.push(XPathParser.DIV);
								values.push(name$1);
								continue;
							}
						}
					}
					if (c == ":") {
						if (s.charAt(pos) == "*") {
							types.push(XPathParser.NCNAMECOLONASTERISK);
							values.push(name$1 + ":*");
							pos++;
							c = s.charAt(pos++);
							continue;
						}
						if (s.charAt(pos) == "_" || Utilities.isLetter(s.charCodeAt(pos))) {
							name$1 += ":";
							c = s.charAt(pos++);
							while (Utilities.isNCNameChar(c.charCodeAt(0))) {
								name$1 += c;
								c = s.charAt(pos++);
							}
							if (c == "(") {
								types.push(XPathParser.FUNCTIONNAME);
								values.push(name$1);
								continue;
							}
							types.push(XPathParser.QNAME);
							values.push(name$1);
							continue;
						}
						if (s.charAt(pos) == ":") {
							types.push(XPathParser.AXISNAME);
							values.push(name$1);
							continue;
						}
					}
					if (c == "(") {
						if (name$1 == "comment" || name$1 == "text" || name$1 == "node") {
							types.push(XPathParser.NODETYPE);
							values.push(name$1);
							continue;
						}
						if (name$1 == "processing-instruction") {
							if (s.charAt(pos) == ")") types.push(XPathParser.NODETYPE);
							else types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
							values.push(name$1);
							continue;
						}
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name$1);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name$1);
					continue;
				}
				throw new Error("Unexpected character " + c);
			}
			types.push(1);
			values.push("[EOF]");
			return [types, values];
		};
		XPathParser.SHIFT = "s";
		XPathParser.REDUCE = "r";
		XPathParser.ACCEPT = "a";
		XPathParser.prototype.parse = function(s) {
			var types;
			var values;
			var res = this.tokenize(s);
			if (res == void 0) return;
			types = res[0];
			values = res[1];
			var tokenPos = 0;
			var state = [];
			var tokenType = [];
			var tokenValue = [];
			var s;
			var a;
			var t;
			state.push(0);
			tokenType.push(1);
			tokenValue.push("_S");
			a = types[tokenPos];
			t = values[tokenPos++];
			while (1) {
				s = state[state.length - 1];
				switch (XPathParser.actionTable[s].charAt(a - 1)) {
					case XPathParser.SHIFT:
						tokenType.push(-a);
						tokenValue.push(t);
						state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
						a = types[tokenPos];
						t = values[tokenPos++];
						break;
					case XPathParser.REDUCE:
						var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
						var rhs = [];
						for (var i = 0; i < num; i++) {
							tokenType.pop();
							rhs.unshift(tokenValue.pop());
							state.pop();
						}
						var s_ = state[state.length - 1];
						tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
						if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == void 0) tokenValue.push(rhs[0]);
						else tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
						state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
						break;
					case XPathParser.ACCEPT: return new XPath(tokenValue.pop());
					default: throw new Error("XPath parse error");
				}
			}
		};
		XPath.prototype = /* @__PURE__ */ new Object();
		XPath.prototype.constructor = XPath;
		XPath.superclass = Object.prototype;
		function XPath(e) {
			this.expression = e;
		}
		XPath.prototype.toString = function() {
			return this.expression.toString();
		};
		function setIfUnset(obj, prop, value) {
			if (!(prop in obj)) obj[prop] = value;
		}
		XPath.prototype.evaluate = function(c) {
			c.contextNode = c.expressionContextNode;
			c.contextSize = 1;
			c.contextPosition = 1;
			if (c.isHtml) {
				setIfUnset(c, "caseInsensitive", true);
				setIfUnset(c, "allowAnyNamespaceForNoPrefix", true);
			}
			setIfUnset(c, "caseInsensitive", false);
			return this.expression.evaluate(c);
		};
		XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
		XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";
		Expression.prototype = /* @__PURE__ */ new Object();
		Expression.prototype.constructor = Expression;
		Expression.superclass = Object.prototype;
		function Expression() {}
		Expression.prototype.init = function() {};
		Expression.prototype.toString = function() {
			return "<Expression>";
		};
		Expression.prototype.evaluate = function(c) {
			throw new Error("Could not evaluate expression.");
		};
		UnaryOperation.prototype = new Expression();
		UnaryOperation.prototype.constructor = UnaryOperation;
		UnaryOperation.superclass = Expression.prototype;
		function UnaryOperation(rhs) {
			if (arguments.length > 0) this.init(rhs);
		}
		UnaryOperation.prototype.init = function(rhs) {
			this.rhs = rhs;
		};
		UnaryMinusOperation.prototype = new UnaryOperation();
		UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
		UnaryMinusOperation.superclass = UnaryOperation.prototype;
		function UnaryMinusOperation(rhs) {
			if (arguments.length > 0) this.init(rhs);
		}
		UnaryMinusOperation.prototype.init = function(rhs) {
			UnaryMinusOperation.superclass.init.call(this, rhs);
		};
		UnaryMinusOperation.prototype.evaluate = function(c) {
			return this.rhs.evaluate(c).number().negate();
		};
		UnaryMinusOperation.prototype.toString = function() {
			return "-" + this.rhs.toString();
		};
		BinaryOperation.prototype = new Expression();
		BinaryOperation.prototype.constructor = BinaryOperation;
		BinaryOperation.superclass = Expression.prototype;
		function BinaryOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		BinaryOperation.prototype.init = function(lhs, rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		};
		OrOperation.prototype = new BinaryOperation();
		OrOperation.prototype.constructor = OrOperation;
		OrOperation.superclass = BinaryOperation.prototype;
		function OrOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		OrOperation.prototype.init = function(lhs, rhs) {
			OrOperation.superclass.init.call(this, lhs, rhs);
		};
		OrOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
		};
		OrOperation.prototype.evaluate = function(c) {
			var b = this.lhs.evaluate(c).bool();
			if (b.booleanValue()) return b;
			return this.rhs.evaluate(c).bool();
		};
		AndOperation.prototype = new BinaryOperation();
		AndOperation.prototype.constructor = AndOperation;
		AndOperation.superclass = BinaryOperation.prototype;
		function AndOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		AndOperation.prototype.init = function(lhs, rhs) {
			AndOperation.superclass.init.call(this, lhs, rhs);
		};
		AndOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
		};
		AndOperation.prototype.evaluate = function(c) {
			var b = this.lhs.evaluate(c).bool();
			if (!b.booleanValue()) return b;
			return this.rhs.evaluate(c).bool();
		};
		EqualsOperation.prototype = new BinaryOperation();
		EqualsOperation.prototype.constructor = EqualsOperation;
		EqualsOperation.superclass = BinaryOperation.prototype;
		function EqualsOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		EqualsOperation.prototype.init = function(lhs, rhs) {
			EqualsOperation.superclass.init.call(this, lhs, rhs);
		};
		EqualsOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
		};
		EqualsOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
		};
		NotEqualOperation.prototype = new BinaryOperation();
		NotEqualOperation.prototype.constructor = NotEqualOperation;
		NotEqualOperation.superclass = BinaryOperation.prototype;
		function NotEqualOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		NotEqualOperation.prototype.init = function(lhs, rhs) {
			NotEqualOperation.superclass.init.call(this, lhs, rhs);
		};
		NotEqualOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
		};
		NotEqualOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
		};
		LessThanOperation.prototype = new BinaryOperation();
		LessThanOperation.prototype.constructor = LessThanOperation;
		LessThanOperation.superclass = BinaryOperation.prototype;
		function LessThanOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		LessThanOperation.prototype.init = function(lhs, rhs) {
			LessThanOperation.superclass.init.call(this, lhs, rhs);
		};
		LessThanOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
		};
		LessThanOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
		};
		GreaterThanOperation.prototype = new BinaryOperation();
		GreaterThanOperation.prototype.constructor = GreaterThanOperation;
		GreaterThanOperation.superclass = BinaryOperation.prototype;
		function GreaterThanOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		GreaterThanOperation.prototype.init = function(lhs, rhs) {
			GreaterThanOperation.superclass.init.call(this, lhs, rhs);
		};
		GreaterThanOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
		};
		GreaterThanOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
		};
		LessThanOrEqualOperation.prototype = new BinaryOperation();
		LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
		LessThanOrEqualOperation.superclass = BinaryOperation.prototype;
		function LessThanOrEqualOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
			LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
		};
		LessThanOrEqualOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
		};
		LessThanOrEqualOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
		};
		GreaterThanOrEqualOperation.prototype = new BinaryOperation();
		GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
		GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;
		function GreaterThanOrEqualOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
			GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
		};
		GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
		};
		GreaterThanOrEqualOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
		};
		PlusOperation.prototype = new BinaryOperation();
		PlusOperation.prototype.constructor = PlusOperation;
		PlusOperation.superclass = BinaryOperation.prototype;
		function PlusOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		PlusOperation.prototype.init = function(lhs, rhs) {
			PlusOperation.superclass.init.call(this, lhs, rhs);
		};
		PlusOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
		};
		PlusOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
		};
		MinusOperation.prototype = new BinaryOperation();
		MinusOperation.prototype.constructor = MinusOperation;
		MinusOperation.superclass = BinaryOperation.prototype;
		function MinusOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		MinusOperation.prototype.init = function(lhs, rhs) {
			MinusOperation.superclass.init.call(this, lhs, rhs);
		};
		MinusOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
		};
		MinusOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
		};
		MultiplyOperation.prototype = new BinaryOperation();
		MultiplyOperation.prototype.constructor = MultiplyOperation;
		MultiplyOperation.superclass = BinaryOperation.prototype;
		function MultiplyOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		MultiplyOperation.prototype.init = function(lhs, rhs) {
			MultiplyOperation.superclass.init.call(this, lhs, rhs);
		};
		MultiplyOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
		};
		MultiplyOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
		};
		DivOperation.prototype = new BinaryOperation();
		DivOperation.prototype.constructor = DivOperation;
		DivOperation.superclass = BinaryOperation.prototype;
		function DivOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		DivOperation.prototype.init = function(lhs, rhs) {
			DivOperation.superclass.init.call(this, lhs, rhs);
		};
		DivOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
		};
		DivOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
		};
		ModOperation.prototype = new BinaryOperation();
		ModOperation.prototype.constructor = ModOperation;
		ModOperation.superclass = BinaryOperation.prototype;
		function ModOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		ModOperation.prototype.init = function(lhs, rhs) {
			ModOperation.superclass.init.call(this, lhs, rhs);
		};
		ModOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
		};
		ModOperation.prototype.toString = function() {
			return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
		};
		BarOperation.prototype = new BinaryOperation();
		BarOperation.prototype.constructor = BarOperation;
		BarOperation.superclass = BinaryOperation.prototype;
		function BarOperation(lhs, rhs) {
			if (arguments.length > 0) this.init(lhs, rhs);
		}
		BarOperation.prototype.init = function(lhs, rhs) {
			BarOperation.superclass.init.call(this, lhs, rhs);
		};
		BarOperation.prototype.evaluate = function(c) {
			return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
		};
		BarOperation.prototype.toString = function() {
			return map$1(toString, [this.lhs, this.rhs]).join(" | ");
		};
		PathExpr.prototype = new Expression();
		PathExpr.prototype.constructor = PathExpr;
		PathExpr.superclass = Expression.prototype;
		function PathExpr(filter$1, filterPreds, locpath) {
			if (arguments.length > 0) this.init(filter$1, filterPreds, locpath);
		}
		PathExpr.prototype.init = function(filter$1, filterPreds, locpath) {
			PathExpr.superclass.init.call(this);
			this.filter = filter$1;
			this.filterPredicates = filterPreds;
			this.locationPath = locpath;
		};
		/**
		* Returns the topmost node of the tree containing node
		*/
		function findRoot(node) {
			while (node && node.parentNode) node = node.parentNode;
			return node;
		}
		PathExpr.applyPredicates = function(predicates, c, nodes) {
			if (predicates.length === 0) return nodes;
			var ctx = c.extend({});
			return reduce(function(inNodes, pred) {
				ctx.contextSize = inNodes.length;
				return filter(function(node, i) {
					ctx.contextNode = node;
					ctx.contextPosition = i + 1;
					return PathExpr.predicateMatches(pred, ctx);
				}, inNodes);
			}, nodes, predicates);
		};
		PathExpr.getRoot = function(xpc, nodes) {
			var firstNode = nodes[0];
			if (firstNode.nodeType === NodeTypes.DOCUMENT_NODE) return firstNode;
			if (xpc.virtualRoot) return xpc.virtualRoot;
			var ownerDoc = firstNode.ownerDocument;
			if (ownerDoc) return ownerDoc;
			var n = firstNode;
			while (n.parentNode != null) n = n.parentNode;
			return n;
		};
		PathExpr.applyStep = function(step, xpc, node) {
			var newNodes = [];
			xpc.contextNode = node;
			switch (step.axis) {
				case Step.ANCESTOR:
					if (xpc.contextNode === xpc.virtualRoot) break;
					var m;
					if (xpc.contextNode.nodeType == NodeTypes.ATTRIBUTE_NODE) m = PathExpr.getOwnerElement(xpc.contextNode);
					else m = xpc.contextNode.parentNode;
					while (m != null) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m === xpc.virtualRoot) break;
						m = m.parentNode;
					}
					break;
				case Step.ANCESTORORSELF:
					for (var m = xpc.contextNode; m != null; m = m.nodeType == NodeTypes.ATTRIBUTE_NODE ? PathExpr.getOwnerElement(m) : m.parentNode) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m === xpc.virtualRoot) break;
					}
					break;
				case Step.ATTRIBUTE:
					var nnm = xpc.contextNode.attributes;
					if (nnm != null) for (var k = 0; k < nnm.length; k++) {
						var m = nnm.item(k);
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					}
					break;
				case Step.CHILD:
					for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.DESCENDANT:
					var st = [xpc.contextNode.firstChild];
					while (st.length > 0) for (var m = st.pop(); m != null;) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m.firstChild != null) {
							st.push(m.nextSibling);
							m = m.firstChild;
						} else m = m.nextSibling;
					}
					break;
				case Step.DESCENDANTORSELF:
					if (step.nodeTest.matches(xpc.contextNode, xpc)) newNodes.push(xpc.contextNode);
					var st = [xpc.contextNode.firstChild];
					while (st.length > 0) for (var m = st.pop(); m != null;) {
						if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
						if (m.firstChild != null) {
							st.push(m.nextSibling);
							m = m.firstChild;
						} else m = m.nextSibling;
					}
					break;
				case Step.FOLLOWING:
					if (xpc.contextNode === xpc.virtualRoot) break;
					var st = [];
					if (xpc.contextNode.firstChild != null) st.unshift(xpc.contextNode.firstChild);
					else st.unshift(xpc.contextNode.nextSibling);
					for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != NodeTypes.DOCUMENT_NODE && m !== xpc.virtualRoot; m = m.parentNode) st.unshift(m.nextSibling);
					do
						for (var m = st.pop(); m != null;) {
							if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
							if (m.firstChild != null) {
								st.push(m.nextSibling);
								m = m.firstChild;
							} else m = m.nextSibling;
						}
					while (st.length > 0);
					break;
				case Step.FOLLOWINGSIBLING:
					if (xpc.contextNode === xpc.virtualRoot) break;
					for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.NAMESPACE:
					var n = {};
					if (xpc.contextNode.nodeType == NodeTypes.ELEMENT_NODE) {
						n["xml"] = XPath.XML_NAMESPACE_URI;
						n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
						for (var m = xpc.contextNode; m != null && m.nodeType == NodeTypes.ELEMENT_NODE; m = m.parentNode) for (var k = 0; k < m.attributes.length; k++) {
							var attr = m.attributes.item(k);
							var nm = String(attr.name);
							if (nm == "xmlns") {
								if (n[""] == void 0) n[""] = attr.value;
							} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
								var pre = nm.substring(6, nm.length);
								if (n[pre] == void 0) n[pre] = attr.value;
							}
						}
						for (var pre in n) {
							var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
							if (step.nodeTest.matches(nsn, xpc)) newNodes.push(nsn);
						}
					}
					break;
				case Step.PARENT:
					m = null;
					if (xpc.contextNode !== xpc.virtualRoot) if (xpc.contextNode.nodeType == NodeTypes.ATTRIBUTE_NODE) m = PathExpr.getOwnerElement(xpc.contextNode);
					else m = xpc.contextNode.parentNode;
					if (m != null && step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.PRECEDING:
					var st;
					if (xpc.virtualRoot != null) st = [xpc.virtualRoot];
					else st = [findRoot(xpc.contextNode)];
					outer: while (st.length > 0) for (var m = st.pop(); m != null;) {
						if (m == xpc.contextNode) break outer;
						if (step.nodeTest.matches(m, xpc)) newNodes.unshift(m);
						if (m.firstChild != null) {
							st.push(m.nextSibling);
							m = m.firstChild;
						} else m = m.nextSibling;
					}
					break;
				case Step.PRECEDINGSIBLING:
					if (xpc.contextNode === xpc.virtualRoot) break;
					for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) if (step.nodeTest.matches(m, xpc)) newNodes.push(m);
					break;
				case Step.SELF:
					if (step.nodeTest.matches(xpc.contextNode, xpc)) newNodes.push(xpc.contextNode);
					break;
				default:
			}
			return newNodes;
		};
		function applyStepWithPredicates(step, xpc, node) {
			return PathExpr.applyPredicates(step.predicates, xpc, PathExpr.applyStep(step, xpc, node));
		}
		function applyStepToNodes(context, nodes, step) {
			return flatten(map$1(applyStepWithPredicates.bind(null, step, context), nodes));
		}
		PathExpr.applySteps = function(steps, xpc, nodes) {
			return reduce(applyStepToNodes.bind(null, xpc), nodes, steps);
		};
		PathExpr.prototype.applyFilter = function(c, xpc) {
			if (!this.filter) return { nodes: [c.contextNode] };
			var ns = this.filter.evaluate(c);
			if (!Utilities.instance_of(ns, XNodeSet)) {
				if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
				return { nonNodes: ns };
			}
			return { nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray()) };
		};
		PathExpr.applyLocationPath = function(locationPath, xpc, nodes) {
			if (!locationPath) return nodes;
			var startNodes = locationPath.absolute ? [PathExpr.getRoot(xpc, nodes)] : nodes;
			return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
		};
		PathExpr.prototype.evaluate = function(c) {
			var xpc = assign(new XPathContext(), c);
			var filterResult = this.applyFilter(c, xpc);
			if ("nonNodes" in filterResult) return filterResult.nonNodes;
			var ns = new XNodeSet();
			ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
			return ns;
		};
		PathExpr.predicateMatches = function(pred, c) {
			var res = pred.evaluate(c);
			return Utilities.instance_of(res, XNumber) ? c.contextPosition === res.numberValue() : res.booleanValue();
		};
		PathExpr.predicateString = function(predicate) {
			return wrap("[", "]", predicate.toString());
		};
		PathExpr.predicatesString = function(predicates) {
			return join("", map$1(PathExpr.predicateString, predicates));
		};
		PathExpr.prototype.toString = function() {
			if (this.filter != void 0) {
				var filterStr = toString(this.filter);
				if (Utilities.instance_of(this.filter, XString)) return wrap("'", "'", filterStr);
				if (this.filterPredicates != void 0 && this.filterPredicates.length) return wrap("(", ")", filterStr) + PathExpr.predicatesString(this.filterPredicates);
				if (this.locationPath != void 0) return filterStr + (this.locationPath.absolute ? "" : "/") + toString(this.locationPath);
				return filterStr;
			}
			return toString(this.locationPath);
		};
		PathExpr.getOwnerElement = function(n) {
			if (n.ownerElement) return n.ownerElement;
			try {
				if (n.selectSingleNode) return n.selectSingleNode("..");
			} catch (e) {}
			var elts = (n.nodeType == NodeTypes.DOCUMENT_NODE ? n : n.ownerDocument).getElementsByTagName("*");
			for (var i = 0; i < elts.length; i++) {
				var elt = elts.item(i);
				var nnm = elt.attributes;
				for (var j = 0; j < nnm.length; j++) if (nnm.item(j) === n) return elt;
			}
			return null;
		};
		LocationPath.prototype = /* @__PURE__ */ new Object();
		LocationPath.prototype.constructor = LocationPath;
		LocationPath.superclass = Object.prototype;
		function LocationPath(abs, steps) {
			if (arguments.length > 0) this.init(abs, steps);
		}
		LocationPath.prototype.init = function(abs, steps) {
			this.absolute = abs;
			this.steps = steps;
		};
		LocationPath.prototype.toString = function() {
			return (this.absolute ? "/" : "") + map$1(toString, this.steps).join("/");
		};
		Step.prototype = /* @__PURE__ */ new Object();
		Step.prototype.constructor = Step;
		Step.superclass = Object.prototype;
		function Step(axis, nodetest, preds) {
			if (arguments.length > 0) this.init(axis, nodetest, preds);
		}
		Step.prototype.init = function(axis, nodetest, preds) {
			this.axis = axis;
			this.nodeTest = nodetest;
			this.predicates = preds;
		};
		Step.prototype.toString = function() {
			return Step.STEPNAMES[this.axis] + "::" + this.nodeTest.toString() + PathExpr.predicatesString(this.predicates);
		};
		Step.ANCESTOR = 0;
		Step.ANCESTORORSELF = 1;
		Step.ATTRIBUTE = 2;
		Step.CHILD = 3;
		Step.DESCENDANT = 4;
		Step.DESCENDANTORSELF = 5;
		Step.FOLLOWING = 6;
		Step.FOLLOWINGSIBLING = 7;
		Step.NAMESPACE = 8;
		Step.PARENT = 9;
		Step.PRECEDING = 10;
		Step.PRECEDINGSIBLING = 11;
		Step.SELF = 12;
		Step.STEPNAMES = reduce(function(acc, x) {
			return acc[x[0]] = x[1], acc;
		}, {}, [
			[Step.ANCESTOR, "ancestor"],
			[Step.ANCESTORORSELF, "ancestor-or-self"],
			[Step.ATTRIBUTE, "attribute"],
			[Step.CHILD, "child"],
			[Step.DESCENDANT, "descendant"],
			[Step.DESCENDANTORSELF, "descendant-or-self"],
			[Step.FOLLOWING, "following"],
			[Step.FOLLOWINGSIBLING, "following-sibling"],
			[Step.NAMESPACE, "namespace"],
			[Step.PARENT, "parent"],
			[Step.PRECEDING, "preceding"],
			[Step.PRECEDINGSIBLING, "preceding-sibling"],
			[Step.SELF, "self"]
		]);
		NodeTest.prototype = /* @__PURE__ */ new Object();
		NodeTest.prototype.constructor = NodeTest;
		NodeTest.superclass = Object.prototype;
		function NodeTest(type, value) {
			if (arguments.length > 0) this.init(type, value);
		}
		NodeTest.prototype.init = function(type, value) {
			this.type = type;
			this.value = value;
		};
		NodeTest.prototype.toString = function() {
			return "<unknown nodetest type>";
		};
		NodeTest.prototype.matches = function(n, xpc) {
			console.warn("unknown node test type");
		};
		NodeTest.NAMETESTANY = 0;
		NodeTest.NAMETESTPREFIXANY = 1;
		NodeTest.NAMETESTQNAME = 2;
		NodeTest.COMMENT = 3;
		NodeTest.TEXT = 4;
		NodeTest.PI = 5;
		NodeTest.NODE = 6;
		NodeTest.isNodeType = function(types) {
			return function(node) {
				return includes(types, node.nodeType);
			};
		};
		NodeTest.makeNodeTestType = function(type, members, ctor) {
			var newType = ctor || function() {};
			newType.prototype = new NodeTest(type);
			newType.prototype.constructor = newType;
			assign(newType.prototype, members);
			return newType;
		};
		NodeTest.makeNodeTypeTest = function(type, nodeTypes, stringVal) {
			return new (NodeTest.makeNodeTestType(type, {
				matches: NodeTest.isNodeType(nodeTypes),
				toString: always(stringVal)
			}))();
		};
		NodeTest.hasPrefix = function(node) {
			return node.prefix || (node.nodeName || node.tagName).indexOf(":") !== -1;
		};
		NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
		NodeTest.nameSpaceMatches = function(prefix, xpc, n) {
			var nNamespace = n.namespaceURI || "";
			if (!prefix) return !nNamespace || xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n);
			var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);
			if (ns == null) throw new Error("Cannot resolve QName " + prefix);
			return ns === nNamespace;
		};
		NodeTest.localNameMatches = function(localName, xpc, n) {
			var nLocalName = n.localName || n.nodeName;
			return xpc.caseInsensitive ? localName.toLowerCase() === nLocalName.toLowerCase() : localName === nLocalName;
		};
		NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(NodeTest.NAMETESTPREFIXANY, {
			matches: function(n, xpc) {
				return NodeTest.isElementOrAttribute(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n);
			},
			toString: function() {
				return this.prefix + ":*";
			}
		}, function NameTestPrefixAny(prefix) {
			this.prefix = prefix;
		});
		NodeTest.NameTestQName = NodeTest.makeNodeTestType(NodeTest.NAMETESTQNAME, {
			matches: function(n, xpc) {
				return NodeTest.isNodeType([
					NodeTypes.ELEMENT_NODE,
					NodeTypes.ATTRIBUTE_NODE,
					XPathNamespace.XPATH_NAMESPACE_NODE
				])(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n) && NodeTest.localNameMatches(this.localName, xpc, n);
			},
			toString: function() {
				return this.name;
			}
		}, function NameTestQName(name$1) {
			var nameParts = name$1.split(":");
			this.name = name$1;
			this.prefix = nameParts.length > 1 ? nameParts[0] : null;
			this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
		});
		NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
			matches: function(n, xpc) {
				return NodeTest.isNodeType([NodeTypes.PROCESSING_INSTRUCTION_NODE])(n) && (n.target || n.nodeName) === this.name;
			},
			toString: function() {
				return wrap("processing-instruction(\"", "\")", this.name);
			}
		}, function(name$1) {
			this.name = name$1;
		});
		NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [
			NodeTypes.ELEMENT_NODE,
			NodeTypes.ATTRIBUTE_NODE,
			XPathNamespace.XPATH_NAMESPACE_NODE
		], "*");
		NodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [NodeTypes.TEXT_NODE, NodeTypes.CDATA_SECTION_NODE], "text()");
		NodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [NodeTypes.COMMENT_NODE], "comment()");
		NodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [
			NodeTypes.ELEMENT_NODE,
			NodeTypes.ATTRIBUTE_NODE,
			NodeTypes.TEXT_NODE,
			NodeTypes.CDATA_SECTION_NODE,
			NodeTypes.PROCESSING_INSTRUCTION_NODE,
			NodeTypes.COMMENT_NODE,
			NodeTypes.DOCUMENT_NODE
		], "node()");
		NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [NodeTypes.PROCESSING_INSTRUCTION_NODE], "processing-instruction()");
		VariableReference.prototype = new Expression();
		VariableReference.prototype.constructor = VariableReference;
		VariableReference.superclass = Expression.prototype;
		function VariableReference(v) {
			if (arguments.length > 0) this.init(v);
		}
		VariableReference.prototype.init = function(v) {
			this.variable = v;
		};
		VariableReference.prototype.toString = function() {
			return "$" + this.variable;
		};
		VariableReference.prototype.evaluate = function(c) {
			var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);
			if (parts[0] == null) throw new Error("Cannot resolve QName " + fn);
			var result = c.variableResolver.getVariable(parts[1], parts[0]);
			if (!result) throw XPathException.fromMessage("Undeclared variable: " + this.toString());
			return result;
		};
		FunctionCall.prototype = new Expression();
		FunctionCall.prototype.constructor = FunctionCall;
		FunctionCall.superclass = Expression.prototype;
		function FunctionCall(fn$1, args) {
			if (arguments.length > 0) this.init(fn$1, args);
		}
		FunctionCall.prototype.init = function(fn$1, args) {
			this.functionName = fn$1;
			this.arguments = args;
		};
		FunctionCall.prototype.toString = function() {
			var s = this.functionName + "(";
			for (var i = 0; i < this.arguments.length; i++) {
				if (i > 0) s += ", ";
				s += this.arguments[i].toString();
			}
			return s + ")";
		};
		FunctionCall.prototype.evaluate = function(c) {
			var f = FunctionResolver.getFunctionFromContext(this.functionName, c);
			if (!f) throw new Error("Unknown function " + this.functionName);
			var a = [c].concat(this.arguments);
			return f.apply(c.functionResolver.thisArg, a);
		};
		var Operators = /* @__PURE__ */ new Object();
		Operators.equals = function(l, r) {
			return l.equals(r);
		};
		Operators.notequal = function(l, r) {
			return l.notequal(r);
		};
		Operators.lessthan = function(l, r) {
			return l.lessthan(r);
		};
		Operators.greaterthan = function(l, r) {
			return l.greaterthan(r);
		};
		Operators.lessthanorequal = function(l, r) {
			return l.lessthanorequal(r);
		};
		Operators.greaterthanorequal = function(l, r) {
			return l.greaterthanorequal(r);
		};
		XString.prototype = new Expression();
		XString.prototype.constructor = XString;
		XString.superclass = Expression.prototype;
		function XString(s) {
			if (arguments.length > 0) this.init(s);
		}
		XString.prototype.init = function(s) {
			this.str = String(s);
		};
		XString.prototype.toString = function() {
			return this.str;
		};
		XString.prototype.evaluate = function(c) {
			return this;
		};
		XString.prototype.string = function() {
			return this;
		};
		XString.prototype.number = function() {
			return new XNumber(this.str);
		};
		XString.prototype.bool = function() {
			return new XBoolean(this.str);
		};
		XString.prototype.nodeset = function() {
			throw new Error("Cannot convert string to nodeset");
		};
		XString.prototype.stringValue = function() {
			return this.str;
		};
		XString.prototype.numberValue = function() {
			return this.number().numberValue();
		};
		XString.prototype.booleanValue = function() {
			return this.bool().booleanValue();
		};
		XString.prototype.equals = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().equals(r);
			if (Utilities.instance_of(r, XNumber)) return this.number().equals(r);
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithString(this, Operators.equals);
			return new XBoolean(this.str == r.str);
		};
		XString.prototype.notequal = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().notequal(r);
			if (Utilities.instance_of(r, XNumber)) return this.number().notequal(r);
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithString(this, Operators.notequal);
			return new XBoolean(this.str != r.str);
		};
		XString.prototype.lessthan = function(r) {
			return this.number().lessthan(r);
		};
		XString.prototype.greaterthan = function(r) {
			return this.number().greaterthan(r);
		};
		XString.prototype.lessthanorequal = function(r) {
			return this.number().lessthanorequal(r);
		};
		XString.prototype.greaterthanorequal = function(r) {
			return this.number().greaterthanorequal(r);
		};
		XNumber.prototype = new Expression();
		XNumber.prototype.constructor = XNumber;
		XNumber.superclass = Expression.prototype;
		function XNumber(n) {
			if (arguments.length > 0) this.init(n);
		}
		XNumber.prototype.init = function(n) {
			this.num = typeof n === "string" ? this.parse(n) : Number(n);
		};
		XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;
		XNumber.prototype.parse = function(s) {
			return this.numberFormat.test(s) ? parseFloat(s) : NaN;
		};
		function padSmallNumber(numberStr) {
			var parts = numberStr.split("e-");
			var base = parts[0].replace(".", "");
			var exponent = Number(parts[1]);
			for (var i = 0; i < exponent - 1; i += 1) base = "0" + base;
			return "0." + base;
		}
		function padLargeNumber(numberStr) {
			var parts = numberStr.split("e");
			var base = parts[0].replace(".", "");
			var zerosToAppend = Number(parts[1]) + 1 - base.length;
			for (var i = 0; i < zerosToAppend; i += 1) base += "0";
			return base;
		}
		XNumber.prototype.toString = function() {
			var strValue = this.num.toString();
			if (strValue.indexOf("e-") !== -1) return padSmallNumber(strValue);
			if (strValue.indexOf("e") !== -1) return padLargeNumber(strValue);
			return strValue;
		};
		XNumber.prototype.evaluate = function(c) {
			return this;
		};
		XNumber.prototype.string = function() {
			return new XString(this.toString());
		};
		XNumber.prototype.number = function() {
			return this;
		};
		XNumber.prototype.bool = function() {
			return new XBoolean(this.num);
		};
		XNumber.prototype.nodeset = function() {
			throw new Error("Cannot convert number to nodeset");
		};
		XNumber.prototype.stringValue = function() {
			return this.string().stringValue();
		};
		XNumber.prototype.numberValue = function() {
			return this.num;
		};
		XNumber.prototype.booleanValue = function() {
			return this.bool().booleanValue();
		};
		XNumber.prototype.negate = function() {
			return new XNumber(-this.num);
		};
		XNumber.prototype.equals = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().equals(r);
			if (Utilities.instance_of(r, XString)) return this.equals(r.number());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.equals);
			return new XBoolean(this.num == r.num);
		};
		XNumber.prototype.notequal = function(r) {
			if (Utilities.instance_of(r, XBoolean)) return this.bool().notequal(r);
			if (Utilities.instance_of(r, XString)) return this.notequal(r.number());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.notequal);
			return new XBoolean(this.num != r.num);
		};
		XNumber.prototype.lessthan = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.greaterthan);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.lessthan(r.number());
			return new XBoolean(this.num < r.num);
		};
		XNumber.prototype.greaterthan = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.lessthan);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.greaterthan(r.number());
			return new XBoolean(this.num > r.num);
		};
		XNumber.prototype.lessthanorequal = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.greaterthanorequal);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.lessthanorequal(r.number());
			return new XBoolean(this.num <= r.num);
		};
		XNumber.prototype.greaterthanorequal = function(r) {
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithNumber(this, Operators.lessthanorequal);
			if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) return this.greaterthanorequal(r.number());
			return new XBoolean(this.num >= r.num);
		};
		XNumber.prototype.plus = function(r) {
			return new XNumber(this.num + r.num);
		};
		XNumber.prototype.minus = function(r) {
			return new XNumber(this.num - r.num);
		};
		XNumber.prototype.multiply = function(r) {
			return new XNumber(this.num * r.num);
		};
		XNumber.prototype.div = function(r) {
			return new XNumber(this.num / r.num);
		};
		XNumber.prototype.mod = function(r) {
			return new XNumber(this.num % r.num);
		};
		XBoolean.prototype = new Expression();
		XBoolean.prototype.constructor = XBoolean;
		XBoolean.superclass = Expression.prototype;
		function XBoolean(b) {
			if (arguments.length > 0) this.init(b);
		}
		XBoolean.prototype.init = function(b) {
			this.b = Boolean(b);
		};
		XBoolean.prototype.toString = function() {
			return this.b.toString();
		};
		XBoolean.prototype.evaluate = function(c) {
			return this;
		};
		XBoolean.prototype.string = function() {
			return new XString(this.b);
		};
		XBoolean.prototype.number = function() {
			return new XNumber(this.b);
		};
		XBoolean.prototype.bool = function() {
			return this;
		};
		XBoolean.prototype.nodeset = function() {
			throw new Error("Cannot convert boolean to nodeset");
		};
		XBoolean.prototype.stringValue = function() {
			return this.string().stringValue();
		};
		XBoolean.prototype.numberValue = function() {
			return this.number().numberValue();
		};
		XBoolean.prototype.booleanValue = function() {
			return this.b;
		};
		XBoolean.prototype.not = function() {
			return new XBoolean(!this.b);
		};
		XBoolean.prototype.equals = function(r) {
			if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) return this.equals(r.bool());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithBoolean(this, Operators.equals);
			return new XBoolean(this.b == r.b);
		};
		XBoolean.prototype.notequal = function(r) {
			if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) return this.notequal(r.bool());
			if (Utilities.instance_of(r, XNodeSet)) return r.compareWithBoolean(this, Operators.notequal);
			return new XBoolean(this.b != r.b);
		};
		XBoolean.prototype.lessthan = function(r) {
			return this.number().lessthan(r);
		};
		XBoolean.prototype.greaterthan = function(r) {
			return this.number().greaterthan(r);
		};
		XBoolean.prototype.lessthanorequal = function(r) {
			return this.number().lessthanorequal(r);
		};
		XBoolean.prototype.greaterthanorequal = function(r) {
			return this.number().greaterthanorequal(r);
		};
		XBoolean.true_ = new XBoolean(true);
		XBoolean.false_ = new XBoolean(false);
		AVLTree.prototype = /* @__PURE__ */ new Object();
		AVLTree.prototype.constructor = AVLTree;
		AVLTree.superclass = Object.prototype;
		function AVLTree(n) {
			this.init(n);
		}
		AVLTree.prototype.init = function(n) {
			this.left = null;
			this.right = null;
			this.node = n;
			this.depth = 1;
		};
		AVLTree.prototype.balance = function() {
			var ldepth = this.left == null ? 0 : this.left.depth;
			var rdepth = this.right == null ? 0 : this.right.depth;
			if (ldepth > rdepth + 1) {
				if ((this.left.left == null ? 0 : this.left.left.depth) < (this.left.right == null ? 0 : this.left.right.depth)) this.left.rotateRR();
				this.rotateLL();
			} else if (ldepth + 1 < rdepth) {
				var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
				if ((this.right.left == null ? 0 : this.right.left.depth) > rrdepth) this.right.rotateLL();
				this.rotateRR();
			}
		};
		AVLTree.prototype.rotateLL = function() {
			var nodeBefore = this.node;
			var rightBefore = this.right;
			this.node = this.left.node;
			this.right = this.left;
			this.left = this.left.left;
			this.right.left = this.right.right;
			this.right.right = rightBefore;
			this.right.node = nodeBefore;
			this.right.updateInNewLocation();
			this.updateInNewLocation();
		};
		AVLTree.prototype.rotateRR = function() {
			var nodeBefore = this.node;
			var leftBefore = this.left;
			this.node = this.right.node;
			this.left = this.right;
			this.right = this.right.right;
			this.left.right = this.left.left;
			this.left.left = leftBefore;
			this.left.node = nodeBefore;
			this.left.updateInNewLocation();
			this.updateInNewLocation();
		};
		AVLTree.prototype.updateInNewLocation = function() {
			this.getDepthFromChildren();
		};
		AVLTree.prototype.getDepthFromChildren = function() {
			this.depth = this.node == null ? 0 : 1;
			if (this.left != null) this.depth = this.left.depth + 1;
			if (this.right != null && this.depth <= this.right.depth) this.depth = this.right.depth + 1;
		};
		function nodeOrder(n1, n2) {
			if (n1 === n2) return 0;
			if (n1.compareDocumentPosition) {
				var cpos = n1.compareDocumentPosition(n2);
				if (cpos & 1) return 1;
				if (cpos & 10) return 1;
				if (cpos & 20) return -1;
				return 0;
			}
			var d1 = 0, d2 = 0;
			for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) d1++;
			for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) d2++;
			if (d1 > d2) {
				while (d1 > d2) {
					n1 = n1.parentNode || n1.ownerElement;
					d1--;
				}
				if (n1 === n2) return 1;
			} else if (d2 > d1) {
				while (d2 > d1) {
					n2 = n2.parentNode || n2.ownerElement;
					d2--;
				}
				if (n1 === n2) return -1;
			}
			var n1Par = n1.parentNode || n1.ownerElement, n2Par = n2.parentNode || n2.ownerElement;
			while (n1Par !== n2Par) {
				n1 = n1Par;
				n2 = n2Par;
				n1Par = n1.parentNode || n1.ownerElement;
				n2Par = n2.parentNode || n2.ownerElement;
			}
			var n1isAttr = Utilities.isAttribute(n1);
			var n2isAttr = Utilities.isAttribute(n2);
			if (n1isAttr && !n2isAttr) return -1;
			if (!n1isAttr && n2isAttr) return 1;
			if (n1Par) {
				var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes, len = cn.length;
				for (var i = 0; i < len; i += 1) {
					var n = cn[i];
					if (n === n1) return -1;
					if (n === n2) return 1;
				}
			}
			throw new Error("Unexpected: could not determine node order");
		}
		AVLTree.prototype.add = function(n) {
			if (n === this.node) return false;
			var o = nodeOrder(n, this.node);
			var ret = false;
			if (o == -1) if (this.left == null) {
				this.left = new AVLTree(n);
				ret = true;
			} else {
				ret = this.left.add(n);
				if (ret) this.balance();
			}
			else if (o == 1) if (this.right == null) {
				this.right = new AVLTree(n);
				ret = true;
			} else {
				ret = this.right.add(n);
				if (ret) this.balance();
			}
			if (ret) this.getDepthFromChildren();
			return ret;
		};
		XNodeSet.prototype = new Expression();
		XNodeSet.prototype.constructor = XNodeSet;
		XNodeSet.superclass = Expression.prototype;
		function XNodeSet() {
			this.init();
		}
		XNodeSet.prototype.init = function() {
			this.tree = null;
			this.nodes = [];
			this.size = 0;
		};
		XNodeSet.prototype.toString = function() {
			var p = this.first();
			if (p == null) return "";
			return this.stringForNode(p);
		};
		XNodeSet.prototype.evaluate = function(c) {
			return this;
		};
		XNodeSet.prototype.string = function() {
			return new XString(this.toString());
		};
		XNodeSet.prototype.stringValue = function() {
			return this.toString();
		};
		XNodeSet.prototype.number = function() {
			return new XNumber(this.string());
		};
		XNodeSet.prototype.numberValue = function() {
			return Number(this.string());
		};
		XNodeSet.prototype.bool = function() {
			return new XBoolean(this.booleanValue());
		};
		XNodeSet.prototype.booleanValue = function() {
			return !!this.size;
		};
		XNodeSet.prototype.nodeset = function() {
			return this;
		};
		XNodeSet.prototype.stringForNode = function(n) {
			if (n.nodeType == NodeTypes.DOCUMENT_NODE || n.nodeType == NodeTypes.ELEMENT_NODE || n.nodeType === NodeTypes.DOCUMENT_FRAGMENT_NODE) return this.stringForContainerNode(n);
			if (n.nodeType === NodeTypes.ATTRIBUTE_NODE) return n.value || n.nodeValue;
			if (n.isNamespaceNode) return n.namespace;
			return n.nodeValue;
		};
		XNodeSet.prototype.stringForContainerNode = function(n) {
			var s = "";
			for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
				var nt = n2.nodeType;
				if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) s += this.stringForNode(n2);
			}
			return s;
		};
		XNodeSet.prototype.buildTree = function() {
			if (!this.tree && this.nodes.length) {
				this.tree = new AVLTree(this.nodes[0]);
				for (var i = 1; i < this.nodes.length; i += 1) this.tree.add(this.nodes[i]);
			}
			return this.tree;
		};
		XNodeSet.prototype.first = function() {
			var p = this.buildTree();
			if (p == null) return null;
			while (p.left != null) p = p.left;
			return p.node;
		};
		XNodeSet.prototype.add = function(n) {
			for (var i = 0; i < this.nodes.length; i += 1) if (n === this.nodes[i]) return;
			this.tree = null;
			this.nodes.push(n);
			this.size += 1;
		};
		XNodeSet.prototype.addArray = function(ns) {
			var self$1 = this;
			forEach(function(x) {
				self$1.add(x);
			}, ns);
		};
		/**
		* Returns an array of the node set's contents in document order
		*/
		XNodeSet.prototype.toArray = function() {
			var a = [];
			this.toArrayRec(this.buildTree(), a);
			return a;
		};
		XNodeSet.prototype.toArrayRec = function(t, a) {
			if (t != null) {
				this.toArrayRec(t.left, a);
				a.push(t.node);
				this.toArrayRec(t.right, a);
			}
		};
		/**
		* Returns an array of the node set's contents in arbitrary order
		*/
		XNodeSet.prototype.toUnsortedArray = function() {
			return this.nodes.slice();
		};
		XNodeSet.prototype.compareWithString = function(r, o) {
			var a = this.toUnsortedArray();
			for (var i = 0; i < a.length; i++) {
				var n = a[i];
				var res = o(new XString(this.stringForNode(n)), r);
				if (res.booleanValue()) return res;
			}
			return new XBoolean(false);
		};
		XNodeSet.prototype.compareWithNumber = function(r, o) {
			var a = this.toUnsortedArray();
			for (var i = 0; i < a.length; i++) {
				var n = a[i];
				var res = o(new XNumber(this.stringForNode(n)), r);
				if (res.booleanValue()) return res;
			}
			return new XBoolean(false);
		};
		XNodeSet.prototype.compareWithBoolean = function(r, o) {
			return o(this.bool(), r);
		};
		XNodeSet.prototype.compareWithNodeSet = function(r, o) {
			var arr = this.toUnsortedArray();
			var oInvert = function(lop, rop) {
				return o(rop, lop);
			};
			for (var i = 0; i < arr.length; i++) {
				var l = new XString(this.stringForNode(arr[i]));
				var res = r.compareWithString(l, oInvert);
				if (res.booleanValue()) return res;
			}
			return new XBoolean(false);
		};
		XNodeSet.compareWith = curry(function(o, r) {
			if (Utilities.instance_of(r, XString)) return this.compareWithString(r, o);
			if (Utilities.instance_of(r, XNumber)) return this.compareWithNumber(r, o);
			if (Utilities.instance_of(r, XBoolean)) return this.compareWithBoolean(r, o);
			return this.compareWithNodeSet(r, o);
		});
		XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
		XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
		XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
		XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
		XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
		XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);
		XNodeSet.prototype.union = function(r) {
			var ns = new XNodeSet();
			ns.addArray(this.toUnsortedArray());
			ns.addArray(r.toUnsortedArray());
			return ns;
		};
		XPathNamespace.prototype = /* @__PURE__ */ new Object();
		XPathNamespace.prototype.constructor = XPathNamespace;
		XPathNamespace.superclass = Object.prototype;
		function XPathNamespace(pre, ns, p) {
			this.isXPathNamespace = true;
			this.ownerDocument = p.ownerDocument;
			this.nodeName = "#namespace";
			this.prefix = pre;
			this.localName = pre;
			this.namespaceURI = ns;
			this.nodeValue = ns;
			this.ownerElement = p;
			this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
		}
		XPathNamespace.prototype.toString = function() {
			return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
		};
		XPathContext.prototype = /* @__PURE__ */ new Object();
		XPathContext.prototype.constructor = XPathContext;
		XPathContext.superclass = Object.prototype;
		function XPathContext(vr, nr, fr) {
			this.variableResolver = vr != null ? vr : new VariableResolver();
			this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
			this.functionResolver = fr != null ? fr : new FunctionResolver();
		}
		XPathContext.prototype.extend = function(newProps) {
			return assign(new XPathContext(), this, newProps);
		};
		VariableResolver.prototype = /* @__PURE__ */ new Object();
		VariableResolver.prototype.constructor = VariableResolver;
		VariableResolver.superclass = Object.prototype;
		function VariableResolver() {}
		VariableResolver.prototype.getVariable = function(ln, ns) {
			return null;
		};
		FunctionResolver.prototype = /* @__PURE__ */ new Object();
		FunctionResolver.prototype.constructor = FunctionResolver;
		FunctionResolver.superclass = Object.prototype;
		function FunctionResolver(thisArg) {
			this.thisArg = thisArg != null ? thisArg : Functions;
			this.functions = /* @__PURE__ */ new Object();
			this.addStandardFunctions();
		}
		FunctionResolver.prototype.addStandardFunctions = function() {
			this.functions["{}last"] = Functions.last;
			this.functions["{}position"] = Functions.position;
			this.functions["{}count"] = Functions.count;
			this.functions["{}id"] = Functions.id;
			this.functions["{}local-name"] = Functions.localName;
			this.functions["{}namespace-uri"] = Functions.namespaceURI;
			this.functions["{}name"] = Functions.name;
			this.functions["{}string"] = Functions.string;
			this.functions["{}concat"] = Functions.concat;
			this.functions["{}starts-with"] = Functions.startsWith;
			this.functions["{}contains"] = Functions.contains;
			this.functions["{}substring-before"] = Functions.substringBefore;
			this.functions["{}substring-after"] = Functions.substringAfter;
			this.functions["{}substring"] = Functions.substring;
			this.functions["{}string-length"] = Functions.stringLength;
			this.functions["{}normalize-space"] = Functions.normalizeSpace;
			this.functions["{}translate"] = Functions.translate;
			this.functions["{}boolean"] = Functions.boolean_;
			this.functions["{}not"] = Functions.not;
			this.functions["{}true"] = Functions.true_;
			this.functions["{}false"] = Functions.false_;
			this.functions["{}lang"] = Functions.lang;
			this.functions["{}number"] = Functions.number;
			this.functions["{}sum"] = Functions.sum;
			this.functions["{}floor"] = Functions.floor;
			this.functions["{}ceiling"] = Functions.ceiling;
			this.functions["{}round"] = Functions.round;
		};
		FunctionResolver.prototype.addFunction = function(ns, ln, f) {
			this.functions["{" + ns + "}" + ln] = f;
		};
		FunctionResolver.getFunctionFromContext = function(qName, context) {
			var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);
			if (parts[0] === null) throw new Error("Cannot resolve QName " + name);
			return context.functionResolver.getFunction(parts[1], parts[0]);
		};
		FunctionResolver.prototype.getFunction = function(localName, namespace) {
			return this.functions["{" + namespace + "}" + localName];
		};
		NamespaceResolver.prototype = /* @__PURE__ */ new Object();
		NamespaceResolver.prototype.constructor = NamespaceResolver;
		NamespaceResolver.superclass = Object.prototype;
		function NamespaceResolver() {}
		NamespaceResolver.prototype.getNamespace = function(prefix, n) {
			if (prefix == "xml") return XPath.XML_NAMESPACE_URI;
			else if (prefix == "xmlns") return XPath.XMLNS_NAMESPACE_URI;
			if (n.nodeType == NodeTypes.DOCUMENT_NODE) n = n.documentElement;
			else if (n.nodeType == NodeTypes.ATTRIBUTE_NODE) n = PathExpr.getOwnerElement(n);
			else if (n.nodeType != NodeTypes.ELEMENT_NODE) n = n.parentNode;
			while (n != null && n.nodeType == NodeTypes.ELEMENT_NODE) {
				var nnm = n.attributes;
				for (var i = 0; i < nnm.length; i++) {
					var a = nnm.item(i);
					var aname = a.name || a.nodeName;
					if (aname === "xmlns" && prefix === "" || aname === "xmlns:" + prefix) return String(a.value || a.nodeValue);
				}
				n = n.parentNode;
			}
			return null;
		};
		var Functions = /* @__PURE__ */ new Object();
		Functions.last = function(c) {
			if (arguments.length != 1) throw new Error("Function last expects ()");
			return new XNumber(c.contextSize);
		};
		Functions.position = function(c) {
			if (arguments.length != 1) throw new Error("Function position expects ()");
			return new XNumber(c.contextPosition);
		};
		Functions.count = function() {
			var c = arguments[0];
			var ns;
			if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) throw new Error("Function count expects (node-set)");
			return new XNumber(ns.size);
		};
		Functions.id = function() {
			var c = arguments[0];
			var id;
			if (arguments.length != 2) throw new Error("Function id expects (object)");
			id = arguments[1].evaluate(c);
			if (Utilities.instance_of(id, XNodeSet)) id = id.toArray().join(" ");
			else id = id.stringValue();
			var ids = id.split(/[\x0d\x0a\x09\x20]+/);
			var count = 0;
			var ns = new XNodeSet();
			var doc = c.contextNode.nodeType == NodeTypes.DOCUMENT_NODE ? c.contextNode : c.contextNode.ownerDocument;
			for (var i = 0; i < ids.length; i++) {
				var n;
				if (doc.getElementById) n = doc.getElementById(ids[i]);
				else n = Utilities.getElementById(doc, ids[i]);
				if (n != null) {
					ns.add(n);
					count++;
				}
			}
			return ns;
		};
		Functions.localName = function(c, eNode) {
			var n;
			if (arguments.length == 1) n = c.contextNode;
			else if (arguments.length == 2) n = eNode.evaluate(c).first();
			else throw new Error("Function local-name expects (node-set?)");
			if (n == null) return new XString("");
			return new XString(n.localName || n.baseName || n.target || n.nodeName || "");
		};
		Functions.namespaceURI = function() {
			var c = arguments[0];
			var n;
			if (arguments.length == 1) n = c.contextNode;
			else if (arguments.length == 2) n = arguments[1].evaluate(c).first();
			else throw new Error("Function namespace-uri expects (node-set?)");
			if (n == null) return new XString("");
			return new XString(n.namespaceURI);
		};
		Functions.name = function() {
			var c = arguments[0];
			var n;
			if (arguments.length == 1) n = c.contextNode;
			else if (arguments.length == 2) n = arguments[1].evaluate(c).first();
			else throw new Error("Function name expects (node-set?)");
			if (n == null) return new XString("");
			if (n.nodeType == NodeTypes.ELEMENT_NODE) return new XString(n.nodeName);
			else if (n.nodeType == NodeTypes.ATTRIBUTE_NODE) return new XString(n.name || n.nodeName);
			else if (n.nodeType === NodeTypes.PROCESSING_INSTRUCTION_NODE) return new XString(n.target || n.nodeName);
			else if (n.localName == null) return new XString("");
			else return new XString(n.localName);
		};
		Functions.string = function() {
			var c = arguments[0];
			if (arguments.length == 1) return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
			else if (arguments.length == 2) return arguments[1].evaluate(c).string();
			throw new Error("Function string expects (object?)");
		};
		Functions.concat = function(c) {
			if (arguments.length < 3) throw new Error("Function concat expects (string, string[, string]*)");
			var s = "";
			for (var i = 1; i < arguments.length; i++) s += arguments[i].evaluate(c).stringValue();
			return new XString(s);
		};
		Functions.startsWith = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function startsWith expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			return new XBoolean(s1.substring(0, s2.length) == s2);
		};
		Functions.contains = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function contains expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			return new XBoolean(s1.indexOf(s2) !== -1);
		};
		Functions.substringBefore = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function substring-before expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			return new XString(s1.substring(0, s1.indexOf(s2)));
		};
		Functions.substringAfter = function() {
			var c = arguments[0];
			if (arguments.length != 3) throw new Error("Function substring-after expects (string, string)");
			var s1 = arguments[1].evaluate(c).stringValue();
			var s2 = arguments[2].evaluate(c).stringValue();
			if (s2.length == 0) return new XString(s1);
			var i = s1.indexOf(s2);
			if (i == -1) return new XString("");
			return new XString(s1.substring(i + s2.length));
		};
		Functions.substring = function() {
			var c = arguments[0];
			if (!(arguments.length == 3 || arguments.length == 4)) throw new Error("Function substring expects (string, number, number?)");
			var s = arguments[1].evaluate(c).stringValue();
			var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
			var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : void 0;
			return new XString(s.substring(n1, n2));
		};
		Functions.stringLength = function() {
			var c = arguments[0];
			var s;
			if (arguments.length == 1) s = XNodeSet.prototype.stringForNode(c.contextNode);
			else if (arguments.length == 2) s = arguments[1].evaluate(c).stringValue();
			else throw new Error("Function string-length expects (string?)");
			return new XNumber(s.length);
		};
		Functions.normalizeSpace = function() {
			var c = arguments[0];
			var s;
			if (arguments.length == 1) s = XNodeSet.prototype.stringForNode(c.contextNode);
			else if (arguments.length == 2) s = arguments[1].evaluate(c).stringValue();
			else throw new Error("Function normalize-space expects (string?)");
			var i = 0;
			var j = s.length - 1;
			while (Utilities.isSpace(s.charCodeAt(j))) j--;
			var t = "";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) i++;
			while (i <= j) if (Utilities.isSpace(s.charCodeAt(i))) {
				t += " ";
				while (i <= j && Utilities.isSpace(s.charCodeAt(i))) i++;
			} else {
				t += s.charAt(i);
				i++;
			}
			return new XString(t);
		};
		Functions.translate = function(c, eValue, eFrom, eTo) {
			if (arguments.length != 4) throw new Error("Function translate expects (string, string, string)");
			var value = eValue.evaluate(c).stringValue();
			var from = eFrom.evaluate(c).stringValue();
			var to = eTo.evaluate(c).stringValue();
			var cMap = reduce(function(acc, ch, i) {
				if (!(ch in acc)) acc[ch] = i > to.length ? "" : to[i];
				return acc;
			}, {}, from);
			return new XString(join("", map$1(function(ch) {
				return ch in cMap ? cMap[ch] : ch;
			}, value)));
		};
		Functions.boolean_ = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function boolean expects (object)");
			return arguments[1].evaluate(c).bool();
		};
		Functions.not = function(c, eValue) {
			if (arguments.length != 2) throw new Error("Function not expects (object)");
			return eValue.evaluate(c).bool().not();
		};
		Functions.true_ = function() {
			if (arguments.length != 1) throw new Error("Function true expects ()");
			return XBoolean.true_;
		};
		Functions.false_ = function() {
			if (arguments.length != 1) throw new Error("Function false expects ()");
			return XBoolean.false_;
		};
		Functions.lang = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function lang expects (string)");
			var lang;
			for (var n = c.contextNode; n != null && n.nodeType != NodeTypes.DOCUMENT_NODE; n = n.parentNode) {
				var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
				if (a != null) {
					lang = String(a);
					break;
				}
			}
			if (lang == null) return XBoolean.false_;
			var s = arguments[1].evaluate(c).stringValue();
			return new XBoolean(lang.substring(0, s.length) == s && (lang.length == s.length || lang.charAt(s.length) == "-"));
		};
		Functions.number = function() {
			var c = arguments[0];
			if (!(arguments.length == 1 || arguments.length == 2)) throw new Error("Function number expects (object?)");
			if (arguments.length == 1) return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
			return arguments[1].evaluate(c).number();
		};
		Functions.sum = function() {
			var c = arguments[0];
			var ns;
			if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) throw new Error("Function sum expects (node-set)");
			ns = ns.toUnsortedArray();
			var n = 0;
			for (var i = 0; i < ns.length; i++) n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
			return new XNumber(n);
		};
		Functions.floor = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function floor expects (number)");
			return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
		};
		Functions.ceiling = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function ceiling expects (number)");
			return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
		};
		Functions.round = function() {
			var c = arguments[0];
			if (arguments.length != 2) throw new Error("Function round expects (number)");
			return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
		};
		var Utilities = /* @__PURE__ */ new Object();
		Utilities.isAttribute = function(val) {
			return val && (val.nodeType === NodeTypes.ATTRIBUTE_NODE || val.ownerElement);
		};
		Utilities.splitQName = function(qn) {
			var i = qn.indexOf(":");
			if (i == -1) return [null, qn];
			return [qn.substring(0, i), qn.substring(i + 1)];
		};
		Utilities.resolveQName = function(qn, nr, n, useDefault) {
			var parts = Utilities.splitQName(qn);
			if (parts[0] != null) parts[0] = nr.getNamespace(parts[0], n);
			else if (useDefault) {
				parts[0] = nr.getNamespace("", n);
				if (parts[0] == null) parts[0] = "";
			} else parts[0] = "";
			return parts;
		};
		Utilities.isSpace = function(c) {
			return c == 9 || c == 13 || c == 10 || c == 32;
		};
		Utilities.isLetter = function(c) {
			return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 255 || c >= 256 && c <= 305 || c >= 308 && c <= 318 || c >= 321 && c <= 328 || c >= 330 && c <= 382 || c >= 384 && c <= 451 || c >= 461 && c <= 496 || c >= 500 && c <= 501 || c >= 506 && c <= 535 || c >= 592 && c <= 680 || c >= 699 && c <= 705 || c == 902 || c >= 904 && c <= 906 || c == 908 || c >= 910 && c <= 929 || c >= 931 && c <= 974 || c >= 976 && c <= 982 || c == 986 || c == 988 || c == 990 || c == 992 || c >= 994 && c <= 1011 || c >= 1025 && c <= 1036 || c >= 1038 && c <= 1103 || c >= 1105 && c <= 1116 || c >= 1118 && c <= 1153 || c >= 1168 && c <= 1220 || c >= 1223 && c <= 1224 || c >= 1227 && c <= 1228 || c >= 1232 && c <= 1259 || c >= 1262 && c <= 1269 || c >= 1272 && c <= 1273 || c >= 1329 && c <= 1366 || c == 1369 || c >= 1377 && c <= 1414 || c >= 1488 && c <= 1514 || c >= 1520 && c <= 1522 || c >= 1569 && c <= 1594 || c >= 1601 && c <= 1610 || c >= 1649 && c <= 1719 || c >= 1722 && c <= 1726 || c >= 1728 && c <= 1742 || c >= 1744 && c <= 1747 || c == 1749 || c >= 1765 && c <= 1766 || c >= 2309 && c <= 2361 || c == 2365 || c >= 2392 && c <= 2401 || c >= 2437 && c <= 2444 || c >= 2447 && c <= 2448 || c >= 2451 && c <= 2472 || c >= 2474 && c <= 2480 || c == 2482 || c >= 2486 && c <= 2489 || c >= 2524 && c <= 2525 || c >= 2527 && c <= 2529 || c >= 2544 && c <= 2545 || c >= 2565 && c <= 2570 || c >= 2575 && c <= 2576 || c >= 2579 && c <= 2600 || c >= 2602 && c <= 2608 || c >= 2610 && c <= 2611 || c >= 2613 && c <= 2614 || c >= 2616 && c <= 2617 || c >= 2649 && c <= 2652 || c == 2654 || c >= 2674 && c <= 2676 || c >= 2693 && c <= 2699 || c == 2701 || c >= 2703 && c <= 2705 || c >= 2707 && c <= 2728 || c >= 2730 && c <= 2736 || c >= 2738 && c <= 2739 || c >= 2741 && c <= 2745 || c == 2749 || c == 2784 || c >= 2821 && c <= 2828 || c >= 2831 && c <= 2832 || c >= 2835 && c <= 2856 || c >= 2858 && c <= 2864 || c >= 2866 && c <= 2867 || c >= 2870 && c <= 2873 || c == 2877 || c >= 2908 && c <= 2909 || c >= 2911 && c <= 2913 || c >= 2949 && c <= 2954 || c >= 2958 && c <= 2960 || c >= 2962 && c <= 2965 || c >= 2969 && c <= 2970 || c == 2972 || c >= 2974 && c <= 2975 || c >= 2979 && c <= 2980 || c >= 2984 && c <= 2986 || c >= 2990 && c <= 2997 || c >= 2999 && c <= 3001 || c >= 3077 && c <= 3084 || c >= 3086 && c <= 3088 || c >= 3090 && c <= 3112 || c >= 3114 && c <= 3123 || c >= 3125 && c <= 3129 || c >= 3168 && c <= 3169 || c >= 3205 && c <= 3212 || c >= 3214 && c <= 3216 || c >= 3218 && c <= 3240 || c >= 3242 && c <= 3251 || c >= 3253 && c <= 3257 || c == 3294 || c >= 3296 && c <= 3297 || c >= 3333 && c <= 3340 || c >= 3342 && c <= 3344 || c >= 3346 && c <= 3368 || c >= 3370 && c <= 3385 || c >= 3424 && c <= 3425 || c >= 3585 && c <= 3630 || c == 3632 || c >= 3634 && c <= 3635 || c >= 3648 && c <= 3653 || c >= 3713 && c <= 3714 || c == 3716 || c >= 3719 && c <= 3720 || c == 3722 || c == 3725 || c >= 3732 && c <= 3735 || c >= 3737 && c <= 3743 || c >= 3745 && c <= 3747 || c == 3749 || c == 3751 || c >= 3754 && c <= 3755 || c >= 3757 && c <= 3758 || c == 3760 || c >= 3762 && c <= 3763 || c == 3773 || c >= 3776 && c <= 3780 || c >= 3904 && c <= 3911 || c >= 3913 && c <= 3945 || c >= 4256 && c <= 4293 || c >= 4304 && c <= 4342 || c == 4352 || c >= 4354 && c <= 4355 || c >= 4357 && c <= 4359 || c == 4361 || c >= 4363 && c <= 4364 || c >= 4366 && c <= 4370 || c == 4412 || c == 4414 || c == 4416 || c == 4428 || c == 4430 || c == 4432 || c >= 4436 && c <= 4437 || c == 4441 || c >= 4447 && c <= 4449 || c == 4451 || c == 4453 || c == 4455 || c == 4457 || c >= 4461 && c <= 4462 || c >= 4466 && c <= 4467 || c == 4469 || c == 4510 || c == 4520 || c == 4523 || c >= 4526 && c <= 4527 || c >= 4535 && c <= 4536 || c == 4538 || c >= 4540 && c <= 4546 || c == 4587 || c == 4592 || c == 4601 || c >= 7680 && c <= 7835 || c >= 7840 && c <= 7929 || c >= 7936 && c <= 7957 || c >= 7960 && c <= 7965 || c >= 7968 && c <= 8005 || c >= 8008 && c <= 8013 || c >= 8016 && c <= 8023 || c == 8025 || c == 8027 || c == 8029 || c >= 8031 && c <= 8061 || c >= 8064 && c <= 8116 || c >= 8118 && c <= 8124 || c == 8126 || c >= 8130 && c <= 8132 || c >= 8134 && c <= 8140 || c >= 8144 && c <= 8147 || c >= 8150 && c <= 8155 || c >= 8160 && c <= 8172 || c >= 8178 && c <= 8180 || c >= 8182 && c <= 8188 || c == 8486 || c >= 8490 && c <= 8491 || c == 8494 || c >= 8576 && c <= 8578 || c >= 12353 && c <= 12436 || c >= 12449 && c <= 12538 || c >= 12549 && c <= 12588 || c >= 44032 && c <= 55203 || c >= 19968 && c <= 40869 || c == 12295 || c >= 12321 && c <= 12329;
		};
		Utilities.isNCNameChar = function(c) {
			return c >= 48 && c <= 57 || c >= 1632 && c <= 1641 || c >= 1776 && c <= 1785 || c >= 2406 && c <= 2415 || c >= 2534 && c <= 2543 || c >= 2662 && c <= 2671 || c >= 2790 && c <= 2799 || c >= 2918 && c <= 2927 || c >= 3047 && c <= 3055 || c >= 3174 && c <= 3183 || c >= 3302 && c <= 3311 || c >= 3430 && c <= 3439 || c >= 3664 && c <= 3673 || c >= 3792 && c <= 3801 || c >= 3872 && c <= 3881 || c == 46 || c == 45 || c == 95 || Utilities.isLetter(c) || c >= 768 && c <= 837 || c >= 864 && c <= 865 || c >= 1155 && c <= 1158 || c >= 1425 && c <= 1441 || c >= 1443 && c <= 1465 || c >= 1467 && c <= 1469 || c == 1471 || c >= 1473 && c <= 1474 || c == 1476 || c >= 1611 && c <= 1618 || c == 1648 || c >= 1750 && c <= 1756 || c >= 1757 && c <= 1759 || c >= 1760 && c <= 1764 || c >= 1767 && c <= 1768 || c >= 1770 && c <= 1773 || c >= 2305 && c <= 2307 || c == 2364 || c >= 2366 && c <= 2380 || c == 2381 || c >= 2385 && c <= 2388 || c >= 2402 && c <= 2403 || c >= 2433 && c <= 2435 || c == 2492 || c == 2494 || c == 2495 || c >= 2496 && c <= 2500 || c >= 2503 && c <= 2504 || c >= 2507 && c <= 2509 || c == 2519 || c >= 2530 && c <= 2531 || c == 2562 || c == 2620 || c == 2622 || c == 2623 || c >= 2624 && c <= 2626 || c >= 2631 && c <= 2632 || c >= 2635 && c <= 2637 || c >= 2672 && c <= 2673 || c >= 2689 && c <= 2691 || c == 2748 || c >= 2750 && c <= 2757 || c >= 2759 && c <= 2761 || c >= 2763 && c <= 2765 || c >= 2817 && c <= 2819 || c == 2876 || c >= 2878 && c <= 2883 || c >= 2887 && c <= 2888 || c >= 2891 && c <= 2893 || c >= 2902 && c <= 2903 || c >= 2946 && c <= 2947 || c >= 3006 && c <= 3010 || c >= 3014 && c <= 3016 || c >= 3018 && c <= 3021 || c == 3031 || c >= 3073 && c <= 3075 || c >= 3134 && c <= 3140 || c >= 3142 && c <= 3144 || c >= 3146 && c <= 3149 || c >= 3157 && c <= 3158 || c >= 3202 && c <= 3203 || c >= 3262 && c <= 3268 || c >= 3270 && c <= 3272 || c >= 3274 && c <= 3277 || c >= 3285 && c <= 3286 || c >= 3330 && c <= 3331 || c >= 3390 && c <= 3395 || c >= 3398 && c <= 3400 || c >= 3402 && c <= 3405 || c == 3415 || c == 3633 || c >= 3636 && c <= 3642 || c >= 3655 && c <= 3662 || c == 3761 || c >= 3764 && c <= 3769 || c >= 3771 && c <= 3772 || c >= 3784 && c <= 3789 || c >= 3864 && c <= 3865 || c == 3893 || c == 3895 || c == 3897 || c == 3902 || c == 3903 || c >= 3953 && c <= 3972 || c >= 3974 && c <= 3979 || c >= 3984 && c <= 3989 || c == 3991 || c >= 3993 && c <= 4013 || c >= 4017 && c <= 4023 || c == 4025 || c >= 8400 && c <= 8412 || c == 8417 || c >= 12330 && c <= 12335 || c == 12441 || c == 12442 || c == 183 || c == 720 || c == 721 || c == 903 || c == 1600 || c == 3654 || c == 3782 || c == 12293 || c >= 12337 && c <= 12341 || c >= 12445 && c <= 12446 || c >= 12540 && c <= 12542;
		};
		Utilities.coalesceText = function(n) {
			for (var m = n.firstChild; m != null; m = m.nextSibling) if (m.nodeType == NodeTypes.TEXT_NODE || m.nodeType == NodeTypes.CDATA_SECTION_NODE) {
				var s = m.nodeValue;
				var first = m;
				m = m.nextSibling;
				while (m != null && (m.nodeType == NodeTypes.TEXT_NODE || m.nodeType == NodeTypes.CDATA_SECTION_NODE)) {
					s += m.nodeValue;
					var del = m;
					m = m.nextSibling;
					del.parentNode.removeChild(del);
				}
				if (first.nodeType == NodeTypes.CDATA_SECTION_NODE) {
					var p = first.parentNode;
					if (first.nextSibling == null) {
						p.removeChild(first);
						p.appendChild(p.ownerDocument.createTextNode(s));
					} else {
						var next = first.nextSibling;
						p.removeChild(first);
						p.insertBefore(p.ownerDocument.createTextNode(s), next);
					}
				} else first.nodeValue = s;
				if (m == null) break;
			} else if (m.nodeType == NodeTypes.ELEMENT_NODE) Utilities.coalesceText(m);
		};
		Utilities.instance_of = function(o, c) {
			while (o != null) {
				if (o.constructor === c) return true;
				if (o === Object) return false;
				o = o.constructor.superclass;
			}
			return false;
		};
		Utilities.getElementById = function(n, id) {
			if (n.nodeType == NodeTypes.ELEMENT_NODE) {
				if (n.getAttribute("id") == id || n.getAttributeNS(null, "id") == id) return n;
			}
			for (var m = n.firstChild; m != null; m = m.nextSibling) {
				var res = Utilities.getElementById(m, id);
				if (res != null) return res;
			}
			return null;
		};
		var XPathException = (function() {
			function getMessage(code, exception) {
				var msg = exception ? ": " + exception.toString() : "";
				switch (code) {
					case XPathException$1.INVALID_EXPRESSION_ERR: return "Invalid expression" + msg;
					case XPathException$1.TYPE_ERR: return "Type error" + msg;
				}
				return null;
			}
			function XPathException$1(code, error$47, message) {
				var err = Error.call(this, getMessage(code, error$47) || message);
				err.code = code;
				err.exception = error$47;
				return err;
			}
			XPathException$1.prototype = Object.create(Error.prototype);
			XPathException$1.prototype.constructor = XPathException$1;
			XPathException$1.superclass = Error;
			XPathException$1.prototype.toString = function() {
				return this.message;
			};
			XPathException$1.fromMessage = function(message, error$47) {
				return new XPathException$1(null, error$47, message);
			};
			XPathException$1.INVALID_EXPRESSION_ERR = 51;
			XPathException$1.TYPE_ERR = 52;
			return XPathException$1;
		})();
		XPathExpression.prototype = {};
		XPathExpression.prototype.constructor = XPathExpression;
		XPathExpression.superclass = Object.prototype;
		function XPathExpression(e, r, p) {
			this.xpath = p.parse(e);
			this.context = new XPathContext();
			this.context.namespaceResolver = new XPathNSResolverWrapper(r);
		}
		XPathExpression.getOwnerDocument = function(n) {
			return n.nodeType === NodeTypes.DOCUMENT_NODE ? n : n.ownerDocument;
		};
		XPathExpression.detectHtmlDom = function(n) {
			if (!n) return false;
			var doc = XPathExpression.getOwnerDocument(n);
			try {
				return doc.implementation.hasFeature("HTML", "2.0");
			} catch (e) {
				return true;
			}
		};
		XPathExpression.prototype.evaluate = function(n, t, res) {
			this.context.expressionContextNode = n;
			this.context.caseInsensitive = XPathExpression.detectHtmlDom(n);
			return new XPathResult(this.xpath.evaluate(this.context), t);
		};
		XPathNSResolverWrapper.prototype = {};
		XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
		XPathNSResolverWrapper.superclass = Object.prototype;
		function XPathNSResolverWrapper(r) {
			this.xpathNSResolver = r;
		}
		XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
			if (this.xpathNSResolver == null) return null;
			return this.xpathNSResolver.lookupNamespaceURI(prefix);
		};
		NodeXPathNSResolver.prototype = {};
		NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
		NodeXPathNSResolver.superclass = Object.prototype;
		function NodeXPathNSResolver(n) {
			this.node = n;
			this.namespaceResolver = new NamespaceResolver();
		}
		NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
			return this.namespaceResolver.getNamespace(prefix, this.node);
		};
		XPathResult.prototype = {};
		XPathResult.prototype.constructor = XPathResult;
		XPathResult.superclass = Object.prototype;
		function XPathResult(v, t) {
			if (t == XPathResult.ANY_TYPE) {
				if (v.constructor === XString) t = XPathResult.STRING_TYPE;
				else if (v.constructor === XNumber) t = XPathResult.NUMBER_TYPE;
				else if (v.constructor === XBoolean) t = XPathResult.BOOLEAN_TYPE;
				else if (v.constructor === XNodeSet) t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
			}
			this.resultType = t;
			switch (t) {
				case XPathResult.NUMBER_TYPE:
					this.numberValue = v.numberValue();
					return;
				case XPathResult.STRING_TYPE:
					this.stringValue = v.stringValue();
					return;
				case XPathResult.BOOLEAN_TYPE:
					this.booleanValue = v.booleanValue();
					return;
				case XPathResult.ANY_UNORDERED_NODE_TYPE:
				case XPathResult.FIRST_ORDERED_NODE_TYPE:
					if (v.constructor === XNodeSet) {
						this.singleNodeValue = v.first();
						return;
					}
					break;
				case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
				case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
					if (v.constructor === XNodeSet) {
						this.invalidIteratorState = false;
						this.nodes = v.toArray();
						this.iteratorIndex = 0;
						return;
					}
					break;
				case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
				case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
					if (v.constructor === XNodeSet) {
						this.nodes = v.toArray();
						this.snapshotLength = this.nodes.length;
						return;
					}
					break;
			}
			throw new XPathException(XPathException.TYPE_ERR);
		}
		XPathResult.prototype.iterateNext = function() {
			if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) throw new XPathException(XPathException.TYPE_ERR);
			return this.nodes[this.iteratorIndex++];
		};
		XPathResult.prototype.snapshotItem = function(i) {
			if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) throw new XPathException(XPathException.TYPE_ERR);
			return this.nodes[i];
		};
		XPathResult.ANY_TYPE = 0;
		XPathResult.NUMBER_TYPE = 1;
		XPathResult.STRING_TYPE = 2;
		XPathResult.BOOLEAN_TYPE = 3;
		XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
		XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
		XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
		XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
		XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
		XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
		function installDOM3XPathSupport(doc, p) {
			doc.createExpression = function(e, r) {
				try {
					return new XPathExpression(e, r, p);
				} catch (e$1) {
					throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e$1);
				}
			};
			doc.createNSResolver = function(n) {
				return new NodeXPathNSResolver(n);
			};
			doc.evaluate = function(e, cn, r, t, res) {
				if (t < 0 || t > 9) throw {
					code: 0,
					toString: function() {
						return "Request type not supported";
					}
				};
				return doc.createExpression(e, r, p).evaluate(cn, t, res);
			};
		}
		try {
			var shouldInstall = true;
			try {
				if (document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("XPath", null)) shouldInstall = false;
			} catch (e) {}
			if (shouldInstall) installDOM3XPathSupport(document, new XPathParser());
		} catch (e) {}
		installDOM3XPathSupport(exports$1, new XPathParser());
		(function() {
			var parser = new XPathParser();
			var defaultNSResolver = new NamespaceResolver();
			var defaultFunctionResolver = new FunctionResolver();
			var defaultVariableResolver = new VariableResolver();
			function makeNSResolverFromFunction(func) {
				return { getNamespace: function(prefix, node) {
					return func(prefix, node) || defaultNSResolver.getNamespace(prefix, node);
				} };
			}
			function makeNSResolverFromObject(obj) {
				return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
			}
			function makeNSResolverFromMap(map$2) {
				return makeNSResolverFromFunction(function(prefix) {
					return map$2[prefix];
				});
			}
			function makeNSResolver(resolver) {
				if (resolver && typeof resolver.getNamespace === "function") return makeNSResolverFromObject(resolver);
				if (typeof resolver === "function") return makeNSResolverFromFunction(resolver);
				if (typeof resolver === "object") return makeNSResolverFromMap(resolver);
				return defaultNSResolver;
			}
			/** Converts native JavaScript types to their XPath library equivalent */
			function convertValue(value) {
				if (value === null || typeof value === "undefined" || value instanceof XString || value instanceof XBoolean || value instanceof XNumber || value instanceof XNodeSet) return value;
				switch (typeof value) {
					case "string": return new XString(value);
					case "boolean": return new XBoolean(value);
					case "number": return new XNumber(value);
				}
				var ns = new XNodeSet();
				ns.addArray([].concat(value));
				return ns;
			}
			function makeEvaluator(func) {
				return function(context) {
					var args = Array.prototype.slice.call(arguments, 1).map(function(arg) {
						return arg.evaluate(context);
					});
					return convertValue(func.apply(this, [].concat(context, args)));
				};
			}
			function makeFunctionResolverFromFunction(func) {
				return { getFunction: function(name$1, namespace) {
					var found = func(name$1, namespace);
					if (found) return makeEvaluator(found);
					return defaultFunctionResolver.getFunction(name$1, namespace);
				} };
			}
			function makeFunctionResolverFromObject(obj) {
				return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
			}
			function makeFunctionResolverFromMap(map$2) {
				return makeFunctionResolverFromFunction(function(name$1) {
					return map$2[name$1];
				});
			}
			function makeFunctionResolver(resolver) {
				if (resolver && typeof resolver.getFunction === "function") return makeFunctionResolverFromObject(resolver);
				if (typeof resolver === "function") return makeFunctionResolverFromFunction(resolver);
				if (typeof resolver === "object") return makeFunctionResolverFromMap(resolver);
				return defaultFunctionResolver;
			}
			function makeVariableResolverFromFunction(func) {
				return { getVariable: function(name$1, namespace) {
					return convertValue(func(name$1, namespace));
				} };
			}
			function makeVariableResolver(resolver) {
				if (resolver) {
					if (typeof resolver.getVariable === "function") return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
					if (typeof resolver === "function") return makeVariableResolverFromFunction(resolver);
					if (typeof resolver === "object") return makeVariableResolverFromFunction(function(name$1) {
						return resolver[name$1];
					});
				}
				return defaultVariableResolver;
			}
			function copyIfPresent(prop, dest, source) {
				if (prop in source) dest[prop] = source[prop];
			}
			function makeContext(options) {
				var context = new XPathContext();
				if (options) {
					context.namespaceResolver = makeNSResolver(options.namespaces);
					context.functionResolver = makeFunctionResolver(options.functions);
					context.variableResolver = makeVariableResolver(options.variables);
					context.expressionContextNode = options.node;
					copyIfPresent("allowAnyNamespaceForNoPrefix", context, options);
					copyIfPresent("isHtml", context, options);
				} else context.namespaceResolver = defaultNSResolver;
				return context;
			}
			function evaluate(parsedExpression, options) {
				var context = makeContext(options);
				return parsedExpression.evaluate(context);
			}
			var evaluatorPrototype = {
				evaluate: function(options) {
					return evaluate(this.expression, options);
				},
				evaluateNumber: function(options) {
					return this.evaluate(options).numberValue();
				},
				evaluateString: function(options) {
					return this.evaluate(options).stringValue();
				},
				evaluateBoolean: function(options) {
					return this.evaluate(options).booleanValue();
				},
				evaluateNodeSet: function(options) {
					return this.evaluate(options).nodeset();
				},
				select: function(options) {
					return this.evaluateNodeSet(options).toArray();
				},
				select1: function(options) {
					return this.select(options)[0];
				}
			};
			function parse$3(xpath) {
				var parsed = parser.parse(xpath);
				return Object.create(evaluatorPrototype, { expression: { value: parsed } });
			}
			exports$1.parse = parse$3;
		})();
		assign(exports$1, {
			XPath,
			XPathParser,
			XPathResult,
			Step,
			PathExpr,
			NodeTest,
			LocationPath,
			OrOperation,
			AndOperation,
			BarOperation,
			EqualsOperation,
			NotEqualOperation,
			LessThanOperation,
			GreaterThanOperation,
			LessThanOrEqualOperation,
			GreaterThanOrEqualOperation,
			PlusOperation,
			MinusOperation,
			MultiplyOperation,
			DivOperation,
			ModOperation,
			UnaryMinusOperation,
			FunctionCall,
			VariableReference,
			XPathContext,
			XNodeSet,
			XBoolean,
			XString,
			XNumber,
			NamespaceResolver,
			FunctionResolver,
			VariableResolver,
			Utilities
		});
		exports$1.select = function(e, doc, single) {
			return exports$1.selectWithResolver(e, doc, null, single);
		};
		exports$1.useNamespaces = function(mappings) {
			var resolver = {
				mappings: mappings || {},
				lookupNamespaceURI: function(prefix) {
					return this.mappings[prefix];
				}
			};
			return function(e, doc, single) {
				return exports$1.selectWithResolver(e, doc, resolver, single);
			};
		};
		exports$1.selectWithResolver = function(e, doc, resolver, single) {
			var expression = new XPathExpression(e, resolver, new XPathParser());
			var type = XPathResult.ANY_TYPE;
			var result = expression.evaluate(doc, type, null);
			if (result.resultType == XPathResult.STRING_TYPE) result = result.stringValue;
			else if (result.resultType == XPathResult.NUMBER_TYPE) result = result.numberValue;
			else if (result.resultType == XPathResult.BOOLEAN_TYPE) result = result.booleanValue;
			else {
				result = result.nodes;
				if (single) result = result[0];
			}
			return result;
		};
		exports$1.select1 = function(e, doc) {
			return exports$1.select(e, doc, true);
		};
		var isNodeLike = function(value) {
			return value && typeof value.nodeType === "number" && Number.isInteger(value.nodeType) && value.nodeType >= 1 && value.nodeType <= 11 && typeof value.nodeName === "string";
		};
		var isArrayOfNodes = function(value) {
			return Array.isArray(value) && value.every(isNodeLike);
		};
		var isNodeOfType = function(type) {
			return function(value) {
				return isNodeLike(value) && value.nodeType === type;
			};
		};
		assign(exports$1, {
			isNodeLike,
			isArrayOfNodes,
			isElement: isNodeOfType(NodeTypes.ELEMENT_NODE),
			isAttribute: isNodeOfType(NodeTypes.ATTRIBUTE_NODE),
			isTextNode: isNodeOfType(NodeTypes.TEXT_NODE),
			isCDATASection: isNodeOfType(NodeTypes.CDATA_SECTION_NODE),
			isProcessingInstruction: isNodeOfType(NodeTypes.PROCESSING_INSTRUCTION_NODE),
			isComment: isNodeOfType(NodeTypes.COMMENT_NODE),
			isDocumentNode: isNodeOfType(NodeTypes.DOCUMENT_NODE),
			isDocumentTypeNode: isNodeOfType(NodeTypes.DOCUMENT_TYPE_NODE),
			isDocumentFragment: isNodeOfType(NodeTypes.DOCUMENT_FRAGMENT_NODE)
		});
	})(typeof exports === "undefined" ? {} : exports);
}));

//#endregion
//#region ../../node_modules/.bun/@xmldom+is-dom-node@1.0.1/node_modules/@xmldom/is-dom-node/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.assertIsDocumentFragmentNode = exports.assertIsDocumentTypeNode = exports.assertIsDocumentNode = exports.assertIsCommentNode = exports.assertIsProcessingInstructionNode = exports.assertIsCDATASectionNode = exports.assertIsTextNode = exports.assertIsAttributeNode = exports.assertIsElementNode = exports.isDocumentFragmentNode = exports.isDocumentTypeNode = exports.isDocumentNode = exports.isCommentNode = exports.isProcessingInstructionNode = exports.isCDATASectionNode = exports.isTextNode = exports.isAttributeNode = exports.isElementNode = exports.assertIsArrayOfNodes = exports.isArrayOfNodes = exports.assertIsNodeLike = exports.isNodeLike = exports.NodeTypes = void 0;
	var NodeTypes;
	(function(NodeTypes) {
		NodeTypes[NodeTypes["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
		NodeTypes[NodeTypes["ATTRIBUTE_NODE"] = 2] = "ATTRIBUTE_NODE";
		NodeTypes[NodeTypes["TEXT_NODE"] = 3] = "TEXT_NODE";
		NodeTypes[NodeTypes["CDATA_SECTION_NODE"] = 4] = "CDATA_SECTION_NODE";
		NodeTypes[NodeTypes["PROCESSING_INSTRUCTION_NODE"] = 7] = "PROCESSING_INSTRUCTION_NODE";
		NodeTypes[NodeTypes["COMMENT_NODE"] = 8] = "COMMENT_NODE";
		NodeTypes[NodeTypes["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
		NodeTypes[NodeTypes["DOCUMENT_TYPE_NODE"] = 10] = "DOCUMENT_TYPE_NODE";
		NodeTypes[NodeTypes["DOCUMENT_FRAGMENT_NODE"] = 11] = "DOCUMENT_FRAGMENT_NODE";
	})(NodeTypes || (exports.NodeTypes = NodeTypes = {}));
	function isNodeLike(value) {
		return value && typeof value === "object" && Number.isInteger(value.nodeType) && value.nodeType >= 1 && value.nodeType <= 11 && typeof value.nodeName === "string" && typeof value.appendChild === "function" && typeof value.removeChild === "function";
	}
	exports.isNodeLike = isNodeLike;
	function assertIsNodeLike(value) {
		if (!isNodeLike(value)) throw new Error(`Value is not a Node-like object. Received: ${value}`);
	}
	exports.assertIsNodeLike = assertIsNodeLike;
	function isArrayOfNodes(value) {
		return Array.isArray(value) && value.every(isNodeLike);
	}
	exports.isArrayOfNodes = isArrayOfNodes;
	function assertIsArrayOfNodes(value) {
		if (!isArrayOfNodes(value)) throw new Error("Value is not an array of Nodes");
	}
	exports.assertIsArrayOfNodes = assertIsArrayOfNodes;
	function isNodeOfType(type, value) {
		return isNodeLike(value) && value.nodeType === type;
	}
	function assertIsNodeOfType(type, value) {
		const typeName = Object.keys(NodeTypes).find((key) => NodeTypes[key] === type);
		if (!isNodeOfType(type, value)) throw new Error(`Value is not of type ${typeName}`);
	}
	const isElementNode = (value) => isNodeOfType(NodeTypes.ELEMENT_NODE, value);
	exports.isElementNode = isElementNode;
	const isAttributeNode = (value) => isNodeOfType(NodeTypes.ATTRIBUTE_NODE, value);
	exports.isAttributeNode = isAttributeNode;
	const isTextNode = (value) => isNodeOfType(NodeTypes.TEXT_NODE, value);
	exports.isTextNode = isTextNode;
	const isCDATASectionNode = (value) => isNodeOfType(NodeTypes.CDATA_SECTION_NODE, value);
	exports.isCDATASectionNode = isCDATASectionNode;
	const isProcessingInstructionNode = (value) => isNodeOfType(NodeTypes.PROCESSING_INSTRUCTION_NODE, value);
	exports.isProcessingInstructionNode = isProcessingInstructionNode;
	const isCommentNode = (value) => isNodeOfType(NodeTypes.COMMENT_NODE, value);
	exports.isCommentNode = isCommentNode;
	const isDocumentNode = (value) => isNodeOfType(NodeTypes.DOCUMENT_NODE, value);
	exports.isDocumentNode = isDocumentNode;
	const isDocumentTypeNode = (value) => isNodeOfType(NodeTypes.DOCUMENT_TYPE_NODE, value);
	exports.isDocumentTypeNode = isDocumentTypeNode;
	const isDocumentFragmentNode = (value) => isNodeOfType(NodeTypes.DOCUMENT_FRAGMENT_NODE, value);
	exports.isDocumentFragmentNode = isDocumentFragmentNode;
	const assertIsElementNode = (value) => {
		assertIsNodeOfType(NodeTypes.ELEMENT_NODE, value);
	};
	exports.assertIsElementNode = assertIsElementNode;
	const assertIsAttributeNode = (value) => assertIsNodeOfType(NodeTypes.ATTRIBUTE_NODE, value);
	exports.assertIsAttributeNode = assertIsAttributeNode;
	const assertIsTextNode = (value) => assertIsNodeOfType(NodeTypes.TEXT_NODE, value);
	exports.assertIsTextNode = assertIsTextNode;
	const assertIsCDATASectionNode = (value) => assertIsNodeOfType(NodeTypes.CDATA_SECTION_NODE, value);
	exports.assertIsCDATASectionNode = assertIsCDATASectionNode;
	const assertIsProcessingInstructionNode = (value) => assertIsNodeOfType(NodeTypes.PROCESSING_INSTRUCTION_NODE, value);
	exports.assertIsProcessingInstructionNode = assertIsProcessingInstructionNode;
	const assertIsCommentNode = (value) => assertIsNodeOfType(NodeTypes.COMMENT_NODE, value);
	exports.assertIsCommentNode = assertIsCommentNode;
	const assertIsDocumentNode = (value) => assertIsNodeOfType(NodeTypes.DOCUMENT_NODE, value);
	exports.assertIsDocumentNode = assertIsDocumentNode;
	const assertIsDocumentTypeNode = (value) => assertIsNodeOfType(NodeTypes.DOCUMENT_TYPE_NODE, value);
	exports.assertIsDocumentTypeNode = assertIsDocumentTypeNode;
	const assertIsDocumentFragmentNode = (value) => assertIsNodeOfType(NodeTypes.DOCUMENT_FRAGMENT_NODE, value);
	exports.assertIsDocumentFragmentNode = assertIsDocumentFragmentNode;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateDigestValue = exports.findAncestorNs = exports.derToPem = exports.pemToDer = exports.normalizePem = exports.BASE64_REGEX = exports.EXTRACT_X509_CERTS = exports.PEM_FORMAT_REGEX = exports.encodeSpecialCharactersInText = exports.encodeSpecialCharactersInAttribute = exports.findChilds = exports.findChildren = exports.findAttr = exports.isArrayHasLength = void 0;
	const xpath = require_xpath();
	const isDomNode = require_dist();
	function isArrayHasLength(array$1) {
		return Array.isArray(array$1) && array$1.length > 0;
	}
	exports.isArrayHasLength = isArrayHasLength;
	function attrEqualsExplicitly(attr, localName, namespace) {
		return attr.localName === localName && (attr.namespaceURI === namespace || namespace == null);
	}
	function attrEqualsImplicitly(attr, localName, namespace, node) {
		return attr.localName === localName && (!attr.namespaceURI && node?.namespaceURI === namespace || namespace == null);
	}
	function findAttr(element, localName, namespace) {
		for (let i = 0; i < element.attributes.length; i++) {
			const attr = element.attributes[i];
			if (attrEqualsExplicitly(attr, localName, namespace) || attrEqualsImplicitly(attr, localName, namespace, element)) return attr;
		}
		return null;
	}
	exports.findAttr = findAttr;
	function findChildren(node, localName, namespace) {
		const element = node.documentElement ?? node;
		const res = [];
		for (let i = 0; i < element.childNodes.length; i++) {
			const child = element.childNodes[i];
			if (isDomNode.isElementNode(child) && child.localName === localName && (child.namespaceURI === namespace || namespace == null)) res.push(child);
		}
		return res;
	}
	exports.findChildren = findChildren;
	/** @deprecated */
	function findChilds(node, localName, namespace) {
		return findChildren(node, localName, namespace);
	}
	exports.findChilds = findChilds;
	const xml_special_to_encoded_attribute = {
		"&": "&amp;",
		"<": "&lt;",
		"\"": "&quot;",
		"\r": "&#xD;",
		"\n": "&#xA;",
		"	": "&#x9;"
	};
	const xml_special_to_encoded_text = {
		"&": "&amp;",
		"<": "&lt;",
		">": "&gt;",
		"\r": "&#xD;"
	};
	function encodeSpecialCharactersInAttribute(attributeValue) {
		return attributeValue.replace(/([&<"\r\n\t])/g, function(str, item) {
			/** Special character normalization.
			* @see:
			* - https://www.w3.org/TR/xml-c14n#ProcessingModel (Attribute Nodes)
			* - https://www.w3.org/TR/xml-c14n#Example-Chars
			*/
			return xml_special_to_encoded_attribute[item];
		});
	}
	exports.encodeSpecialCharactersInAttribute = encodeSpecialCharactersInAttribute;
	function encodeSpecialCharactersInText(text) {
		return text.replace(/([&<>\r])/g, function(str, item) {
			/** Special character normalization.
			* @see:
			* - https://www.w3.org/TR/xml-c14n#ProcessingModel (Text Nodes)
			* - https://www.w3.org/TR/xml-c14n#Example-Chars
			*/
			return xml_special_to_encoded_text[item];
		});
	}
	exports.encodeSpecialCharactersInText = encodeSpecialCharactersInText;
	/**
	* PEM format has wide range of usages, but this library
	* is enforcing RFC7468 which focuses on PKIX, PKCS and CMS.
	*
	* https://www.rfc-editor.org/rfc/rfc7468
	*
	* PEM_FORMAT_REGEX is validating given PEM file against RFC7468 'stricttextualmsg' definition.
	*
	* With few exceptions;
	*  - 'posteb' MAY have 'eol', but it is not mandatory.
	*  - 'preeb' and 'posteb' lines are limited to 64 characters, but
	*     should not cause any issues in context of PKIX, PKCS and CMS.
	*/
	exports.PEM_FORMAT_REGEX = new RegExp("^-----BEGIN [A-Z ]{1,48}-----([^-]*)-----END [A-Z ]{1,48}-----$", "s");
	exports.EXTRACT_X509_CERTS = new RegExp("-----BEGIN CERTIFICATE-----[^-]*-----END CERTIFICATE-----", "g");
	exports.BASE64_REGEX = new RegExp("^(?:[A-Za-z0-9\\+\\/]{4}\\n{0,1})*(?:[A-Za-z0-9\\+\\/]{2}==|[A-Za-z0-9\\+\\/]{3}=)?$", "s");
	/**
	* -----BEGIN [LABEL]-----
	* base64([DATA])
	* -----END [LABEL]-----
	*
	* Above is shown what PEM file looks like. As can be seen, base64 data
	* can be in single line or multiple lines.
	*
	* This function normalizes PEM presentation to;
	*  - contain PEM header and footer as they are given
	*  - normalize line endings to '\n'
	*  - normalize line length to maximum of 64 characters
	*  - ensure that 'preeb' has line ending '\n'
	*
	* With a couple of notes:
	*  - 'eol' is normalized to '\n'
	*
	* @param pem The PEM string to normalize to RFC7468 'stricttextualmsg' definition
	*/
	function normalizePem(pem) {
		return `${(pem.trim().replace(/(\r\n|\r)/g, "\n").match(/.{1,64}/g) ?? []).join("\n")}\n`;
	}
	exports.normalizePem = normalizePem;
	/**
	* @param pem The PEM-encoded base64 certificate to strip headers from
	*/
	function pemToDer(pem) {
		if (!exports.PEM_FORMAT_REGEX.test(pem.trim())) throw new Error("Invalid PEM format.");
		return Buffer.from(pem.replace(/(\r\n|\r)/g, "").replace(/-----BEGIN [A-Z\x20]{1,48}-----\n?/, "").replace(/-----END [A-Z\x20]{1,48}-----\n?/, ""), "base64");
	}
	exports.pemToDer = pemToDer;
	/**
	* @param der The DER-encoded base64 certificate to add PEM headers too
	* @param pemLabel The label of the header and footer to add
	*/
	function derToPem(der, pemLabel) {
		const base64Der = Buffer.isBuffer(der) ? der.toString("base64").trim() : der.replace(/(\r\n|\r)/g, "").trim();
		if (exports.PEM_FORMAT_REGEX.test(base64Der)) return normalizePem(base64Der);
		if (exports.BASE64_REGEX.test(base64Der.replace(/ /g, ""))) {
			if (pemLabel == null) throw new Error("PEM label is required when DER is given.");
			return normalizePem(`-----BEGIN ${pemLabel}-----\n${base64Der.replace(/ /g, "")}\n-----END ${pemLabel}-----`);
		}
		throw new Error("Unknown DER format.");
	}
	exports.derToPem = derToPem;
	function collectAncestorNamespaces(node, nsArray = []) {
		if (!isDomNode.isElementNode(node.parentNode)) return nsArray;
		const parent = node.parentNode;
		if (!parent) return nsArray;
		if (parent.attributes && parent.attributes.length > 0) for (let i = 0; i < parent.attributes.length; i++) {
			const attr = parent.attributes[i];
			if (attr && attr.nodeName && attr.nodeName.search(/^xmlns:?/) !== -1) nsArray.push({
				prefix: attr.nodeName.replace(/^xmlns:?/, ""),
				namespaceURI: attr.nodeValue || ""
			});
		}
		return collectAncestorNamespaces(parent, nsArray);
	}
	function findNSPrefix(subset) {
		const subsetAttributes = subset.attributes;
		for (let k = 0; k < subsetAttributes.length; k++) {
			const nodeName = subsetAttributes[k].nodeName;
			if (nodeName.search(/^xmlns:?/) !== -1) return nodeName.replace(/^xmlns:?/, "");
		}
		return subset.prefix || "";
	}
	function isElementSubset(docSubset) {
		return docSubset.every((node) => isDomNode.isElementNode(node));
	}
	/**
	* Extract ancestor namespaces in order to import it to root of document subset
	* which is being canonicalized for non-exclusive c14n.
	*
	* @param doc - Usually a product from `new xmldom.DOMParser().parseFromString()`
	* @param docSubsetXpath - xpath query to get document subset being canonicalized
	* @param namespaceResolver - xpath namespace resolver
	* @returns i.e. [{prefix: "saml", namespaceURI: "urn:oasis:names:tc:SAML:2.0:assertion"}]
	*/
	function findAncestorNs(doc, docSubsetXpath, namespaceResolver) {
		if (docSubsetXpath == null) return [];
		const docSubset = xpath.selectWithResolver(docSubsetXpath, doc, namespaceResolver);
		if (!isArrayHasLength(docSubset)) return [];
		if (!isElementSubset(docSubset)) throw new Error("Document subset must be list of elements");
		const ancestorNs = collectAncestorNamespaces(docSubset[0]);
		const ancestorNsWithoutDuplicate = [];
		for (let i = 0; i < ancestorNs.length; i++) {
			let notOnTheList = true;
			for (const v in ancestorNsWithoutDuplicate) if (ancestorNsWithoutDuplicate[v].prefix === ancestorNs[i].prefix) {
				notOnTheList = false;
				break;
			}
			if (notOnTheList) ancestorNsWithoutDuplicate.push(ancestorNs[i]);
		}
		const returningNs = [];
		const subsetNsPrefix = findNSPrefix(docSubset[0]);
		for (const ancestorNs$1 of ancestorNsWithoutDuplicate) if (ancestorNs$1.prefix !== subsetNsPrefix) returningNs.push(ancestorNs$1);
		return returningNs;
	}
	exports.findAncestorNs = findAncestorNs;
	function validateDigestValue(digest, expectedDigest) {
		const buffer$1 = Buffer.from(digest, "base64");
		const expectedBuffer = Buffer.from(expectedDigest, "base64");
		if (typeof buffer$1.equals === "function") return buffer$1.equals(expectedBuffer);
		if (buffer$1.length !== expectedBuffer.length) return false;
		for (let i = 0; i < buffer$1.length; i++) if (buffer$1[i] !== expectedBuffer[i]) return false;
		return true;
	}
	exports.validateDigestValue = validateDigestValue;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/c14n-canonicalization.js
var require_c14n_canonicalization = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.C14nCanonicalizationWithComments = exports.C14nCanonicalization = void 0;
	const utils = require_utils$1();
	const isDomNode = require_dist();
	var C14nCanonicalization = class {
		constructor() {
			this.includeComments = false;
			this.includeComments = false;
		}
		attrCompare(a, b) {
			if (!a.namespaceURI && b.namespaceURI) return -1;
			if (!b.namespaceURI && a.namespaceURI) return 1;
			const left = a.namespaceURI + a.localName;
			const right = b.namespaceURI + b.localName;
			if (left === right) return 0;
			else if (left < right) return -1;
			else return 1;
		}
		nsCompare(a, b) {
			const attr1 = a.prefix;
			const attr2 = b.prefix;
			if (attr1 === attr2) return 0;
			return attr1.localeCompare(attr2);
		}
		renderAttrs(node) {
			let i;
			let attr;
			const attrListToRender = [];
			if (isDomNode.isCommentNode(node)) return this.renderComment(node);
			if (node.attributes) for (i = 0; i < node.attributes.length; ++i) {
				attr = node.attributes[i];
				if (attr.name.indexOf("xmlns") === 0) continue;
				attrListToRender.push(attr);
			}
			attrListToRender.sort(this.attrCompare);
			return attrListToRender.map((attr$1) => {
				return ` ${attr$1.name}="${utils.encodeSpecialCharactersInAttribute(attr$1.value)}"`;
			}).join("");
		}
		/**
		* Create the string of all namespace declarations that should appear on this element
		*
		* @param node The node we now render
		* @param prefixesInScope The prefixes defined on this node parents which are a part of the output set
		* @param defaultNs The current default namespace
		* @param defaultNsForPrefix
		* @param ancestorNamespaces Import ancestor namespaces if it is specified
		* @api private
		*/
		renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {
			let i;
			let attr;
			const res = [];
			let newDefaultNs = defaultNs;
			const nsListToRender = [];
			const currNs = node.namespaceURI || "";
			if (node.prefix) {
				if (prefixesInScope.indexOf(node.prefix) === -1) {
					nsListToRender.push({
						prefix: node.prefix,
						namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix]
					});
					prefixesInScope.push(node.prefix);
				}
			} else if (defaultNs !== currNs) {
				newDefaultNs = node.namespaceURI || "";
				res.push(" xmlns=\"", newDefaultNs, "\"");
			}
			if (node.attributes) for (i = 0; i < node.attributes.length; ++i) {
				attr = node.attributes[i];
				if (attr.prefix === "xmlns" && prefixesInScope.indexOf(attr.localName) === -1) {
					nsListToRender.push({
						prefix: attr.localName,
						namespaceURI: attr.value
					});
					prefixesInScope.push(attr.localName);
				}
				if (attr.prefix && prefixesInScope.indexOf(attr.prefix) === -1 && attr.prefix !== "xmlns" && attr.prefix !== "xml") {
					nsListToRender.push({
						prefix: attr.prefix,
						namespaceURI: attr.namespaceURI
					});
					prefixesInScope.push(attr.prefix);
				}
			}
			if (utils.isArrayHasLength(ancestorNamespaces)) for (const ancestorNamespace of ancestorNamespaces) {
				let alreadyListed = false;
				for (const nsToRender of nsListToRender) if (nsToRender.prefix === ancestorNamespace.prefix && nsToRender.namespaceURI === ancestorNamespace.namespaceURI) alreadyListed = true;
				if (!alreadyListed) nsListToRender.push(ancestorNamespace);
			}
			nsListToRender.sort(this.nsCompare);
			res.push(...nsListToRender.map((attr$1) => {
				if (attr$1.prefix) return ` xmlns:${attr$1.prefix}="${attr$1.namespaceURI}"`;
				return ` xmlns="${attr$1.namespaceURI}"`;
			}));
			return {
				rendered: res.join(""),
				newDefaultNs
			};
		}
		/**
		* @param node Node
		*/
		processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {
			if (isDomNode.isCommentNode(node)) return this.renderComment(node);
			if (node.data) return utils.encodeSpecialCharactersInText(node.data);
			if (isDomNode.isElementNode(node)) {
				let i;
				let pfxCopy;
				const ns = this.renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces);
				const res = [
					"<",
					node.tagName,
					ns.rendered,
					this.renderAttrs(node),
					">"
				];
				for (i = 0; i < node.childNodes.length; ++i) {
					pfxCopy = prefixesInScope.slice(0);
					res.push(this.processInner(node.childNodes[i], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, []));
				}
				res.push("</", node.tagName, ">");
				return res.join("");
			}
			throw new Error(`Unable to canonicalize node type: ${node.nodeType}`);
		}
		renderComment(node) {
			if (!this.includeComments) return "";
			const isOutsideDocument = node.ownerDocument === node.parentNode;
			let isBeforeDocument = false;
			let isAfterDocument = false;
			if (isOutsideDocument) {
				let nextNode = node;
				let previousNode = node;
				while (nextNode !== null) {
					if (nextNode === node.ownerDocument.documentElement) {
						isBeforeDocument = true;
						break;
					}
					nextNode = nextNode.nextSibling;
				}
				while (previousNode !== null) {
					if (previousNode === node.ownerDocument.documentElement) {
						isAfterDocument = true;
						break;
					}
					previousNode = previousNode.previousSibling;
				}
			}
			const afterDocument = isAfterDocument ? "\n" : "";
			const beforeDocument = isBeforeDocument ? "\n" : "";
			return `${afterDocument}<!--${utils.encodeSpecialCharactersInText(node.data)}-->${beforeDocument}`;
		}
		/**
		* Perform canonicalization of the given node
		*
		* @param node
		* @api public
		*/
		process(node, options) {
			options = options || {};
			const defaultNs = options.defaultNs || "";
			const defaultNsForPrefix = options.defaultNsForPrefix || {};
			const ancestorNamespaces = options.ancestorNamespaces || [];
			const prefixesInScope = [];
			for (let i = 0; i < ancestorNamespaces.length; i++) prefixesInScope.push(ancestorNamespaces[i].prefix);
			return this.processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces);
		}
		getAlgorithmName() {
			return "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
		}
	};
	exports.C14nCanonicalization = C14nCanonicalization;
	/**
	* Add c14n#WithComments here (very simple subclass)
	*/
	var C14nCanonicalizationWithComments = class extends C14nCanonicalization {
		constructor() {
			super();
			this.includeComments = true;
		}
		getAlgorithmName() {
			return "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
		}
	};
	exports.C14nCanonicalizationWithComments = C14nCanonicalizationWithComments;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/exclusive-canonicalization.js
var require_exclusive_canonicalization = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ExclusiveCanonicalizationWithComments = exports.ExclusiveCanonicalization = void 0;
	const utils = require_utils$1();
	const isDomNode = require_dist();
	function isPrefixInScope(prefixesInScope, prefix, namespaceURI) {
		let ret = false;
		prefixesInScope.forEach(function(pf) {
			if (pf.prefix === prefix && pf.namespaceURI === namespaceURI) ret = true;
		});
		return ret;
	}
	var ExclusiveCanonicalization = class {
		constructor() {
			this.includeComments = false;
			this.includeComments = false;
		}
		attrCompare(a, b) {
			if (!a.namespaceURI && b.namespaceURI) return -1;
			if (!b.namespaceURI && a.namespaceURI) return 1;
			const left = a.namespaceURI + a.localName;
			const right = b.namespaceURI + b.localName;
			if (left === right) return 0;
			else if (left < right) return -1;
			else return 1;
		}
		nsCompare(a, b) {
			const attr1 = a.prefix;
			const attr2 = b.prefix;
			if (attr1 === attr2) return 0;
			return attr1.localeCompare(attr2);
		}
		renderAttrs(node) {
			let i;
			let attr;
			const res = [];
			const attrListToRender = [];
			if (isDomNode.isCommentNode(node)) return this.renderComment(node);
			if (node.attributes) for (i = 0; i < node.attributes.length; ++i) {
				attr = node.attributes[i];
				if (attr.name.indexOf("xmlns") === 0) continue;
				attrListToRender.push(attr);
			}
			attrListToRender.sort(this.attrCompare);
			for (attr of attrListToRender) res.push(" ", attr.name, "=\"", utils.encodeSpecialCharactersInAttribute(attr.value), "\"");
			return res.join("");
		}
		/**
		* Create the string of all namespace declarations that should appear on this element
		*
		* @param {Node} node. The node we now render
		* @param {Array} prefixesInScope. The prefixes defined on this node
		*                parents which are a part of the output set
		* @param {String} defaultNs. The current default namespace
		* @return {String}
		* @api private
		*/
		renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList) {
			let i;
			let attr;
			const res = [];
			let newDefaultNs = defaultNs;
			const nsListToRender = [];
			const currNs = node.namespaceURI || "";
			if (node.prefix) {
				if (!isPrefixInScope(prefixesInScope, node.prefix, node.namespaceURI || defaultNsForPrefix[node.prefix])) {
					nsListToRender.push({
						prefix: node.prefix,
						namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix]
					});
					prefixesInScope.push({
						prefix: node.prefix,
						namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix]
					});
				}
			} else if (defaultNs !== currNs) {
				newDefaultNs = node.namespaceURI;
				res.push(" xmlns=\"", newDefaultNs, "\"");
			}
			if (node.attributes) for (i = 0; i < node.attributes.length; ++i) {
				attr = node.attributes[i];
				if (attr.prefix && !isPrefixInScope(prefixesInScope, attr.localName, attr.value) && inclusiveNamespacesPrefixList.indexOf(attr.localName) >= 0) {
					nsListToRender.push({
						prefix: attr.localName,
						namespaceURI: attr.value
					});
					prefixesInScope.push({
						prefix: attr.localName,
						namespaceURI: attr.value
					});
				}
				if (attr.prefix && !isPrefixInScope(prefixesInScope, attr.prefix, attr.namespaceURI) && attr.prefix !== "xmlns" && attr.prefix !== "xml") {
					nsListToRender.push({
						prefix: attr.prefix,
						namespaceURI: attr.namespaceURI
					});
					prefixesInScope.push({
						prefix: attr.prefix,
						namespaceURI: attr.namespaceURI
					});
				}
			}
			nsListToRender.sort(this.nsCompare);
			for (const p of nsListToRender) res.push(" xmlns:", p.prefix, "=\"", p.namespaceURI, "\"");
			return {
				rendered: res.join(""),
				newDefaultNs
			};
		}
		/**
		* @param node Node
		*/
		processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList) {
			if (isDomNode.isCommentNode(node)) return this.renderComment(node);
			if (node.data) return utils.encodeSpecialCharactersInText(node.data);
			if (isDomNode.isElementNode(node)) {
				let i;
				let pfxCopy;
				const ns = this.renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList);
				const res = [
					"<",
					node.tagName,
					ns.rendered,
					this.renderAttrs(node),
					">"
				];
				for (i = 0; i < node.childNodes.length; ++i) {
					pfxCopy = prefixesInScope.slice(0);
					res.push(this.processInner(node.childNodes[i], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList));
				}
				res.push("</", node.tagName, ">");
				return res.join("");
			}
			throw new Error(`Unable to exclusive canonicalize node type: ${node.nodeType}`);
		}
		renderComment(node) {
			if (!this.includeComments) return "";
			const isOutsideDocument = node.ownerDocument === node.parentNode;
			let isBeforeDocument = false;
			let isAfterDocument = false;
			if (isOutsideDocument) {
				let nextNode = node;
				let previousNode = node;
				while (nextNode != null) {
					if (nextNode === node.ownerDocument.documentElement) {
						isBeforeDocument = true;
						break;
					}
					nextNode = nextNode.nextSibling;
				}
				while (previousNode != null) {
					if (previousNode === node.ownerDocument.documentElement) {
						isAfterDocument = true;
						break;
					}
					previousNode = previousNode.previousSibling;
				}
			}
			const afterDocument = isAfterDocument ? "\n" : "";
			const beforeDocument = isBeforeDocument ? "\n" : "";
			return `${afterDocument}<!--${utils.encodeSpecialCharactersInText(node.data)}-->${beforeDocument}`;
		}
		/**
		* Perform canonicalization of the given element node
		*
		* @api public
		*/
		process(elem, options) {
			options = options || {};
			let inclusiveNamespacesPrefixList = options.inclusiveNamespacesPrefixList || [];
			const defaultNs = options.defaultNs || "";
			const defaultNsForPrefix = options.defaultNsForPrefix || {};
			const ancestorNamespaces = options.ancestorNamespaces || [];
			/**
			* If the inclusiveNamespacesPrefixList has not been explicitly provided then look it up in CanonicalizationMethod/InclusiveNamespaces
			*/
			if (!utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {
				const CanonicalizationMethod = utils.findChildren(elem, "CanonicalizationMethod");
				if (CanonicalizationMethod.length !== 0) {
					const inclusiveNamespaces = utils.findChildren(CanonicalizationMethod[0], "InclusiveNamespaces");
					if (inclusiveNamespaces.length !== 0) inclusiveNamespacesPrefixList = (inclusiveNamespaces[0].getAttribute("PrefixList") || "").split(" ");
				}
			}
			/**
			* If you have a PrefixList then use it and the ancestors to add the necessary namespaces
			*/
			if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) inclusiveNamespacesPrefixList.forEach(function(prefix) {
				if (ancestorNamespaces) ancestorNamespaces.forEach(function(ancestorNamespace) {
					if (prefix === ancestorNamespace.prefix) elem.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:${prefix}`, ancestorNamespace.namespaceURI);
				});
			});
			return this.processInner(elem, [], defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList);
		}
		getAlgorithmName() {
			return "http://www.w3.org/2001/10/xml-exc-c14n#";
		}
	};
	exports.ExclusiveCanonicalization = ExclusiveCanonicalization;
	var ExclusiveCanonicalizationWithComments = class extends ExclusiveCanonicalization {
		constructor() {
			super();
			this.includeComments = true;
		}
		getAlgorithmName() {
			return "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
		}
	};
	exports.ExclusiveCanonicalizationWithComments = ExclusiveCanonicalizationWithComments;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/enveloped-signature.js
var require_enveloped_signature = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.EnvelopedSignature = void 0;
	const xpath = require_xpath();
	const isDomNode = require_dist();
	var EnvelopedSignature = class {
		constructor() {
			this.includeComments = false;
			this.includeComments = false;
		}
		process(node, options) {
			if (null == options.signatureNode) {
				const signature = xpath.select1("./*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", node);
				if (isDomNode.isNodeLike(signature) && signature.parentNode) signature.parentNode.removeChild(signature);
				return node;
			}
			const signatureNode = options.signatureNode;
			const expectedSignatureValue = xpath.select1(".//*[local-name(.)='SignatureValue']/text()", signatureNode);
			if (isDomNode.isTextNode(expectedSignatureValue)) {
				const expectedSignatureValueData = expectedSignatureValue.data;
				const signatures = xpath.select(".//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", node);
				for (const nodeSignature of Array.isArray(signatures) ? signatures : []) {
					const signatureValue = xpath.select1(".//*[local-name(.)='SignatureValue']/text()", nodeSignature);
					if (isDomNode.isTextNode(signatureValue)) {
						if (expectedSignatureValueData === signatureValue.data) {
							if (nodeSignature.parentNode) nodeSignature.parentNode.removeChild(nodeSignature);
						}
					}
				}
			}
			return node;
		}
		getAlgorithmName() {
			return "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
		}
	};
	exports.EnvelopedSignature = EnvelopedSignature;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/hash-algorithms.js
var require_hash_algorithms = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Sha512 = exports.Sha256 = exports.Sha1 = void 0;
	const crypto$4 = __require("crypto");
	var Sha1 = class {
		constructor() {
			this.getHash = function(xml) {
				const shasum = crypto$4.createHash("sha1");
				shasum.update(xml, "utf8");
				return shasum.digest("base64");
			};
			this.getAlgorithmName = function() {
				return "http://www.w3.org/2000/09/xmldsig#sha1";
			};
		}
	};
	exports.Sha1 = Sha1;
	var Sha256 = class {
		constructor() {
			this.getHash = function(xml) {
				const shasum = crypto$4.createHash("sha256");
				shasum.update(xml, "utf8");
				return shasum.digest("base64");
			};
			this.getAlgorithmName = function() {
				return "http://www.w3.org/2001/04/xmlenc#sha256";
			};
		}
	};
	exports.Sha256 = Sha256;
	var Sha512 = class {
		constructor() {
			this.getHash = function(xml) {
				const shasum = crypto$4.createHash("sha512");
				shasum.update(xml, "utf8");
				return shasum.digest("base64");
			};
			this.getAlgorithmName = function() {
				return "http://www.w3.org/2001/04/xmlenc#sha512";
			};
		}
	};
	exports.Sha512 = Sha512;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/types.js
var require_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createOptionalCallbackFunction = void 0;
	/**
	* ### Sign
	* #### Properties
	* - {@link SignedXml#privateKey} [required]
	* - {@link SignedXml#publicCert} [optional]
	* - {@link SignedXml#signatureAlgorithm} [optional]
	* - {@link SignedXml#canonicalizationAlgorithm} [optional]
	* #### Api
	*  - {@link SignedXml#addReference}
	*  - {@link SignedXml#computeSignature}
	*  - {@link SignedXml#getSignedXml}
	*  - {@link SignedXml#getSignatureXml}
	*  - {@link SignedXml#getOriginalXmlWithIds}
	*
	* ### Verify
	* #### Properties
	* -  {@link SignedXml#publicCert} [optional]
	* #### Api
	*  - {@link SignedXml#loadSignature}
	*  - {@link SignedXml#checkSignature}
	*/
	function isErrorFirstCallback(possibleCallback) {
		return typeof possibleCallback === "function";
	}
	/**
	* This function will add a callback version of a sync function.
	*
	* This follows the factory pattern.
	* Just call this function, passing the function that you'd like to add a callback version of.
	*/
	function createOptionalCallbackFunction(syncVersion) {
		return ((...args) => {
			const possibleCallback = args[args.length - 1];
			if (isErrorFirstCallback(possibleCallback)) try {
				possibleCallback(null, syncVersion(...args.slice(0, -1)));
			} catch (err) {
				possibleCallback(err instanceof Error ? err : /* @__PURE__ */ new Error("Unknown error"));
			}
			else return syncVersion(...args);
		});
	}
	exports.createOptionalCallbackFunction = createOptionalCallbackFunction;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/signature-algorithms.js
var require_signature_algorithms = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HmacSha1 = exports.RsaSha512 = exports.RsaSha256 = exports.RsaSha1 = void 0;
	const crypto$3 = __require("crypto");
	const types_1 = require_types();
	var RsaSha1 = class {
		constructor() {
			this.getSignature = (0, types_1.createOptionalCallbackFunction)((signedInfo, privateKey) => {
				const signer = crypto$3.createSign("RSA-SHA1");
				signer.update(signedInfo);
				return signer.sign(privateKey, "base64");
			});
			this.verifySignature = (0, types_1.createOptionalCallbackFunction)((material, key, signatureValue) => {
				const verifier = crypto$3.createVerify("RSA-SHA1");
				verifier.update(material);
				return verifier.verify(key, signatureValue, "base64");
			});
			this.getAlgorithmName = () => {
				return "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
			};
		}
	};
	exports.RsaSha1 = RsaSha1;
	var RsaSha256 = class {
		constructor() {
			this.getSignature = (0, types_1.createOptionalCallbackFunction)((signedInfo, privateKey) => {
				const signer = crypto$3.createSign("RSA-SHA256");
				signer.update(signedInfo);
				return signer.sign(privateKey, "base64");
			});
			this.verifySignature = (0, types_1.createOptionalCallbackFunction)((material, key, signatureValue) => {
				const verifier = crypto$3.createVerify("RSA-SHA256");
				verifier.update(material);
				return verifier.verify(key, signatureValue, "base64");
			});
			this.getAlgorithmName = () => {
				return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
			};
		}
	};
	exports.RsaSha256 = RsaSha256;
	var RsaSha512 = class {
		constructor() {
			this.getSignature = (0, types_1.createOptionalCallbackFunction)((signedInfo, privateKey) => {
				const signer = crypto$3.createSign("RSA-SHA512");
				signer.update(signedInfo);
				return signer.sign(privateKey, "base64");
			});
			this.verifySignature = (0, types_1.createOptionalCallbackFunction)((material, key, signatureValue) => {
				const verifier = crypto$3.createVerify("RSA-SHA512");
				verifier.update(material);
				return verifier.verify(key, signatureValue, "base64");
			});
			this.getAlgorithmName = () => {
				return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512";
			};
		}
	};
	exports.RsaSha512 = RsaSha512;
	var HmacSha1 = class {
		constructor() {
			this.getSignature = (0, types_1.createOptionalCallbackFunction)((signedInfo, privateKey) => {
				const signer = crypto$3.createHmac("SHA1", privateKey);
				signer.update(signedInfo);
				return signer.digest("base64");
			});
			this.verifySignature = (0, types_1.createOptionalCallbackFunction)((material, key, signatureValue) => {
				const verifier = crypto$3.createHmac("SHA1", key);
				verifier.update(material);
				return verifier.digest("base64") === signatureValue;
			});
			this.getAlgorithmName = () => {
				return "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
			};
		}
	};
	exports.HmacSha1 = HmacSha1;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/signed-xml.js
var require_signed_xml = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SignedXml = void 0;
	const isDomNode = require_dist();
	const xmldom = require_lib$3();
	const util_1 = __require("util");
	const xpath = require_xpath();
	const c14n = require_c14n_canonicalization();
	const envelopedSignatures = require_enveloped_signature();
	const execC14n = require_exclusive_canonicalization();
	const hashAlgorithms = require_hash_algorithms();
	const signatureAlgorithms = require_signature_algorithms();
	const utils = require_utils$1();
	var SignedXml = class SignedXml {
		/**
		* The SignedXml constructor provides an abstraction for sign and verify xml documents. The object is constructed using
		* @param options {@link SignedXmlOptions}
		*/
		constructor(options = {}) {
			/**
			* One of the supported signature algorithms.
			* @see {@link SignatureAlgorithmType}
			*/
			this.signatureAlgorithm = void 0;
			/**
			* Rules used to convert an XML document into its canonical form.
			*/
			this.canonicalizationAlgorithm = void 0;
			/**
			* It specifies a list of namespace prefixes that should be considered "inclusive" during the canonicalization process.
			*/
			this.inclusiveNamespacesPrefixList = [];
			this.namespaceResolver = { lookupNamespaceURI: function() {
				throw new Error("Not implemented");
			} };
			this.implicitTransforms = [];
			this.keyInfoAttributes = {};
			this.getKeyInfoContent = SignedXml.getKeyInfoContent;
			this.getCertFromKeyInfo = SignedXml.getCertFromKeyInfo;
			this.id = 0;
			this.signedXml = "";
			this.signatureXml = "";
			this.signatureNode = null;
			this.signatureValue = "";
			this.originalXmlWithIds = "";
			this.keyInfo = null;
			/**
			* Contains the references that were signed.
			* @see {@link Reference}
			*/
			this.references = [];
			/**
			* Contains the canonicalized XML of the references that were validly signed.
			*
			* This populates with the canonical XML of the reference only after
			* verifying the signature is cryptographically authentic.
			*/
			this.signedReferences = [];
			/**
			*  To add a new transformation algorithm create a new class that implements the {@link TransformationAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}
			*/
			this.CanonicalizationAlgorithms = {
				"http://www.w3.org/TR/2001/REC-xml-c14n-20010315": c14n.C14nCanonicalization,
				"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments": c14n.C14nCanonicalizationWithComments,
				"http://www.w3.org/2001/10/xml-exc-c14n#": execC14n.ExclusiveCanonicalization,
				"http://www.w3.org/2001/10/xml-exc-c14n#WithComments": execC14n.ExclusiveCanonicalizationWithComments,
				"http://www.w3.org/2000/09/xmldsig#enveloped-signature": envelopedSignatures.EnvelopedSignature
			};
			/**
			* To add a new hash algorithm create a new class that implements the {@link HashAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}
			*/
			this.HashAlgorithms = {
				"http://www.w3.org/2000/09/xmldsig#sha1": hashAlgorithms.Sha1,
				"http://www.w3.org/2001/04/xmlenc#sha256": hashAlgorithms.Sha256,
				"http://www.w3.org/2001/04/xmlenc#sha512": hashAlgorithms.Sha512
			};
			/**
			* To add a new signature algorithm create a new class that implements the {@link SignatureAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}
			*/
			this.SignatureAlgorithms = {
				"http://www.w3.org/2000/09/xmldsig#rsa-sha1": signatureAlgorithms.RsaSha1,
				"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256": signatureAlgorithms.RsaSha256,
				"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512": signatureAlgorithms.RsaSha512
			};
			const { idMode, idAttribute, privateKey, publicCert, signatureAlgorithm, canonicalizationAlgorithm, inclusiveNamespacesPrefixList, implicitTransforms, keyInfoAttributes, getKeyInfoContent, getCertFromKeyInfo } = options;
			this.idMode = idMode;
			this.idAttributes = [
				"Id",
				"ID",
				"id"
			];
			if (idAttribute) this.idAttributes.unshift(idAttribute);
			this.privateKey = privateKey;
			this.publicCert = publicCert;
			this.signatureAlgorithm = signatureAlgorithm ?? this.signatureAlgorithm;
			this.canonicalizationAlgorithm = canonicalizationAlgorithm;
			if (typeof inclusiveNamespacesPrefixList === "string") this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(" ");
			else if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;
			this.implicitTransforms = implicitTransforms ?? this.implicitTransforms;
			this.keyInfoAttributes = keyInfoAttributes ?? this.keyInfoAttributes;
			this.getKeyInfoContent = getKeyInfoContent ?? this.getKeyInfoContent;
			this.getCertFromKeyInfo = getCertFromKeyInfo ?? SignedXml.noop;
			this.CanonicalizationAlgorithms;
			this.HashAlgorithms;
			this.SignatureAlgorithms;
		}
		/**
		* Due to key-confusion issues, it's risky to have both hmac
		* and digital signature algorithms enabled at the same time.
		* This enables HMAC and disables other signing algorithms.
		*/
		enableHMAC() {
			this.SignatureAlgorithms = { "http://www.w3.org/2000/09/xmldsig#hmac-sha1": signatureAlgorithms.HmacSha1 };
			this.getKeyInfoContent = SignedXml.noop;
		}
		/**
		* Builds the contents of a KeyInfo element as an XML string.
		*
		* For example, if the value of the prefix argument is 'foo', then
		* the resultant XML string will be "<foo:X509Data></foo:X509Data>"
		*
		* @return an XML string representation of the contents of a KeyInfo element, or `null` if no `KeyInfo` element should be included
		*/
		static getKeyInfoContent({ publicCert, prefix }) {
			if (publicCert == null) return null;
			prefix = prefix ? `${prefix}:` : "";
			let x509Certs = "";
			if (Buffer.isBuffer(publicCert)) publicCert = publicCert.toString("latin1");
			let publicCertMatches = [];
			if (typeof publicCert === "string") publicCertMatches = publicCert.match(utils.EXTRACT_X509_CERTS) || [];
			if (publicCertMatches.length > 0) x509Certs = publicCertMatches.map((c) => `<${prefix}X509Certificate>${utils.pemToDer(c).toString("base64")}</${prefix}X509Certificate>`).join("");
			return `<${prefix}X509Data>${x509Certs}</${prefix}X509Data>`;
		}
		/**
		* Returns the value of the signing certificate based on the contents of the
		* specified KeyInfo.
		*
		* @param keyInfo KeyInfo element (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)
		* @return the signing certificate as a string in PEM format
		*/
		static getCertFromKeyInfo(keyInfo) {
			if (keyInfo != null) {
				const cert = xpath.select1(".//*[local-name(.)='X509Certificate']", keyInfo);
				if (isDomNode.isNodeLike(cert)) return utils.derToPem(cert.textContent ?? "", "CERTIFICATE");
			}
			return null;
		}
		checkSignature(xml, callback$1) {
			if (callback$1 != null && typeof callback$1 !== "function") throw new Error("Last parameter must be a callback function");
			this.signedXml = xml;
			const doc = new xmldom.DOMParser().parseFromString(xml);
			this.references = [];
			const unverifiedSignedInfoCanon = this.getCanonSignedInfoXml(doc);
			if (!unverifiedSignedInfoCanon) {
				if (callback$1) {
					callback$1(/* @__PURE__ */ new Error("Canonical signed info cannot be empty"), false);
					return;
				}
				throw new Error("Canonical signed info cannot be empty");
			}
			const unverifiedSignedInfoDoc = new xmldom.DOMParser().parseFromString(unverifiedSignedInfoCanon, "text/xml").documentElement;
			if (!unverifiedSignedInfoDoc) {
				if (callback$1) {
					callback$1(/* @__PURE__ */ new Error("Could not parse unverifiedSignedInfoCanon into a document"), false);
					return;
				}
				throw new Error("Could not parse unverifiedSignedInfoCanon into a document");
			}
			const references = utils.findChildren(unverifiedSignedInfoDoc, "Reference");
			if (!utils.isArrayHasLength(references)) {
				if (callback$1) {
					callback$1(/* @__PURE__ */ new Error("could not find any Reference elements"), false);
					return;
				}
				throw new Error("could not find any Reference elements");
			}
			for (const reference of references) this.loadReference(reference);
			if (!this.getReferences().every((ref) => this.validateReference(ref, doc))) {
				this.signedReferences = [];
				this.references.forEach((ref) => {
					ref.signedReference = void 0;
				});
				if (callback$1) {
					callback$1(/* @__PURE__ */ new Error("Could not validate all references"), false);
					return;
				}
				return false;
			}
			const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);
			const key = this.getCertFromKeyInfo(this.keyInfo) || this.publicCert || this.privateKey;
			if (key == null) throw new Error("KeyInfo or publicCert or privateKey is required to validate signature");
			if (signer.verifySignature(unverifiedSignedInfoCanon, key, this.signatureValue) === true) if (callback$1) callback$1(null, true);
			else return true;
			else {
				this.signedReferences = [];
				this.references.forEach((ref) => {
					ref.signedReference = void 0;
				});
				if (callback$1) {
					callback$1(/* @__PURE__ */ new Error(`invalid signature: the signature value ${this.signatureValue} is incorrect`));
					return;
				} else throw new Error(`invalid signature: the signature value ${this.signatureValue} is incorrect`);
			}
		}
		getCanonSignedInfoXml(doc) {
			if (this.signatureNode == null) throw new Error("No signature found.");
			if (typeof this.canonicalizationAlgorithm !== "string") throw new Error("Missing canonicalizationAlgorithm when trying to get signed info for XML");
			const signedInfo = utils.findChildren(this.signatureNode, "SignedInfo");
			if (signedInfo.length === 0) throw new Error("could not find SignedInfo element in the message");
			if (signedInfo.length > 1) throw new Error("could not get canonicalized signed info for a signature that contains multiple SignedInfo nodes");
			if (this.canonicalizationAlgorithm === "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" || this.canonicalizationAlgorithm === "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments") {
				if (!doc || typeof doc !== "object") throw new Error("When canonicalization method is non-exclusive, whole xml dom must be provided as an argument");
			}
			const c14nOptions = { ancestorNamespaces: utils.findAncestorNs(doc, "//*[local-name()='SignedInfo']") };
			return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);
		}
		getCanonReferenceXml(doc, ref, node) {
			/**
			* Search for ancestor namespaces before canonicalization.
			*/
			if (Array.isArray(ref.transforms)) ref.ancestorNamespaces = utils.findAncestorNs(doc, ref.xpath, this.namespaceResolver);
			const c14nOptions = {
				inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,
				ancestorNamespaces: ref.ancestorNamespaces
			};
			return this.getCanonXml(ref.transforms, node, c14nOptions);
		}
		calculateSignatureValue(doc, callback$1) {
			const signedInfoCanon = this.getCanonSignedInfoXml(doc);
			const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);
			if (this.privateKey == null) throw new Error("Private key is required to compute signature");
			if (typeof callback$1 === "function") signer.getSignature(signedInfoCanon, this.privateKey, callback$1);
			else this.signatureValue = signer.getSignature(signedInfoCanon, this.privateKey);
		}
		findSignatureAlgorithm(name$1) {
			if (name$1 == null) throw new Error("signatureAlgorithm is required");
			const algo = this.SignatureAlgorithms[name$1];
			if (algo) return new algo();
			else throw new Error(`signature algorithm '${name$1}' is not supported`);
		}
		findCanonicalizationAlgorithm(name$1) {
			if (name$1 != null) {
				const algo = this.CanonicalizationAlgorithms[name$1];
				if (algo) return new algo();
			}
			throw new Error(`canonicalization algorithm '${name$1}' is not supported`);
		}
		findHashAlgorithm(name$1) {
			const algo = this.HashAlgorithms[name$1];
			if (algo) return new algo();
			else throw new Error(`hash algorithm '${name$1}' is not supported`);
		}
		validateElementAgainstReferences(elemOrXpath, doc) {
			let elem;
			if (typeof elemOrXpath === "string") {
				const firstElem = xpath.select1(elemOrXpath, doc);
				isDomNode.assertIsElementNode(firstElem);
				elem = firstElem;
			} else elem = elemOrXpath;
			for (const ref of this.getReferences()) {
				const uri = ref.uri?.[0] === "#" ? ref.uri.substring(1) : ref.uri;
				for (const attr of this.idAttributes) if (uri === elem.getAttribute(attr)) {
					ref.xpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;
					break;
				}
				const canonXml = this.getCanonReferenceXml(doc, ref, elem);
				const digest = this.findHashAlgorithm(ref.digestAlgorithm).getHash(canonXml);
				if (utils.validateDigestValue(digest, ref.digestValue)) return ref;
			}
			throw new Error("No references passed validation");
		}
		validateReference(ref, doc) {
			const uri = ref.uri?.[0] === "#" ? ref.uri.substring(1) : ref.uri;
			let elem = null;
			if (uri === "") elem = xpath.select1("//*", doc);
			else if (uri?.indexOf("'") !== -1) throw new Error("Cannot validate a uri with quotes inside it");
			else {
				let num_elements_for_id = 0;
				for (const attr of this.idAttributes) {
					const tmp_elemXpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;
					const tmp_elem = xpath.select(tmp_elemXpath, doc);
					if (utils.isArrayHasLength(tmp_elem)) {
						num_elements_for_id += tmp_elem.length;
						if (num_elements_for_id > 1) throw new Error("Cannot validate a document which contains multiple elements with the same value for the ID / Id / Id attributes, in order to prevent signature wrapping attack.");
						elem = tmp_elem[0];
						ref.xpath = tmp_elemXpath;
					}
				}
			}
			ref.getValidatedNode = (0, util_1.deprecate)((xpathSelector) => {
				xpathSelector = xpathSelector || ref.xpath;
				if (typeof xpathSelector !== "string" || ref.validationError != null) return null;
				const selectedValue = xpath.select1(xpathSelector, doc);
				return isDomNode.isNodeLike(selectedValue) ? selectedValue : null;
			}, "`ref.getValidatedNode()` is deprecated and insecure. Use `ref.signedReference` or `this.getSignedReferences()` instead.");
			if (!isDomNode.isNodeLike(elem)) {
				ref.validationError = /* @__PURE__ */ new Error(`invalid signature: the signature references an element with uri ${ref.uri} but could not find such element in the xml`);
				return false;
			}
			const canonXml = this.getCanonReferenceXml(doc, ref, elem);
			const digest = this.findHashAlgorithm(ref.digestAlgorithm).getHash(canonXml);
			if (!utils.validateDigestValue(digest, ref.digestValue)) {
				ref.validationError = /* @__PURE__ */ new Error(`invalid signature: for uri ${ref.uri} calculated digest is ${digest} but the xml to validate supplies digest ${ref.digestValue}`);
				return false;
			}
			this.signedReferences.push(canonXml);
			ref.signedReference = canonXml;
			return true;
		}
		findSignatures(doc) {
			const nodes = xpath.select("//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", doc);
			return isDomNode.isArrayOfNodes(nodes) ? nodes : [];
		}
		/**
		* Loads the signature information from the provided XML node or string.
		*
		* @param signatureNode The XML node or string representing the signature.
		*/
		loadSignature(signatureNode) {
			if (typeof signatureNode === "string") this.signatureNode = signatureNode = new xmldom.DOMParser().parseFromString(signatureNode);
			else this.signatureNode = signatureNode;
			this.signatureXml = signatureNode.toString();
			const node = xpath.select1(".//*[local-name(.)='CanonicalizationMethod']/@Algorithm", signatureNode);
			if (!isDomNode.isNodeLike(node)) throw new Error("could not find CanonicalizationMethod/@Algorithm element");
			if (isDomNode.isAttributeNode(node)) this.canonicalizationAlgorithm = node.value;
			const signatureAlgorithm = xpath.select1(".//*[local-name(.)='SignatureMethod']/@Algorithm", signatureNode);
			if (isDomNode.isAttributeNode(signatureAlgorithm)) this.signatureAlgorithm = signatureAlgorithm.value;
			const signedInfoNodes = utils.findChildren(this.signatureNode, "SignedInfo");
			if (!utils.isArrayHasLength(signedInfoNodes)) throw new Error("no signed info node found");
			if (signedInfoNodes.length > 1) throw new Error("could not load signature that contains multiple SignedInfo nodes");
			let canonicalizationAlgorithmForSignedInfo = this.canonicalizationAlgorithm;
			if (!canonicalizationAlgorithmForSignedInfo || canonicalizationAlgorithmForSignedInfo === "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" || canonicalizationAlgorithmForSignedInfo === "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments") canonicalizationAlgorithmForSignedInfo = "http://www.w3.org/2001/10/xml-exc-c14n#";
			const temporaryCanonSignedInfo = this.getCanonXml([canonicalizationAlgorithmForSignedInfo], signedInfoNodes[0]);
			const signedInfoDoc = new xmldom.DOMParser().parseFromString(temporaryCanonSignedInfo, "text/xml").documentElement;
			this.references = [];
			const references = utils.findChildren(signedInfoDoc, "Reference");
			if (!utils.isArrayHasLength(references)) throw new Error("could not find any Reference elements");
			for (const reference of references) this.loadReference(reference);
			const signatureValue = xpath.select1(".//*[local-name(.)='SignatureValue']/text()", signatureNode);
			if (isDomNode.isTextNode(signatureValue)) this.signatureValue = signatureValue.data.replace(/\r?\n/g, "");
			const keyInfo = xpath.select1(".//*[local-name(.)='KeyInfo']", signatureNode);
			if (isDomNode.isNodeLike(keyInfo)) this.keyInfo = keyInfo;
		}
		/**
		* Load the reference xml node to a model
		*
		*/
		loadReference(refNode) {
			let nodes = utils.findChildren(refNode, "DigestMethod");
			if (nodes.length === 0) throw new Error(`could not find DigestMethod in reference ${refNode.toString()}`);
			const digestAlgoNode = nodes[0];
			const attr = utils.findAttr(digestAlgoNode, "Algorithm");
			if (!attr) throw new Error(`could not find Algorithm attribute in node ${digestAlgoNode.toString()}`);
			const digestAlgo = attr.value;
			nodes = utils.findChildren(refNode, "DigestValue");
			if (nodes.length === 0) throw new Error(`could not find DigestValue node in reference ${refNode.toString()}`);
			if (nodes.length > 1) throw new Error(`could not load reference for a node that contains multiple DigestValue nodes: ${refNode.toString()}`);
			const digestValue = nodes[0].textContent;
			if (!digestValue) throw new Error(`could not find the value of DigestValue in ${refNode.toString()}`);
			const transforms = [];
			let inclusiveNamespacesPrefixList = [];
			nodes = utils.findChildren(refNode, "Transforms");
			if (nodes.length !== 0) {
				const transformsNode = nodes[0];
				const transformsAll = utils.findChildren(transformsNode, "Transform");
				for (const transform$1 of transformsAll) {
					const transformAttr = utils.findAttr(transform$1, "Algorithm");
					if (transformAttr) transforms.push(transformAttr.value);
				}
				const inclusiveNamespaces = utils.findChildren(transformsAll[transformsAll.length - 1], "InclusiveNamespaces");
				if (utils.isArrayHasLength(inclusiveNamespaces)) inclusiveNamespacesPrefixList = inclusiveNamespaces.flatMap((namespace) => (namespace.getAttribute("PrefixList") ?? "").split(" ")).filter((value) => value.length > 0);
			}
			if (utils.isArrayHasLength(this.implicitTransforms)) this.implicitTransforms.forEach(function(t) {
				transforms.push(t);
			});
			/**
			* DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we
			* need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no
			* transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.
			* @see:
			* https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod
			* https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel
			* https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document
			*/
			if (transforms.length === 0 || transforms[transforms.length - 1] === "http://www.w3.org/2000/09/xmldsig#enveloped-signature") transforms.push("http://www.w3.org/TR/2001/REC-xml-c14n-20010315");
			const refUri = isDomNode.isElementNode(refNode) ? refNode.getAttribute("URI") || void 0 : void 0;
			this.addReference({
				transforms,
				digestAlgorithm: digestAlgo,
				uri: refUri,
				digestValue,
				inclusiveNamespacesPrefixList,
				isEmptyUri: false
			});
		}
		/**
		* Adds a reference to the signature.
		*
		* @param xpath The XPath expression to select the XML nodes to be referenced.
		* @param transforms An array of transform algorithms to be applied to the selected nodes.
		* @param digestAlgorithm The digest algorithm to use for computing the digest value.
		* @param uri The URI identifier for the reference. If empty, an empty URI will be used.
		* @param digestValue The expected digest value for the reference.
		* @param inclusiveNamespacesPrefixList The prefix list for inclusive namespace canonicalization.
		* @param isEmptyUri Indicates whether the URI is empty. Defaults to `false`.
		*/
		addReference({ xpath, transforms, digestAlgorithm, uri = "", digestValue, inclusiveNamespacesPrefixList = [], isEmptyUri = false }) {
			if (digestAlgorithm == null) throw new Error("digestAlgorithm is required");
			if (!utils.isArrayHasLength(transforms)) throw new Error("transforms must contain at least one transform algorithm");
			this.references.push({
				xpath,
				transforms,
				digestAlgorithm,
				uri,
				digestValue,
				inclusiveNamespacesPrefixList,
				isEmptyUri,
				getValidatedNode: () => {
					throw new Error("Reference has not been validated yet; Did you call `sig.checkSignature()`?");
				}
			});
		}
		/**
		* Returns the list of references.
		*/
		getReferences() {
			return this.references;
		}
		getSignedReferences() {
			return [...this.signedReferences];
		}
		computeSignature(xml, options, callbackParam) {
			let callback$1;
			if (typeof options === "function" && callbackParam == null) {
				callback$1 = options;
				options = {};
			} else {
				callback$1 = callbackParam;
				options = options ?? {};
			}
			const doc = new xmldom.DOMParser().parseFromString(xml);
			let xmlNsAttr = "xmlns";
			const signatureAttrs = [];
			let currentPrefix;
			const validActions = [
				"append",
				"prepend",
				"before",
				"after"
			];
			const prefix = options.prefix;
			const attrs = options.attrs || {};
			const location = options.location || {};
			const existingPrefixes = options.existingPrefixes || {};
			this.namespaceResolver = { lookupNamespaceURI: function(prefix$1) {
				return prefix$1 ? existingPrefixes[prefix$1] : null;
			} };
			location.reference = location.reference || "/*";
			location.action = location.action || "append";
			if (validActions.indexOf(location.action) === -1) {
				const err = /* @__PURE__ */ new Error(`location.action option has an invalid action: ${location.action}, must be any of the following values: ${validActions.join(", ")}`);
				if (!callback$1) throw err;
				else {
					callback$1(err);
					return;
				}
			}
			if (prefix) {
				xmlNsAttr += `:${prefix}`;
				currentPrefix = `${prefix}:`;
			} else currentPrefix = "";
			Object.keys(attrs).forEach(function(name$1) {
				if (name$1 !== "xmlns" && name$1 !== xmlNsAttr) signatureAttrs.push(`${name$1}="${attrs[name$1]}"`);
			});
			signatureAttrs.push(`${xmlNsAttr}="http://www.w3.org/2000/09/xmldsig#"`);
			let signatureXml = `<${currentPrefix}Signature ${signatureAttrs.join(" ")}>`;
			signatureXml += this.createSignedInfo(doc, prefix);
			signatureXml += this.getKeyInfo(prefix);
			signatureXml += `</${currentPrefix}Signature>`;
			this.originalXmlWithIds = doc.toString();
			let existingPrefixesString = "";
			Object.keys(existingPrefixes).forEach(function(key) {
				existingPrefixesString += `xmlns:${key}="${existingPrefixes[key]}" `;
			});
			const dummySignatureWrapper = `<Dummy ${existingPrefixesString}>${signatureXml}</Dummy>`;
			const signatureDoc = new xmldom.DOMParser().parseFromString(dummySignatureWrapper).documentElement.firstChild;
			const referenceNode = xpath.select1(location.reference, doc);
			if (!isDomNode.isNodeLike(referenceNode)) {
				const err2 = /* @__PURE__ */ new Error(`the following xpath cannot be used because it was not found: ${location.reference}`);
				if (!callback$1) throw err2;
				else {
					callback$1(err2);
					return;
				}
			}
			if (location.action === "append") referenceNode.appendChild(signatureDoc);
			else if (location.action === "prepend") referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);
			else if (location.action === "before") {
				if (referenceNode.parentNode == null) throw new Error("`location.reference` refers to the root node (by default), so we can't insert `before`");
				referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);
			} else if (location.action === "after") {
				if (referenceNode.parentNode == null) throw new Error("`location.reference` refers to the root node (by default), so we can't insert `after`");
				referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);
			}
			this.signatureNode = signatureDoc;
			const signedInfoNodes = utils.findChildren(this.signatureNode, "SignedInfo");
			if (signedInfoNodes.length === 0) {
				const err3 = /* @__PURE__ */ new Error("could not find SignedInfo element in the message");
				if (!callback$1) throw err3;
				else {
					callback$1(err3);
					return;
				}
			}
			const signedInfoNode = signedInfoNodes[0];
			if (typeof callback$1 === "function") this.calculateSignatureValue(doc, (err, signature) => {
				if (err) callback$1(err);
				else {
					this.signatureValue = signature || "";
					signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);
					this.signatureXml = signatureDoc.toString();
					this.signedXml = doc.toString();
					callback$1(null, this);
				}
			});
			else {
				this.calculateSignatureValue(doc);
				signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);
				this.signatureXml = signatureDoc.toString();
				this.signedXml = doc.toString();
			}
		}
		getKeyInfo(prefix) {
			const currentPrefix = prefix ? `${prefix}:` : "";
			let keyInfoAttrs = "";
			if (this.keyInfoAttributes) Object.keys(this.keyInfoAttributes).forEach((name$1) => {
				keyInfoAttrs += ` ${name$1}="${this.keyInfoAttributes[name$1]}"`;
			});
			const keyInfoContent = this.getKeyInfoContent({
				publicCert: this.publicCert,
				prefix
			});
			if (keyInfoAttrs || keyInfoContent) return `<${currentPrefix}KeyInfo${keyInfoAttrs}>${keyInfoContent}</${currentPrefix}KeyInfo>`;
			return "";
		}
		/**
		* Generate the Reference nodes (as part of the signature process)
		*
		*/
		createReferences(doc, prefix) {
			let res = "";
			prefix = prefix || "";
			prefix = prefix ? `${prefix}:` : prefix;
			for (const ref of this.getReferences()) {
				const nodes = xpath.selectWithResolver(ref.xpath ?? "", doc, this.namespaceResolver);
				if (!utils.isArrayHasLength(nodes)) throw new Error(`the following xpath cannot be signed because it was not found: ${ref.xpath}`);
				for (const node of nodes) {
					if (ref.isEmptyUri) res += `<${prefix}Reference URI="">`;
					else {
						const id = this.ensureHasId(node);
						ref.uri = id;
						res += `<${prefix}Reference URI="#${id}">`;
					}
					res += `<${prefix}Transforms>`;
					for (const trans of ref.transforms || []) {
						const transform$1 = this.findCanonicalizationAlgorithm(trans);
						res += `<${prefix}Transform Algorithm="${transform$1.getAlgorithmName()}"`;
						if (utils.isArrayHasLength(ref.inclusiveNamespacesPrefixList)) {
							res += ">";
							res += `<InclusiveNamespaces PrefixList="${ref.inclusiveNamespacesPrefixList.join(" ")}" xmlns="${transform$1.getAlgorithmName()}"/>`;
							res += `</${prefix}Transform>`;
						} else res += " />";
					}
					const canonXml = this.getCanonReferenceXml(doc, ref, node);
					const digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);
					res += `</${prefix}Transforms><${prefix}DigestMethod Algorithm="${digestAlgorithm.getAlgorithmName()}" /><${prefix}DigestValue>${digestAlgorithm.getHash(canonXml)}</${prefix}DigestValue></${prefix}Reference>`;
				}
			}
			return res;
		}
		getCanonXml(transforms, node, options = {}) {
			options.defaultNsForPrefix = options.defaultNsForPrefix ?? SignedXml.defaultNsForPrefix;
			options.signatureNode = this.signatureNode;
			let transformedXml = node.cloneNode(true);
			transforms.forEach((transformName) => {
				if (isDomNode.isNodeLike(transformedXml)) transformedXml = this.findCanonicalizationAlgorithm(transformName).process(transformedXml, options);
			});
			return transformedXml.toString();
		}
		/**
		* Ensure an element has Id attribute. If not create it with unique value.
		* Work with both normal and wssecurity Id flavour
		*/
		ensureHasId(node) {
			let attr;
			if (this.idMode === "wssecurity") attr = utils.findAttr(node, "Id", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
			else this.idAttributes.some((idAttribute) => {
				attr = utils.findAttr(node, idAttribute);
				return !!attr;
			});
			if (attr) return attr.value;
			const id = `_${this.id++}`;
			if (this.idMode === "wssecurity") {
				node.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
				node.setAttributeNS("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", "wsu:Id", id);
			} else node.setAttribute("Id", id);
			return id;
		}
		/**
		* Create the SignedInfo element
		*
		*/
		createSignedInfo(doc, prefix) {
			if (typeof this.canonicalizationAlgorithm !== "string") throw new Error("Missing canonicalizationAlgorithm when trying to create signed info for XML");
			const transform$1 = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);
			const algo = this.findSignatureAlgorithm(this.signatureAlgorithm);
			let currentPrefix;
			currentPrefix = prefix || "";
			currentPrefix = currentPrefix ? `${currentPrefix}:` : currentPrefix;
			let res = `<${currentPrefix}SignedInfo>`;
			res += `<${currentPrefix}CanonicalizationMethod Algorithm="${transform$1.getAlgorithmName()}"`;
			if (utils.isArrayHasLength(this.inclusiveNamespacesPrefixList)) {
				res += ">";
				res += `<InclusiveNamespaces PrefixList="${this.inclusiveNamespacesPrefixList.join(" ")}" xmlns="${transform$1.getAlgorithmName()}"/>`;
				res += `</${currentPrefix}CanonicalizationMethod>`;
			} else res += " />";
			res += `<${currentPrefix}SignatureMethod Algorithm="${algo.getAlgorithmName()}" />`;
			res += this.createReferences(doc, prefix);
			res += `</${currentPrefix}SignedInfo>`;
			return res;
		}
		/**
		* Create the Signature element
		*
		*/
		createSignature(prefix) {
			let xmlNsAttr = "xmlns";
			if (prefix) {
				xmlNsAttr += `:${prefix}`;
				prefix += ":";
			} else prefix = "";
			const signatureValueXml = `<${prefix}SignatureValue>${this.signatureValue}</${prefix}SignatureValue>`;
			const dummySignatureWrapper = `<${prefix}Signature ${xmlNsAttr}="http://www.w3.org/2000/09/xmldsig#">${signatureValueXml}</${prefix}Signature>`;
			return new xmldom.DOMParser().parseFromString(dummySignatureWrapper).documentElement.firstChild;
		}
		/**
		* Returns just the signature part, must be called only after {@link computeSignature}
		*
		* @returns The signature XML.
		*/
		getSignatureXml() {
			return this.signatureXml;
		}
		/**
		* Returns the original xml with Id attributes added on relevant elements (required for validation), must be called only after {@link computeSignature}
		*
		* @returns The original XML with IDs.
		*/
		getOriginalXmlWithIds() {
			return this.originalXmlWithIds;
		}
		/**
		* Returns the original xml document with the signature in it, must be called only after {@link computeSignature}
		*
		* @returns The signed XML.
		*/
		getSignedXml() {
			return this.signedXml;
		}
	};
	exports.SignedXml = SignedXml;
	SignedXml.defaultNsForPrefix = { ds: "http://www.w3.org/2000/09/xmldsig#" };
	SignedXml.noop = () => null;
}));

//#endregion
//#region ../../node_modules/.bun/xml-crypto@6.1.2/node_modules/xml-crypto/lib/index.js
var require_lib$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __exportStar = exports && exports.__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SignedXml = exports.ExclusiveCanonicalizationWithComments = exports.ExclusiveCanonicalization = exports.C14nCanonicalizationWithComments = exports.C14nCanonicalization = void 0;
	var c14n_canonicalization_1 = require_c14n_canonicalization();
	Object.defineProperty(exports, "C14nCanonicalization", {
		enumerable: true,
		get: function() {
			return c14n_canonicalization_1.C14nCanonicalization;
		}
	});
	Object.defineProperty(exports, "C14nCanonicalizationWithComments", {
		enumerable: true,
		get: function() {
			return c14n_canonicalization_1.C14nCanonicalizationWithComments;
		}
	});
	var exclusive_canonicalization_1 = require_exclusive_canonicalization();
	Object.defineProperty(exports, "ExclusiveCanonicalization", {
		enumerable: true,
		get: function() {
			return exclusive_canonicalization_1.ExclusiveCanonicalization;
		}
	});
	Object.defineProperty(exports, "ExclusiveCanonicalizationWithComments", {
		enumerable: true,
		get: function() {
			return exclusive_canonicalization_1.ExclusiveCanonicalizationWithComments;
		}
	});
	var signed_xml_1 = require_signed_xml();
	Object.defineProperty(exports, "SignedXml", {
		enumerable: true,
		get: function() {
			return signed_xml_1.SignedXml;
		}
	});
	__exportStar(require_types(), exports);
	__exportStar(require_utils$1(), exports);
}));

//#endregion
//#region ../../node_modules/.bun/escape-html@1.0.3/node_modules/escape-html/index.js
/*!
* escape-html
* Copyright(c) 2012-2013 TJ Holowaychuk
* Copyright(c) 2015 Andreas Lubbe
* Copyright(c) 2015 Tiancheng "Timothy" Gu
* MIT Licensed
*/
var require_escape_html = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module variables.
	* @private
	*/
	var matchHtmlRegExp = /["'&<>]/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = escapeHtml;
	/**
	* Escape special characters in the given string of html.
	*
	* @param  {string} string The string to escape for inserting into HTML
	* @return {string}
	* @public
	*/
	function escapeHtml(string$3) {
		var str = "" + string$3;
		var match = matchHtmlRegExp.exec(str);
		if (!match) return str;
		var escape$1;
		var html = "";
		var index = 0;
		var lastIndex = 0;
		for (index = match.index; index < str.length; index++) {
			switch (str.charCodeAt(index)) {
				case 34:
					escape$1 = "&quot;";
					break;
				case 38:
					escape$1 = "&amp;";
					break;
				case 39:
					escape$1 = "&#39;";
					break;
				case 60:
					escape$1 = "&lt;";
					break;
				case 62:
					escape$1 = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index) html += str.substring(lastIndex, index);
			lastIndex = index + 1;
			html += escape$1;
		}
		return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
}));

//#endregion
//#region ../../node_modules/.bun/@authenio+xml-encryption@2.0.2/node_modules/@authenio/xml-encryption/lib/templates/encrypted-key.tpl.xml.js
var require_encrypted_key_tpl_xml = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var escapehtml = require_escape_html();
	module.exports = ({ contentEncryptionMethod, keyInfo, encryptedContent }) => `
<xenc:EncryptedData Type="http://www.w3.org/2001/04/xmlenc#Element" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
  <xenc:EncryptionMethod Algorithm="${escapehtml(contentEncryptionMethod)}" />
  ${keyInfo}
  <xenc:CipherData>
    <xenc:CipherValue>${escapehtml(encryptedContent)}</xenc:CipherValue>
  </xenc:CipherData>
</xenc:EncryptedData>
`;
}));

//#endregion
//#region ../../node_modules/.bun/@authenio+xml-encryption@2.0.2/node_modules/@authenio/xml-encryption/lib/templates/keyinfo.tpl.xml.js
var require_keyinfo_tpl_xml = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var escapehtml = require_escape_html();
	module.exports = ({ encryptionPublicCert, encryptedKey, keyEncryptionMethod }) => `
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
  <e:EncryptedKey xmlns:e="http://www.w3.org/2001/04/xmlenc#">
    <e:EncryptionMethod Algorithm="${escapehtml(keyEncryptionMethod)}">
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1" />
    </e:EncryptionMethod>
    <KeyInfo>
      ${encryptionPublicCert}
    </KeyInfo>
    <e:CipherData>
      <e:CipherValue>${escapehtml(encryptedKey)}</e:CipherValue>
    </e:CipherData>
  </e:EncryptedKey>
</KeyInfo>
`;
}));

//#endregion
//#region ../../node_modules/.bun/@authenio+xml-encryption@2.0.2/node_modules/@authenio/xml-encryption/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	__require("path");
	__require("fs");
	var templates = {
		"encrypted-key": require_encrypted_key_tpl_xml(),
		"keyinfo": require_keyinfo_tpl_xml()
	};
	function renderTemplate(file$1, data) {
		return templates[file$1](data);
	}
	function pemToCert(pem) {
		var cert = /-----BEGIN CERTIFICATE-----([^-]*)-----END CERTIFICATE-----/g.exec(pem);
		if (cert.length > 0) return cert[1].replace(/[\n|\r\n]/g, "");
		return null;
	}
	function warnInsecureAlgorithm(algorithm, enabled = true) {
		if (enabled) console.warn(algorithm + " is no longer recommended due to security reasons. Please deprecate its use as soon as possible.");
	}
	module.exports = {
		renderTemplate,
		pemToCert,
		warnInsecureAlgorithm
	};
}));

//#endregion
//#region ../../node_modules/.bun/@authenio+xml-encryption@2.0.2/node_modules/@authenio/xml-encryption/lib/xmlenc.js
var require_xmlenc = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var crypto$2 = __require("crypto");
	var xmldom = require_lib$3();
	var xpath = require_xpath$1();
	var utils = require_utils();
	const insecureAlgorithms = ["http://www.w3.org/2001/04/xmlenc#rsa-1_5", "http://www.w3.org/2001/04/xmlenc#tripledes-cbc"];
	function encryptKeyInfoWithScheme(symmetricKey, options, scheme, callback$1) {
		const padding = scheme === "RSA-OAEP" ? crypto$2.constants.RSA_PKCS1_OAEP_PADDING : crypto$2.constants.RSA_PKCS1_PADDING;
		const symmetricKeyBuffer = Buffer.isBuffer(symmetricKey) ? symmetricKey : Buffer.from(symmetricKey, "utf-8");
		try {
			var params = {
				encryptedKey: crypto$2.publicEncrypt({
					key: options.rsa_pub,
					padding
				}, symmetricKeyBuffer).toString("base64"),
				encryptionPublicCert: "<X509Data><X509Certificate>" + utils.pemToCert(options.pem.toString()) + "</X509Certificate></X509Data>",
				keyEncryptionMethod: options.keyEncryptionAlgorithm
			};
			callback$1(null, utils.renderTemplate("keyinfo", params));
		} catch (e) {
			callback$1(e);
		}
	}
	function encryptKeyInfo(symmetricKey, options, callback$1) {
		if (!options) return callback$1(/* @__PURE__ */ new Error("must provide options"));
		if (!options.rsa_pub) return callback$1(/* @__PURE__ */ new Error("must provide options.rsa_pub with public key RSA"));
		if (!options.pem) return callback$1(/* @__PURE__ */ new Error("must provide options.pem with certificate"));
		if (!options.keyEncryptionAlgorithm) return callback$1(/* @__PURE__ */ new Error("encryption without encrypted key is not supported yet"));
		if (options.disallowEncryptionWithInsecureAlgorithm && insecureAlgorithms.indexOf(options.keyEncryptionAlgorithm) >= 0) return callback$1(/* @__PURE__ */ new Error("encryption algorithm " + options.keyEncryptionAlgorithm + "is not secure"));
		switch (options.keyEncryptionAlgorithm) {
			case "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p": return encryptKeyInfoWithScheme(symmetricKey, options, "RSA-OAEP", callback$1);
			case "http://www.w3.org/2001/04/xmlenc#rsa-1_5":
				utils.warnInsecureAlgorithm(options.keyEncryptionAlgorithm, options.warnInsecureAlgorithm);
				return encryptKeyInfoWithScheme(symmetricKey, options, "RSAES-PKCS1-V1_5", callback$1);
			default: return callback$1(/* @__PURE__ */ new Error("encryption key algorithm not supported"));
		}
	}
	function encrypt(content, options, callback$1) {
		if (!options) return callback$1(/* @__PURE__ */ new Error("must provide options"));
		if (!content) return callback$1(/* @__PURE__ */ new Error("must provide content to encrypt"));
		if (!options.rsa_pub) return callback$1(/* @__PURE__ */ new Error("rsa_pub option is mandatory and you should provide a valid RSA public key"));
		if (!options.pem) return callback$1(/* @__PURE__ */ new Error("pem option is mandatory and you should provide a valid x509 certificate encoded as PEM"));
		if (options.disallowEncryptionWithInsecureAlgorithm && (insecureAlgorithms.indexOf(options.keyEncryptionAlgorithm) >= 0 || insecureAlgorithms.indexOf(options.encryptionAlgorithm) >= 0)) return callback$1(/* @__PURE__ */ new Error("encryption algorithm " + options.keyEncryptionAlgorithm + " is not secure"));
		options.input_encoding = options.input_encoding || "utf8";
		function generate_symmetric_key(cb) {
			switch (options.encryptionAlgorithm) {
				case "http://www.w3.org/2001/04/xmlenc#aes128-cbc":
					crypto$2.randomBytes(16, cb);
					break;
				case "http://www.w3.org/2001/04/xmlenc#aes256-cbc":
					crypto$2.randomBytes(32, cb);
					break;
				case "http://www.w3.org/2009/xmlenc11#aes128-gcm":
					crypto$2.randomBytes(16, cb);
					break;
				case "http://www.w3.org/2009/xmlenc11#aes256-gcm":
					crypto$2.randomBytes(32, cb);
					break;
				case "http://www.w3.org/2001/04/xmlenc#tripledes-cbc":
					utils.warnInsecureAlgorithm(options.encryptionAlgorithm, options.warnInsecureAlgorithm);
					crypto$2.randomBytes(24, cb);
					break;
				default: crypto$2.randomBytes(32, cb);
			}
		}
		function encrypt_content(symmetricKey, cb) {
			switch (options.encryptionAlgorithm) {
				case "http://www.w3.org/2001/04/xmlenc#aes128-cbc":
					encryptWithAlgorithm("aes-128-cbc", symmetricKey, 16, content, options.input_encoding, function(err, encryptedContent) {
						if (err) return cb(err);
						cb(null, encryptedContent);
					});
					break;
				case "http://www.w3.org/2001/04/xmlenc#aes256-cbc":
					encryptWithAlgorithm("aes-256-cbc", symmetricKey, 16, content, options.input_encoding, function(err, encryptedContent) {
						if (err) return cb(err);
						cb(null, encryptedContent);
					});
					break;
				case "http://www.w3.org/2009/xmlenc11#aes128-gcm":
					encryptWithAlgorithm("aes-128-gcm", symmetricKey, 12, content, options.input_encoding, function(err, encryptedContent) {
						if (err) return cb(err);
						cb(null, encryptedContent);
					});
					break;
				case "http://www.w3.org/2009/xmlenc11#aes256-gcm":
					encryptWithAlgorithm("aes-256-gcm", symmetricKey, 12, content, options.input_encoding, function(err, encryptedContent) {
						if (err) return cb(err);
						cb(null, encryptedContent);
					});
					break;
				case "http://www.w3.org/2001/04/xmlenc#tripledes-cbc":
					utils.warnInsecureAlgorithm(options.encryptionAlgorithm, options.warnInsecureAlgorithm);
					encryptWithAlgorithm("des-ede3-cbc", symmetricKey, 8, content, options.input_encoding, function(err, encryptedContent) {
						if (err) return cb(err);
						cb(null, encryptedContent);
					});
					break;
				default: cb(/* @__PURE__ */ new Error("encryption algorithm not supported"));
			}
		}
		function encrypt_key(symmetricKey, encryptedContent, cb) {
			encryptKeyInfo(symmetricKey, options, function(err, keyInfo) {
				if (err) return cb(err);
				cb(null, utils.renderTemplate("encrypted-key", {
					encryptedContent: encryptedContent.toString("base64"),
					keyInfo,
					contentEncryptionMethod: options.encryptionAlgorithm
				}));
			});
		}
		generate_symmetric_key(function(genKeyError, symmetricKey) {
			if (genKeyError) return callback$1(genKeyError);
			encrypt_content(symmetricKey, function(encryptContentError, encryptedContent) {
				if (encryptContentError) return callback$1(encryptContentError);
				encrypt_key(symmetricKey, encryptedContent, function(encryptKeyError, result) {
					if (encryptKeyError) return callback$1(encryptKeyError);
					callback$1(null, result);
				});
			});
		});
	}
	function decrypt(xml, options, callback$1) {
		if (!options) return callback$1(/* @__PURE__ */ new Error("must provide options"));
		if (!xml) return callback$1(/* @__PURE__ */ new Error("must provide XML to encrypt"));
		if (!options.key) return callback$1(/* @__PURE__ */ new Error("key option is mandatory and you should provide a valid RSA private key"));
		try {
			var doc = typeof xml === "string" ? new xmldom.DOMParser().parseFromString(xml) : xml;
			var symmetricKey = decryptKeyInfo(doc, options);
			var encryptionAlgorithm = xpath.select("//*[local-name(.)='EncryptedData']/*[local-name(.)='EncryptionMethod']", doc)[0].getAttribute("Algorithm");
			if (options.disallowDecryptionWithInsecureAlgorithm && insecureAlgorithms.indexOf(encryptionAlgorithm) >= 0) return callback$1(/* @__PURE__ */ new Error("encryption algorithm " + encryptionAlgorithm + " is not secure, fail to decrypt"));
			var encryptedContent = xpath.select("//*[local-name(.)='EncryptedData']/*[local-name(.)='CipherData']/*[local-name(.)='CipherValue']", doc)[0];
			var encrypted = Buffer.from(encryptedContent.textContent, "base64");
			switch (encryptionAlgorithm) {
				case "http://www.w3.org/2001/04/xmlenc#aes128-cbc": return callback$1(null, decryptWithAlgorithm("aes-128-cbc", symmetricKey, 16, encrypted));
				case "http://www.w3.org/2001/04/xmlenc#aes256-cbc": return callback$1(null, decryptWithAlgorithm("aes-256-cbc", symmetricKey, 16, encrypted));
				case "http://www.w3.org/2001/04/xmlenc#tripledes-cbc":
					utils.warnInsecureAlgorithm(encryptionAlgorithm, options.warnInsecureAlgorithm);
					return callback$1(null, decryptWithAlgorithm("des-ede3-cbc", symmetricKey, 8, encrypted));
				case "http://www.w3.org/2009/xmlenc11#aes128-gcm": return callback$1(null, decryptWithAlgorithm("aes-128-gcm", symmetricKey, 12, encrypted));
				case "http://www.w3.org/2009/xmlenc11#aes256-gcm": return callback$1(null, decryptWithAlgorithm("aes-256-gcm", symmetricKey, 12, encrypted));
				default: return callback$1(/* @__PURE__ */ new Error("encryption algorithm " + encryptionAlgorithm + " not supported"));
			}
		} catch (e) {
			return callback$1(e);
		}
	}
	function decryptKeyInfo(doc, options) {
		if (typeof doc === "string") doc = new xmldom.DOMParser().parseFromString(doc);
		var keyRetrievalMethodUri;
		var keyInfo = xpath.select("//*[local-name(.)='KeyInfo' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", doc)[0];
		var keyEncryptionMethod = xpath.select("//*[local-name(.)='KeyInfo']/*[local-name(.)='EncryptedKey']/*[local-name(.)='EncryptionMethod']", doc)[0];
		if (!keyEncryptionMethod) {
			var keyRetrievalMethod = xpath.select("//*[local-name(.)='EncryptedData']/*[local-name(.)='KeyInfo']/*[local-name(.)='RetrievalMethod']", doc)[0];
			keyRetrievalMethodUri = keyRetrievalMethod ? keyRetrievalMethod.getAttribute("URI") : null;
			keyEncryptionMethod = keyRetrievalMethodUri ? xpath.select("//*[local-name(.)='EncryptedKey' and @Id='" + keyRetrievalMethodUri.substring(1) + "']/*[local-name(.)='EncryptionMethod']", doc)[0] : null;
		}
		if (!keyEncryptionMethod) throw new Error("cant find encryption algorithm");
		var keyEncryptionAlgorithm = keyEncryptionMethod.getAttribute("Algorithm");
		if (options.disallowDecryptionWithInsecureAlgorithm && insecureAlgorithms.indexOf(keyEncryptionAlgorithm) >= 0) throw new Error("encryption algorithm " + keyEncryptionAlgorithm + " is not secure, fail to decrypt");
		var encryptedKey = keyRetrievalMethodUri ? xpath.select("//*[local-name(.)='EncryptedKey' and @Id='" + keyRetrievalMethodUri.substring(1) + "']/*[local-name(.)='CipherData']/*[local-name(.)='CipherValue']", keyInfo)[0] : xpath.select("//*[local-name(.)='CipherValue']", keyInfo)[0];
		switch (keyEncryptionAlgorithm) {
			case "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p": return decryptKeyInfoWithScheme(encryptedKey, options, "RSA-OAEP");
			case "http://www.w3.org/2001/04/xmlenc#rsa-1_5":
				utils.warnInsecureAlgorithm(keyEncryptionAlgorithm, options.warnInsecureAlgorithm);
				return decryptKeyInfoWithScheme(encryptedKey, options, "RSAES-PKCS1-V1_5");
			default: throw new Error("key encryption algorithm " + keyEncryptionAlgorithm + " not supported");
		}
	}
	function decryptKeyInfoWithScheme(encryptedKey, options, scheme) {
		var padding = scheme === "RSA-OAEP" ? crypto$2.constants.RSA_PKCS1_OAEP_PADDING : crypto$2.constants.RSA_PKCS1_PADDING;
		var key = Buffer.from(encryptedKey.textContent, "base64");
		var decrypted = crypto$2.privateDecrypt({
			key: options.key,
			padding
		}, key);
		return Buffer.from(decrypted, "binary");
	}
	function encryptWithAlgorithm(algorithm, symmetricKey, ivLength, content, encoding, callback$1) {
		crypto$2.randomBytes(ivLength, function(err, iv) {
			if (err) return callback$1(err);
			var cipher = crypto$2.createCipheriv(algorithm, symmetricKey, iv);
			var encrypted = cipher.update(content, encoding, "binary") + cipher.final("binary");
			var authTag = algorithm.slice(-3) === "gcm" ? cipher.getAuthTag() : Buffer.from("");
			return callback$1(null, Buffer.concat([
				iv,
				Buffer.from(encrypted, "binary"),
				authTag
			]));
		});
	}
	function decryptWithAlgorithm(algorithm, symmetricKey, ivLength, content) {
		var decipher = crypto$2.createDecipheriv(algorithm, symmetricKey, content.slice(0, ivLength));
		decipher.setAutoPadding(false);
		if (algorithm.slice(-3) === "gcm") {
			decipher.setAuthTag(content.slice(-16));
			content = content.slice(0, -16);
		}
		var decrypted = decipher.update(content.slice(ivLength), null, "binary") + decipher.final("binary");
		if (algorithm.slice(-3) !== "gcm") {
			var padding = decrypted.charCodeAt(decrypted.length - 1);
			if (1 <= padding && padding <= ivLength) decrypted = decrypted.substr(0, decrypted.length - padding);
			else {
				callback(/* @__PURE__ */ new Error("padding length invalid"));
				return;
			}
		}
		return Buffer.from(decrypted, "binary").toString("utf8");
	}
	exports = module.exports = {
		decrypt,
		encrypt,
		encryptKeyInfo,
		decryptKeyInfo
	};
}));

//#endregion
//#region ../../node_modules/.bun/@authenio+xml-encryption@2.0.2/node_modules/@authenio/xml-encryption/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	exports = module.exports = require_xmlenc();
}));

//#endregion
//#region ../../node_modules/.bun/xml-escape@1.1.0/node_modules/xml-escape/index.js
var require_xml_escape = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var escape = module.exports = function escape$1(string$3, ignore) {
		var pattern;
		if (string$3 === null || string$3 === void 0) return;
		ignore = (ignore || "").replace(/[^&"<>\']/g, "");
		pattern = "([&\"<>'])".replace(new RegExp("[" + ignore + "]", "g"), "");
		return string$3.replace(new RegExp(pattern, "g"), function(str, item) {
			return escape$1.map[item];
		});
	};
	escape.map = {
		">": "&gt;",
		"<": "&lt;",
		"'": "&apos;",
		"\"": "&quot;",
		"&": "&amp;"
	};
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/libsaml.js
var require_libsaml = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @file SamlLib.js
	* @author tngan
	* @desc  A simple library including some common functions
	*/
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __generator = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g;
		return g = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
			return this;
		}), g;
		function verb(n) {
			return function(v) {
				return step([n, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __values = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
		if (m) return m.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var utility_1 = __importStar(require_utility());
	var urn_1 = require_urn();
	var xpath_1 = require_xpath$1();
	var node_rsa_1 = __importDefault(require_NodeRSA());
	var xml_crypto_1 = require_lib$1();
	var xmlenc = __importStar(require_lib());
	var camelcase_1 = __importDefault(require_camelcase());
	var api_1 = require_api();
	var xml_escape_1 = __importDefault(require_xml_escape());
	var fs = __importStar(__require("fs"));
	var xmldom_1 = require_lib$3();
	var signatureAlgorithms = urn_1.algorithms.signature;
	var digestAlgorithms = urn_1.algorithms.digest;
	var certUse = urn_1.wording.certUse;
	var urlParams = urn_1.wording.urlParams;
	var libSaml = function() {
		/**
		* @desc helper function to get back the query param for redirect binding for SLO/SSO
		* @type {string}
		*/
		function getQueryParamByType(type) {
			if ([urlParams.logoutRequest, urlParams.samlRequest].indexOf(type) !== -1) return "SAMLRequest";
			if ([urlParams.logoutResponse, urlParams.samlResponse].indexOf(type) !== -1) return "SAMLResponse";
			throw new Error("ERR_UNDEFINED_QUERY_PARAMS");
		}
		/**
		*
		*/
		var nrsaAliasMapping = {
			"http://www.w3.org/2000/09/xmldsig#rsa-sha1": "pkcs1-sha1",
			"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256": "pkcs1-sha256",
			"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512": "pkcs1-sha512"
		};
		/**
		* @desc Default login request template
		* @type {LoginRequestTemplate}
		*/
		var defaultLoginRequestTemplate = { context: "<samlp:AuthnRequest xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"{ID}\" Version=\"2.0\" IssueInstant=\"{IssueInstant}\" Destination=\"{Destination}\" ProtocolBinding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" AssertionConsumerServiceURL=\"{AssertionConsumerServiceURL}\"><saml:Issuer>{Issuer}</saml:Issuer><samlp:NameIDPolicy Format=\"{NameIDFormat}\" AllowCreate=\"{AllowCreate}\"/></samlp:AuthnRequest>" };
		/**
		* @desc Default logout request template
		* @type {LogoutRequestTemplate}
		*/
		var defaultLogoutRequestTemplate = { context: "<samlp:LogoutRequest xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"{ID}\" Version=\"2.0\" IssueInstant=\"{IssueInstant}\" Destination=\"{Destination}\"><saml:Issuer>{Issuer}</saml:Issuer><saml:NameID Format=\"{NameIDFormat}\">{NameID}</saml:NameID></samlp:LogoutRequest>" };
		/**
		* @desc Default AttributeStatement template
		* @type {AttributeStatementTemplate}
		*/
		var defaultAttributeStatementTemplate = { context: "<saml:AttributeStatement>{Attributes}</saml:AttributeStatement>" };
		/**
		* @desc Default Attribute template
		* @type {AttributeTemplate}
		*/
		var defaultAttributeTemplate = { context: "<saml:Attribute Name=\"{Name}\" NameFormat=\"{NameFormat}\"><saml:AttributeValue xmlns:xs=\"{ValueXmlnsXs}\" xmlns:xsi=\"{ValueXmlnsXsi}\" xsi:type=\"{ValueXsiType}\">{Value}</saml:AttributeValue></saml:Attribute>" };
		/**
		* @desc Default login response template
		* @type {LoginResponseTemplate}
		*/
		var defaultLoginResponseTemplate = {
			context: "<samlp:Response xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"{ID}\" Version=\"2.0\" IssueInstant=\"{IssueInstant}\" Destination=\"{Destination}\" InResponseTo=\"{InResponseTo}\"><saml:Issuer>{Issuer}</saml:Issuer><samlp:Status><samlp:StatusCode Value=\"{StatusCode}\"/></samlp:Status><saml:Assertion xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"{AssertionID}\" Version=\"2.0\" IssueInstant=\"{IssueInstant}\"><saml:Issuer>{Issuer}</saml:Issuer><saml:Subject><saml:NameID Format=\"{NameIDFormat}\">{NameID}</saml:NameID><saml:SubjectConfirmation Method=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><saml:SubjectConfirmationData NotOnOrAfter=\"{SubjectConfirmationDataNotOnOrAfter}\" Recipient=\"{SubjectRecipient}\" InResponseTo=\"{InResponseTo}\"/></saml:SubjectConfirmation></saml:Subject><saml:Conditions NotBefore=\"{ConditionsNotBefore}\" NotOnOrAfter=\"{ConditionsNotOnOrAfter}\"><saml:AudienceRestriction><saml:Audience>{Audience}</saml:Audience></saml:AudienceRestriction></saml:Conditions>{AuthnStatement}{AttributeStatement}</saml:Assertion></samlp:Response>",
			attributes: [],
			additionalTemplates: {
				"attributeStatementTemplate": defaultAttributeStatementTemplate,
				"attributeTemplate": defaultAttributeTemplate
			}
		};
		/**
		* @desc Default logout response template
		* @type {LogoutResponseTemplate}
		*/
		var defaultLogoutResponseTemplate = { context: "<samlp:LogoutResponse xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"{ID}\" Version=\"2.0\" IssueInstant=\"{IssueInstant}\" Destination=\"{Destination}\" InResponseTo=\"{InResponseTo}\"><saml:Issuer>{Issuer}</saml:Issuer><samlp:Status><samlp:StatusCode Value=\"{StatusCode}\"/></samlp:Status></samlp:LogoutResponse>" };
		/**
		* @private
		* @desc Get the signing scheme alias by signature algorithms, used by the node-rsa module
		* @param {string} sigAlg    signature algorithm
		* @return {string/null} signing algorithm short-hand for the module node-rsa
		*/
		function getSigningScheme(sigAlg) {
			if (sigAlg) {
				var algAlias = nrsaAliasMapping[sigAlg];
				if (!(algAlias === void 0)) return algAlias;
			}
			return nrsaAliasMapping[signatureAlgorithms.RSA_SHA1];
		}
		/**
		* @private
		* @desc Get the digest algorithms by signature algorithms
		* @param {string} sigAlg    signature algorithm
		* @return {string/undefined} digest algorithm
		*/
		function getDigestMethod(sigAlg) {
			return digestAlgorithms[sigAlg];
		}
		/**
		* @public
		* @desc Create XPath
		* @param  {string/object} local     parameters to create XPath
		* @param  {boolean} isExtractAll    define whether returns whole content according to the XPath
		* @return {string} xpath
		*/
		function createXPath(local, isExtractAll) {
			if ((0, utility_1.isString)(local)) return isExtractAll === true ? "//*[local-name(.)='" + local + "']/text()" : "//*[local-name(.)='" + local + "']";
			return "//*[local-name(.)='" + local.name + "']/@" + local.attr;
		}
		/**
		* @private
		* @desc Tag normalization
		* @param {string} prefix     prefix of the tag
		* @param {content} content   normalize it to capitalized camel case
		* @return {string}
		*/
		function tagging(prefix, content) {
			var camelContent = (0, camelcase_1.default)(content, { locale: "en-us" });
			return prefix + camelContent.charAt(0).toUpperCase() + camelContent.slice(1);
		}
		function escapeTag(replacement) {
			return function(_match, quote) {
				var text = replacement === null || replacement === void 0 ? "" : String(replacement);
				return quote ? "".concat(quote).concat((0, xml_escape_1.default)(text)) : text;
			};
		}
		return {
			createXPath,
			getQueryParamByType,
			defaultLoginRequestTemplate,
			defaultLoginResponseTemplate,
			defaultAttributeStatementTemplate,
			defaultAttributeTemplate,
			defaultLogoutRequestTemplate,
			defaultLogoutResponseTemplate,
			replaceTagsByValue: function(rawXML, tagValues) {
				Object.keys(tagValues).forEach(function(t) {
					rawXML = rawXML.replace(new RegExp("(\"?)\\{".concat(t, "\\}"), "g"), escapeTag(tagValues[t]));
				});
				return rawXML;
			},
			attributeStatementBuilder: function(attributes, attributeTemplate, attributeStatementTemplate) {
				if (attributeTemplate === void 0) attributeTemplate = defaultAttributeTemplate;
				if (attributeStatementTemplate === void 0) attributeStatementTemplate = defaultAttributeStatementTemplate;
				var attr = attributes.map(function(_a$1) {
					var name$1 = _a$1.name, nameFormat = _a$1.nameFormat, valueTag = _a$1.valueTag, valueXsiType = _a$1.valueXsiType, valueXmlnsXs = _a$1.valueXmlnsXs, valueXmlnsXsi = _a$1.valueXmlnsXsi;
					var defaultValueXmlnsXs = "http://www.w3.org/2001/XMLSchema";
					var defaultValueXmlnsXsi = "http://www.w3.org/2001/XMLSchema-instance";
					var attributeLine = attributeTemplate.context;
					attributeLine = attributeLine.replace("{Name}", name$1);
					attributeLine = attributeLine.replace("{NameFormat}", nameFormat);
					attributeLine = attributeLine.replace("{ValueXmlnsXs}", valueXmlnsXs ? valueXmlnsXs : defaultValueXmlnsXs);
					attributeLine = attributeLine.replace("{ValueXmlnsXsi}", valueXmlnsXsi ? valueXmlnsXsi : defaultValueXmlnsXsi);
					attributeLine = attributeLine.replace("{ValueXsiType}", valueXsiType);
					attributeLine = attributeLine.replace("{Value}", "{".concat(tagging("attr", valueTag), "}"));
					return attributeLine;
				}).join("");
				return attributeStatementTemplate.context.replace("{Attributes}", attr);
			},
			constructSAMLSignature: function(opts) {
				var rawSamlMessage = opts.rawSamlMessage, referenceTagXPath = opts.referenceTagXPath, privateKey = opts.privateKey, privateKeyPass = opts.privateKeyPass, _a$1 = opts.signatureAlgorithm, signatureAlgorithm = _a$1 === void 0 ? signatureAlgorithms.RSA_SHA256 : _a$1, _b = opts.transformationAlgorithms, transformationAlgorithms = _b === void 0 ? ["http://www.w3.org/2000/09/xmldsig#enveloped-signature", "http://www.w3.org/2001/10/xml-exc-c14n#"] : _b, signingCert = opts.signingCert, signatureConfig = opts.signatureConfig, _c = opts.isBase64Output, isBase64Output = _c === void 0 ? true : _c, _d = opts.isMessageSigned, isMessageSigned = _d === void 0 ? false : _d;
				var sig = new xml_crypto_1.SignedXml();
				var digestAlgorithm = getDigestMethod(signatureAlgorithm);
				if (referenceTagXPath) sig.addReference({
					xpath: referenceTagXPath,
					transforms: transformationAlgorithms,
					digestAlgorithm
				});
				if (isMessageSigned) sig.addReference({
					xpath: "/*",
					transforms: transformationAlgorithms,
					digestAlgorithm
				});
				sig.signatureAlgorithm = signatureAlgorithm;
				sig.publicCert = this.getKeyInfo(signingCert, signatureConfig).getKey();
				sig.getKeyInfoContent = this.getKeyInfo(signingCert, signatureConfig).getKeyInfo;
				sig.privateKey = utility_1.default.readPrivateKey(privateKey, privateKeyPass, true);
				sig.canonicalizationAlgorithm = "http://www.w3.org/2001/10/xml-exc-c14n#";
				if (signatureConfig) sig.computeSignature(rawSamlMessage, signatureConfig);
				else sig.computeSignature(rawSamlMessage);
				return isBase64Output !== false ? utility_1.default.base64Encode(sig.getSignedXml()) : sig.getSignedXml();
			},
			verifySignature: function(xml, opts) {
				var e_1, _a$1;
				var doc = (0, api_1.getContext)().dom.parseFromString(xml);
				var docParser = new xmldom_1.DOMParser();
				var messageSignatureXpath = "/*[contains(local-name(), 'Response') or contains(local-name(), 'Request')]/*[local-name(.)='Signature']";
				var assertionSignatureXpath = "/*[contains(local-name(), 'Response') or contains(local-name(), 'Request')]/*[local-name(.)='Assertion']/*[local-name(.)='Signature']";
				var wrappingElementsXPath = "/*[contains(local-name(), 'Response')]/*[local-name(.)='Assertion']/*[local-name(.)='Subject']/*[local-name(.)='SubjectConfirmation']/*[local-name(.)='SubjectConfirmationData']//*[local-name(.)='Assertion' or local-name(.)='Signature']";
				var selection = [];
				var messageSignatureNode = (0, xpath_1.select)(messageSignatureXpath, doc);
				var assertionSignatureNode = (0, xpath_1.select)(assertionSignatureXpath, doc);
				var wrappingElementNode = (0, xpath_1.select)(wrappingElementsXPath, doc);
				selection = selection.concat(messageSignatureNode);
				selection = selection.concat(assertionSignatureNode);
				if (wrappingElementNode.length !== 0) throw new Error("ERR_POTENTIAL_WRAPPING_ATTACK");
				if (selection.length === 0) return [false, null];
				var _loop_1 = function(signatureNode$1) {
					var sig = new xml_crypto_1.SignedXml();
					var verified = false;
					sig.signatureAlgorithm = opts.signatureAlgorithm;
					if (!opts.keyFile && !opts.metadata) throw new Error("ERR_UNDEFINED_SIGNATURE_VERIFIER_OPTIONS");
					if (opts.keyFile) sig.publicCert = fs.readFileSync(opts.keyFile);
					if (opts.metadata) {
						var certificateNode = (0, xpath_1.select)(".//*[local-name(.)='X509Certificate']", signatureNode$1);
						var metadataCert = opts.metadata.getX509Certificate(certUse.signing);
						if (Array.isArray(metadataCert)) metadataCert = (0, utility_1.flattenDeep)(metadataCert);
						else if (typeof metadataCert === "string") metadataCert = [metadataCert];
						metadataCert = metadataCert.map(utility_1.default.normalizeCerString);
						if (certificateNode.length === 0 && metadataCert.length === 0) throw new Error("NO_SELECTED_CERTIFICATE");
						if (certificateNode.length !== 0) {
							var x509CertificateData = certificateNode[0].firstChild.data;
							var x509Certificate_1 = utility_1.default.normalizeCerString(x509CertificateData);
							if (metadataCert.length >= 1 && !metadataCert.find(function(cert) {
								return cert.trim() === x509Certificate_1.trim();
							})) throw new Error("ERROR_UNMATCH_CERTIFICATE_DECLARATION_IN_METADATA");
							sig.publicCert = this_1.getKeyInfo(x509Certificate_1).getKey();
						} else sig.publicCert = this_1.getKeyInfo(metadataCert[0]).getKey();
					}
					sig.loadSignature(signatureNode$1);
					verified = sig.checkSignature(doc.toString());
					if (!verified) return "continue";
					if (!(sig.getSignedReferences().length >= 1)) throw new Error("NO_SIGNATURE_REFERENCES");
					var signedVerifiedXML = sig.getSignedReferences()[0];
					var rootNode = docParser.parseFromString(signedVerifiedXML, "text/xml").documentElement;
					if (rootNode.localName === "Response") {
						var assertions = (0, xpath_1.select)("./*[local-name()='Assertion']", rootNode);
						var encryptedAssertions = (0, xpath_1.select)("./*[local-name()='EncryptedAssertion']", rootNode);
						if (assertions.length === 1) return { value: [true, assertions[0].toString()] };
						else if (encryptedAssertions.length >= 1) return { value: [true, rootNode.toString()] };
						else return { value: [true, null] };
					} else if (rootNode.localName === "Assertion") return { value: [true, rootNode.toString()] };
					else return { value: [true, null] };
				};
				var this_1 = this;
				try {
					for (var selection_1 = __values(selection), selection_1_1 = selection_1.next(); !selection_1_1.done; selection_1_1 = selection_1.next()) {
						var signatureNode = selection_1_1.value;
						var state_1 = _loop_1(signatureNode);
						if (typeof state_1 === "object") return state_1.value;
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (selection_1_1 && !selection_1_1.done && (_a$1 = selection_1.return)) _a$1.call(selection_1);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				return [false, null];
			},
			createKeySection: function(use, certString) {
				var _a$1, _b, _c;
				return _a$1 = {}, _a$1["KeyDescriptor"] = [{ _attr: { use } }, (_b = {}, _b["ds:KeyInfo"] = [{ _attr: { "xmlns:ds": "http://www.w3.org/2000/09/xmldsig#" } }, (_c = {}, _c["ds:X509Data"] = [{ "ds:X509Certificate": utility_1.default.normalizeCerString(certString) }], _c)], _b)], _a$1;
			},
			constructMessageSignature: function(octetString, key, passphrase, isBase64, signingAlgorithm) {
				var signature = new node_rsa_1.default(utility_1.default.readPrivateKey(key, passphrase), void 0, { signingScheme: getSigningScheme(signingAlgorithm) }).sign(octetString);
				return isBase64 !== false ? signature.toString("base64") : signature;
			},
			verifyMessageSignature: function(metadata, octetString, signature, verifyAlgorithm) {
				var signCert = metadata.getX509Certificate(certUse.signing);
				var signingScheme = getSigningScheme(verifyAlgorithm);
				return new node_rsa_1.default(utility_1.default.getPublicKeyPemFromCertificate(signCert), "public", { signingScheme }).verify(Buffer.from(octetString), Buffer.from(signature));
			},
			getKeyInfo: function(x509Certificate, signatureConfig) {
				if (signatureConfig === void 0) signatureConfig = {};
				var prefix = signatureConfig.prefix ? "".concat(signatureConfig.prefix, ":") : "";
				return {
					getKeyInfo: function() {
						return "<".concat(prefix, "X509Data><").concat(prefix, "X509Certificate>").concat(x509Certificate, "</").concat(prefix, "X509Certificate></").concat(prefix, "X509Data>");
					},
					getKey: function() {
						return utility_1.default.getPublicKeyPemFromCertificate(x509Certificate).toString();
					}
				};
			},
			encryptAssertion: function(sourceEntity, targetEntity, xml) {
				return new Promise(function(resolve, reject) {
					if (!xml) return reject(/* @__PURE__ */ new Error("ERR_UNDEFINED_ASSERTION"));
					var sourceEntitySetting = sourceEntity.entitySetting;
					var targetEntityMetadata = targetEntity.entityMeta;
					var dom = (0, api_1.getContext)().dom;
					var doc = dom.parseFromString(xml);
					var assertions = (0, xpath_1.select)("//*[local-name(.)='Assertion']", doc);
					if (!Array.isArray(assertions) || assertions.length === 0) throw new Error("ERR_NO_ASSERTION");
					if (assertions.length > 1) throw new Error("ERR_MULTIPLE_ASSERTION");
					var rawAssertionNode = assertions[0];
					if (sourceEntitySetting.isAssertionEncrypted) {
						var publicKeyPem = utility_1.default.getPublicKeyPemFromCertificate(targetEntityMetadata.getX509Certificate(certUse.encrypt));
						xmlenc.encrypt(rawAssertionNode.toString(), {
							rsa_pub: Buffer.from(publicKeyPem),
							pem: Buffer.from("-----BEGIN CERTIFICATE-----".concat(targetEntityMetadata.getX509Certificate(certUse.encrypt), "-----END CERTIFICATE-----")),
							encryptionAlgorithm: sourceEntitySetting.dataEncryptionAlgorithm,
							keyEncryptionAlgorithm: sourceEntitySetting.keyEncryptionAlgorithm
						}, function(err, res) {
							if (err) {
								console.error(err);
								return reject(/* @__PURE__ */ new Error("ERR_EXCEPTION_OF_ASSERTION_ENCRYPTION"));
							}
							if (!res) return reject(/* @__PURE__ */ new Error("ERR_UNDEFINED_ENCRYPTED_ASSERTION"));
							var encAssertionPrefix = sourceEntitySetting.tagPrefix.encryptedAssertion;
							var encryptAssertionDoc = dom.parseFromString("<".concat(encAssertionPrefix, ":EncryptedAssertion xmlns:").concat(encAssertionPrefix, "=\"").concat(urn_1.namespace.names.assertion, "\">").concat(res, "</").concat(encAssertionPrefix, ":EncryptedAssertion>"));
							doc.documentElement.replaceChild(encryptAssertionDoc.documentElement, rawAssertionNode);
							return resolve(utility_1.default.base64Encode(doc.toString()));
						});
					} else return resolve(utility_1.default.base64Encode(xml));
				});
			},
			decryptAssertion: function(here, entireXML) {
				return new Promise(function(resolve, reject) {
					if (!entireXML) return reject(/* @__PURE__ */ new Error("ERR_UNDEFINED_ASSERTION"));
					var hereSetting = here.entitySetting;
					var dom = (0, api_1.getContext)().dom;
					var doc = dom.parseFromString(entireXML);
					var encryptedAssertions = (0, xpath_1.select)("/*[contains(local-name(), 'Response')]/*[local-name(.)='EncryptedAssertion']", doc);
					if (!Array.isArray(encryptedAssertions) || encryptedAssertions.length === 0) throw new Error("ERR_UNDEFINED_ENCRYPTED_ASSERTION");
					if (encryptedAssertions.length > 1) throw new Error("ERR_MULTIPLE_ASSERTION");
					var encAssertionNode = encryptedAssertions[0];
					return xmlenc.decrypt(encAssertionNode.toString(), { key: utility_1.default.readPrivateKey(hereSetting.encPrivateKey, hereSetting.encPrivateKeyPass) }, function(err, res) {
						if (err) {
							console.error(err);
							return reject(/* @__PURE__ */ new Error("ERR_EXCEPTION_OF_ASSERTION_DECRYPTION"));
						}
						if (!res) return reject(/* @__PURE__ */ new Error("ERR_UNDEFINED_ENCRYPTED_ASSERTION"));
						var rawAssertionDoc = dom.parseFromString(res);
						doc.documentElement.replaceChild(rawAssertionDoc.documentElement, encAssertionNode);
						return resolve([doc.toString(), res]);
					});
				});
			},
			isValidXml: function(input) {
				return __awaiter(this, void 0, void 0, function() {
					var validate$2, e_2;
					return __generator(this, function(_a$1) {
						switch (_a$1.label) {
							case 0:
								validate$2 = (0, api_1.getContext)().validate;
								/**
								* user can write a validate function that always returns
								* a resolved promise and skip the validator even in
								* production, user will take the responsibility if
								* they intend to skip the validation
								*/
								if (!validate$2) return [2, Promise.reject("Your application is potentially vulnerable because no validation function found. Please read the documentation on how to setup the validator. (https://github.com/tngan/samlify#installation)")];
								_a$1.label = 1;
							case 1:
								_a$1.trys.push([
									1,
									3,
									,
									4
								]);
								return [4, validate$2(input)];
							case 2: return [2, _a$1.sent()];
							case 3:
								e_2 = _a$1.sent();
								throw e_2;
							case 4: return [2];
						}
					});
				});
			}
		};
	};
	exports.default = libSaml();
}));

//#endregion
//#region ../../node_modules/.bun/xml@1.0.1/node_modules/xml/lib/escapeForXML.js
var require_escapeForXML = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var XML_CHARACTER_MAP = {
		"&": "&amp;",
		"\"": "&quot;",
		"'": "&apos;",
		"<": "&lt;",
		">": "&gt;"
	};
	function escapeForXML(string$3) {
		return string$3 && string$3.replace ? string$3.replace(/([&"<>'])/g, function(str, item) {
			return XML_CHARACTER_MAP[item];
		}) : string$3;
	}
	module.exports = escapeForXML;
}));

//#endregion
//#region ../../node_modules/.bun/xml@1.0.1/node_modules/xml/lib/xml.js
var require_xml = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var escapeForXML = require_escapeForXML();
	var Stream = __require("stream").Stream;
	var DEFAULT_INDENT = "    ";
	function xml(input, options) {
		if (typeof options !== "object") options = { indent: options };
		var stream = options.stream ? new Stream() : null, output = "", interrupted = false, indent = !options.indent ? "" : options.indent === true ? DEFAULT_INDENT : options.indent, instant = true;
		function delay(func) {
			if (!instant) func();
			else process.nextTick(func);
		}
		function append(interrupt, out) {
			if (out !== void 0) output += out;
			if (interrupt && !interrupted) {
				stream = stream || new Stream();
				interrupted = true;
			}
			if (interrupt && interrupted) {
				var data = output;
				delay(function() {
					stream.emit("data", data);
				});
				output = "";
			}
		}
		function add(value, last) {
			format(append, resolve(value, indent, indent ? 1 : 0), last);
		}
		function end() {
			if (stream) {
				var data = output;
				delay(function() {
					stream.emit("data", data);
					stream.emit("end");
					stream.readable = false;
					stream.emit("close");
				});
			}
		}
		function addXmlDeclaration(declaration) {
			var attr = {
				version: "1.0",
				encoding: declaration.encoding || "UTF-8"
			};
			if (declaration.standalone) attr.standalone = declaration.standalone;
			add({ "?xml": { _attr: attr } });
			output = output.replace("/>", "?>");
		}
		delay(function() {
			instant = false;
		});
		if (options.declaration) addXmlDeclaration(options.declaration);
		if (input && input.forEach) input.forEach(function(value, i) {
			var last;
			if (i + 1 === input.length) last = end;
			add(value, last);
		});
		else add(input, end);
		if (stream) {
			stream.readable = true;
			return stream;
		}
		return output;
	}
	function element() {
		var self$1 = { _elem: resolve(Array.prototype.slice.call(arguments)) };
		self$1.push = function(input) {
			if (!this.append) throw new Error("not assigned to a parent!");
			var that = this;
			var indent = this._elem.indent;
			format(this.append, resolve(input, indent, this._elem.icount + (indent ? 1 : 0)), function() {
				that.append(true);
			});
		};
		self$1.close = function(input) {
			if (input !== void 0) this.push(input);
			if (this.end) this.end();
		};
		return self$1;
	}
	function create_indent(character, count) {
		return new Array(count || 0).join(character || "");
	}
	function resolve(data, indent, indent_count) {
		indent_count = indent_count || 0;
		var indent_spaces = create_indent(indent, indent_count);
		var name$1;
		var values = data;
		var interrupt = false;
		if (typeof data === "object") {
			name$1 = Object.keys(data)[0];
			values = data[name$1];
			if (values && values._elem) {
				values._elem.name = name$1;
				values._elem.icount = indent_count;
				values._elem.indent = indent;
				values._elem.indents = indent_spaces;
				values._elem.interrupt = values;
				return values._elem;
			}
		}
		var attributes = [], content = [];
		var isStringContent;
		function get_attributes(obj) {
			Object.keys(obj).forEach(function(key) {
				attributes.push(attribute(key, obj[key]));
			});
		}
		switch (typeof values) {
			case "object":
				if (values === null) break;
				if (values._attr) get_attributes(values._attr);
				if (values._cdata) content.push(("<![CDATA[" + values._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>");
				if (values.forEach) {
					isStringContent = false;
					content.push("");
					values.forEach(function(value) {
						if (typeof value == "object") if (Object.keys(value)[0] == "_attr") get_attributes(value._attr);
						else content.push(resolve(value, indent, indent_count + 1));
						else {
							content.pop();
							isStringContent = true;
							content.push(escapeForXML(value));
						}
					});
					if (!isStringContent) content.push("");
				}
				break;
			default: content.push(escapeForXML(values));
		}
		return {
			name: name$1,
			interrupt,
			attributes,
			content,
			icount: indent_count,
			indents: indent_spaces,
			indent
		};
	}
	function format(append, elem, end) {
		if (typeof elem != "object") return append(false, elem);
		var len = elem.interrupt ? 1 : elem.content.length;
		function proceed() {
			while (elem.content.length) {
				var value = elem.content.shift();
				if (value === void 0) continue;
				if (interrupt(value)) return;
				format(append, value);
			}
			append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? "\n" : ""));
			if (end) end();
		}
		function interrupt(value) {
			if (value.interrupt) {
				value.interrupt.append = append;
				value.interrupt.end = proceed;
				value.interrupt = false;
				append(true);
				return true;
			}
			return false;
		}
		append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
		if (!len) return append(false, elem.indent ? "\n" : "");
		if (!interrupt(elem)) proceed();
	}
	function attribute(key, value) {
		return key + "=\"" + escapeForXML(value) + "\"";
	}
	module.exports = xml;
	module.exports.element = module.exports.Element = element;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/metadata-idp.js
var require_metadata_idp = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __extends = exports && exports.__extends || (function() {
		var extendStatics = function(d, b) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
				d$1.__proto__ = b$1;
			} || function(d$1, b$1) {
				for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
			};
			return extendStatics(d, b);
		};
		return function(d, b) {
			if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			extendStatics(d, b);
			function __() {
				this.constructor = d;
			}
			d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
	})();
	var __values = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
		if (m) return m.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IdpMetadata = void 0;
	/**
	* @file metadata-idp.ts
	* @author tngan
	* @desc  Metadata of identity provider
	*/
	var metadata_1 = __importDefault(require_metadata());
	var urn_1 = require_urn();
	var libsaml_1 = __importDefault(require_libsaml());
	var utility_1 = require_utility();
	var xml_1 = __importDefault(require_xml());
	function default_1(meta$2) {
		return new IdpMetadata(meta$2);
	}
	exports.default = default_1;
	var IdpMetadata = function(_super) {
		var e_1, e_2;
		__extends(IdpMetadata, _super);
		function IdpMetadata(meta$2) {
			if (!((0, utility_1.isString)(meta$2) || meta$2 instanceof Buffer)) {
				var _a$1 = meta$2, entityID = _a$1.entityID, signingCert = _a$1.signingCert, encryptCert = _a$1.encryptCert, _b = _a$1.wantAuthnRequestsSigned, wantAuthnRequestsSigned = _b === void 0 ? false : _b, _c = _a$1.nameIDFormat, nameIDFormat = _c === void 0 ? [] : _c, _d = _a$1.singleSignOnService, singleSignOnService = _d === void 0 ? [] : _d, _e = _a$1.singleLogoutService, singleLogoutService = _e === void 0 ? [] : _e;
				var IDPSSODescriptor_1 = [{ _attr: {
					WantAuthnRequestsSigned: String(wantAuthnRequestsSigned),
					protocolSupportEnumeration: urn_1.namespace.names.protocol
				} }];
				try {
					for (var _f = __values((0, utility_1.castArrayOpt)(signingCert)), _g = _f.next(); !_g.done; _g = _f.next()) {
						var cert = _g.value;
						IDPSSODescriptor_1.push(libsaml_1.default.createKeySection("signing", cert));
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (_g && !_g.done && (_a$1 = _f.return)) _a$1.call(_f);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				try {
					for (var _h = __values((0, utility_1.castArrayOpt)(encryptCert)), _j = _h.next(); !_j.done; _j = _h.next()) {
						var cert = _j.value;
						IDPSSODescriptor_1.push(libsaml_1.default.createKeySection("encryption", cert));
					}
				} catch (e_2_1) {
					e_2 = { error: e_2_1 };
				} finally {
					try {
						if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
					} finally {
						if (e_2) throw e_2.error;
					}
				}
				if ((0, utility_1.isNonEmptyArray)(nameIDFormat)) nameIDFormat.forEach(function(f) {
					return IDPSSODescriptor_1.push({ NameIDFormat: f });
				});
				if ((0, utility_1.isNonEmptyArray)(singleSignOnService)) singleSignOnService.forEach(function(a, indexCount) {
					var attr = {
						Binding: a.Binding,
						Location: a.Location
					};
					if (a.isDefault) attr.isDefault = true;
					IDPSSODescriptor_1.push({ SingleSignOnService: [{ _attr: attr }] });
				});
				else throw new Error("ERR_IDP_METADATA_MISSING_SINGLE_SIGN_ON_SERVICE");
				if ((0, utility_1.isNonEmptyArray)(singleLogoutService)) singleLogoutService.forEach(function(a, indexCount) {
					var attr = {};
					if (a.isDefault) attr.isDefault = true;
					attr.Binding = a.Binding;
					attr.Location = a.Location;
					IDPSSODescriptor_1.push({ SingleLogoutService: [{ _attr: attr }] });
				});
				else console.warn("Construct identity  provider - missing endpoint of SingleLogoutService");
				meta$2 = (0, xml_1.default)([{ EntityDescriptor: [{ _attr: {
					"xmlns": urn_1.namespace.names.metadata,
					"xmlns:assertion": urn_1.namespace.names.assertion,
					"xmlns:ds": "http://www.w3.org/2000/09/xmldsig#",
					entityID
				} }, { IDPSSODescriptor: IDPSSODescriptor_1 }] }]);
			}
			return _super.call(this, meta$2, [{
				key: "wantAuthnRequestsSigned",
				localPath: ["EntityDescriptor", "IDPSSODescriptor"],
				attributes: ["WantAuthnRequestsSigned"]
			}, {
				key: "singleSignOnService",
				localPath: [
					"EntityDescriptor",
					"IDPSSODescriptor",
					"SingleSignOnService"
				],
				index: ["Binding"],
				attributePath: [],
				attributes: ["Location"]
			}]) || this;
		}
		/**
		* @desc Get the preference whether it wants a signed request
		* @return {boolean} WantAuthnRequestsSigned
		*/
		IdpMetadata.prototype.isWantAuthnRequestsSigned = function() {
			var was = this.meta.wantAuthnRequestsSigned;
			if (was === void 0) return false;
			return String(was) === "true";
		};
		/**
		* @desc Get the entity endpoint for single sign on service
		* @param  {string} binding      protocol binding (e.g. redirect, post)
		* @return {string/object} location
		*/
		IdpMetadata.prototype.getSingleSignOnService = function(binding) {
			if ((0, utility_1.isString)(binding)) {
				var bindName = urn_1.namespace.binding[binding];
				var service = this.meta.singleSignOnService[bindName];
				if (service) return service;
			}
			return this.meta.singleSignOnService;
		};
		return IdpMetadata;
	}(metadata_1.default);
	exports.IdpMetadata = IdpMetadata;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/metadata-sp.js
var require_metadata_sp = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __extends = exports && exports.__extends || (function() {
		var extendStatics = function(d, b) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
				d$1.__proto__ = b$1;
			} || function(d$1, b$1) {
				for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
			};
			return extendStatics(d, b);
		};
		return function(d, b) {
			if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			extendStatics(d, b);
			function __() {
				this.constructor = d;
			}
			d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
	})();
	var __values = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
		if (m) return m.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SpMetadata = void 0;
	/**
	* @file metadata-sp.ts
	* @author tngan
	* @desc  Metadata of service provider
	*/
	var metadata_1 = __importDefault(require_metadata());
	var urn_1 = require_urn();
	var libsaml_1 = __importDefault(require_libsaml());
	var utility_1 = require_utility();
	var xml_1 = __importDefault(require_xml());
	function default_1(meta$2) {
		return new SpMetadata(meta$2);
	}
	exports.default = default_1;
	/**
	* @desc SP Metadata is for creating Service Provider, provides a set of API to manage the actions in SP.
	*/
	var SpMetadata = function(_super) {
		var e_1, e_2;
		__extends(SpMetadata, _super);
		/**
		* @param  {object/string} meta (either xml string or configuration in object)
		* @return {object} prototypes including public functions
		*/
		function SpMetadata(meta$2) {
			if (!((0, utility_1.isString)(meta$2) || meta$2 instanceof Buffer)) {
				var _a$1 = meta$2, _b = _a$1.elementsOrder, elementsOrder = _b === void 0 ? urn_1.elementsOrder.default : _b, entityID = _a$1.entityID, signingCert = _a$1.signingCert, encryptCert = _a$1.encryptCert, _c = _a$1.authnRequestsSigned, authnRequestsSigned = _c === void 0 ? false : _c, _d = _a$1.wantAssertionsSigned, wantAssertionsSigned = _d === void 0 ? false : _d, _e = _a$1.wantMessageSigned, wantMessageSigned = _e === void 0 ? false : _e, signatureConfig = _a$1.signatureConfig, _f = _a$1.nameIDFormat, nameIDFormat = _f === void 0 ? [] : _f, _g = _a$1.singleLogoutService, singleLogoutService = _g === void 0 ? [] : _g, _h = _a$1.assertionConsumerService, assertionConsumerService = _h === void 0 ? [] : _h;
				var descriptors_1 = {
					KeyDescriptor: [],
					NameIDFormat: [],
					SingleLogoutService: [],
					AssertionConsumerService: [],
					AttributeConsumingService: []
				};
				var SPSSODescriptor_1 = [{ _attr: {
					AuthnRequestsSigned: String(authnRequestsSigned),
					WantAssertionsSigned: String(wantAssertionsSigned),
					protocolSupportEnumeration: urn_1.namespace.names.protocol
				} }];
				if (wantMessageSigned && signatureConfig === void 0) console.warn("Construct service provider - missing signatureConfig");
				try {
					for (var _j = __values((0, utility_1.castArrayOpt)(signingCert)), _k = _j.next(); !_k.done; _k = _j.next()) {
						var cert = _k.value;
						descriptors_1.KeyDescriptor.push(libsaml_1.default.createKeySection("signing", cert).KeyDescriptor);
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (_k && !_k.done && (_a$1 = _j.return)) _a$1.call(_j);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				try {
					for (var _l = __values((0, utility_1.castArrayOpt)(encryptCert)), _m = _l.next(); !_m.done; _m = _l.next()) {
						var cert = _m.value;
						descriptors_1.KeyDescriptor.push(libsaml_1.default.createKeySection("encryption", cert).KeyDescriptor);
					}
				} catch (e_2_1) {
					e_2 = { error: e_2_1 };
				} finally {
					try {
						if (_m && !_m.done && (_b = _l.return)) _b.call(_l);
					} finally {
						if (e_2) throw e_2.error;
					}
				}
				if ((0, utility_1.isNonEmptyArray)(nameIDFormat)) nameIDFormat.forEach(function(f) {
					return descriptors_1.NameIDFormat.push(f);
				});
				else descriptors_1.NameIDFormat.push(urn_1.namespace.format.emailAddress);
				if ((0, utility_1.isNonEmptyArray)(singleLogoutService)) singleLogoutService.forEach(function(a) {
					var attr = {
						Binding: a.Binding,
						Location: a.Location
					};
					if (a.isDefault) attr.isDefault = true;
					descriptors_1.SingleLogoutService.push([{ _attr: attr }]);
				});
				if ((0, utility_1.isNonEmptyArray)(assertionConsumerService)) {
					var indexCount_1 = 0;
					assertionConsumerService.forEach(function(a) {
						var attr = {
							index: String(indexCount_1++),
							Binding: a.Binding,
							Location: a.Location
						};
						if (a.isDefault) attr.isDefault = true;
						descriptors_1.AssertionConsumerService.push([{ _attr: attr }]);
					});
				}
				elementsOrder.filter(function(name$1) {
					return (0, utility_1.isNonEmptyArray)(descriptors_1[name$1]);
				}).forEach(function(name$1) {
					descriptors_1[name$1].forEach(function(e) {
						var _a$2;
						return SPSSODescriptor_1.push((_a$2 = {}, _a$2[name$1] = e, _a$2));
					});
				});
				meta$2 = (0, xml_1.default)([{ EntityDescriptor: [{ _attr: {
					entityID,
					"xmlns": urn_1.namespace.names.metadata,
					"xmlns:assertion": urn_1.namespace.names.assertion,
					"xmlns:ds": "http://www.w3.org/2000/09/xmldsig#"
				} }, { SPSSODescriptor: SPSSODescriptor_1 }] }]);
			}
			return _super.call(this, meta$2, [{
				key: "spSSODescriptor",
				localPath: ["EntityDescriptor", "SPSSODescriptor"],
				attributes: ["WantAssertionsSigned", "AuthnRequestsSigned"]
			}, {
				key: "assertionConsumerService",
				localPath: [
					"EntityDescriptor",
					"SPSSODescriptor",
					"AssertionConsumerService"
				],
				attributes: [
					"Binding",
					"Location",
					"isDefault",
					"index"
				]
			}]) || this;
		}
		/**
		* @desc Get the preference whether it wants a signed assertion response
		* @return {boolean} Wantassertionssigned
		*/
		SpMetadata.prototype.isWantAssertionsSigned = function() {
			return this.meta.spSSODescriptor.wantAssertionsSigned === "true";
		};
		/**
		* @desc Get the preference whether it signs request
		* @return {boolean} Authnrequestssigned
		*/
		SpMetadata.prototype.isAuthnRequestSigned = function() {
			return this.meta.spSSODescriptor.authnRequestsSigned === "true";
		};
		/**
		* @desc Get the entity endpoint for assertion consumer service
		* @param  {string} binding         protocol binding (e.g. redirect, post)
		* @return {string/[string]} URL of endpoint(s)
		*/
		SpMetadata.prototype.getAssertionConsumerService = function(binding) {
			if ((0, utility_1.isString)(binding)) {
				var location_1;
				var bindName_1 = urn_1.namespace.binding[binding];
				if ((0, utility_1.isNonEmptyArray)(this.meta.assertionConsumerService)) this.meta.assertionConsumerService.forEach(function(obj) {
					if (obj.binding === bindName_1) {
						location_1 = obj.location;
						return;
					}
				});
				else if (this.meta.assertionConsumerService.binding === bindName_1) location_1 = this.meta.assertionConsumerService.location;
				return location_1;
			}
			return this.meta.assertionConsumerService;
		};
		return SpMetadata;
	}(metadata_1.default);
	exports.SpMetadata = SpMetadata;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/binding-redirect.js
var require_binding_redirect = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* @file binding-redirect.ts
	* @author tngan
	* @desc Binding-level API, declare the functions using Redirect binding
	*/
	var utility_1 = __importStar(require_utility());
	var libsaml_1 = __importDefault(require_libsaml());
	var url = __importStar(__require("url"));
	var urn_1 = require_urn();
	var binding = urn_1.wording.binding;
	var urlParams = urn_1.wording.urlParams;
	/**
	* @private
	* @desc Helper of generating URL param/value pair
	* @param  {string} param     key
	* @param  {string} value     value of key
	* @param  {boolean} first    determine whether the param is the starting one in order to add query header '?'
	* @return {string}
	*/
	function pvPair(param, value, first) {
		return (first === true ? "?" : "&") + param + "=" + value;
	}
	/**
	* @private
	* @desc Refractored part of URL generation for login/logout request
	* @param  {string} type
	* @param  {boolean} isSigned
	* @param  {string} rawSamlRequest
	* @param  {object} entitySetting
	* @return {string}
	*/
	function buildRedirectURL(opts) {
		var baseUrl = opts.baseUrl, type = opts.type, isSigned = opts.isSigned, context = opts.context, entitySetting = opts.entitySetting;
		var _a$1 = opts.relayState, relayState = _a$1 === void 0 ? "" : _a$1;
		var noParams = (url.parse(baseUrl).query || []).length === 0;
		var queryParam = libsaml_1.default.getQueryParamByType(type);
		var samlRequest = encodeURIComponent(utility_1.default.base64Encode(utility_1.default.deflateString(context)));
		if (relayState !== "") relayState = pvPair(urlParams.relayState, encodeURIComponent(relayState));
		if (isSigned) {
			var sigAlg = pvPair(urlParams.sigAlg, encodeURIComponent(entitySetting.requestSignatureAlgorithm));
			var octetString = samlRequest + relayState + sigAlg;
			return baseUrl + pvPair(queryParam, octetString, noParams) + pvPair(urlParams.signature, encodeURIComponent(libsaml_1.default.constructMessageSignature(queryParam + "=" + octetString, entitySetting.privateKey, entitySetting.privateKeyPass, void 0, entitySetting.requestSignatureAlgorithm).toString()));
		}
		return baseUrl + pvPair(queryParam, samlRequest + relayState, noParams);
	}
	/**
	* @desc Redirect URL for login request
	* @param  {object} entity                       object includes both idp and sp
	* @param  {function} customTagReplacement      used when developers have their own login response template
	* @return {string} redirect URL
	*/
	function loginRequestRedirectURL(entity, customTagReplacement) {
		var metadata = {
			idp: entity.idp.entityMeta,
			sp: entity.sp.entityMeta
		};
		var spSetting = entity.sp.entitySetting;
		var id = "";
		if (metadata && metadata.idp && metadata.sp) {
			var base = metadata.idp.getSingleSignOnService(binding.redirect);
			var rawSamlRequest = void 0;
			if (spSetting.loginRequestTemplate && customTagReplacement) {
				var info = customTagReplacement(spSetting.loginRequestTemplate);
				id = (0, utility_1.get)(info, "id", null);
				rawSamlRequest = (0, utility_1.get)(info, "context", null);
			} else {
				var nameIDFormat = spSetting.nameIDFormat;
				var selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
				id = spSetting.generateID();
				rawSamlRequest = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLoginRequestTemplate.context, {
					ID: id,
					Destination: base,
					Issuer: metadata.sp.getEntityID(),
					IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
					NameIDFormat: selectedNameIDFormat,
					AssertionConsumerServiceURL: metadata.sp.getAssertionConsumerService(binding.post),
					EntityID: metadata.sp.getEntityID(),
					AllowCreate: spSetting.allowCreate
				});
			}
			return {
				id,
				context: buildRedirectURL({
					context: rawSamlRequest,
					type: urlParams.samlRequest,
					isSigned: metadata.sp.isAuthnRequestSigned(),
					entitySetting: spSetting,
					baseUrl: base,
					relayState: spSetting.relayState
				})
			};
		}
		throw new Error("ERR_GENERATE_REDIRECT_LOGIN_REQUEST_MISSING_METADATA");
	}
	/**
	* @desc Redirect URL for login response
	* @param  {object} requestInfo             corresponding request, used to obtain the id
	* @param  {object} entity                      object includes both idp and sp
	* @param  {object} user                         current logged user (e.g. req.user)
	* @param  {String} relayState                the relaystate sent by sp corresponding request
	* @param  {function} customTagReplacement     used when developers have their own login response template
	*/
	function loginResponseRedirectURL(requestInfo, entity, user, relayState, customTagReplacement) {
		if (user === void 0) user = {};
		var idpSetting = entity.idp.entitySetting;
		var spSetting = entity.sp.entitySetting;
		var metadata = {
			idp: entity.idp.entityMeta,
			sp: entity.sp.entityMeta
		};
		var id = idpSetting.generateID();
		if (metadata && metadata.idp && metadata.sp) {
			var base = metadata.sp.getAssertionConsumerService(binding.redirect);
			var rawSamlResponse = void 0;
			var nameIDFormat = idpSetting.nameIDFormat;
			var selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
			var nowTime = /* @__PURE__ */ new Date();
			var fiveMinutesLaterTime = new Date(nowTime.getTime() + 3e5);
			var tvalue = {
				ID: id,
				AssertionID: idpSetting.generateID(),
				Destination: base,
				SubjectRecipient: base,
				Issuer: metadata.idp.getEntityID(),
				Audience: metadata.sp.getEntityID(),
				EntityID: metadata.sp.getEntityID(),
				IssueInstant: nowTime.toISOString(),
				AssertionConsumerServiceURL: base,
				StatusCode: urn_1.namespace.statusCode.success,
				ConditionsNotBefore: nowTime.toISOString(),
				ConditionsNotOnOrAfter: fiveMinutesLaterTime.toISOString(),
				SubjectConfirmationDataNotOnOrAfter: fiveMinutesLaterTime.toISOString(),
				NameIDFormat: selectedNameIDFormat,
				NameID: user.email || "",
				InResponseTo: (0, utility_1.get)(requestInfo, "extract.request.id", ""),
				AuthnStatement: "",
				AttributeStatement: ""
			};
			if (idpSetting.loginResponseTemplate && customTagReplacement) {
				var template = customTagReplacement(idpSetting.loginResponseTemplate.context);
				id = (0, utility_1.get)(template, "id", null);
				rawSamlResponse = (0, utility_1.get)(template, "context", null);
			} else {
				if (requestInfo !== null) tvalue.InResponseTo = requestInfo.extract.request.id;
				rawSamlResponse = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLoginResponseTemplate.context, tvalue);
			}
			var config$1 = {
				privateKey: idpSetting.privateKey,
				privateKeyPass: idpSetting.privateKeyPass,
				signatureAlgorithm: idpSetting.requestSignatureAlgorithm,
				signingCert: metadata.idp.getX509Certificate("signing"),
				isBase64Output: false
			};
			if (metadata.sp.isWantAssertionsSigned()) rawSamlResponse = libsaml_1.default.constructSAMLSignature(__assign(__assign({}, config$1), {
				rawSamlMessage: rawSamlResponse,
				transformationAlgorithms: spSetting.transformationAlgorithms,
				referenceTagXPath: "/*[local-name(.)='Response']/*[local-name(.)='Assertion']",
				signatureConfig: {
					prefix: "ds",
					location: {
						reference: "/*[local-name(.)='Response']/*[local-name(.)='Assertion']/*[local-name(.)='Issuer']",
						action: "after"
					}
				}
			}));
			return {
				id,
				context: buildRedirectURL({
					baseUrl: base,
					type: urlParams.samlResponse,
					isSigned: true,
					context: rawSamlResponse,
					entitySetting: idpSetting,
					relayState
				})
			};
		}
		throw new Error("ERR_GENERATE_REDIRECT_LOGIN_RESPONSE_MISSING_METADATA");
	}
	/**
	* @desc Redirect URL for logout request
	* @param  {object} user                        current logged user (e.g. req.user)
	* @param  {object} entity                      object includes both idp and sp
	* @param  {function} customTagReplacement     used when developers have their own login response template
	* @return {string} redirect URL
	*/
	function logoutRequestRedirectURL(user, entity, relayState, customTagReplacement) {
		var metadata = {
			init: entity.init.entityMeta,
			target: entity.target.entityMeta
		};
		var initSetting = entity.init.entitySetting;
		var id = initSetting.generateID();
		var nameIDFormat = initSetting.nameIDFormat;
		var selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
		if (metadata && metadata.init && metadata.target) {
			var base = metadata.target.getSingleLogoutService(binding.redirect);
			var rawSamlRequest = "";
			var requiredTags = {
				ID: id,
				Destination: base,
				EntityID: metadata.init.getEntityID(),
				Issuer: metadata.init.getEntityID(),
				IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
				NameIDFormat: selectedNameIDFormat,
				NameID: user.logoutNameID,
				SessionIndex: user.sessionIndex
			};
			if (initSetting.logoutRequestTemplate && customTagReplacement) {
				var info = customTagReplacement(initSetting.logoutRequestTemplate, requiredTags);
				id = (0, utility_1.get)(info, "id", null);
				rawSamlRequest = (0, utility_1.get)(info, "context", null);
			} else rawSamlRequest = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLogoutRequestTemplate.context, requiredTags);
			return {
				id,
				context: buildRedirectURL({
					context: rawSamlRequest,
					relayState,
					type: urlParams.logoutRequest,
					isSigned: entity.target.entitySetting.wantLogoutRequestSigned,
					entitySetting: initSetting,
					baseUrl: base
				})
			};
		}
		throw new Error("ERR_GENERATE_REDIRECT_LOGOUT_REQUEST_MISSING_METADATA");
	}
	/**
	* @desc Redirect URL for logout response
	* @param  {object} requescorresponding request, used to obtain the id
	* @param  {object} entity                      object includes both idp and sp
	* @param  {function} customTagReplacement     used when developers have their own login response template
	*/
	function logoutResponseRedirectURL(requestInfo, entity, relayState, customTagReplacement) {
		var metadata = {
			init: entity.init.entityMeta,
			target: entity.target.entityMeta
		};
		var initSetting = entity.init.entitySetting;
		var id = initSetting.generateID();
		if (metadata && metadata.init && metadata.target) {
			var base = metadata.target.getSingleLogoutService(binding.redirect);
			var rawSamlResponse = void 0;
			if (initSetting.logoutResponseTemplate && customTagReplacement) {
				var template = customTagReplacement(initSetting.logoutResponseTemplate);
				id = (0, utility_1.get)(template, "id", null);
				rawSamlResponse = (0, utility_1.get)(template, "context", null);
			} else {
				var tvalue = {
					ID: id,
					Destination: base,
					Issuer: metadata.init.getEntityID(),
					EntityID: metadata.init.getEntityID(),
					IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
					StatusCode: urn_1.namespace.statusCode.success
				};
				if (requestInfo && requestInfo.extract && requestInfo.extract.request) tvalue.InResponseTo = requestInfo.extract.request.id;
				rawSamlResponse = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLogoutResponseTemplate.context, tvalue);
			}
			return {
				id,
				context: buildRedirectURL({
					baseUrl: base,
					type: urlParams.logoutResponse,
					isSigned: entity.target.entitySetting.wantLogoutResponseSigned,
					context: rawSamlResponse,
					entitySetting: initSetting,
					relayState
				})
			};
		}
		throw new Error("ERR_GENERATE_REDIRECT_LOGOUT_RESPONSE_MISSING_METADATA");
	}
	var redirectBinding = {
		loginRequestRedirectURL,
		loginResponseRedirectURL,
		logoutRequestRedirectURL,
		logoutResponseRedirectURL
	};
	exports.default = redirectBinding;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/binding-post.js
var require_binding_post = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @file binding-post.ts
	* @author tngan
	* @desc Binding-level API, declare the functions using POST binding
	*/
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __generator = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g;
		return g = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
			return this;
		}), g;
		function verb(n) {
			return function(v) {
				return step([n, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var urn_1 = require_urn();
	var libsaml_1 = __importDefault(require_libsaml());
	var utility_1 = __importStar(require_utility());
	var binding = urn_1.wording.binding;
	/**
	* @desc Generate a base64 encoded login request
	* @param  {string} referenceTagXPath           reference uri
	* @param  {object} entity                      object includes both idp and sp
	* @param  {function} customTagReplacement     used when developers have their own login response template
	*/
	function base64LoginRequest(referenceTagXPath, entity, customTagReplacement) {
		var metadata = {
			idp: entity.idp.entityMeta,
			sp: entity.sp.entityMeta
		};
		var spSetting = entity.sp.entitySetting;
		var id = "";
		if (metadata && metadata.idp && metadata.sp) {
			var base = metadata.idp.getSingleSignOnService(binding.post);
			var rawSamlRequest = void 0;
			if (spSetting.loginRequestTemplate && customTagReplacement) {
				var info = customTagReplacement(spSetting.loginRequestTemplate.context);
				id = (0, utility_1.get)(info, "id", null);
				rawSamlRequest = (0, utility_1.get)(info, "context", null);
			} else {
				var nameIDFormat = spSetting.nameIDFormat;
				var selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
				id = spSetting.generateID();
				rawSamlRequest = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLoginRequestTemplate.context, {
					ID: id,
					Destination: base,
					Issuer: metadata.sp.getEntityID(),
					IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
					AssertionConsumerServiceURL: metadata.sp.getAssertionConsumerService(binding.post),
					EntityID: metadata.sp.getEntityID(),
					AllowCreate: spSetting.allowCreate,
					NameIDFormat: selectedNameIDFormat
				});
			}
			if (metadata.idp.isWantAuthnRequestsSigned()) {
				var privateKey = spSetting.privateKey, privateKeyPass = spSetting.privateKeyPass, signatureAlgorithm = spSetting.requestSignatureAlgorithm, transformationAlgorithms = spSetting.transformationAlgorithms;
				return {
					id,
					context: libsaml_1.default.constructSAMLSignature({
						referenceTagXPath,
						privateKey,
						privateKeyPass,
						signatureAlgorithm,
						transformationAlgorithms,
						rawSamlMessage: rawSamlRequest,
						signingCert: metadata.sp.getX509Certificate("signing"),
						signatureConfig: spSetting.signatureConfig || {
							prefix: "ds",
							location: {
								reference: "/*[local-name(.)='AuthnRequest']/*[local-name(.)='Issuer']",
								action: "after"
							}
						}
					})
				};
			}
			return {
				id,
				context: utility_1.default.base64Encode(rawSamlRequest)
			};
		}
		throw new Error("ERR_GENERATE_POST_LOGIN_REQUEST_MISSING_METADATA");
	}
	/**
	* @desc Generate a base64 encoded login response
	* @param  {object} requestInfo                 corresponding request, used to obtain the id
	* @param  {object} entity                      object includes both idp and sp
	* @param  {object} user                        current logged user (e.g. req.user)
	* @param  {function} customTagReplacement     used when developers have their own login response template
	* @param  {boolean}  encryptThenSign           whether or not to encrypt then sign first (if signing). Defaults to sign-then-encrypt
	*/
	function base64LoginResponse(requestInfo, entity, user, customTagReplacement, encryptThenSign) {
		if (requestInfo === void 0) requestInfo = {};
		if (user === void 0) user = {};
		if (encryptThenSign === void 0) encryptThenSign = false;
		return __awaiter(this, void 0, void 0, function() {
			var idpSetting, spSetting, id, metadata, nameIDFormat, selectedNameIDFormat, base, rawSamlResponse, nowTime, spEntityID, fiveMinutesLaterTime, fiveMinutesLater, now, acl, tvalue, template, privateKey, privateKeyPass, signatureAlgorithm, config$1, context;
			return __generator(this, function(_a$1) {
				switch (_a$1.label) {
					case 0:
						idpSetting = entity.idp.entitySetting;
						spSetting = entity.sp.entitySetting;
						id = idpSetting.generateID();
						metadata = {
							idp: entity.idp.entityMeta,
							sp: entity.sp.entityMeta
						};
						nameIDFormat = idpSetting.nameIDFormat;
						selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
						if (!(metadata && metadata.idp && metadata.sp)) return [3, 3];
						base = metadata.sp.getAssertionConsumerService(binding.post);
						rawSamlResponse = void 0;
						nowTime = /* @__PURE__ */ new Date();
						spEntityID = metadata.sp.getEntityID();
						fiveMinutesLaterTime = new Date(nowTime.getTime());
						fiveMinutesLaterTime.setMinutes(fiveMinutesLaterTime.getMinutes() + 5);
						fiveMinutesLater = fiveMinutesLaterTime.toISOString();
						now = nowTime.toISOString();
						acl = metadata.sp.getAssertionConsumerService(binding.post);
						tvalue = {
							ID: id,
							AssertionID: idpSetting.generateID(),
							Destination: base,
							Audience: spEntityID,
							EntityID: spEntityID,
							SubjectRecipient: acl,
							Issuer: metadata.idp.getEntityID(),
							IssueInstant: now,
							AssertionConsumerServiceURL: acl,
							StatusCode: urn_1.StatusCode.Success,
							ConditionsNotBefore: now,
							ConditionsNotOnOrAfter: fiveMinutesLater,
							SubjectConfirmationDataNotOnOrAfter: fiveMinutesLater,
							NameIDFormat: selectedNameIDFormat,
							NameID: user.email || "",
							InResponseTo: (0, utility_1.get)(requestInfo, "extract.request.id", ""),
							AuthnStatement: "",
							AttributeStatement: ""
						};
						if (idpSetting.loginResponseTemplate && customTagReplacement) {
							template = customTagReplacement(idpSetting.loginResponseTemplate.context);
							rawSamlResponse = (0, utility_1.get)(template, "context", null);
						} else {
							if (requestInfo !== null) tvalue.InResponseTo = requestInfo.extract.request.id;
							rawSamlResponse = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLoginResponseTemplate.context, tvalue);
						}
						privateKey = idpSetting.privateKey, privateKeyPass = idpSetting.privateKeyPass, signatureAlgorithm = idpSetting.requestSignatureAlgorithm;
						config$1 = {
							privateKey,
							privateKeyPass,
							signatureAlgorithm,
							signingCert: metadata.idp.getX509Certificate("signing"),
							isBase64Output: false
						};
						if (metadata.sp.isWantAssertionsSigned()) rawSamlResponse = libsaml_1.default.constructSAMLSignature(__assign(__assign({}, config$1), {
							rawSamlMessage: rawSamlResponse,
							transformationAlgorithms: spSetting.transformationAlgorithms,
							referenceTagXPath: "/*[local-name(.)='Response']/*[local-name(.)='Assertion']",
							signatureConfig: {
								prefix: "ds",
								location: {
									reference: "/*[local-name(.)='Response']/*[local-name(.)='Assertion']/*[local-name(.)='Issuer']",
									action: "after"
								}
							}
						}));
						if (!encryptThenSign && (spSetting.wantMessageSigned || !metadata.sp.isWantAssertionsSigned())) rawSamlResponse = libsaml_1.default.constructSAMLSignature(__assign(__assign({}, config$1), {
							rawSamlMessage: rawSamlResponse,
							isMessageSigned: true,
							transformationAlgorithms: spSetting.transformationAlgorithms,
							signatureConfig: spSetting.signatureConfig || {
								prefix: "ds",
								location: {
									reference: "/*[local-name(.)='Response']/*[local-name(.)='Issuer']",
									action: "after"
								}
							}
						}));
						if (!idpSetting.isAssertionEncrypted) return [3, 2];
						return [4, libsaml_1.default.encryptAssertion(entity.idp, entity.sp, rawSamlResponse)];
					case 1:
						context = _a$1.sent();
						if (encryptThenSign) rawSamlResponse = utility_1.default.base64Decode(context);
						else return [2, Promise.resolve({
							id,
							context
						})];
						_a$1.label = 2;
					case 2:
						if (encryptThenSign && (spSetting.wantMessageSigned || !metadata.sp.isWantAssertionsSigned())) rawSamlResponse = libsaml_1.default.constructSAMLSignature(__assign(__assign({}, config$1), {
							rawSamlMessage: rawSamlResponse,
							isMessageSigned: true,
							transformationAlgorithms: spSetting.transformationAlgorithms,
							signatureConfig: spSetting.signatureConfig || {
								prefix: "ds",
								location: {
									reference: "/*[local-name(.)='Response']/*[local-name(.)='Issuer']",
									action: "after"
								}
							}
						}));
						return [2, Promise.resolve({
							id,
							context: utility_1.default.base64Encode(rawSamlResponse)
						})];
					case 3: throw new Error("ERR_GENERATE_POST_LOGIN_RESPONSE_MISSING_METADATA");
				}
			});
		});
	}
	/**
	* @desc Generate a base64 encoded logout request
	* @param  {object} user                         current logged user (e.g. req.user)
	* @param  {string} referenceTagXPath            reference uri
	* @param  {object} entity                       object includes both idp and sp
	* @param  {function} customTagReplacement      used when developers have their own login response template
	* @return {string} base64 encoded request
	*/
	function base64LogoutRequest(user, referenceTagXPath, entity, customTagReplacement) {
		var metadata = {
			init: entity.init.entityMeta,
			target: entity.target.entityMeta
		};
		var initSetting = entity.init.entitySetting;
		var nameIDFormat = initSetting.nameIDFormat;
		var selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
		var id = "";
		if (metadata && metadata.init && metadata.target) {
			var rawSamlRequest = void 0;
			if (initSetting.logoutRequestTemplate && customTagReplacement) {
				var template = customTagReplacement(initSetting.logoutRequestTemplate.context);
				id = (0, utility_1.get)(template, "id", null);
				rawSamlRequest = (0, utility_1.get)(template, "context", null);
			} else {
				id = initSetting.generateID();
				var tvalue = {
					ID: id,
					Destination: metadata.target.getSingleLogoutService(binding.post),
					Issuer: metadata.init.getEntityID(),
					IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
					EntityID: metadata.init.getEntityID(),
					NameIDFormat: selectedNameIDFormat,
					NameID: user.logoutNameID
				};
				rawSamlRequest = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLogoutRequestTemplate.context, tvalue);
			}
			if (entity.target.entitySetting.wantLogoutRequestSigned) {
				var privateKey = initSetting.privateKey, privateKeyPass = initSetting.privateKeyPass, signatureAlgorithm = initSetting.requestSignatureAlgorithm, transformationAlgorithms = initSetting.transformationAlgorithms;
				return {
					id,
					context: libsaml_1.default.constructSAMLSignature({
						referenceTagXPath,
						privateKey,
						privateKeyPass,
						signatureAlgorithm,
						transformationAlgorithms,
						rawSamlMessage: rawSamlRequest,
						signingCert: metadata.init.getX509Certificate("signing"),
						signatureConfig: initSetting.signatureConfig || {
							prefix: "ds",
							location: {
								reference: "/*[local-name(.)='LogoutRequest']/*[local-name(.)='Issuer']",
								action: "after"
							}
						}
					})
				};
			}
			return {
				id,
				context: utility_1.default.base64Encode(rawSamlRequest)
			};
		}
		throw new Error("ERR_GENERATE_POST_LOGOUT_REQUEST_MISSING_METADATA");
	}
	/**
	* @desc Generate a base64 encoded logout response
	* @param  {object} requestInfo                 corresponding request, used to obtain the id
	* @param  {string} referenceTagXPath           reference uri
	* @param  {object} entity                      object includes both idp and sp
	* @param  {function} customTagReplacement     used when developers have their own login response template
	*/
	function base64LogoutResponse(requestInfo, entity, customTagReplacement) {
		var metadata = {
			init: entity.init.entityMeta,
			target: entity.target.entityMeta
		};
		var id = "";
		var initSetting = entity.init.entitySetting;
		if (metadata && metadata.init && metadata.target) {
			var rawSamlResponse = void 0;
			if (initSetting.logoutResponseTemplate) {
				var template = customTagReplacement(initSetting.logoutResponseTemplate.context);
				id = template.id;
				rawSamlResponse = template.context;
			} else {
				id = initSetting.generateID();
				var tvalue = {
					ID: id,
					Destination: metadata.target.getSingleLogoutService(binding.post),
					EntityID: metadata.init.getEntityID(),
					Issuer: metadata.init.getEntityID(),
					IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
					StatusCode: urn_1.StatusCode.Success,
					InResponseTo: (0, utility_1.get)(requestInfo, "extract.request.id", null)
				};
				rawSamlResponse = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLogoutResponseTemplate.context, tvalue);
			}
			if (entity.target.entitySetting.wantLogoutResponseSigned) {
				var privateKey = initSetting.privateKey, privateKeyPass = initSetting.privateKeyPass, signatureAlgorithm = initSetting.requestSignatureAlgorithm, transformationAlgorithms = initSetting.transformationAlgorithms;
				return {
					id,
					context: libsaml_1.default.constructSAMLSignature({
						isMessageSigned: true,
						transformationAlgorithms,
						privateKey,
						privateKeyPass,
						signatureAlgorithm,
						rawSamlMessage: rawSamlResponse,
						signingCert: metadata.init.getX509Certificate("signing"),
						signatureConfig: {
							prefix: "ds",
							location: {
								reference: "/*[local-name(.)='LogoutResponse']/*[local-name(.)='Issuer']",
								action: "after"
							}
						}
					})
				};
			}
			return {
				id,
				context: utility_1.default.base64Encode(rawSamlResponse)
			};
		}
		throw new Error("ERR_GENERATE_POST_LOGOUT_RESPONSE_MISSING_METADATA");
	}
	var postBinding = {
		base64LoginRequest,
		base64LoginResponse,
		base64LogoutRequest,
		base64LogoutResponse
	};
	exports.default = postBinding;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/validator.js
var require_validator = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __read = exports && exports.__read || function(o, n) {
		var m = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m) return o;
		var i = m.call(o), r, ar = [], e;
		try {
			while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error$47) {
			e = { error: error$47 };
		} finally {
			try {
				if (r && !r.done && (m = i["return"])) m.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.verifyTime = void 0;
	function verifyTime(utcNotBefore, utcNotOnOrAfter, drift) {
		if (drift === void 0) drift = [0, 0];
		var now = /* @__PURE__ */ new Date();
		if (!utcNotBefore && !utcNotOnOrAfter) {
			console.warn("You intend to have time validation however the document doesn't include the valid range.");
			return true;
		}
		var notBeforeLocal = null;
		var notOnOrAfterLocal = null;
		var _a$1 = __read(drift, 2), notBeforeDrift = _a$1[0], notOnOrAfterDrift = _a$1[1];
		if (utcNotBefore && !utcNotOnOrAfter) {
			notBeforeLocal = new Date(utcNotBefore);
			return +notBeforeLocal + notBeforeDrift <= +now;
		}
		if (!utcNotBefore && utcNotOnOrAfter) {
			notOnOrAfterLocal = new Date(utcNotOnOrAfter);
			return +now < +notOnOrAfterLocal + notOnOrAfterDrift;
		}
		notBeforeLocal = new Date(utcNotBefore);
		notOnOrAfterLocal = new Date(utcNotOnOrAfter);
		return +notBeforeLocal + notBeforeDrift <= +now && +now < +notOnOrAfterLocal + notOnOrAfterDrift;
	}
	exports.verifyTime = verifyTime;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/flow.js
var require_flow = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __generator = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g;
		return g = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
			return this;
		}), g;
		function verb(n) {
			return function(v) {
				return step([n, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __read = exports && exports.__read || function(o, n) {
		var m = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m) return o;
		var i = m.call(o), r, ar = [], e;
		try {
			while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error$47) {
			e = { error: error$47 };
		} finally {
			try {
				if (r && !r.done && (m = i["return"])) m.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.flow = void 0;
	var utility_1 = require_utility();
	var validator_1 = require_validator();
	var libsaml_1 = __importDefault(require_libsaml());
	var extractor_1 = require_extractor();
	var urn_1 = require_urn();
	var bindDict = urn_1.wording.binding;
	var urlParams = urn_1.wording.urlParams;
	function getDefaultExtractorFields(parserType, assertion) {
		switch (parserType) {
			case urn_1.ParserType.SAMLRequest: return extractor_1.loginRequestFields;
			case urn_1.ParserType.SAMLResponse:
				if (!assertion) throw new Error("ERR_EMPTY_ASSERTION");
				return (0, extractor_1.loginResponseFields)(assertion);
			case urn_1.ParserType.LogoutRequest: return extractor_1.logoutRequestFields;
			case urn_1.ParserType.LogoutResponse: return extractor_1.logoutResponseFields;
			default: throw new Error("ERR_UNDEFINED_PARSERTYPE");
		}
	}
	function redirectFlow(options) {
		return __awaiter(this, void 0, void 0, function() {
			var request, parserType, self$1, _a$1, checkSignature, from, query, octetString, sigAlg, signature, targetEntityMetadata, direction, content, xmlString, assertion, verifiedDoc, extractorFields, parseResult, base64Signature, decodeSigAlg, verified, issuer, extractedProperties;
			return __generator(this, function(_b) {
				switch (_b.label) {
					case 0:
						request = options.request, parserType = options.parserType, self$1 = options.self, _a$1 = options.checkSignature, checkSignature = _a$1 === void 0 ? true : _a$1, from = options.from;
						query = request.query, octetString = request.octetString;
						sigAlg = query.SigAlg, signature = query.Signature;
						targetEntityMetadata = from.entityMeta;
						direction = libsaml_1.default.getQueryParamByType(parserType);
						content = query[direction];
						if (content === void 0) return [2, Promise.reject("ERR_REDIRECT_FLOW_BAD_ARGS")];
						xmlString = (0, utility_1.inflateString)(decodeURIComponent(content));
						_b.label = 1;
					case 1:
						_b.trys.push([
							1,
							3,
							,
							4
						]);
						return [4, libsaml_1.default.isValidXml(xmlString)];
					case 2:
						_b.sent();
						return [3, 4];
					case 3:
						_b.sent();
						return [2, Promise.reject("ERR_INVALID_XML")];
					case 4: return [4, checkStatus(xmlString, parserType)];
					case 5:
						_b.sent();
						assertion = "";
						if (parserType === urlParams.samlResponse) {
							verifiedDoc = (0, extractor_1.extract)(xmlString, [{
								key: "assertion",
								localPath: ["~Response", "Assertion"],
								attributes: [],
								context: true
							}]);
							if (verifiedDoc && verifiedDoc.assertion) assertion = verifiedDoc.assertion;
						}
						extractorFields = getDefaultExtractorFields(parserType, assertion.length > 0 ? assertion : null);
						parseResult = {
							samlContent: xmlString,
							sigAlg: null,
							extract: (0, extractor_1.extract)(xmlString, extractorFields)
						};
						if (checkSignature) {
							if (!signature || !sigAlg) return [2, Promise.reject("ERR_MISSING_SIG_ALG")];
							base64Signature = Buffer.from(decodeURIComponent(signature), "base64");
							decodeSigAlg = decodeURIComponent(sigAlg);
							verified = libsaml_1.default.verifyMessageSignature(targetEntityMetadata, octetString, base64Signature, sigAlg);
							if (!verified) return [2, Promise.reject("ERR_FAILED_MESSAGE_SIGNATURE_VERIFICATION")];
							parseResult.sigAlg = decodeSigAlg;
						}
						issuer = targetEntityMetadata.getEntityID();
						extractedProperties = parseResult.extract;
						if ((parserType === "LogoutResponse" || parserType === "SAMLResponse") && extractedProperties && extractedProperties.issuer !== issuer) return [2, Promise.reject("ERR_UNMATCH_ISSUER")];
						if (parserType === "SAMLResponse" && extractedProperties.sessionIndex.sessionNotOnOrAfter && !(0, validator_1.verifyTime)(void 0, extractedProperties.sessionIndex.sessionNotOnOrAfter, self$1.entitySetting.clockDrifts)) return [2, Promise.reject("ERR_EXPIRED_SESSION")];
						if (parserType === "SAMLResponse" && extractedProperties.conditions && !(0, validator_1.verifyTime)(extractedProperties.conditions.notBefore, extractedProperties.conditions.notOnOrAfter, self$1.entitySetting.clockDrifts)) return [2, Promise.reject("ERR_SUBJECT_UNCONFIRMED")];
						return [2, Promise.resolve(parseResult)];
				}
			});
		});
	}
	function postFlow(options) {
		return __awaiter(this, void 0, void 0, function() {
			var request, from, self$1, parserType, _a$1, checkSignature, body, direction, encodedRequest, samlContent, verificationOptions, decryptRequired, extractorFields, _b, verified, verifiedAssertionNode, result, result, decryptedDoc, _c, decryptedDocVerified, verifiedDecryptedAssertion, parseResult, targetEntityMetadata, issuer, extractedProperties;
			return __generator(this, function(_d) {
				switch (_d.label) {
					case 0:
						request = options.request, from = options.from, self$1 = options.self, parserType = options.parserType, _a$1 = options.checkSignature, checkSignature = _a$1 === void 0 ? true : _a$1;
						body = request.body;
						direction = libsaml_1.default.getQueryParamByType(parserType);
						encodedRequest = body[direction];
						samlContent = String((0, utility_1.base64Decode)(encodedRequest));
						verificationOptions = {
							metadata: from.entityMeta,
							signatureAlgorithm: from.entitySetting.requestSignatureAlgorithm
						};
						decryptRequired = from.entitySetting.isAssertionEncrypted;
						extractorFields = [];
						return [4, libsaml_1.default.isValidXml(samlContent)];
					case 1:
						_d.sent();
						if (parserType !== urlParams.samlResponse) extractorFields = getDefaultExtractorFields(parserType, null);
						return [4, checkStatus(samlContent, parserType)];
					case 2:
						_d.sent();
						if (!checkSignature) return [3, 7];
						_b = __read(libsaml_1.default.verifySignature(samlContent, verificationOptions), 2), verified = _b[0], verifiedAssertionNode = _b[1];
						if (!(decryptRequired && verified && parserType === "SAMLResponse" && verifiedAssertionNode)) return [3, 4];
						return [4, libsaml_1.default.decryptAssertion(self$1, verifiedAssertionNode)];
					case 3:
						result = _d.sent();
						samlContent = result[0];
						extractorFields = getDefaultExtractorFields(parserType, result[1]);
						return [3, 7];
					case 4:
						if (!(decryptRequired && !verified)) return [3, 6];
						return [4, libsaml_1.default.decryptAssertion(self$1, samlContent)];
					case 5:
						result = _d.sent();
						decryptedDoc = result[0];
						_c = __read(libsaml_1.default.verifySignature(decryptedDoc, verificationOptions), 2), decryptedDocVerified = _c[0], verifiedDecryptedAssertion = _c[1];
						if (decryptedDocVerified) extractorFields = getDefaultExtractorFields(parserType, verifiedDecryptedAssertion);
						else return [2, Promise.reject("FAILED_TO_VERIFY_SIGNATURE")];
						return [3, 7];
					case 6:
						if (verified) extractorFields = getDefaultExtractorFields(parserType, verifiedAssertionNode);
						else return [2, Promise.reject("FAILED_TO_VERIFY_SIGNATURE")];
						_d.label = 7;
					case 7:
						parseResult = {
							samlContent,
							extract: (0, extractor_1.extract)(samlContent, extractorFields)
						};
						targetEntityMetadata = from.entityMeta;
						issuer = targetEntityMetadata.getEntityID();
						extractedProperties = parseResult.extract;
						if ((parserType === "LogoutResponse" || parserType === "SAMLResponse") && extractedProperties && extractedProperties.issuer !== issuer) return [2, Promise.reject("ERR_UNMATCH_ISSUER")];
						if (parserType === "SAMLResponse" && extractedProperties.sessionIndex.sessionNotOnOrAfter && !(0, validator_1.verifyTime)(void 0, extractedProperties.sessionIndex.sessionNotOnOrAfter, self$1.entitySetting.clockDrifts)) return [2, Promise.reject("ERR_EXPIRED_SESSION")];
						if (parserType === "SAMLResponse" && extractedProperties.conditions && !(0, validator_1.verifyTime)(extractedProperties.conditions.notBefore, extractedProperties.conditions.notOnOrAfter, self$1.entitySetting.clockDrifts)) return [2, Promise.reject("ERR_SUBJECT_UNCONFIRMED")];
						return [2, Promise.resolve(parseResult)];
				}
			});
		});
	}
	function postSimpleSignFlow(options) {
		return __awaiter(this, void 0, void 0, function() {
			var request, parserType, self$1, _a$1, checkSignature, from, body, octetString, targetEntityMetadata, direction, encodedRequest, sigAlg, signature, xmlString, assertion, verifiedDoc, extractorFields, parseResult, base64Signature, verified, issuer, extractedProperties;
			return __generator(this, function(_b) {
				switch (_b.label) {
					case 0:
						request = options.request, parserType = options.parserType, self$1 = options.self, _a$1 = options.checkSignature, checkSignature = _a$1 === void 0 ? true : _a$1, from = options.from;
						body = request.body, octetString = request.octetString;
						targetEntityMetadata = from.entityMeta;
						direction = libsaml_1.default.getQueryParamByType(parserType);
						encodedRequest = body[direction];
						sigAlg = body["SigAlg"];
						signature = body["Signature"];
						if (encodedRequest === void 0) return [2, Promise.reject("ERR_SIMPLESIGN_FLOW_BAD_ARGS")];
						xmlString = String((0, utility_1.base64Decode)(encodedRequest));
						_b.label = 1;
					case 1:
						_b.trys.push([
							1,
							3,
							,
							4
						]);
						return [4, libsaml_1.default.isValidXml(xmlString)];
					case 2:
						_b.sent();
						return [3, 4];
					case 3:
						_b.sent();
						return [2, Promise.reject("ERR_INVALID_XML")];
					case 4: return [4, checkStatus(xmlString, parserType)];
					case 5:
						_b.sent();
						assertion = "";
						if (parserType === urlParams.samlResponse) {
							verifiedDoc = (0, extractor_1.extract)(xmlString, [{
								key: "assertion",
								localPath: ["~Response", "Assertion"],
								attributes: [],
								context: true
							}]);
							if (verifiedDoc && verifiedDoc.assertion) assertion = verifiedDoc.assertion;
						}
						extractorFields = getDefaultExtractorFields(parserType, assertion.length > 0 ? assertion : null);
						parseResult = {
							samlContent: xmlString,
							sigAlg: null,
							extract: (0, extractor_1.extract)(xmlString, extractorFields)
						};
						if (checkSignature) {
							if (!signature || !sigAlg) return [2, Promise.reject("ERR_MISSING_SIG_ALG")];
							base64Signature = Buffer.from(signature, "base64");
							verified = libsaml_1.default.verifyMessageSignature(targetEntityMetadata, octetString, base64Signature, sigAlg);
							if (!verified) return [2, Promise.reject("ERR_FAILED_MESSAGE_SIGNATURE_VERIFICATION")];
							parseResult.sigAlg = sigAlg;
						}
						issuer = targetEntityMetadata.getEntityID();
						extractedProperties = parseResult.extract;
						if ((parserType === "LogoutResponse" || parserType === "SAMLResponse") && extractedProperties && extractedProperties.issuer !== issuer) return [2, Promise.reject("ERR_UNMATCH_ISSUER")];
						if (parserType === "SAMLResponse" && extractedProperties.sessionIndex.sessionNotOnOrAfter && !(0, validator_1.verifyTime)(void 0, extractedProperties.sessionIndex.sessionNotOnOrAfter, self$1.entitySetting.clockDrifts)) return [2, Promise.reject("ERR_EXPIRED_SESSION")];
						if (parserType === "SAMLResponse" && extractedProperties.conditions && !(0, validator_1.verifyTime)(extractedProperties.conditions.notBefore, extractedProperties.conditions.notOnOrAfter, self$1.entitySetting.clockDrifts)) return [2, Promise.reject("ERR_SUBJECT_UNCONFIRMED")];
						return [2, Promise.resolve(parseResult)];
				}
			});
		});
	}
	function checkStatus(content, parserType) {
		if (parserType !== urlParams.samlResponse && parserType !== urlParams.logoutResponse) return Promise.resolve("SKIPPED");
		var fields = parserType === urlParams.samlResponse ? extractor_1.loginResponseStatusFields : extractor_1.logoutResponseStatusFields;
		var _a$1 = (0, extractor_1.extract)(content, fields), top = _a$1.top, second = _a$1.second;
		if (top === urn_1.StatusCode.Success) return Promise.resolve("OK");
		if (!top) throw new Error("ERR_UNDEFINED_STATUS");
		throw new Error("ERR_FAILED_STATUS with top tier code: ".concat(top, ", second tier code: ").concat(second));
	}
	function flow(options) {
		var binding = options.binding;
		var parserType = options.parserType;
		options.supportBindings = [
			urn_1.BindingNamespace.Redirect,
			urn_1.BindingNamespace.Post,
			urn_1.BindingNamespace.SimpleSign
		];
		if (parserType === urn_1.ParserType.SAMLResponse) options.supportBindings = [
			urn_1.BindingNamespace.Post,
			urn_1.BindingNamespace.Redirect,
			urn_1.BindingNamespace.SimpleSign
		];
		if (binding === bindDict.post) return postFlow(options);
		if (binding === bindDict.redirect) return redirectFlow(options);
		if (binding === bindDict.simpleSign) return postSimpleSignFlow(options);
		return Promise.reject("ERR_UNEXPECTED_FLOW");
	}
	exports.flow = flow;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/entity.js
var require_entity = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* @file entity.ts
	* @author tngan
	* @desc  An abstraction for identity provider and service provider.
	*/
	var utility_1 = require_utility();
	var urn_1 = require_urn();
	var uuid = __importStar((init_esm_node(), __toCommonJS(esm_node_exports)));
	var metadata_idp_1 = __importDefault(require_metadata_idp());
	var metadata_sp_1 = __importDefault(require_metadata_sp());
	var binding_redirect_1 = __importDefault(require_binding_redirect());
	var binding_post_1 = __importDefault(require_binding_post());
	var flow_1 = require_flow();
	var dataEncryptionAlgorithm = urn_1.algorithms.encryption.data;
	var keyEncryptionAlgorithm = urn_1.algorithms.encryption.key;
	var signatureAlgorithms = urn_1.algorithms.signature;
	var defaultEntitySetting = {
		wantLogoutResponseSigned: false,
		messageSigningOrder: urn_1.messageConfigurations.signingOrder.SIGN_THEN_ENCRYPT,
		wantLogoutRequestSigned: false,
		allowCreate: false,
		isAssertionEncrypted: false,
		requestSignatureAlgorithm: signatureAlgorithms.RSA_SHA256,
		dataEncryptionAlgorithm: dataEncryptionAlgorithm.AES_256,
		keyEncryptionAlgorithm: keyEncryptionAlgorithm.RSA_OAEP_MGF1P,
		generateID: function() {
			return "_" + uuid.v4();
		},
		relayState: ""
	};
	var Entity = function() {
		/**
		* @param entitySetting
		* @param entityMeta is the entity metadata, deprecated after 2.0
		*/
		function Entity(entitySetting, entityType) {
			this.entitySetting = Object.assign({}, defaultEntitySetting, entitySetting);
			var metadata = entitySetting.metadata || entitySetting;
			switch (entityType) {
				case "idp":
					this.entityMeta = (0, metadata_idp_1.default)(metadata);
					this.entitySetting.wantAuthnRequestsSigned = this.entityMeta.isWantAuthnRequestsSigned();
					this.entitySetting.nameIDFormat = this.entityMeta.getNameIDFormat() || this.entitySetting.nameIDFormat;
					break;
				case "sp":
					this.entityMeta = (0, metadata_sp_1.default)(metadata);
					this.entitySetting.authnRequestsSigned = this.entityMeta.isAuthnRequestSigned();
					this.entitySetting.wantAssertionsSigned = this.entityMeta.isWantAssertionsSigned();
					this.entitySetting.nameIDFormat = this.entityMeta.getNameIDFormat() || this.entitySetting.nameIDFormat;
					break;
				default: throw new Error("ERR_UNDEFINED_ENTITY_TYPE");
			}
		}
		/**
		* @desc  Returns the setting of entity
		* @return {object}
		*/
		Entity.prototype.getEntitySetting = function() {
			return this.entitySetting;
		};
		/**
		* @desc  Returns the xml string of entity metadata
		* @return {string}
		*/
		Entity.prototype.getMetadata = function() {
			return this.entityMeta.getMetadata();
		};
		/**
		* @desc  Exports the entity metadata into specified folder
		* @param  {string} exportFile indicates the file name
		*/
		Entity.prototype.exportMetadata = function(exportFile) {
			return this.entityMeta.exportMetadata(exportFile);
		};
		/** * @desc  Verify fields with the one specified in metadata
		* @param  {string/[string]} field is a string or an array of string indicating the field value in SAML message
		* @param  {string} metaField is a string indicating the same field specified in metadata
		* @return {boolean} True/False
		*/
		Entity.prototype.verifyFields = function(field, metaField) {
			if ((0, utility_1.isString)(field)) return field === metaField;
			if ((0, utility_1.isNonEmptyArray)(field)) {
				var res_1 = true;
				field.forEach(function(f) {
					if (f !== metaField) {
						res_1 = false;
						return;
					}
				});
				return res_1;
			}
			return false;
		};
		/** @desc   Generates the logout request for developers to design their own method
		* @param  {ServiceProvider} sp     object of service provider
		* @param  {string}   binding       protocol binding
		* @param  {object}   user          current logged user (e.g. user)
		* @param  {string} relayState      the URL to which to redirect the user when logout is complete
		* @param  {function} customTagReplacement     used when developers have their own login response template
		*/
		Entity.prototype.createLogoutRequest = function(targetEntity, binding, user, relayState, customTagReplacement) {
			if (relayState === void 0) relayState = "";
			if (binding === urn_1.wording.binding.redirect) return binding_redirect_1.default.logoutRequestRedirectURL(user, {
				init: this,
				target: targetEntity
			}, relayState, customTagReplacement);
			if (binding === urn_1.wording.binding.post) {
				var entityEndpoint = targetEntity.entityMeta.getSingleLogoutService(binding);
				var context = binding_post_1.default.base64LogoutRequest(user, "/*[local-name(.)='LogoutRequest']", {
					init: this,
					target: targetEntity
				}, customTagReplacement);
				return __assign(__assign({}, context), {
					relayState,
					entityEndpoint,
					type: "SAMLRequest"
				});
			}
			throw new Error("ERR_UNDEFINED_BINDING");
		};
		/**
		* @desc  Generates the logout response for developers to design their own method
		* @param  {IdentityProvider} idp               object of identity provider
		* @param  {object} requestInfo                 corresponding request, used to obtain the id
		* @param  {string} relayState                  the URL to which to redirect the user when logout is complete.
		* @param  {string} binding                     protocol binding
		* @param  {function} customTagReplacement                 used when developers have their own login response template
		*/
		Entity.prototype.createLogoutResponse = function(target, requestInfo, binding, relayState, customTagReplacement) {
			if (relayState === void 0) relayState = "";
			var protocol = urn_1.namespace.binding[binding];
			if (protocol === urn_1.namespace.binding.redirect) return binding_redirect_1.default.logoutResponseRedirectURL(requestInfo, {
				init: this,
				target
			}, relayState, customTagReplacement);
			if (protocol === urn_1.namespace.binding.post) {
				var context = binding_post_1.default.base64LogoutResponse(requestInfo, {
					init: this,
					target
				}, customTagReplacement);
				return __assign(__assign({}, context), {
					relayState,
					entityEndpoint: target.entityMeta.getSingleLogoutService(binding),
					type: "SAMLResponse"
				});
			}
			throw new Error("ERR_CREATE_LOGOUT_RESPONSE_UNDEFINED_BINDING");
		};
		/**
		* @desc   Validation of the parsed the URL parameters
		* @param  {IdentityProvider}   idp             object of identity provider
		* @param  {string}   binding                   protocol binding
		* @param  {request}   req                      request
		* @return {Promise}
		*/
		Entity.prototype.parseLogoutRequest = function(from, binding, request) {
			var self$1 = this;
			return (0, flow_1.flow)({
				from,
				self: self$1,
				type: "logout",
				parserType: "LogoutRequest",
				checkSignature: this.entitySetting.wantLogoutRequestSigned,
				binding,
				request
			});
		};
		/**
		* @desc   Validation of the parsed the URL parameters
		* @param  {object} config                      config for the parser
		* @param  {string}   binding                   protocol binding
		* @param  {request}   req                      request
		* @return {Promise}
		*/
		Entity.prototype.parseLogoutResponse = function(from, binding, request) {
			var self$1 = this;
			return (0, flow_1.flow)({
				from,
				self: self$1,
				type: "logout",
				parserType: "LogoutResponse",
				checkSignature: self$1.entitySetting.wantLogoutResponseSigned,
				binding,
				request
			});
		};
		return Entity;
	}();
	exports.default = Entity;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/binding-simplesign.js
var require_binding_simplesign = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @file binding-simplesign.ts
	* @author Orange
	* @desc Binding-level API, declare the functions using POST SimpleSign binding
	*/
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __generator = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g;
		return g = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
			return this;
		}), g;
		function verb(n) {
			return function(v) {
				return step([n, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var urn_1 = require_urn();
	var libsaml_1 = __importDefault(require_libsaml());
	var utility_1 = __importStar(require_utility());
	var binding = urn_1.wording.binding;
	var urlParams = urn_1.wording.urlParams;
	/**
	* @private
	* @desc Helper of generating URL param/value pair
	* @param  {string} param     key
	* @param  {string} value     value of key
	* @param  {boolean} first    determine whether the param is the starting one in order to add query header '?'
	* @return {string}
	*/
	function pvPair(param, value, first) {
		return (first === true ? "?" : "&") + param + "=" + value;
	}
	/**
	* @private
	* @desc Refactored part of simple signature generation for login/logout request
	* @param  {string} type
	* @param  {string} rawSamlRequest
	* @param  {object} entitySetting
	* @return {string}
	*/
	function buildSimpleSignature(opts) {
		var type = opts.type, context = opts.context, entitySetting = opts.entitySetting;
		var _a$1 = opts.relayState, relayState = _a$1 === void 0 ? "" : _a$1;
		var queryParam = libsaml_1.default.getQueryParamByType(type);
		if (relayState !== "") relayState = pvPair(urlParams.relayState, relayState);
		var sigAlg = pvPair(urlParams.sigAlg, entitySetting.requestSignatureAlgorithm);
		var octetString = context + relayState + sigAlg;
		return libsaml_1.default.constructMessageSignature(queryParam + "=" + octetString, entitySetting.privateKey, entitySetting.privateKeyPass, void 0, entitySetting.requestSignatureAlgorithm).toString();
	}
	/**
	* @desc Generate a base64 encoded login request
	* @param  {string} referenceTagXPath           reference uri
	* @param  {object} entity                      object includes both idp and sp
	* @param  {function} customTagReplacement     used when developers have their own login response template
	*/
	function base64LoginRequest(entity, customTagReplacement) {
		var metadata = {
			idp: entity.idp.entityMeta,
			sp: entity.sp.entityMeta
		};
		var spSetting = entity.sp.entitySetting;
		var id = "";
		if (metadata && metadata.idp && metadata.sp) {
			var base = metadata.idp.getSingleSignOnService(binding.simpleSign);
			var rawSamlRequest = void 0;
			if (spSetting.loginRequestTemplate && customTagReplacement) {
				var info = customTagReplacement(spSetting.loginRequestTemplate.context);
				id = (0, utility_1.get)(info, "id", null);
				rawSamlRequest = (0, utility_1.get)(info, "context", null);
			} else {
				var nameIDFormat = spSetting.nameIDFormat;
				var selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
				id = spSetting.generateID();
				rawSamlRequest = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLoginRequestTemplate.context, {
					ID: id,
					Destination: base,
					Issuer: metadata.sp.getEntityID(),
					IssueInstant: (/* @__PURE__ */ new Date()).toISOString(),
					AssertionConsumerServiceURL: metadata.sp.getAssertionConsumerService(binding.simpleSign),
					EntityID: metadata.sp.getEntityID(),
					AllowCreate: spSetting.allowCreate,
					NameIDFormat: selectedNameIDFormat
				});
			}
			var simpleSignatureContext = null;
			if (metadata.idp.isWantAuthnRequestsSigned()) simpleSignatureContext = {
				signature: buildSimpleSignature({
					type: urlParams.samlRequest,
					context: rawSamlRequest,
					entitySetting: spSetting,
					relayState: spSetting.relayState
				}),
				sigAlg: spSetting.requestSignatureAlgorithm
			};
			return __assign({
				id,
				context: utility_1.default.base64Encode(rawSamlRequest)
			}, simpleSignatureContext);
		}
		throw new Error("ERR_GENERATE_POST_SIMPLESIGN_LOGIN_REQUEST_MISSING_METADATA");
	}
	/**
	* @desc Generate a base64 encoded login response
	* @param  {object} requestInfo                 corresponding request, used to obtain the id
	* @param  {object} entity                      object includes both idp and sp
	* @param  {object} user                        current logged user (e.g. req.user)
	* @param  {string}  relayState               the relay state
	* @param  {function} customTagReplacement     used when developers have their own login response template
	*/
	function base64LoginResponse(requestInfo, entity, user, relayState, customTagReplacement) {
		if (requestInfo === void 0) requestInfo = {};
		if (user === void 0) user = {};
		return __awaiter(this, void 0, void 0, function() {
			var idpSetting, spSetting, id, metadata, nameIDFormat, selectedNameIDFormat, base, rawSamlResponse, nowTime, fiveMinutesLaterTime, tvalue, template, privateKey, privateKeyPass, signatureAlgorithm, config$1, simpleSignature;
			return __generator(this, function(_a$1) {
				idpSetting = entity.idp.entitySetting;
				spSetting = entity.sp.entitySetting;
				id = idpSetting.generateID();
				metadata = {
					idp: entity.idp.entityMeta,
					sp: entity.sp.entityMeta
				};
				nameIDFormat = idpSetting.nameIDFormat;
				selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat;
				if (metadata && metadata.idp && metadata.sp) {
					base = metadata.sp.getAssertionConsumerService(binding.simpleSign);
					rawSamlResponse = void 0;
					nowTime = /* @__PURE__ */ new Date();
					fiveMinutesLaterTime = new Date(nowTime.getTime() + 3e5);
					tvalue = {
						ID: id,
						AssertionID: idpSetting.generateID(),
						Destination: base,
						Audience: metadata.sp.getEntityID(),
						EntityID: metadata.sp.getEntityID(),
						SubjectRecipient: base,
						Issuer: metadata.idp.getEntityID(),
						IssueInstant: nowTime.toISOString(),
						AssertionConsumerServiceURL: base,
						StatusCode: urn_1.StatusCode.Success,
						ConditionsNotBefore: nowTime.toISOString(),
						ConditionsNotOnOrAfter: fiveMinutesLaterTime.toISOString(),
						SubjectConfirmationDataNotOnOrAfter: fiveMinutesLaterTime.toISOString(),
						NameIDFormat: selectedNameIDFormat,
						NameID: user.email || "",
						InResponseTo: (0, utility_1.get)(requestInfo, "extract.request.id", ""),
						AuthnStatement: "",
						AttributeStatement: ""
					};
					if (idpSetting.loginResponseTemplate && customTagReplacement) {
						template = customTagReplacement(idpSetting.loginResponseTemplate.context);
						rawSamlResponse = (0, utility_1.get)(template, "context", null);
					} else {
						if (requestInfo !== null) tvalue.InResponseTo = requestInfo.extract.request.id;
						rawSamlResponse = libsaml_1.default.replaceTagsByValue(libsaml_1.default.defaultLoginResponseTemplate.context, tvalue);
					}
					privateKey = idpSetting.privateKey, privateKeyPass = idpSetting.privateKeyPass, signatureAlgorithm = idpSetting.requestSignatureAlgorithm;
					config$1 = {
						privateKey,
						privateKeyPass,
						signatureAlgorithm,
						signingCert: metadata.idp.getX509Certificate("signing"),
						isBase64Output: false
					};
					if (metadata.sp.isWantAssertionsSigned()) rawSamlResponse = libsaml_1.default.constructSAMLSignature(__assign(__assign({}, config$1), {
						rawSamlMessage: rawSamlResponse,
						transformationAlgorithms: spSetting.transformationAlgorithms,
						referenceTagXPath: "/*[local-name(.)='Response']/*[local-name(.)='Assertion']",
						signatureConfig: {
							prefix: "ds",
							location: {
								reference: "/*[local-name(.)='Response']/*[local-name(.)='Assertion']/*[local-name(.)='Issuer']",
								action: "after"
							}
						}
					}));
					simpleSignature = "";
					simpleSignature = buildSimpleSignature({
						type: urlParams.samlResponse,
						context: rawSamlResponse,
						entitySetting: idpSetting,
						relayState
					});
					return [2, Promise.resolve({
						id,
						context: utility_1.default.base64Encode(rawSamlResponse),
						signature: simpleSignature,
						sigAlg: idpSetting.requestSignatureAlgorithm
					})];
				}
				throw new Error("ERR_GENERATE_POST_SIMPLESIGN_LOGIN_RESPONSE_MISSING_METADATA");
			});
		});
	}
	var simpleSignBinding = {
		base64LoginRequest,
		base64LoginResponse
	};
	exports.default = simpleSignBinding;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/entity-idp.js
var require_entity_idp = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __extends = exports && exports.__extends || (function() {
		var extendStatics = function(d, b) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
				d$1.__proto__ = b$1;
			} || function(d$1, b$1) {
				for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
			};
			return extendStatics(d, b);
		};
		return function(d, b) {
			if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			extendStatics(d, b);
			function __() {
				this.constructor = d;
			}
			d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
	})();
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __generator = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g;
		return g = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
			return this;
		}), g;
		function verb(n) {
			return function(v) {
				return step([n, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IdentityProvider = void 0;
	/**
	* @file entity-idp.ts
	* @author tngan
	* @desc  Declares the actions taken by identity provider
	*/
	var entity_1 = __importDefault(require_entity());
	var libsaml_1 = __importDefault(require_libsaml());
	var urn_1 = require_urn();
	var binding_post_1 = __importDefault(require_binding_post());
	var binding_redirect_1 = __importDefault(require_binding_redirect());
	var binding_simplesign_1 = __importDefault(require_binding_simplesign());
	var flow_1 = require_flow();
	var utility_1 = require_utility();
	/**
	* Identity provider can be configured using either metadata importing or idpSetting
	*/
	function default_1(props) {
		return new IdentityProvider(props);
	}
	exports.default = default_1;
	/**
	* Identity provider can be configured using either metadata importing or idpSetting
	*/
	var IdentityProvider = function(_super) {
		__extends(IdentityProvider, _super);
		function IdentityProvider(idpSetting) {
			var entitySetting = Object.assign({
				wantAuthnRequestsSigned: false,
				tagPrefix: { encryptedAssertion: "saml" }
			}, idpSetting);
			if (idpSetting.loginResponseTemplate) if ((0, utility_1.isString)(idpSetting.loginResponseTemplate.context) && Array.isArray(idpSetting.loginResponseTemplate.attributes)) {
				var attributeStatementTemplate = void 0;
				var attributeTemplate = void 0;
				if (!idpSetting.loginResponseTemplate.additionalTemplates || !idpSetting.loginResponseTemplate.additionalTemplates.attributeStatementTemplate) attributeStatementTemplate = libsaml_1.default.defaultAttributeStatementTemplate;
				else attributeStatementTemplate = idpSetting.loginResponseTemplate.additionalTemplates.attributeStatementTemplate;
				if (!idpSetting.loginResponseTemplate.additionalTemplates || !idpSetting.loginResponseTemplate.additionalTemplates.attributeTemplate) attributeTemplate = libsaml_1.default.defaultAttributeTemplate;
				else attributeTemplate = idpSetting.loginResponseTemplate.additionalTemplates.attributeTemplate;
				var replacement = { AttributeStatement: libsaml_1.default.attributeStatementBuilder(idpSetting.loginResponseTemplate.attributes, attributeTemplate, attributeStatementTemplate) };
				entitySetting.loginResponseTemplate = __assign(__assign({}, entitySetting.loginResponseTemplate), { context: libsaml_1.default.replaceTagsByValue(entitySetting.loginResponseTemplate.context, replacement) });
			} else console.warn("Invalid login response template");
			return _super.call(this, entitySetting, "idp") || this;
		}
		/**
		* @desc  Generates the login response for developers to design their own method
		* @param  sp                        object of service provider
		* @param  requestInfo               corresponding request, used to obtain the id
		* @param  binding                   protocol binding
		* @param  user                      current logged user (e.g. req.user)
		* @param  customTagReplacement      used when developers have their own login response template
		* @param  encryptThenSign           whether or not to encrypt then sign first (if signing)
		* @param  relayState             the relayState from corresponding request
		*/
		IdentityProvider.prototype.createLoginResponse = function(sp, requestInfo, binding, user, customTagReplacement, encryptThenSign, relayState) {
			return __awaiter(this, void 0, void 0, function() {
				var protocol, context, _a$1;
				return __generator(this, function(_b) {
					switch (_b.label) {
						case 0:
							protocol = urn_1.namespace.binding[binding];
							context = null;
							_a$1 = protocol;
							switch (_a$1) {
								case urn_1.namespace.binding.post: return [3, 1];
								case urn_1.namespace.binding.simpleSign: return [3, 3];
								case urn_1.namespace.binding.redirect: return [3, 5];
							}
							return [3, 6];
						case 1: return [4, binding_post_1.default.base64LoginResponse(requestInfo, {
							idp: this,
							sp
						}, user, customTagReplacement, encryptThenSign)];
						case 2:
							context = _b.sent();
							return [3, 7];
						case 3: return [4, binding_simplesign_1.default.base64LoginResponse(requestInfo, {
							idp: this,
							sp
						}, user, relayState, customTagReplacement)];
						case 4:
							context = _b.sent();
							return [3, 7];
						case 5: return [2, binding_redirect_1.default.loginResponseRedirectURL(requestInfo, {
							idp: this,
							sp
						}, user, relayState, customTagReplacement)];
						case 6: throw new Error("ERR_CREATE_RESPONSE_UNDEFINED_BINDING");
						case 7: return [2, __assign(__assign({}, context), {
							relayState,
							entityEndpoint: sp.entityMeta.getAssertionConsumerService(binding),
							type: "SAMLResponse"
						})];
					}
				});
			});
		};
		/**
		* Validation of the parsed URL parameters
		* @param sp ServiceProvider instance
		* @param binding Protocol binding
		* @param req RequesmessageSigningOrderst
		*/
		IdentityProvider.prototype.parseLoginRequest = function(sp, binding, req) {
			var self$1 = this;
			return (0, flow_1.flow)({
				from: sp,
				self: self$1,
				checkSignature: self$1.entityMeta.isWantAuthnRequestsSigned(),
				parserType: "SAMLRequest",
				type: "login",
				binding,
				request: req
			});
		};
		return IdentityProvider;
	}(entity_1.default);
	exports.IdentityProvider = IdentityProvider;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/src/entity-sp.js
var require_entity_sp = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __extends = exports && exports.__extends || (function() {
		var extendStatics = function(d, b) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
				d$1.__proto__ = b$1;
			} || function(d$1, b$1) {
				for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
			};
			return extendStatics(d, b);
		};
		return function(d, b) {
			if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			extendStatics(d, b);
			function __() {
				this.constructor = d;
			}
			d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
	})();
	var __assign = exports && exports.__assign || function() {
		__assign = Object.assign || function(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ServiceProvider = void 0;
	/**
	* @file entity-sp.ts
	* @author tngan
	* @desc  Declares the actions taken by service provider
	*/
	var entity_1 = __importDefault(require_entity());
	var urn_1 = require_urn();
	var binding_redirect_1 = __importDefault(require_binding_redirect());
	var binding_post_1 = __importDefault(require_binding_post());
	var binding_simplesign_1 = __importDefault(require_binding_simplesign());
	var flow_1 = require_flow();
	function default_1(props) {
		return new ServiceProvider(props);
	}
	exports.default = default_1;
	/**
	* @desc Service provider can be configured using either metadata importing or spSetting
	* @param  {object} spSettingimport { FlowResult } from '../types/src/flow.d';
	
	*/
	var ServiceProvider = function(_super) {
		__extends(ServiceProvider, _super);
		/**
		* @desc  Inherited from Entity
		* @param {object} spSetting    setting of service provider
		*/
		function ServiceProvider(spSetting) {
			var entitySetting = Object.assign({
				authnRequestsSigned: false,
				wantAssertionsSigned: false,
				wantMessageSigned: false
			}, spSetting);
			return _super.call(this, entitySetting, "sp") || this;
		}
		/**
		* @desc  Generates the login request for developers to design their own method
		* @param  {IdentityProvider} idp               object of identity provider
		* @param  {string}   binding                   protocol binding
		* @param  {function} customTagReplacement     used when developers have their own login response template
		*/
		ServiceProvider.prototype.createLoginRequest = function(idp, binding, customTagReplacement) {
			if (binding === void 0) binding = "redirect";
			var nsBinding = urn_1.namespace.binding;
			var protocol = nsBinding[binding];
			if (this.entityMeta.isAuthnRequestSigned() !== idp.entityMeta.isWantAuthnRequestsSigned()) throw new Error("ERR_METADATA_CONFLICT_REQUEST_SIGNED_FLAG");
			var context = null;
			switch (protocol) {
				case nsBinding.redirect: return binding_redirect_1.default.loginRequestRedirectURL({
					idp,
					sp: this
				}, customTagReplacement);
				case nsBinding.post:
					context = binding_post_1.default.base64LoginRequest("/*[local-name(.)='AuthnRequest']", {
						idp,
						sp: this
					}, customTagReplacement);
					break;
				case nsBinding.simpleSign:
					context = binding_simplesign_1.default.base64LoginRequest({
						idp,
						sp: this
					}, customTagReplacement);
					break;
				default: throw new Error("ERR_SP_LOGIN_REQUEST_UNDEFINED_BINDING");
			}
			return __assign(__assign({}, context), {
				relayState: this.entitySetting.relayState,
				entityEndpoint: idp.entityMeta.getSingleSignOnService(binding),
				type: "SAMLRequest"
			});
		};
		/**
		* @desc   Validation of the parsed the URL parameters
		* @param  {IdentityProvider}   idp             object of identity provider
		* @param  {string}   binding                   protocol binding
		* @param  {request}   req                      request
		*/
		ServiceProvider.prototype.parseLoginResponse = function(idp, binding, request) {
			var self$1 = this;
			return (0, flow_1.flow)({
				from: idp,
				self: self$1,
				checkSignature: true,
				parserType: "SAMLResponse",
				type: "login",
				binding,
				request
			});
		};
		return ServiceProvider;
	}(entity_1.default);
	exports.ServiceProvider = ServiceProvider;
}));

//#endregion
//#region ../../node_modules/.bun/samlify@2.10.2/node_modules/samlify/build/index.js
var require_build = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.setDOMParserOptions = exports.setSchemaValidator = exports.ServiceProviderInstance = exports.ServiceProvider = exports.IdentityProviderInstance = exports.IdentityProvider = exports.Extractor = exports.Constants = exports.SamlLib = exports.Utility = exports.SPMetadata = exports.IdPMetadata = void 0;
	var entity_idp_1 = __importStar(require_entity_idp());
	exports.IdentityProvider = entity_idp_1.default;
	Object.defineProperty(exports, "IdentityProviderInstance", {
		enumerable: true,
		get: function() {
			return entity_idp_1.IdentityProvider;
		}
	});
	var entity_sp_1 = __importStar(require_entity_sp());
	exports.ServiceProvider = entity_sp_1.default;
	Object.defineProperty(exports, "ServiceProviderInstance", {
		enumerable: true,
		get: function() {
			return entity_sp_1.ServiceProvider;
		}
	});
	var metadata_idp_1 = require_metadata_idp();
	Object.defineProperty(exports, "IdPMetadata", {
		enumerable: true,
		get: function() {
			return __importDefault(metadata_idp_1).default;
		}
	});
	var metadata_sp_1 = require_metadata_sp();
	Object.defineProperty(exports, "SPMetadata", {
		enumerable: true,
		get: function() {
			return __importDefault(metadata_sp_1).default;
		}
	});
	var utility_1 = require_utility();
	Object.defineProperty(exports, "Utility", {
		enumerable: true,
		get: function() {
			return __importDefault(utility_1).default;
		}
	});
	var libsaml_1 = require_libsaml();
	Object.defineProperty(exports, "SamlLib", {
		enumerable: true,
		get: function() {
			return __importDefault(libsaml_1).default;
		}
	});
	var Constants = __importStar(require_urn());
	exports.Constants = Constants;
	var Extractor = __importStar(require_extractor());
	exports.Extractor = Extractor;
	var api_1 = require_api();
	Object.defineProperty(exports, "setSchemaValidator", {
		enumerable: true,
		get: function() {
			return api_1.setSchemaValidator;
		}
	});
	Object.defineProperty(exports, "setDOMParserOptions", {
		enumerable: true,
		get: function() {
			return api_1.setDOMParserOptions;
		}
	});
}));

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/classic/index.js
var import_build = /* @__PURE__ */ __toESM(require_build(), 1);
var classic_default = external_exports;

//#endregion
//#region ../../node_modules/.bun/zod@4.3.6/node_modules/zod/v4/index.js
var v4_default = classic_default;

//#endregion
//#region ../../node_modules/.bun/@better-auth+sso@1.4.18+39a339321b6c5df2/node_modules/@better-auth/sso/dist/index.mjs
const domainVerificationBodySchema = object({ providerId: string$1() });
/**
* Default TTL for AuthnRequest records (5 minutes).
* This should be sufficient for most IdPs while protecting against stale requests.
*/
const DEFAULT_AUTHN_REQUEST_TTL_MS = 300 * 1e3;
/**
* Default TTL for used assertion records (15 minutes).
* This should match the maximum expected NotOnOrAfter window plus clock skew.
*/
const DEFAULT_ASSERTION_TTL_MS = 900 * 1e3;
/**
* Default clock skew tolerance (5 minutes).
* Allows for minor time differences between IdP and SP servers.
*
* Accommodates:
* - Network latency and processing time
* - Clock synchronization differences (NTP drift)
* - Distributed systems across timezones
*/
const DEFAULT_CLOCK_SKEW_MS = 300 * 1e3;
/**
* Default maximum size for SAML responses (256 KB).
* Protects against memory exhaustion from oversized SAML payloads.
*/
const DEFAULT_MAX_SAML_RESPONSE_SIZE = 256 * 1024;
/**
* Default maximum size for IdP metadata (100 KB).
* Protects against oversized metadata documents.
*/
const DEFAULT_MAX_SAML_METADATA_SIZE = 100 * 1024;
const xmlParser = new XMLParser({
	ignoreAttributes: false,
	attributeNamePrefix: "@_",
	removeNSPrefix: true,
	processEntities: false
});
const SignatureAlgorithm = {
	RSA_SHA1: "http://www.w3.org/2000/09/xmldsig#rsa-sha1",
	RSA_SHA256: "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256",
	RSA_SHA384: "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384",
	RSA_SHA512: "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512",
	ECDSA_SHA256: "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256",
	ECDSA_SHA384: "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384",
	ECDSA_SHA512: "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512"
};
const DigestAlgorithm = {
	SHA1: "http://www.w3.org/2000/09/xmldsig#sha1",
	SHA256: "http://www.w3.org/2001/04/xmlenc#sha256",
	SHA384: "http://www.w3.org/2001/04/xmldsig-more#sha384",
	SHA512: "http://www.w3.org/2001/04/xmlenc#sha512"
};
const KeyEncryptionAlgorithm = {
	RSA_1_5: "http://www.w3.org/2001/04/xmlenc#rsa-1_5",
	RSA_OAEP: "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p",
	RSA_OAEP_SHA256: "http://www.w3.org/2009/xmlenc11#rsa-oaep"
};
const DataEncryptionAlgorithm = {
	TRIPLEDES_CBC: "http://www.w3.org/2001/04/xmlenc#tripledes-cbc",
	AES_128_CBC: "http://www.w3.org/2001/04/xmlenc#aes128-cbc",
	AES_192_CBC: "http://www.w3.org/2001/04/xmlenc#aes192-cbc",
	AES_256_CBC: "http://www.w3.org/2001/04/xmlenc#aes256-cbc",
	AES_128_GCM: "http://www.w3.org/2009/xmlenc11#aes128-gcm",
	AES_192_GCM: "http://www.w3.org/2009/xmlenc11#aes192-gcm",
	AES_256_GCM: "http://www.w3.org/2009/xmlenc11#aes256-gcm"
};
const DEPRECATED_SIGNATURE_ALGORITHMS$1 = [SignatureAlgorithm.RSA_SHA1];
const DEPRECATED_KEY_ENCRYPTION_ALGORITHMS = [KeyEncryptionAlgorithm.RSA_1_5];
const DEPRECATED_DATA_ENCRYPTION_ALGORITHMS = [DataEncryptionAlgorithm.TRIPLEDES_CBC];
const DEPRECATED_DIGEST_ALGORITHMS$1 = [DigestAlgorithm.SHA1];
const SECURE_SIGNATURE_ALGORITHMS = [
	SignatureAlgorithm.RSA_SHA256,
	SignatureAlgorithm.RSA_SHA384,
	SignatureAlgorithm.RSA_SHA512,
	SignatureAlgorithm.ECDSA_SHA256,
	SignatureAlgorithm.ECDSA_SHA384,
	SignatureAlgorithm.ECDSA_SHA512
];
const SECURE_DIGEST_ALGORITHMS = [
	DigestAlgorithm.SHA256,
	DigestAlgorithm.SHA384,
	DigestAlgorithm.SHA512
];
const SHORT_FORM_SIGNATURE_TO_URI = {
	sha1: SignatureAlgorithm.RSA_SHA1,
	sha256: SignatureAlgorithm.RSA_SHA256,
	sha384: SignatureAlgorithm.RSA_SHA384,
	sha512: SignatureAlgorithm.RSA_SHA512,
	"rsa-sha1": SignatureAlgorithm.RSA_SHA1,
	"rsa-sha256": SignatureAlgorithm.RSA_SHA256,
	"rsa-sha384": SignatureAlgorithm.RSA_SHA384,
	"rsa-sha512": SignatureAlgorithm.RSA_SHA512,
	"ecdsa-sha256": SignatureAlgorithm.ECDSA_SHA256,
	"ecdsa-sha384": SignatureAlgorithm.ECDSA_SHA384,
	"ecdsa-sha512": SignatureAlgorithm.ECDSA_SHA512
};
const SHORT_FORM_DIGEST_TO_URI = {
	sha1: DigestAlgorithm.SHA1,
	sha256: DigestAlgorithm.SHA256,
	sha384: DigestAlgorithm.SHA384,
	sha512: DigestAlgorithm.SHA512
};
const oidcMappingSchema = v4_default.object({
	id: v4_default.string().optional(),
	email: v4_default.string().optional(),
	emailVerified: v4_default.string().optional(),
	name: v4_default.string().optional(),
	image: v4_default.string().optional(),
	extraFields: v4_default.record(v4_default.string(), v4_default.any()).optional()
}).optional();
const samlMappingSchema = v4_default.object({
	id: v4_default.string().optional(),
	email: v4_default.string().optional(),
	emailVerified: v4_default.string().optional(),
	name: v4_default.string().optional(),
	firstName: v4_default.string().optional(),
	lastName: v4_default.string().optional(),
	extraFields: v4_default.record(v4_default.string(), v4_default.any()).optional()
}).optional();
const oidcConfigSchema$1 = v4_default.object({
	clientId: v4_default.string().optional(),
	clientSecret: v4_default.string().optional(),
	authorizationEndpoint: v4_default.string().url().optional(),
	tokenEndpoint: v4_default.string().url().optional(),
	userInfoEndpoint: v4_default.string().url().optional(),
	tokenEndpointAuthentication: v4_default.enum(["client_secret_post", "client_secret_basic"]).optional(),
	jwksEndpoint: v4_default.string().url().optional(),
	discoveryEndpoint: v4_default.string().url().optional(),
	scopes: v4_default.array(v4_default.string()).optional(),
	pkce: v4_default.boolean().optional(),
	overrideUserInfo: v4_default.boolean().optional(),
	mapping: oidcMappingSchema
});
const samlConfigSchema$1 = v4_default.object({
	entryPoint: v4_default.string().url().optional(),
	cert: v4_default.string().optional(),
	callbackUrl: v4_default.string().url().optional(),
	audience: v4_default.string().optional(),
	idpMetadata: v4_default.object({
		metadata: v4_default.string().optional(),
		entityID: v4_default.string().optional(),
		cert: v4_default.string().optional(),
		privateKey: v4_default.string().optional(),
		privateKeyPass: v4_default.string().optional(),
		isAssertionEncrypted: v4_default.boolean().optional(),
		encPrivateKey: v4_default.string().optional(),
		encPrivateKeyPass: v4_default.string().optional(),
		singleSignOnService: v4_default.array(v4_default.object({
			Binding: v4_default.string(),
			Location: v4_default.string().url()
		})).optional()
	}).optional(),
	spMetadata: v4_default.object({
		metadata: v4_default.string().optional(),
		entityID: v4_default.string().optional(),
		binding: v4_default.string().optional(),
		privateKey: v4_default.string().optional(),
		privateKeyPass: v4_default.string().optional(),
		isAssertionEncrypted: v4_default.boolean().optional(),
		encPrivateKey: v4_default.string().optional(),
		encPrivateKeyPass: v4_default.string().optional()
	}).optional(),
	wantAssertionsSigned: v4_default.boolean().optional(),
	signatureAlgorithm: v4_default.string().optional(),
	digestAlgorithm: v4_default.string().optional(),
	identifierFormat: v4_default.string().optional(),
	privateKey: v4_default.string().optional(),
	decryptionPvk: v4_default.string().optional(),
	additionalParams: v4_default.record(v4_default.string(), v4_default.any()).optional(),
	mapping: samlMappingSchema
});
const updateSSOProviderBodySchema = v4_default.object({
	issuer: v4_default.string().url().optional(),
	domain: v4_default.string().optional(),
	oidcConfig: oidcConfigSchema$1.optional(),
	samlConfig: samlConfigSchema$1.optional()
});
const getSSOProviderParamsSchema = v4_default.object({ providerId: v4_default.string() });
/**
* Custom error class for OIDC discovery failures.
* Can be caught and mapped to APIError at the edge.
*/
var DiscoveryError = class DiscoveryError$1 extends Error {
	code;
	details;
	constructor(code, message, details, options) {
		super(message, options);
		this.name = "DiscoveryError";
		this.code = code;
		this.details = details;
		if (Error.captureStackTrace) Error.captureStackTrace(this, DiscoveryError$1);
	}
};
/**
* Required fields that must be present in a valid discovery document.
*/
const REQUIRED_DISCOVERY_FIELDS = [
	"issuer",
	"authorization_endpoint",
	"token_endpoint",
	"jwks_uri"
];
/**
* OIDC Discovery Pipeline
*
* Implements OIDC discovery document fetching, validation, and hydration.
* This module is used both at provider registration time (to persist validated config)
* and at runtime (to hydrate legacy providers that are missing metadata).
*
* @see https://openid.net/specs/openid-connect-discovery-1_0.html
*/
/** Default timeout for discovery requests (10 seconds) */
const DEFAULT_DISCOVERY_TIMEOUT = 1e4;
/**
* Main entry point: Discover and hydrate OIDC configuration from an issuer.
*
* This function:
* 1. Computes the discovery URL from the issuer
* 2. Validates the discovery URL
* 3. Fetches the discovery document
* 4. Validates the discovery document (issuer match + required fields)
* 5. Normalizes URLs
* 6. Selects token endpoint auth method
* 7. Merges with existing config (existing values take precedence)
*
* @param params - Discovery parameters
* @param isTrustedOrigin - Origin verification tester function
* @returns Hydrated OIDC configuration ready for persistence
* @throws DiscoveryError on any failure
*/
async function discoverOIDCConfig(params) {
	const { issuer, existingConfig, timeout = DEFAULT_DISCOVERY_TIMEOUT } = params;
	const discoveryUrl = params.discoveryEndpoint || existingConfig?.discoveryEndpoint || computeDiscoveryUrl(issuer);
	validateDiscoveryUrl(discoveryUrl, params.isTrustedOrigin);
	const discoveryDoc = await fetchDiscoveryDocument(discoveryUrl, timeout);
	validateDiscoveryDocument(discoveryDoc, issuer);
	const normalizedDoc = normalizeDiscoveryUrls(discoveryDoc, issuer, params.isTrustedOrigin);
	const tokenEndpointAuth = selectTokenEndpointAuthMethod(normalizedDoc, existingConfig?.tokenEndpointAuthentication);
	return {
		issuer: existingConfig?.issuer ?? normalizedDoc.issuer,
		discoveryEndpoint: existingConfig?.discoveryEndpoint ?? discoveryUrl,
		authorizationEndpoint: existingConfig?.authorizationEndpoint ?? normalizedDoc.authorization_endpoint,
		tokenEndpoint: existingConfig?.tokenEndpoint ?? normalizedDoc.token_endpoint,
		jwksEndpoint: existingConfig?.jwksEndpoint ?? normalizedDoc.jwks_uri,
		userInfoEndpoint: existingConfig?.userInfoEndpoint ?? normalizedDoc.userinfo_endpoint,
		tokenEndpointAuthentication: existingConfig?.tokenEndpointAuthentication ?? tokenEndpointAuth,
		scopesSupported: existingConfig?.scopesSupported ?? normalizedDoc.scopes_supported
	};
}
/**
* Compute the discovery URL from an issuer URL.
*
* Per OIDC Discovery spec, the discovery document is located at:
* <issuer>/.well-known/openid-configuration
*
* Handles trailing slashes correctly.
*/
function computeDiscoveryUrl(issuer) {
	return `${issuer.endsWith("/") ? issuer.slice(0, -1) : issuer}/.well-known/openid-configuration`;
}
/**
* Validate a discovery URL before fetching.
*
* @param url - The discovery URL to validate
* @param isTrustedOrigin - Origin verification tester function
* @throws DiscoveryError if URL is invalid
*/
function validateDiscoveryUrl(url$2, isTrustedOrigin) {
	const discoveryEndpoint = parseURL("discoveryEndpoint", url$2).toString();
	if (!isTrustedOrigin(discoveryEndpoint)) throw new DiscoveryError("discovery_untrusted_origin", `The main discovery endpoint "${discoveryEndpoint}" is not trusted by your trusted origins configuration.`, { url: discoveryEndpoint });
}
/**
* Fetch the OIDC discovery document from the IdP.
*
* @param url - The discovery endpoint URL
* @param timeout - Request timeout in milliseconds
* @returns The parsed discovery document
* @throws DiscoveryError on network errors, timeouts, or invalid responses
*/
async function fetchDiscoveryDocument(url$2, timeout = DEFAULT_DISCOVERY_TIMEOUT) {
	try {
		const response = await betterFetch(url$2, {
			method: "GET",
			timeout
		});
		if (response.error) {
			const { status } = response.error;
			if (status === 404) throw new DiscoveryError("discovery_not_found", "Discovery endpoint not found", {
				url: url$2,
				status
			});
			if (status === 408) throw new DiscoveryError("discovery_timeout", "Discovery request timed out", {
				url: url$2,
				timeout
			});
			throw new DiscoveryError("discovery_unexpected_error", `Unexpected discovery error: ${response.error.statusText}`, {
				url: url$2,
				...response.error
			});
		}
		if (!response.data) throw new DiscoveryError("discovery_invalid_json", "Discovery endpoint returned an empty response", { url: url$2 });
		const data = response.data;
		if (typeof data === "string") throw new DiscoveryError("discovery_invalid_json", "Discovery endpoint returned invalid JSON", {
			url: url$2,
			bodyPreview: data.slice(0, 200)
		});
		return data;
	} catch (error$47) {
		if (error$47 instanceof DiscoveryError) throw error$47;
		if (error$47 instanceof Error && error$47.name === "AbortError") throw new DiscoveryError("discovery_timeout", "Discovery request timed out", {
			url: url$2,
			timeout
		});
		throw new DiscoveryError("discovery_unexpected_error", `Unexpected error during discovery: ${error$47 instanceof Error ? error$47.message : String(error$47)}`, { url: url$2 }, { cause: error$47 });
	}
}
/**
* Validate a discovery document.
*
* Checks:
* 1. All required fields are present
* 2. Issuer matches the configured issuer (case-sensitive, exact match)
*
* Invariant: If this function returns without throwing, the document is safe
* to use for hydrating OIDC config (required fields present, issuer matches
* configured value, basic structural sanity verified).
*
* @param doc - The discovery document to validate
* @param configuredIssuer - The expected issuer value
* @throws DiscoveryError if validation fails
*/
function validateDiscoveryDocument(doc, configuredIssuer) {
	const missingFields = [];
	for (const field of REQUIRED_DISCOVERY_FIELDS) if (!doc[field]) missingFields.push(field);
	if (missingFields.length > 0) throw new DiscoveryError("discovery_incomplete", `Discovery document is missing required fields: ${missingFields.join(", ")}`, { missingFields });
	if ((doc.issuer.endsWith("/") ? doc.issuer.slice(0, -1) : doc.issuer) !== (configuredIssuer.endsWith("/") ? configuredIssuer.slice(0, -1) : configuredIssuer)) throw new DiscoveryError("issuer_mismatch", `Discovered issuer "${doc.issuer}" does not match configured issuer "${configuredIssuer}"`, {
		discovered: doc.issuer,
		configured: configuredIssuer
	});
}
/**
* Normalize URLs in the discovery document.
*
* @param document - The discovery document
* @param issuer - The base issuer URL
* @param isTrustedOrigin - Origin verification tester function
* @returns The normalized discovery document
*/
function normalizeDiscoveryUrls(document$1, issuer, isTrustedOrigin) {
	const doc = { ...document$1 };
	doc.token_endpoint = normalizeAndValidateUrl("token_endpoint", doc.token_endpoint, issuer, isTrustedOrigin);
	doc.authorization_endpoint = normalizeAndValidateUrl("authorization_endpoint", doc.authorization_endpoint, issuer, isTrustedOrigin);
	doc.jwks_uri = normalizeAndValidateUrl("jwks_uri", doc.jwks_uri, issuer, isTrustedOrigin);
	if (doc.userinfo_endpoint) doc.userinfo_endpoint = normalizeAndValidateUrl("userinfo_endpoint", doc.userinfo_endpoint, issuer, isTrustedOrigin);
	if (doc.revocation_endpoint) doc.revocation_endpoint = normalizeAndValidateUrl("revocation_endpoint", doc.revocation_endpoint, issuer, isTrustedOrigin);
	if (doc.end_session_endpoint) doc.end_session_endpoint = normalizeAndValidateUrl("end_session_endpoint", doc.end_session_endpoint, issuer, isTrustedOrigin);
	if (doc.introspection_endpoint) doc.introspection_endpoint = normalizeAndValidateUrl("introspection_endpoint", doc.introspection_endpoint, issuer, isTrustedOrigin);
	return doc;
}
/**
* Normalizes and validates a single URL endpoint
* @param name The url name
* @param endpoint The url to validate
* @param issuer The issuer base url
* @param isTrustedOrigin - Origin verification tester function
* @returns
*/
function normalizeAndValidateUrl(name$1, endpoint, issuer, isTrustedOrigin) {
	const url$2 = normalizeUrl(name$1, endpoint, issuer);
	if (!isTrustedOrigin(url$2)) throw new DiscoveryError("discovery_untrusted_origin", `The ${name$1} "${url$2}" is not trusted by your trusted origins configuration.`, {
		endpoint: name$1,
		url: url$2
	});
	return url$2;
}
/**
* Normalize a single URL endpoint.
*
* @param name - The endpoint name (e.g token_endpoint)
* @param endpoint - The endpoint URL to normalize
* @param issuer - The base issuer URL
* @returns The normalized endpoint URL
*/
function normalizeUrl(name$1, endpoint, issuer) {
	try {
		return parseURL(name$1, endpoint).toString();
	} catch {
		const issuerURL = parseURL(name$1, issuer);
		const basePath = issuerURL.pathname.replace(/\/+$/, "");
		const endpointPath = endpoint.replace(/^\/+/, "");
		return parseURL(name$1, basePath + "/" + endpointPath, issuerURL.origin).toString();
	}
}
/**
* Parses the given URL or throws in case of invalid or unsupported protocols
*
* @param name the url name
* @param endpoint the endpoint url
* @param [base] optional base path
* @returns
*/
function parseURL(name$1, endpoint, base) {
	let endpointURL;
	try {
		endpointURL = new URL(endpoint, base);
		if (endpointURL.protocol === "http:" || endpointURL.protocol === "https:") return endpointURL;
	} catch (error$47) {
		throw new DiscoveryError("discovery_invalid_url", `The url "${name$1}" must be valid: ${endpoint}`, { url: endpoint }, { cause: error$47 });
	}
	throw new DiscoveryError("discovery_invalid_url", `The url "${name$1}" must use the http or https supported protocols: ${endpoint}`, {
		url: endpoint,
		protocol: endpointURL.protocol
	});
}
/**
* Select the token endpoint authentication method.
*
* @param doc - The discovery document
* @param existing - Existing authentication method from config
* @returns The selected authentication method
*/
function selectTokenEndpointAuthMethod(doc, existing) {
	if (existing) return existing;
	const supported = doc.token_endpoint_auth_methods_supported;
	if (!supported || supported.length === 0) return "client_secret_basic";
	if (supported.includes("client_secret_basic")) return "client_secret_basic";
	if (supported.includes("client_secret_post")) return "client_secret_post";
	return "client_secret_basic";
}
const spMetadataQuerySchema = v4_default.object({
	providerId: v4_default.string(),
	format: v4_default.enum(["xml", "json"]).default("xml")
});
const ssoProviderBodySchema = v4_default.object({
	providerId: v4_default.string({}).meta({ description: "The ID of the provider. This is used to identify the provider during login and callback" }),
	issuer: v4_default.string({}).meta({ description: "The issuer of the provider" }),
	domain: v4_default.string({}).meta({ description: "The domain(s) of the provider. For enterprise multi-domain SSO where a single IdP serves multiple email domains, use comma-separated values (e.g., 'company.com,subsidiary.com,acquired-company.com')" }),
	oidcConfig: v4_default.object({
		clientId: v4_default.string({}).meta({ description: "The client ID" }),
		clientSecret: v4_default.string({}).meta({ description: "The client secret" }),
		authorizationEndpoint: v4_default.string({}).meta({ description: "The authorization endpoint" }).optional(),
		tokenEndpoint: v4_default.string({}).meta({ description: "The token endpoint" }).optional(),
		userInfoEndpoint: v4_default.string({}).meta({ description: "The user info endpoint" }).optional(),
		tokenEndpointAuthentication: v4_default.enum(["client_secret_post", "client_secret_basic"]).optional(),
		jwksEndpoint: v4_default.string({}).meta({ description: "The JWKS endpoint" }).optional(),
		discoveryEndpoint: v4_default.string().optional(),
		skipDiscovery: v4_default.boolean().meta({ description: "Skip OIDC discovery during registration. When true, you must provide authorizationEndpoint, tokenEndpoint, and jwksEndpoint manually." }).optional(),
		scopes: v4_default.array(v4_default.string(), {}).meta({ description: "The scopes to request. Defaults to ['openid', 'email', 'profile', 'offline_access']" }).optional(),
		pkce: v4_default.boolean({}).meta({ description: "Whether to use PKCE for the authorization flow" }).default(true).optional(),
		mapping: v4_default.object({
			id: v4_default.string({}).meta({ description: "Field mapping for user ID (defaults to 'sub')" }),
			email: v4_default.string({}).meta({ description: "Field mapping for email (defaults to 'email')" }),
			emailVerified: v4_default.string({}).meta({ description: "Field mapping for email verification (defaults to 'email_verified')" }).optional(),
			name: v4_default.string({}).meta({ description: "Field mapping for name (defaults to 'name')" }),
			image: v4_default.string({}).meta({ description: "Field mapping for image (defaults to 'picture')" }).optional(),
			extraFields: v4_default.record(v4_default.string(), v4_default.any()).optional()
		}).optional()
	}).optional(),
	samlConfig: v4_default.object({
		entryPoint: v4_default.string({}).meta({ description: "The entry point of the provider" }),
		cert: v4_default.string({}).meta({ description: "The certificate of the provider" }),
		callbackUrl: v4_default.string({}).meta({ description: "The callback URL of the provider" }),
		audience: v4_default.string().optional(),
		idpMetadata: v4_default.object({
			metadata: v4_default.string().optional(),
			entityID: v4_default.string().optional(),
			cert: v4_default.string().optional(),
			privateKey: v4_default.string().optional(),
			privateKeyPass: v4_default.string().optional(),
			isAssertionEncrypted: v4_default.boolean().optional(),
			encPrivateKey: v4_default.string().optional(),
			encPrivateKeyPass: v4_default.string().optional(),
			singleSignOnService: v4_default.array(v4_default.object({
				Binding: v4_default.string().meta({ description: "The binding type for the SSO service" }),
				Location: v4_default.string().meta({ description: "The URL for the SSO service" })
			})).optional().meta({ description: "Single Sign-On service configuration" })
		}).optional(),
		spMetadata: v4_default.object({
			metadata: v4_default.string().optional(),
			entityID: v4_default.string().optional(),
			binding: v4_default.string().optional(),
			privateKey: v4_default.string().optional(),
			privateKeyPass: v4_default.string().optional(),
			isAssertionEncrypted: v4_default.boolean().optional(),
			encPrivateKey: v4_default.string().optional(),
			encPrivateKeyPass: v4_default.string().optional()
		}),
		wantAssertionsSigned: v4_default.boolean().optional(),
		signatureAlgorithm: v4_default.string().optional(),
		digestAlgorithm: v4_default.string().optional(),
		identifierFormat: v4_default.string().optional(),
		privateKey: v4_default.string().optional(),
		decryptionPvk: v4_default.string().optional(),
		additionalParams: v4_default.record(v4_default.string(), v4_default.any()).optional(),
		mapping: v4_default.object({
			id: v4_default.string({}).meta({ description: "Field mapping for user ID (defaults to 'nameID')" }),
			email: v4_default.string({}).meta({ description: "Field mapping for email (defaults to 'email')" }),
			emailVerified: v4_default.string({}).meta({ description: "Field mapping for email verification" }).optional(),
			name: v4_default.string({}).meta({ description: "Field mapping for name (defaults to 'displayName')" }),
			firstName: v4_default.string({}).meta({ description: "Field mapping for first name (defaults to 'givenName')" }).optional(),
			lastName: v4_default.string({}).meta({ description: "Field mapping for last name (defaults to 'surname')" }).optional(),
			extraFields: v4_default.record(v4_default.string(), v4_default.any()).optional()
		}).optional()
	}).optional(),
	organizationId: v4_default.string({}).meta({ description: "If organization plugin is enabled, the organization id to link the provider to" }).optional(),
	overrideUserInfo: v4_default.boolean({}).meta({ description: "Override user info with the provider info. Defaults to false" }).default(false).optional()
});
const signInSSOBodySchema = v4_default.object({
	email: v4_default.string({}).meta({ description: "The email address to sign in with. This is used to identify the issuer to sign in with. It's optional if the issuer is provided" }).optional(),
	organizationSlug: v4_default.string({}).meta({ description: "The slug of the organization to sign in with" }).optional(),
	providerId: v4_default.string({}).meta({ description: "The ID of the provider to sign in with. This can be provided instead of email or issuer" }).optional(),
	domain: v4_default.string({}).meta({ description: "The domain of the provider." }).optional(),
	callbackURL: v4_default.string({}).meta({ description: "The URL to redirect to after login" }),
	errorCallbackURL: v4_default.string({}).meta({ description: "The URL to redirect to after login" }).optional(),
	newUserCallbackURL: v4_default.string({}).meta({ description: "The URL to redirect to after login if the user is new" }).optional(),
	scopes: v4_default.array(v4_default.string(), {}).meta({ description: "Scopes to request from the provider." }).optional(),
	loginHint: v4_default.string({}).meta({ description: "Login hint to send to the identity provider (e.g., email or identifier). If supported, will be sent as 'login_hint'." }).optional(),
	requestSignUp: v4_default.boolean({}).meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider" }).optional(),
	providerType: v4_default.enum(["oidc", "saml"]).optional()
});
const callbackSSOQuerySchema = v4_default.object({
	code: v4_default.string().optional(),
	state: v4_default.string(),
	error: v4_default.string().optional(),
	error_description: v4_default.string().optional()
});
const callbackSSOSAMLBodySchema = v4_default.object({
	SAMLResponse: v4_default.string(),
	RelayState: v4_default.string().optional()
});
const acsEndpointBodySchema = v4_default.object({
	SAMLResponse: v4_default.string(),
	RelayState: v4_default.string().optional()
});
import_build.setSchemaValidator({ async validate(xml) {
	if (XMLValidator.validate(xml, { allowBooleanAttributes: true }) === true) return "SUCCESS_VALIDATE_XML";
	throw "ERR_INVALID_XML";
} });

//#endregion
//#region src/routes/sso-validation.ts
const DEPRECATED_SIGNATURE_ALGORITHMS = [SignatureAlgorithm.RSA_SHA1];
const DEPRECATED_DIGEST_ALGORITHMS = [DigestAlgorithm.SHA1];
function validateSAMLMetadataSize(metadataXml, maxSize = DEFAULT_MAX_SAML_METADATA_SIZE) {
	if (new TextEncoder().encode(metadataXml).byteLength > maxSize) throw new Error(`IdP metadata exceeds maximum allowed size (${Math.round(maxSize / 1024)}KB)`);
}
function extractAlgorithmsFromSAMLMetadata(metadataXml) {
	const signatureAlgorithms = [];
	const digestAlgorithms = [];
	const sigMethodRegex = /<(?:[\w-]+:)?SignatureMethod\s[^>]*Algorithm\s*=\s*"([^"]+)"/g;
	let match;
	while ((match = sigMethodRegex.exec(metadataXml)) !== null) if (match[1] && !signatureAlgorithms.includes(match[1])) signatureAlgorithms.push(match[1]);
	const signingMethodRegex = /<(?:[\w-]+:)?SigningMethod\s[^>]*Algorithm\s*=\s*"([^"]+)"/g;
	while ((match = signingMethodRegex.exec(metadataXml)) !== null) if (match[1] && !signatureAlgorithms.includes(match[1])) signatureAlgorithms.push(match[1]);
	const digestMethodRegex = /<(?:[\w-]+:)?DigestMethod\s[^>]*Algorithm\s*=\s*"([^"]+)"/g;
	while ((match = digestMethodRegex.exec(metadataXml)) !== null) if (match[1] && !digestAlgorithms.includes(match[1])) digestAlgorithms.push(match[1]);
	return {
		signatureAlgorithms,
		digestAlgorithms
	};
}
function validateSAMLMetadataAlgorithms(metadataXml) {
	const warnings = [];
	const { signatureAlgorithms, digestAlgorithms } = extractAlgorithmsFromSAMLMetadata(metadataXml);
	for (const alg of signatureAlgorithms) if (DEPRECATED_SIGNATURE_ALGORITHMS.includes(alg)) warnings.push(`IdP metadata contains deprecated signature algorithm: ${alg}. Consider requesting SHA-256 or stronger from your IdP.`);
	for (const alg of digestAlgorithms) if (DEPRECATED_DIGEST_ALGORITHMS.includes(alg)) warnings.push(`IdP metadata contains deprecated digest algorithm: ${alg}. Consider requesting SHA-256 or stronger from your IdP.`);
	return warnings;
}

//#endregion
//#region src/validation/ssrf.ts
/**
* SSRF (Server-Side Request Forgery) Protection
*
* Validates URLs before server-side fetches to block requests to private/reserved
* networks. Covers IPv4 private ranges, IPv6 private ranges, and IPv4-mapped IPv6
* bypass vectors.
*/
function isPrivateIPv4(a, b) {
	if (a === 10) return true;
	if (a === 172 && b >= 16 && b <= 31) return true;
	if (a === 192 && b === 168) return true;
	if (a === 127) return true;
	if (a === 169 && b === 254) return true;
	if (a === 0) return true;
	return false;
}
function parseIPv6(addr) {
	const sides = addr.split("::");
	if (sides.length > 2) return null;
	const parseGroups = (s) => s === "" ? [] : s.split(":").map((g) => parseInt(g, 16));
	const left = parseGroups(sides[0]);
	const right = sides.length === 2 ? parseGroups(sides[1]) : [];
	if (left.some(isNaN) || right.some(isNaN)) return null;
	const missing = 8 - left.length - right.length;
	if (sides.length === 2) {
		if (missing < 0) return null;
		return [
			...left,
			...Array(missing).fill(0),
			...right
		];
	}
	if (left.length !== 8) return null;
	return left;
}
function isPrivateHost(hostname$2) {
	if (hostname$2 === "localhost" || hostname$2.endsWith(".local") || hostname$2.endsWith(".internal")) return true;
	const bare = hostname$2.replace(/^\[|\]$/g, "");
	const v4parts = bare.split(".").map(Number);
	if (v4parts.length === 4 && v4parts.every((p) => !isNaN(p) && p >= 0 && p <= 255)) return isPrivateIPv4(v4parts[0], v4parts[1]);
	const groups = parseIPv6(bare);
	if (groups && groups.length === 8) {
		if (groups.slice(0, 7).every((g) => g === 0) && groups[7] === 1) return true;
		if (groups.every((g) => g === 0)) return true;
		if ((groups[0] & 65472) === 65152) return true;
		if ((groups[0] & 65024) === 64512) return true;
		if (groups[0] === 0 && groups[1] === 0 && groups[2] === 0 && groups[3] === 0 && groups[4] === 0 && groups[5] === 65535) return isPrivateIPv4(groups[6] >> 8 & 255, groups[6] & 255);
		if (groups[0] === 0 && groups[1] === 0 && groups[2] === 0 && groups[3] === 0 && groups[4] === 65535 && groups[5] === 0) return isPrivateIPv4(groups[6] >> 8 & 255, groups[6] & 255);
		if (groups[0] === 100 && groups[1] === 65435 && groups.slice(2, 6).every((g) => g === 0)) return isPrivateIPv4(groups[6] >> 8 & 255, groups[6] & 255);
		if (groups[0] === 8193 && groups[1] === 3512) return true;
		if (groups[0] === 256 && groups.slice(1, 4).every((g) => g === 0)) return true;
	}
	return false;
}
function parseAndValidateUrl(url$2) {
	try {
		const parsed = new URL(url$2);
		if (!["http:", "https:"].includes(parsed.protocol)) return null;
		if (isPrivateHost(parsed.hostname)) return null;
		return parsed;
	} catch {
		return null;
	}
}

//#endregion
//#region src/routes/plugin-session.ts
/**
* Builds an in-memory session context for calling plugin endpoints
* from the infra layer via plugin.endpoints.xxx({ context }).
*/
function buildSessionContext(userId, user) {
	const now = /* @__PURE__ */ new Date();
	return { session: {
		user: {
			id: userId,
			...user
		},
		session: {
			id: `infra-${now.getTime()}`,
			userId,
			token: `infra-temp-${now.getTime()}`,
			createdAt: now,
			updatedAt: now,
			expiresAt: new Date(now.getTime() + 6e4),
			synthetic: true
		}
	} };
}
function getSSOPlugin(ctx) {
	const plugin = ctx.context.options.plugins?.find((p) => p.id === "sso");
	if (!plugin || !("endpoints" in plugin)) return null;
	return plugin;
}

//#endregion
//#region src/routes/organizations.ts
const listOrganizations = (options) => {
	return createAuthEndpoint("/dash/list-organizations", {
		method: "GET",
		use: [jwtMiddleware(options)],
		query: zod_default.object({
			limit: zod_default.number().or(zod_default.string().transform(Number)).optional(),
			offset: zod_default.number().or(zod_default.string().transform(Number)).optional(),
			sortBy: zod_default.enum([
				"createdAt",
				"name",
				"slug",
				"members"
			]).optional(),
			sortOrder: zod_default.enum(["asc", "desc"]).optional(),
			search: zod_default.string().optional(),
			startDate: zod_default.date().or(zod_default.string().transform((val) => new Date(val))).optional(),
			endDate: zod_default.date().or(zod_default.string().transform((val) => new Date(val))).optional()
		}).optional()
	}, async (ctx) => {
		const { limit = 10, offset = 0, sortBy = "createdAt", sortOrder = "desc", search } = ctx.query || {};
		const where = [];
		if (search && search.trim().length > 0) {
			const searchTerm = search.trim();
			where.push({
				field: "name",
				value: searchTerm,
				operator: "starts_with",
				connector: "OR"
			}, {
				field: "slug",
				value: searchTerm,
				operator: "starts_with",
				connector: "OR"
			});
		}
		if (ctx.query?.startDate) where.push({
			field: "createdAt",
			value: ctx.query.startDate,
			operator: "gte"
		});
		if (ctx.query?.endDate) where.push({
			field: "createdAt",
			value: ctx.query.endDate,
			operator: "lte"
		});
		const [organizations, initialTotal] = await Promise.all([ctx.context.adapter.findMany({
			model: "organization",
			where,
			limit,
			offset,
			sortBy: {
				field: sortBy,
				direction: sortOrder
			},
			join: { member: true }
		}), ctx.context.adapter.count({
			model: "organization",
			where
		})]);
		let withCounts = organizations.map((organization) => ({
			...organization,
			memberCount: organization.member.length
		}));
		const allUserIds = /* @__PURE__ */ new Set();
		for (const organization of withCounts) for (const member of organization.member.slice(0, 5)) allUserIds.add(member.userId);
		const users = await ctx.context.adapter.findMany({
			model: "user",
			where: [{
				field: "id",
				value: Array.from(allUserIds),
				operator: "in"
			}]
		});
		const userMap = new Map(users.map((u) => [u.id, u]));
		return {
			organizations: withCounts.map((organization) => {
				const members = organization.member.slice(0, 5).map((m) => userMap.get(m.userId)).filter((u) => u !== void 0).map((u) => ({
					id: u.id,
					name: u.name,
					email: u.email,
					image: u.image
				}));
				return {
					...organization,
					members
				};
			}),
			total: initialTotal,
			offset,
			limit
		};
	});
};
const getOrganizationOptions = (options) => {
	return createAuthEndpoint("/dash/organization/options", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) return { teamsEnabled: false };
		return { teamsEnabled: organizationPlugin.options?.teams?.enabled && organizationPlugin.options.teams.defaultTeam?.enabled !== false };
	});
};
const getOrganization = (options) => {
	return createAuthEndpoint("/dash/organization/:id", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		const organization = (await ctx.context.adapter.findMany({
			model: "organization",
			where: [{
				field: "id",
				value: ctx.params.id
			}],
			limit: 1
		}))[0];
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		const membersCount = await ctx.context.adapter.count({
			model: "member",
			where: [{
				field: "organizationId",
				value: organization.id
			}]
		});
		return {
			...organization,
			memberCount: membersCount
		};
	});
};
const listOrganizationMembers = (options) => {
	return createAuthEndpoint("/dash/organization/:id/members", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		const members = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "organizationId",
				value: ctx.params.id
			}]
		});
		const userIds = members.map((m) => m.userId);
		const users = userIds.length ? await ctx.context.adapter.findMany({
			model: "user",
			where: [{
				field: "id",
				value: userIds,
				operator: "in"
			}]
		}) : [];
		const invitations = await ctx.context.adapter.findMany({
			model: "invitation",
			where: [{
				field: "organizationId",
				value: ctx.params.id
			}, {
				field: "status",
				value: "accepted"
			}]
		});
		const inviterIds = [...new Set(invitations.map((i) => i.inviterId).filter(Boolean))];
		const inviters = inviterIds.length ? await ctx.context.adapter.findMany({
			model: "user",
			where: [{
				field: "id",
				value: inviterIds,
				operator: "in"
			}]
		}) : [];
		const inviterById = new Map(inviters.map((u) => [u.id, u]));
		const userById = new Map(users.map((u) => [u.id, u]));
		const invitationByEmail = new Map(invitations.map((i) => [i.email.toLowerCase(), i]));
		return members.map((m) => {
			const user = userById.get(m.userId);
			const invitation = user ? invitationByEmail.get(user.email.toLowerCase()) : null;
			const inviter = invitation ? inviterById.get(invitation.inviterId) : null;
			return {
				...m,
				user: user ? {
					id: user.id,
					email: user.email,
					name: user.name,
					image: user.image || null
				} : null,
				invitedBy: inviter ? {
					id: inviter.id,
					name: inviter.name,
					email: inviter.email,
					image: inviter.image || null
				} : null
			};
		});
	});
};
const listOrganizationInvitations = (options) => {
	return createAuthEndpoint("/dash/organization/:id/invitations", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		const invitations = await ctx.context.adapter.findMany({
			model: "invitation",
			where: [{
				field: "organizationId",
				value: ctx.params.id
			}]
		});
		const emails = [...new Set(invitations.map((i) => i.email.toLowerCase()))];
		const users = emails.length ? await ctx.context.adapter.findMany({
			model: "user",
			where: [{
				field: "email",
				value: emails,
				operator: "in"
			}]
		}) : [];
		const userByEmail = new Map(users.map((u) => [u.email.toLowerCase(), u]));
		return invitations.map((invitation) => {
			const user = userByEmail.get(invitation.email.toLowerCase());
			return {
				...invitation,
				user: user ? {
					id: user.id,
					name: user.name,
					email: user.email,
					image: user.image || null
				} : null
			};
		});
	});
};
const deleteOrganization = (options) => {
	return createAuthEndpoint("/dash/organization/delete", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ organizationId: zod_default.string() })
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const { organizationId: bodyOrganizationId } = ctx.body;
		const orgOptions = (ctx.context.options.plugins?.find((p) => p.id === "organization"))?.options || {};
		if (organizationId !== bodyOrganizationId) throw ctx.error("BAD_REQUEST", { message: "Organization ID mismatch" });
		const owners = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "role",
				value: "owner"
			}],
			sortBy: {
				field: "createdAt",
				direction: "asc"
			},
			limit: 1
		});
		if (owners.length === 0) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		const owner = owners[0];
		const deletedByUser = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: owner.userId
			}]
		});
		if (!deletedByUser) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		if (orgOptions?.organizationHooks?.beforeDeleteOrganization) await orgOptions.organizationHooks.beforeDeleteOrganization({
			organization,
			user: deletedByUser
		});
		await ctx.context.adapter.delete({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (orgOptions?.organizationHooks?.afterDeleteOrganization) await orgOptions.organizationHooks.afterDeleteOrganization({
			organization,
			user: deletedByUser
		});
		return { success: true };
	});
};
const listOrganizationTeams = (options) => {
	return createAuthEndpoint("/dash/organization/:id/teams", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		try {
			const teams = await ctx.context.adapter.findMany({
				model: "team",
				where: [{
					field: "organizationId",
					value: ctx.params.id
				}]
			});
			return await Promise.all(teams.map(async (team) => {
				let memberCount = 0;
				try {
					memberCount = await ctx.context.adapter.count({
						model: "teamMember",
						where: [{
							field: "teamId",
							value: team.id
						}]
					});
				} catch {
					memberCount = 0;
				}
				return {
					...team,
					memberCount
				};
			}));
		} catch {
			return [];
		}
	});
};
const updateTeam = (options) => {
	return createAuthEndpoint("/dash/organization/update-team", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			teamId: zod_default.string(),
			name: zod_default.string().optional()
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin not enabled" });
		const orgOptions = organizationPlugin.options || {};
		if (!orgOptions?.teams?.enabled) throw ctx.error("BAD_REQUEST", { message: "Teams are not enabled" });
		const existingTeam = await ctx.context.adapter.findOne({
			model: "team",
			where: [{
				field: "id",
				value: ctx.body.teamId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!existingTeam) throw ctx.error("NOT_FOUND", { message: "Team not found" });
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		const owners = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "role",
				value: "owner"
			}],
			sortBy: {
				field: "createdAt",
				direction: "asc"
			},
			limit: 1
		});
		if (owners.length === 0) throw ctx.error("NOT_FOUND", { message: "Owner not found" });
		const owner = owners[0];
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: owner.userId
			}]
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		let updateData = { updatedAt: /* @__PURE__ */ new Date() };
		if (ctx.body.name) updateData.name = ctx.body.name;
		if (orgOptions?.organizationHooks?.beforeUpdateTeam) {
			const response = await orgOptions.organizationHooks.beforeUpdateTeam({
				team: existingTeam,
				updates: updateData,
				user,
				organization
			});
			if (response && typeof response === "object" && "data" in response) updateData = {
				...updateData,
				...response.data
			};
		}
		const team = await ctx.context.adapter.update({
			model: "team",
			where: [{
				field: "id",
				value: ctx.body.teamId
			}],
			update: updateData
		});
		if (orgOptions?.organizationHooks?.afterUpdateTeam) await orgOptions.organizationHooks.afterUpdateTeam({
			team,
			user,
			organization
		});
		return team;
	});
};
const deleteTeam = (options) => {
	return createAuthEndpoint("/dash/organization/delete-team", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ teamId: zod_default.string() })
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin not enabled" });
		const orgOptions = organizationPlugin.options || {};
		if (!orgOptions?.teams?.enabled) throw ctx.error("BAD_REQUEST", { message: "Teams are not enabled" });
		const team = await ctx.context.adapter.findOne({
			model: "team",
			where: [{
				field: "id",
				value: ctx.body.teamId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!team) throw ctx.error("NOT_FOUND", { message: "Team not found" });
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		if (orgOptions?.teams?.allowRemovingAllTeams === false) {
			if (await ctx.context.adapter.count({
				model: "team",
				where: [{
					field: "organizationId",
					value: organizationId
				}]
			}) <= 1) throw ctx.error("BAD_REQUEST", { message: "Cannot remove the last team in the organization" });
		}
		const owners = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "role",
				value: "owner"
			}],
			sortBy: {
				field: "createdAt",
				direction: "asc"
			},
			limit: 1
		});
		if (owners.length === 0) throw ctx.error("NOT_FOUND", { message: "Owner not found" });
		const owner = owners[0];
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: owner.userId
			}]
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		if (orgOptions?.organizationHooks?.beforeDeleteTeam) await orgOptions.organizationHooks.beforeDeleteTeam({
			team,
			user,
			organization
		});
		await ctx.context.adapter.delete({
			model: "team",
			where: [{
				field: "id",
				value: ctx.body.teamId
			}]
		});
		if (orgOptions?.organizationHooks?.afterDeleteTeam) await orgOptions.organizationHooks.afterDeleteTeam({
			team,
			user,
			organization
		});
		return { success: true };
	});
};
const createTeam = (options) => {
	return createAuthEndpoint("/dash/organization/create-team", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ name: zod_default.string() })
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin not enabled" });
		const orgOptions = organizationPlugin.options || {};
		if (!orgOptions?.teams?.enabled) throw ctx.error("BAD_REQUEST", { message: "Teams are not enabled" });
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		if (orgOptions?.teams?.maximumTeams) {
			const teamsCount = await ctx.context.adapter.count({
				model: "team",
				where: [{
					field: "organizationId",
					value: organizationId
				}]
			});
			const maxTeams = typeof orgOptions.teams.maximumTeams === "function" ? await orgOptions.teams.maximumTeams({ organizationId }) : orgOptions.teams.maximumTeams;
			if (teamsCount >= maxTeams) throw ctx.error("BAD_REQUEST", { message: `Maximum number of teams (${maxTeams}) reached for this organization` });
		}
		const owners = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "role",
				value: "owner"
			}],
			sortBy: {
				field: "createdAt",
				direction: "asc"
			},
			limit: 1
		});
		if (owners.length === 0) throw ctx.error("NOT_FOUND", { message: "Owner not found" });
		const owner = owners[0];
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: owner.userId
			}]
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		let teamData = {
			name: ctx.body.name,
			organizationId,
			createdAt: /* @__PURE__ */ new Date()
		};
		if (orgOptions?.organizationHooks?.beforeCreateTeam) {
			const response = await orgOptions.organizationHooks.beforeCreateTeam({
				team: teamData,
				user,
				organization
			});
			if (response && typeof response === "object" && "data" in response) teamData = {
				...teamData,
				...response.data
			};
		}
		const team = await ctx.context.adapter.create({
			model: "team",
			data: teamData
		});
		if (orgOptions?.organizationHooks?.afterCreateTeam) await orgOptions.organizationHooks.afterCreateTeam({
			team,
			user,
			organization
		});
		return team;
	});
};
const listTeamMembers = (options) => {
	return createAuthEndpoint("/dash/organization/:orgId/teams/:teamId/members", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		try {
			if (!await ctx.context.adapter.findOne({
				model: "team",
				where: [{
					field: "id",
					value: ctx.params.teamId
				}, {
					field: "organizationId",
					value: ctx.params.orgId
				}]
			})) throw ctx.error("NOT_FOUND", { message: "Team not found" });
			const teamMembers = await ctx.context.adapter.findMany({
				model: "teamMember",
				where: [{
					field: "teamId",
					value: ctx.params.teamId
				}]
			});
			return await Promise.all(teamMembers.map(async (tm) => {
				const user = await ctx.context.adapter.findOne({
					model: "user",
					where: [{
						field: "id",
						value: tm.userId
					}]
				});
				return {
					...tm,
					user: user ? {
						id: user.id,
						name: user.name,
						email: user.email,
						image: user.image
					} : null
				};
			}));
		} catch (e) {
			return [];
		}
	});
};
const addTeamMember = (options) => {
	return createAuthEndpoint("/dash/organization/add-team-member", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			teamId: zod_default.string(),
			userId: zod_default.string()
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin not enabled" });
		const orgOptions = organizationPlugin.options || {};
		if (!orgOptions?.teams?.enabled) throw ctx.error("BAD_REQUEST", { message: "Teams are not enabled" });
		const team = await ctx.context.adapter.findOne({
			model: "team",
			where: [{
				field: "id",
				value: ctx.body.teamId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!team) throw ctx.error("NOT_FOUND", { message: "Team not found" });
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: ctx.body.userId
			}]
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		if (!await ctx.context.adapter.findOne({
			model: "member",
			where: [{
				field: "userId",
				value: ctx.body.userId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		})) throw ctx.error("BAD_REQUEST", { message: "User is not a member of this organization" });
		if (await ctx.context.adapter.findOne({
			model: "teamMember",
			where: [{
				field: "teamId",
				value: ctx.body.teamId
			}, {
				field: "userId",
				value: ctx.body.userId
			}]
		})) throw ctx.error("BAD_REQUEST", { message: "User is already a member of this team" });
		if (orgOptions?.teams?.maximumMembersPerTeam) {
			const teamMemberCount = await ctx.context.adapter.count({
				model: "teamMember",
				where: [{
					field: "teamId",
					value: ctx.body.teamId
				}]
			});
			const maxMembers = typeof orgOptions.teams.maximumMembersPerTeam === "function" ? await orgOptions.teams.maximumMembersPerTeam({
				teamId: ctx.body.teamId,
				organizationId
			}) : orgOptions.teams.maximumMembersPerTeam;
			if (teamMemberCount >= maxMembers) throw ctx.error("BAD_REQUEST", { message: `Maximum number of team members (${maxMembers}) reached for this team` });
		}
		let teamMemberData = {
			teamId: ctx.body.teamId,
			userId: ctx.body.userId,
			createdAt: /* @__PURE__ */ new Date()
		};
		if (orgOptions?.organizationHooks?.beforeAddTeamMember) {
			const response = await orgOptions.organizationHooks.beforeAddTeamMember({
				teamMember: teamMemberData,
				team,
				user,
				organization
			});
			if (response && typeof response === "object" && "data" in response) teamMemberData = {
				...teamMemberData,
				...response.data
			};
		}
		const teamMember = await ctx.context.adapter.create({
			model: "teamMember",
			data: teamMemberData
		});
		if (orgOptions?.organizationHooks?.afterAddTeamMember) await orgOptions.organizationHooks.afterAddTeamMember({
			teamMember,
			team,
			user,
			organization
		});
		return teamMember;
	});
};
const removeTeamMember = (options) => {
	return createAuthEndpoint("/dash/organization/remove-team-member", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			teamId: zod_default.string(),
			userId: zod_default.string()
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin not enabled" });
		const orgOptions = organizationPlugin.options || {};
		if (!orgOptions?.teams?.enabled) throw ctx.error("BAD_REQUEST", { message: "Teams are not enabled" });
		const team = await ctx.context.adapter.findOne({
			model: "team",
			where: [{
				field: "id",
				value: ctx.body.teamId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!team) throw ctx.error("NOT_FOUND", { message: "Team not found" });
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: ctx.body.userId
			}]
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		const teamMember = await ctx.context.adapter.findOne({
			model: "teamMember",
			where: [{
				field: "teamId",
				value: ctx.body.teamId
			}, {
				field: "userId",
				value: ctx.body.userId
			}]
		});
		if (!teamMember) throw ctx.error("NOT_FOUND", { message: "User is not a member of this team" });
		if (orgOptions?.organizationHooks?.beforeRemoveTeamMember) await orgOptions.organizationHooks.beforeRemoveTeamMember({
			teamMember,
			team,
			user,
			organization
		});
		await ctx.context.adapter.delete({
			model: "teamMember",
			where: [{
				field: "teamId",
				value: ctx.body.teamId
			}, {
				field: "userId",
				value: ctx.body.userId
			}]
		});
		if (orgOptions?.organizationHooks?.afterRemoveTeamMember) await orgOptions.organizationHooks.afterRemoveTeamMember({
			teamMember,
			team,
			user,
			organization
		});
		return { success: true };
	});
};
const createOrganization = (options) => {
	return createAuthEndpoint("/dash/organization/create", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({
			userId: zod_default.string(),
			skipDefaultTeam: zod_default.boolean().optional().default(false)
		}))],
		body: zod_default.object({
			name: zod_default.string(),
			slug: zod_default.string(),
			logo: zod_default.string().optional(),
			defaultTeamName: zod_default.string().optional()
		}).passthrough()
	}, async (ctx) => {
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin not enabled" });
		const { userId } = ctx.context.payload;
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: userId
			}]
		});
		if (!user) throw ctx.error("BAD_REQUEST", { message: "User not found" });
		const orgOptions = organizationPlugin.options || {};
		if (await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "slug",
				value: ctx.body.slug
			}]
		})) throw ctx.error("BAD_REQUEST", { message: "Organization already exists" });
		let orgData = {
			...ctx.body,
			defaultTeamName: void 0
		};
		if (orgOptions.organizationCreation?.beforeCreate) {
			const response = await orgOptions.organizationCreation.beforeCreate({
				organization: {
					...orgData,
					createdAt: /* @__PURE__ */ new Date()
				},
				user
			}, ctx.request);
			if (response && typeof response === "object" && "data" in response) orgData = {
				...orgData,
				...response.data
			};
		}
		if (orgOptions?.organizationHooks?.beforeCreateOrganization) {
			const response = await orgOptions?.organizationHooks.beforeCreateOrganization({
				organization: orgData,
				user
			});
			if (response && typeof response === "object" && "data" in response) orgData = {
				...orgData,
				...response.data
			};
		}
		const organization = await ctx.context.adapter.create({
			model: "organization",
			data: {
				...orgData,
				createdAt: /* @__PURE__ */ new Date()
			}
		});
		let member;
		let data = {
			userId: user.id,
			organizationId: organization.id,
			role: orgOptions.creatorRole || "owner"
		};
		if (orgOptions?.organizationHooks?.beforeAddMember) {
			const response = await orgOptions?.organizationHooks.beforeAddMember({
				member: {
					userId: user.id,
					organizationId: organization.id,
					role: orgOptions.creatorRole || "owner",
					createdAt: /* @__PURE__ */ new Date(),
					updatedAt: /* @__PURE__ */ new Date()
				},
				user,
				organization
			});
			if (response && typeof response === "object" && "data" in response) data = {
				...data,
				...response.data
			};
		}
		member = await ctx.context.adapter.create({
			model: "member",
			data: {
				userId: data.userId,
				organizationId: data.organizationId,
				role: data.role,
				createdAt: /* @__PURE__ */ new Date()
			}
		});
		if (orgOptions?.organizationHooks?.afterAddMember) await orgOptions?.organizationHooks.afterAddMember({
			member,
			user,
			organization
		});
		if (orgOptions?.teams?.enabled && orgOptions.teams.defaultTeam?.enabled !== false && !ctx.context.payload.skipDefaultTeam) {
			let teamData = {
				organizationId: organization.id,
				name: ctx.body.defaultTeamName || `${organization.name}`,
				createdAt: /* @__PURE__ */ new Date()
			};
			if (orgOptions?.organizationHooks?.beforeCreateTeam) {
				const response = await orgOptions?.organizationHooks.beforeCreateTeam({
					team: {
						organizationId: organization.id,
						name: teamData.name
					},
					user,
					organization
				});
				if (response && typeof response === "object" && "data" in response) teamData = {
					...teamData,
					...response.data
				};
			}
			const defaultTeam = await orgOptions.teams.defaultTeam?.customCreateDefaultTeam?.(organization, ctx) || await ctx.context.adapter.create({
				model: "team",
				data: teamData
			});
			if (!await ctx.context.adapter.findOne({
				model: "teamMember",
				where: [{
					field: "teamId",
					value: defaultTeam.id
				}, {
					field: "userId",
					value: user.id
				}]
			})) await ctx.context.adapter.create({
				model: "teamMember",
				data: {
					teamId: defaultTeam.id,
					userId: user.id,
					role: "owner"
				}
			});
			if (orgOptions?.organizationHooks?.afterCreateTeam) await orgOptions?.organizationHooks.afterCreateTeam({
				team: defaultTeam,
				user,
				organization
			});
		}
		if (orgOptions.organizationCreation?.afterCreate) await orgOptions.organizationCreation.afterCreate({
			organization,
			user,
			member
		}, ctx.request);
		if (orgOptions?.organizationHooks?.afterCreateOrganization) await orgOptions?.organizationHooks.afterCreateOrganization({
			organization,
			user,
			member
		});
		return {
			...organization,
			members: [member]
		};
	});
};
const updateOrganization = (options) => {
	return createAuthEndpoint("/dash/organization/update", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			logo: zod_default.string().url().optional(),
			name: zod_default.string().optional(),
			slug: zod_default.string().optional(),
			metadata: zod_default.string().optional()
		}).passthrough()
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const orgOptions = (ctx.context.options.plugins?.find((p) => p.id === "organization"))?.options || {};
		if (ctx.body.slug) {
			const existingOrg = await ctx.context.adapter.findOne({
				model: "organization",
				where: [{
					field: "slug",
					value: ctx.body.slug
				}]
			});
			if (existingOrg && existingOrg.id !== organizationId) throw ctx.error("BAD_REQUEST", { message: "Slug already exists" });
		}
		const owners = await ctx.context.adapter.findMany({
			model: "member",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "role",
				value: "owner"
			}],
			sortBy: {
				field: "createdAt",
				direction: "asc"
			},
			limit: 1
		});
		if (owners.length === 0) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		const owner = owners[0];
		const updatedByUser = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: owner.userId
			}]
		});
		if (!updatedByUser) throw ctx.error("NOT_FOUND", { message: "Owner user not found" });
		let updateData = { ...ctx.body };
		if (orgOptions?.organizationHooks?.beforeUpdateOrganization) {
			const response = await orgOptions.organizationHooks.beforeUpdateOrganization({
				organization: updateData,
				user: updatedByUser
			});
			if (response && typeof response === "object" && "data" in response) updateData = {
				...updateData,
				...response.data
			};
		}
		const organization = await ctx.context.adapter.update({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}],
			update: updateData
		});
		if (orgOptions?.organizationHooks?.afterUpdateOrganization) await orgOptions.organizationHooks.afterUpdateOrganization({
			organization,
			user: updatedByUser
		});
		return organization;
	});
};
const addMember = (options) => {
	return createAuthEndpoint("/dash/organization/add-member", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			userId: zod_default.string(),
			role: zod_default.string()
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const orgOptions = (ctx.context.options.plugins?.find((p) => p.id === "organization"))?.options || {};
		const organization = await ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		});
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: ctx.body.userId
			}]
		});
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		let memberData = {
			organizationId,
			userId: ctx.body.userId,
			role: ctx.body.role,
			createdAt: /* @__PURE__ */ new Date()
		};
		if (orgOptions?.organizationHooks?.beforeAddMember) {
			const response = await orgOptions.organizationHooks.beforeAddMember({
				member: memberData,
				user,
				organization
			});
			if (response && typeof response === "object" && "data" in response) memberData = {
				...memberData,
				...response.data
			};
		}
		const member = await ctx.context.adapter.create({
			model: "member",
			data: memberData
		});
		if (orgOptions?.organizationHooks?.afterAddMember) await orgOptions.organizationHooks.afterAddMember({
			member,
			user,
			organization
		});
		return member;
	});
};
const removeMember = (options) => {
	return createAuthEndpoint("/dash/organization/remove-member", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ memberId: zod_default.string() })
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const orgOptions = (ctx.context.options.plugins?.find((p) => p.id === "organization"))?.options || {};
		const member = await ctx.context.adapter.findOne({
			model: "member",
			where: [{
				field: "id",
				value: ctx.body.memberId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!member) throw ctx.error("NOT_FOUND", { message: "Member not found" });
		const [user, organization] = await Promise.all([ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: member.userId
			}]
		}), ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		})]);
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		if (orgOptions?.organizationHooks?.beforeRemoveMember) await orgOptions.organizationHooks.beforeRemoveMember({
			member,
			user,
			organization
		});
		if (orgOptions?.teams?.enabled) {
			const teamsInOrg = await ctx.context.adapter.findMany({
				model: "team",
				where: [{
					field: "organizationId",
					value: organizationId
				}]
			});
			if (teamsInOrg.length > 0) {
				const teamIds = teamsInOrg.map((t) => t.id);
				await ctx.context.adapter.deleteMany({
					model: "teamMember",
					where: [{
						field: "userId",
						value: member.userId
					}, {
						field: "teamId",
						value: teamIds,
						operator: "in"
					}]
				});
			}
		}
		await ctx.context.adapter.delete({
			model: "member",
			where: [{
				field: "id",
				value: ctx.body.memberId
			}]
		});
		if (orgOptions?.organizationHooks?.afterRemoveMember) await orgOptions.organizationHooks.afterRemoveMember({
			member,
			user,
			organization
		});
		return { success: true };
	});
};
const updateMemberRole = (options) => {
	return createAuthEndpoint("/dash/organization/update-member-role", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			memberId: zod_default.string(),
			role: zod_default.string()
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const orgOptions = (ctx.context.options.plugins?.find((p) => p.id === "organization"))?.options || {};
		const existingMember = await ctx.context.adapter.findOne({
			model: "member",
			where: [{
				field: "id",
				value: ctx.body.memberId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!existingMember) throw ctx.error("NOT_FOUND", { message: "Member not found" });
		const [user, organization] = await Promise.all([ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: existingMember.userId
			}]
		}), ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		})]);
		if (!user) throw ctx.error("NOT_FOUND", { message: "User not found" });
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		const previousRole = existingMember.role;
		let newRole = ctx.body.role;
		if (orgOptions?.organizationHooks?.beforeUpdateMemberRole) {
			const response = await orgOptions.organizationHooks.beforeUpdateMemberRole({
				member: existingMember,
				user,
				organization,
				role: newRole
			});
			if (response && typeof response === "object" && "data" in response) newRole = response.data.role || newRole;
		}
		const member = await ctx.context.adapter.update({
			model: "member",
			where: [{
				field: "id",
				value: ctx.body.memberId
			}],
			update: { role: newRole }
		});
		if (orgOptions?.organizationHooks?.afterUpdateMemberRole) await orgOptions.organizationHooks.afterUpdateMemberRole({
			member,
			user,
			organization,
			previousRole
		});
		return member;
	});
};
const inviteMember = (options) => {
	return createAuthEndpoint("/dash/organization/invite-member", {
		method: "POST",
		body: zod_default.object({
			email: zod_default.string(),
			role: zod_default.string(),
			invitedBy: zod_default.string()
		}),
		use: [jwtMiddleware(options, zod_default.object({
			organizationId: zod_default.string(),
			invitedBy: zod_default.string()
		}))]
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin.options?.sendInvitationEmail) throw ctx.error("BAD_REQUEST", { message: "Invitation email is not enabled" });
		const invitedBy = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: ctx.context.payload.invitedBy
			}]
		});
		if (!invitedBy) throw ctx.error("BAD_REQUEST", { message: "Invited by user not found" });
		return await organizationPlugin.endpoints.createInvitation({
			headers: ctx.request?.headers,
			body: {
				email: ctx.body.email,
				role: ctx.body.role,
				organizationId
			},
			context: {
				...ctx.context,
				session: {
					user: invitedBy,
					session: { userId: ctx.context.payload.invitedBy }
				},
				orgOptions: organizationPlugin.options
			}
		});
	});
};
const checkUserByEmail = (options) => {
	return createAuthEndpoint("/dash/organization/check-user-by-email", {
		method: "POST",
		body: zod_default.object({ email: zod_default.string() }),
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))]
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const user = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "email",
				value: ctx.body.email
			}]
		});
		if (!user) return {
			exists: false,
			user: null,
			isAlreadyMember: false
		};
		const existingMember = await ctx.context.adapter.findOne({
			model: "member",
			where: [{
				field: "userId",
				value: user.id
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		return {
			exists: true,
			user: {
				id: user.id,
				name: user.name,
				email: user.email,
				image: user.image
			},
			isAlreadyMember: !!existingMember
		};
	});
};
const cancelInvitation = (options) => {
	return createAuthEndpoint("/dash/organization/cancel-invitation", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({
			organizationId: zod_default.string(),
			invitationId: zod_default.string()
		}))],
		body: zod_default.object({ invitationId: zod_default.string() })
	}, async (ctx) => {
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin is not enabled" });
		const orgOptions = organizationPlugin.options || {};
		const { invitationId, organizationId } = ctx.context.payload;
		const invitation = await ctx.context.adapter.findOne({
			model: "invitation",
			where: [{
				field: "id",
				value: invitationId
			}]
		});
		if (!invitation) throw ctx.error("NOT_FOUND", { message: "Invitation not found" });
		const [user, organization] = await Promise.all([ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: invitation.inviterId
			}]
		}), ctx.context.adapter.findOne({
			model: "organization",
			where: [{
				field: "id",
				value: organizationId
			}]
		})]);
		if (!user) throw ctx.error("NOT_FOUND", { message: "Inviter user not found" });
		if (!organization) throw ctx.error("NOT_FOUND", { message: "Organization not found" });
		if (orgOptions?.organizationHooks?.beforeCancelInvitation) await orgOptions.organizationHooks.beforeCancelInvitation({
			invitation,
			organization,
			cancelledBy: user
		});
		await ctx.context.adapter.update({
			model: "invitation",
			where: [{
				field: "id",
				value: invitationId
			}],
			update: { status: "canceled" }
		});
		if (orgOptions?.organizationHooks?.afterCancelInvitation) await orgOptions.organizationHooks.afterCancelInvitation({
			invitation: {
				...invitation,
				status: "canceled"
			},
			organization,
			cancelledBy: user
		});
		return { success: true };
	});
};
const samlConfigSchema = zod_default.object({
	idpMetadata: zod_default.object({
		metadata: zod_default.string().optional(),
		metadataUrl: zod_default.string().optional()
	}).optional(),
	entryPoint: zod_default.string().optional(),
	cert: zod_default.string().optional(),
	entityId: zod_default.string().optional(),
	mapping: zod_default.object({
		id: zod_default.string().optional(),
		email: zod_default.string().optional(),
		emailVerified: zod_default.string().optional(),
		name: zod_default.string().optional(),
		firstName: zod_default.string().optional(),
		lastName: zod_default.string().optional(),
		extraFields: zod_default.record(zod_default.string(), zod_default.any()).optional()
	}).optional()
});
const oidcConfigSchema = zod_default.object({
	clientId: zod_default.string(),
	clientSecret: zod_default.string().optional(),
	discoveryUrl: zod_default.string().optional(),
	issuer: zod_default.string().optional(),
	mapping: zod_default.object({
		id: zod_default.string().optional(),
		email: zod_default.string().optional(),
		emailVerified: zod_default.string().optional(),
		name: zod_default.string().optional(),
		image: zod_default.string().optional(),
		extraFields: zod_default.record(zod_default.string(), zod_default.any()).optional()
	}).optional()
});
async function resolveSAMLConfig(samlConfig, providerId, baseURL, ctx) {
	let idpMetadataXml = samlConfig.idpMetadata?.metadata;
	if (!idpMetadataXml && samlConfig.idpMetadata?.metadataUrl) {
		const validatedMetadataUrl = parseAndValidateUrl(samlConfig.idpMetadata.metadataUrl);
		if (!validatedMetadataUrl) throw ctx.error("BAD_REQUEST", { message: "Invalid or blocked IdP metadata URL" });
		try {
			const metadataResponse = await fetch(validatedMetadataUrl.toString());
			if (!metadataResponse.ok) throw ctx.error("BAD_REQUEST", { message: `Failed to fetch IdP metadata from URL: ${metadataResponse.status} ${metadataResponse.statusText}` });
			idpMetadataXml = await metadataResponse.text();
		} catch (e) {
			ctx.context.logger.error("Failed to fetch IdP metadata from URL", { error: e });
			throw ctx.error("BAD_REQUEST", { message: "Failed to fetch IdP metadata from URL" });
		}
	}
	const metadataAlgorithmWarnings = [];
	if (idpMetadataXml) {
		try {
			validateSAMLMetadataSize(idpMetadataXml);
		} catch (e) {
			throw ctx.error("BAD_REQUEST", { message: e instanceof Error ? e.message : "IdP metadata exceeds maximum allowed size" });
		}
		const warnings = validateSAMLMetadataAlgorithms(idpMetadataXml);
		if (warnings.length > 0) {
			metadataAlgorithmWarnings.push(...warnings);
			ctx.context.logger.warn("SAML IdP metadata uses deprecated algorithms", {
				providerId,
				warnings
			});
		}
	}
	const idpMetadata = idpMetadataXml ? { metadata: idpMetadataXml } : {
		...samlConfig.entryPoint ? { singleSignOnService: [{
			Binding: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect",
			Location: samlConfig.entryPoint
		}] } : {},
		...samlConfig.cert ? { cert: samlConfig.cert } : {}
	};
	return {
		config: {
			issuer: samlConfig.entityId ?? `${baseURL}/sso/saml2/sp/metadata?providerId=${providerId}`,
			callbackUrl: `${baseURL}/sso/saml2/sp/acs/${providerId}`,
			idpMetadata,
			spMetadata: {},
			...samlConfig.entryPoint ? { entryPoint: samlConfig.entryPoint } : {},
			...samlConfig.cert ? { cert: samlConfig.cert } : {},
			...samlConfig.mapping ? { mapping: samlConfig.mapping } : {}
		},
		...metadataAlgorithmWarnings.length > 0 ? { warnings: metadataAlgorithmWarnings } : {}
	};
}
async function resolveOIDCConfig(oidcConfig, domain$1, ctx) {
	let normalizedDomain = domain$1;
	try {
		if (domain$1.startsWith("http://") || domain$1.startsWith("https://")) normalizedDomain = new URL(domain$1).hostname;
	} catch {
		normalizedDomain = domain$1;
	}
	const issuerHint = oidcConfig.issuer || `https://${normalizedDomain}`;
	const issuer = issuerHint.startsWith("http") ? issuerHint : `https://${issuerHint}`;
	try {
		const hydratedConfig = await discoverOIDCConfig({
			issuer,
			discoveryEndpoint: oidcConfig.discoveryUrl,
			isTrustedOrigin: (url$2) => {
				try {
					const issuerOrigin = new URL(issuer).origin;
					return new URL(url$2).origin === issuerOrigin;
				} catch {
					return false;
				}
			}
		});
		return {
			config: {
				clientId: oidcConfig.clientId,
				clientSecret: oidcConfig.clientSecret,
				issuer: hydratedConfig.issuer,
				discoveryEndpoint: hydratedConfig.discoveryEndpoint,
				authorizationEndpoint: hydratedConfig.authorizationEndpoint,
				tokenEndpoint: hydratedConfig.tokenEndpoint,
				jwksEndpoint: hydratedConfig.jwksEndpoint,
				userInfoEndpoint: hydratedConfig.userInfoEndpoint,
				tokenEndpointAuthentication: hydratedConfig.tokenEndpointAuthentication,
				pkce: true,
				...oidcConfig.mapping ? { mapping: oidcConfig.mapping } : {}
			},
			issuer: hydratedConfig.issuer
		};
	} catch (e) {
		if (e instanceof DiscoveryError) {
			ctx.context.logger.error("OIDC discovery failed", {
				code: e.code,
				message: e.message,
				details: e.details
			});
			throw ctx.error("BAD_REQUEST", {
				message: `OIDC discovery failed: ${e.message}`,
				code: e.code
			});
		}
		ctx.context.logger.error("OIDC discovery failed", {
			issuer,
			error: e
		});
		throw ctx.error("BAD_REQUEST", {
			message: `OIDC discovery failed: Unable to discover configuration from ${issuer}`,
			code: "OIDC_DISCOVERY_FAILED"
		});
	}
}
function requireOrganizationAccess(ctx) {
	const orgIdFromUrl = ctx.params.id;
	const orgIdFromToken = ctx.context.payload?.organizationId;
	if (!orgIdFromToken || orgIdFromUrl !== orgIdFromToken) throw ctx.error("FORBIDDEN", { message: "You do not have access to this organization" });
}
const listOrganizationSsoProviders = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-providers", {
		method: "GET",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))]
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		if (!ctx.context.options.plugins?.find((p) => p.id === "sso")) return [];
		try {
			return await ctx.context.adapter.findMany({
				model: "ssoProvider",
				where: [{
					field: "organizationId",
					value: ctx.params.id
				}]
			});
		} catch {
			return [];
		}
	});
};
const createSsoProvider = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-provider/create", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			providerId: zod_default.string(),
			domain: zod_default.string(),
			protocol: zod_default.enum(["SAML", "OIDC"]),
			userId: zod_default.string(),
			samlConfig: samlConfigSchema.optional(),
			oidcConfig: oidcConfigSchema.optional()
		})
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		const ssoPlugin = getSSOPlugin(ctx);
		if (!ssoPlugin) throw ctx.error("BAD_REQUEST", { message: "SSO plugin is not enabled" });
		const organizationId = ctx.params.id;
		const { providerId, domain: domain$1, protocol, samlConfig, oidcConfig, userId } = ctx.body;
		const registerBody = {
			providerId,
			domain: domain$1,
			issuer: domain$1,
			organizationId
		};
		if (protocol === "SAML" && samlConfig) {
			const samlResult = await resolveSAMLConfig(samlConfig, providerId, ctx.context.baseURL, ctx);
			registerBody.issuer = samlResult.config.issuer ?? (samlConfig.entityId || `${ctx.context.baseURL}/sso/saml2/sp/metadata?providerId=${providerId}`);
			registerBody.samlConfig = samlResult.config;
		}
		if (protocol === "OIDC" && oidcConfig) {
			if (!oidcConfig.clientSecret) throw ctx.error("BAD_REQUEST", { message: "Client secret is required when creating an OIDC provider" });
			const result = await resolveOIDCConfig(oidcConfig, domain$1, ctx);
			registerBody.issuer = result.issuer;
			registerBody.oidcConfig = result.config;
		}
		try {
			const result = await ssoPlugin.endpoints.registerSSOProvider({
				body: registerBody,
				context: {
					...ctx.context,
					...buildSessionContext(userId)
				}
			});
			return {
				success: true,
				provider: {
					id: result.id,
					providerId: result.providerId || providerId,
					domain: result.domain || domain$1
				},
				domainVerification: {
					txtRecordName: `better-auth-token-${providerId}`,
					verificationToken: result.domainVerificationToken || null
				}
			};
		} catch (e) {
			if (e instanceof APIError$1) throw e;
			throw ctx.error("BAD_REQUEST", { message: e instanceof Error ? e.message : "Failed to create SSO provider" });
		}
	});
};
const updateSsoProvider = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-provider/update", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			providerId: zod_default.string(),
			domain: zod_default.string(),
			protocol: zod_default.enum(["SAML", "OIDC"]),
			samlConfig: samlConfigSchema.optional(),
			oidcConfig: oidcConfigSchema.optional()
		})
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		const ssoPlugin = getSSOPlugin(ctx);
		if (!ssoPlugin) throw ctx.error("BAD_REQUEST", { message: "SSO plugin is not enabled" });
		const organizationId = ctx.params.id;
		const { providerId, domain: domain$1, protocol, samlConfig, oidcConfig } = ctx.body;
		const existingProvider = await ctx.context.adapter.findOne({
			model: "ssoProvider",
			where: [{
				field: "providerId",
				value: providerId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!existingProvider) throw ctx.error("NOT_FOUND", { message: "SSO provider not found" });
		const updateBody = { providerId };
		if (domain$1 && domain$1 !== existingProvider.domain) updateBody.domain = domain$1;
		if (protocol === "SAML" && samlConfig) {
			const samlResult = await resolveSAMLConfig(samlConfig, providerId, ctx.context.baseURL, ctx);
			updateBody.issuer = samlResult.config.issuer ?? (samlConfig.entityId || `${ctx.context.baseURL}/sso/saml2/sp/metadata?providerId=${providerId}`);
			updateBody.samlConfig = samlResult.config;
		}
		if (protocol === "OIDC" && oidcConfig) {
			let effectiveOidcConfig = oidcConfig;
			if (!oidcConfig.clientSecret) {
				if (!existingProvider.oidcConfig) throw ctx.error("BAD_REQUEST", { message: "Client secret is required when updating an OIDC provider" });
				let existingOidc;
				try {
					existingOidc = JSON.parse(existingProvider.oidcConfig);
				} catch {
					throw ctx.error("BAD_REQUEST", { message: "Client secret is required. Existing provider configuration is invalid." });
				}
				if (existingOidc.clientSecret) effectiveOidcConfig = {
					...oidcConfig,
					clientSecret: existingOidc.clientSecret
				};
				else throw ctx.error("BAD_REQUEST", { message: "Client secret is required. Existing provider has no client secret stored." });
			}
			const result = await resolveOIDCConfig(effectiveOidcConfig, domain$1, ctx);
			updateBody.issuer = result.issuer;
			updateBody.oidcConfig = result.config;
		}
		const providerUserId = existingProvider.userId;
		if (!providerUserId) throw ctx.error("BAD_REQUEST", { message: "SSO provider has no associated user. Cannot update via session." });
		try {
			const result = await ssoPlugin.endpoints.updateSSOProvider({
				body: updateBody,
				context: {
					...ctx.context,
					...buildSessionContext(providerUserId)
				}
			});
			return {
				success: true,
				provider: {
					id: result.id || existingProvider.id,
					providerId: result.providerId || existingProvider.providerId,
					domain: result.domain || domain$1
				}
			};
		} catch (e) {
			if (e instanceof APIError$1) throw e;
			throw ctx.error("BAD_REQUEST", { message: e instanceof Error ? e.message : "Failed to update SSO provider" });
		}
	});
};
const requestSsoVerificationToken = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-provider/request-verification-token", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ providerId: zod_default.string() })
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		const ssoPlugin = getSSOPlugin(ctx);
		if (!ssoPlugin || !ssoPlugin.options?.domainVerification?.enabled) throw ctx.error("BAD_REQUEST", { message: "SSO plugin with domain verification is not enabled" });
		const organizationId = ctx.params.id;
		const { providerId } = ctx.body;
		const provider = await ctx.context.adapter.findOne({
			model: "ssoProvider",
			where: [{
				field: "providerId",
				value: providerId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!provider) throw ctx.error("NOT_FOUND", { message: "SSO provider not found" });
		const txtRecordName = `${ssoPlugin.options?.domainVerification?.tokenPrefix || "better-auth-token"}-${provider.providerId}`;
		try {
			const result = await ssoPlugin.endpoints.requestDomainVerification({
				body: { providerId },
				context: {
					...ctx.context,
					...buildSessionContext(provider.userId)
				}
			});
			return {
				success: true,
				providerId: provider.providerId,
				domain: provider.domain,
				verificationToken: result.domainVerificationToken,
				txtRecordName
			};
		} catch (e) {
			if (e instanceof APIError$1) throw e;
			throw ctx.error("BAD_REQUEST", { message: e instanceof Error ? e.message : "Failed to request verification token" });
		}
	});
};
const verifySsoProviderDomain = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-provider/verify-domain", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ providerId: zod_default.string() })
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		const ssoPlugin = getSSOPlugin(ctx);
		if (!ssoPlugin || !ssoPlugin.options?.domainVerification?.enabled) throw ctx.error("BAD_REQUEST", { message: "SSO plugin with domain verification is not enabled" });
		const organizationId = ctx.params.id;
		const { providerId } = ctx.body;
		const provider = await ctx.context.adapter.findOne({
			model: "ssoProvider",
			where: [{
				field: "providerId",
				value: providerId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!provider) throw ctx.error("NOT_FOUND", { message: "SSO provider not found" });
		try {
			await ssoPlugin.endpoints.verifyDomain({
				body: { providerId },
				context: {
					...ctx.context,
					...buildSessionContext(provider.userId)
				}
			});
			return {
				verified: true,
				message: "Domain ownership verified successfully"
			};
		} catch (e) {
			if (e instanceof APIError$1) {
				if (e.status === "CONFLICT") return {
					verified: true,
					message: "Domain has already been verified"
				};
				if (e.status === "BAD_GATEWAY") return {
					verified: false,
					message: "Unable to verify domain ownership. The TXT record was not found. It may take up to 48 hours for DNS changes to propagate."
				};
				throw e;
			}
			throw ctx.error("BAD_REQUEST", { message: e instanceof Error ? e.message : "Failed to verify domain" });
		}
	});
};
const deleteSsoProvider = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-provider/delete", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ providerId: zod_default.string() })
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		const ssoPlugin = getSSOPlugin(ctx);
		if (!ssoPlugin) throw ctx.error("BAD_REQUEST", { message: "SSO plugin is not enabled" });
		const organizationId = ctx.params.id;
		const { providerId } = ctx.body;
		const provider = await ctx.context.adapter.findOne({
			model: "ssoProvider",
			where: [{
				field: "providerId",
				value: providerId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!provider) throw ctx.error("NOT_FOUND", { message: "SSO provider not found" });
		try {
			await ssoPlugin.endpoints.deleteSSOProvider({
				params: { providerId },
				body: { providerId },
				context: {
					...ctx.context,
					...buildSessionContext(provider.userId)
				}
			});
			return {
				success: true,
				message: "SSO provider deleted successfully"
			};
		} catch (e) {
			if (e instanceof APIError$1) throw e;
			throw ctx.error("BAD_REQUEST", { message: e instanceof Error ? e.message : "Failed to delete SSO provider" });
		}
	});
};
const markSsoProviderDomainVerified = (options) => {
	return createAuthEndpoint("/dash/organization/:id/sso-provider/mark-domain-verified", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			providerId: zod_default.string(),
			verified: zod_default.boolean()
		})
	}, async (ctx) => {
		requireOrganizationAccess(ctx);
		const organizationId = ctx.params.id;
		const { providerId, verified } = ctx.body;
		const provider = await ctx.context.adapter.findOne({
			model: "ssoProvider",
			where: [{
				field: "providerId",
				value: providerId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!provider) throw ctx.error("NOT_FOUND", { message: "SSO provider not found" });
		await ctx.context.adapter.update({
			model: "ssoProvider",
			where: [{
				field: "providerId",
				value: provider.providerId
			}],
			update: { domainVerified: verified }
		});
		return {
			success: true,
			domainVerified: verified,
			message: verified ? "Domain marked as verified" : "Domain verification unmarked"
		};
	});
};
const resendInvitation = (options) => {
	return createAuthEndpoint("/dash/organization/resend-invitation", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({
			organizationId: zod_default.string(),
			invitationId: zod_default.string()
		}))],
		body: zod_default.object({ invitationId: zod_default.string() })
	}, async (ctx) => {
		const organizationPlugin = ctx.context.options.plugins?.find((p) => p.id === "organization");
		if (!organizationPlugin) throw ctx.error("BAD_REQUEST", { message: "Organization plugin is not enabled" });
		const { invitationId, organizationId } = ctx.context.payload;
		const invitation = await ctx.context.adapter.findOne({
			model: "invitation",
			where: [{
				field: "id",
				value: invitationId
			}]
		});
		if (!invitation) throw ctx.error("NOT_FOUND", { message: "Invitation not found" });
		if (invitation.status !== "pending") throw ctx.error("BAD_REQUEST", { message: "Only pending invitations can be resent" });
		const invitedByUser = await ctx.context.adapter.findOne({
			model: "user",
			where: [{
				field: "id",
				value: invitation.inviterId
			}]
		});
		if (!invitedByUser) throw ctx.error("BAD_REQUEST", { message: "Inviter user not found" });
		if (!organizationPlugin.endpoints?.createInvitation) throw ctx.error("INTERNAL_SERVER_ERROR", { message: "Organization plugin endpoints not available" });
		await organizationPlugin.endpoints.createInvitation({
			headers: ctx.request?.headers,
			body: {
				email: invitation.email,
				role: invitation.role,
				organizationId,
				resend: true
			},
			context: {
				...ctx.context,
				session: {
					user: invitedByUser,
					session: { userId: invitation.inviterId }
				},
				orgOptions: organizationPlugin.options
			}
		});
		return { success: true };
	});
};

//#endregion
//#region src/routes/org-log-drains.ts
const datadogConfigSchema = zod_default.object({
	apiKey: zod_default.string().min(1, "API key is required"),
	site: zod_default.string().optional().default("datadoghq.com"),
	service: zod_default.string().optional(),
	source: zod_default.string().optional(),
	tags: zod_default.array(zod_default.string()).optional()
});
const splunkConfigSchema = zod_default.object({
	hecEndpoint: zod_default.string().url("Invalid HEC endpoint URL"),
	hecToken: zod_default.string().min(1, "HEC token is required"),
	index: zod_default.string().optional(),
	source: zod_default.string().optional(),
	sourcetype: zod_default.string().optional()
});
const webhookConfigSchema = zod_default.object({
	url: zod_default.string().url("Invalid webhook URL"),
	headers: zod_default.record(zod_default.string(), zod_default.string()).optional(),
	method: zod_default.enum(["POST", "PUT"]).optional().default("POST")
});
function maskSensitiveConfig(config$1, destinationType) {
	switch (destinationType) {
		case "datadog": {
			const apiKey = config$1.apiKey;
			return {
				...config$1,
				apiKey: apiKey ? `****${apiKey.slice(-4)}` : ""
			};
		}
		case "splunk": {
			const hecToken = config$1.hecToken;
			return {
				...config$1,
				hecToken: hecToken ? `****${hecToken.slice(-4)}` : ""
			};
		}
		case "webhook": {
			const headers = config$1.headers;
			if (headers?.Authorization) return {
				...config$1,
				headers: {
					...headers,
					Authorization: "****"
				}
			};
			return config$1;
		}
	}
}
const listOrganizationLogDrains = (options) => {
	return createAuthEndpoint("/dash/organization/:id/log-drains", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		try {
			return (await ctx.context.adapter.findMany({
				model: "orgLogDrain",
				where: [{
					field: "organizationId",
					value: ctx.params.id
				}]
			})).map((drain) => ({
				...drain,
				config: maskSensitiveConfig(drain.config, drain.destinationType)
			}));
		} catch {
			return [];
		}
	});
};
const createOrganizationLogDrain = (options) => {
	return createAuthEndpoint("/dash/organization/log-drain/create", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			name: zod_default.string().min(1, "Name is required"),
			destinationType: zod_default.enum([
				"datadog",
				"splunk",
				"webhook"
			]),
			eventTypes: zod_default.array(zod_default.enum([
				"auth",
				"security",
				"email",
				"all"
			])),
			config: zod_default.record(zod_default.string(), zod_default.unknown()),
			enabled: zod_default.boolean().optional().default(true)
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		let validatedConfig;
		switch (ctx.body.destinationType) {
			case "datadog":
				validatedConfig = datadogConfigSchema.parse(ctx.body.config);
				break;
			case "splunk":
				validatedConfig = splunkConfigSchema.parse(ctx.body.config);
				break;
			case "webhook":
				validatedConfig = webhookConfigSchema.parse(ctx.body.config);
				break;
		}
		const logDrain = await ctx.context.adapter.create({
			model: "orgLogDrain",
			data: {
				organizationId,
				name: ctx.body.name,
				enabled: ctx.body.enabled,
				destinationType: ctx.body.destinationType,
				eventTypes: ctx.body.eventTypes,
				config: validatedConfig,
				createdAt: /* @__PURE__ */ new Date(),
				updatedAt: /* @__PURE__ */ new Date()
			}
		});
		return {
			...logDrain,
			config: maskSensitiveConfig(logDrain.config, logDrain.destinationType)
		};
	});
};
const updateOrganizationLogDrain = (options) => {
	return createAuthEndpoint("/dash/organization/log-drain/update", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			logDrainId: zod_default.string(),
			name: zod_default.string().min(1).optional(),
			destinationType: zod_default.enum([
				"datadog",
				"splunk",
				"webhook"
			]).optional(),
			eventTypes: zod_default.array(zod_default.enum([
				"auth",
				"security",
				"email",
				"all"
			])).optional(),
			config: zod_default.record(zod_default.string(), zod_default.unknown()).optional(),
			enabled: zod_default.boolean().optional()
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		const existingDrain = await ctx.context.adapter.findOne({
			model: "orgLogDrain",
			where: [{
				field: "id",
				value: ctx.body.logDrainId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		});
		if (!existingDrain) throw ctx.error("NOT_FOUND", { message: "Log drain not found" });
		const updateData = { updatedAt: /* @__PURE__ */ new Date() };
		if (ctx.body.name !== void 0) updateData.name = ctx.body.name;
		if (ctx.body.enabled !== void 0) updateData.enabled = ctx.body.enabled;
		if (ctx.body.eventTypes !== void 0) updateData.eventTypes = ctx.body.eventTypes;
		const destinationType = ctx.body.destinationType || existingDrain.destinationType;
		if (ctx.body.destinationType !== void 0) updateData.destinationType = ctx.body.destinationType;
		if (ctx.body.config !== void 0) {
			let validatedConfig;
			switch (destinationType) {
				case "datadog":
					validatedConfig = datadogConfigSchema.parse(ctx.body.config);
					break;
				case "splunk":
					validatedConfig = splunkConfigSchema.parse(ctx.body.config);
					break;
				case "webhook":
					validatedConfig = webhookConfigSchema.parse(ctx.body.config);
					break;
			}
			updateData.config = validatedConfig;
		}
		const logDrain = await ctx.context.adapter.update({
			model: "orgLogDrain",
			where: [{
				field: "id",
				value: ctx.body.logDrainId
			}],
			update: updateData
		});
		if (!logDrain) throw ctx.error("NOT_FOUND", { message: "Log drain not found" });
		return {
			...logDrain,
			config: maskSensitiveConfig(logDrain.config, logDrain.destinationType)
		};
	});
};
const deleteOrganizationLogDrain = (options) => {
	return createAuthEndpoint("/dash/organization/log-drain/delete", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ logDrainId: zod_default.string() })
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		if (!await ctx.context.adapter.findOne({
			model: "orgLogDrain",
			where: [{
				field: "id",
				value: ctx.body.logDrainId
			}, {
				field: "organizationId",
				value: organizationId
			}]
		})) throw ctx.error("NOT_FOUND", { message: "Log drain not found" });
		await ctx.context.adapter.delete({
			model: "orgLogDrain",
			where: [{
				field: "id",
				value: ctx.body.logDrainId
			}]
		});
		return { success: true };
	});
};
const testOrganizationLogDrain = (options) => {
	return createAuthEndpoint("/dash/organization/log-drain/test", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			destinationType: zod_default.enum([
				"datadog",
				"splunk",
				"webhook"
			]),
			config: zod_default.record(zod_default.string(), zod_default.unknown())
		})
	}, async (ctx) => {
		const { destinationType, config: config$1 } = ctx.body;
		let validatedConfig;
		switch (destinationType) {
			case "datadog":
				validatedConfig = datadogConfigSchema.parse(config$1);
				break;
			case "splunk":
				validatedConfig = splunkConfigSchema.parse(config$1);
				break;
			case "webhook":
				validatedConfig = webhookConfigSchema.parse(config$1);
				break;
		}
		const testEvent = {
			id: crypto.randomUUID(),
			timestamp: (/* @__PURE__ */ new Date()).toISOString(),
			eventType: "test.connection",
			eventCategory: "auth",
			actor: { type: "system" },
			context: { organizationId: ctx.context.payload.organizationId },
			metadata: { message: "Test event from Better Auth Dashboard" }
		};
		try {
			switch (destinationType) {
				case "datadog": {
					const ddConfig = validatedConfig;
					const url$2 = `https://http-intake.logs.${ddConfig.site || "datadoghq.com"}/api/v2/logs`;
					const response = await fetch(url$2, {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
							"DD-API-KEY": ddConfig.apiKey
						},
						body: JSON.stringify([{
							ddsource: ddConfig.source || "better-auth",
							ddtags: [
								`organization:${ctx.context.payload.organizationId}`,
								`event_type:test.connection`,
								...ddConfig.tags || []
							].join(","),
							hostname: "better-auth",
							service: ddConfig.service || "authentication",
							message: "Test connection from Better Auth Dashboard",
							...testEvent
						}])
					});
					if (!response.ok) {
						const text = await response.text();
						throw new Error(`Datadog API error: ${response.status} - ${text}`);
					}
					break;
				}
				case "splunk": {
					const splunkConfig = validatedConfig;
					const response = await fetch(splunkConfig.hecEndpoint, {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
							Authorization: `Splunk ${splunkConfig.hecToken}`
						},
						body: JSON.stringify({
							time: Math.floor(Date.now() / 1e3),
							host: "better-auth",
							source: splunkConfig.source || "better-auth",
							sourcetype: splunkConfig.sourcetype || "better-auth:events",
							index: splunkConfig.index || "main",
							event: testEvent
						})
					});
					if (!response.ok) {
						const text = await response.text();
						throw new Error(`Splunk HEC error: ${response.status} - ${text}`);
					}
					break;
				}
				case "webhook": {
					const webhookConfig = validatedConfig;
					const response = await fetch(webhookConfig.url, {
						method: webhookConfig.method || "POST",
						headers: {
							"Content-Type": "application/json",
							...webhookConfig.headers
						},
						body: JSON.stringify(testEvent)
					});
					if (!response.ok) {
						const text = await response.text();
						throw new Error(`Webhook error: ${response.status} - ${text}`);
					}
					break;
				}
			}
			return { success: true };
		} catch (error$47) {
			return {
				success: false,
				error: error$47 instanceof Error ? error$47.message : "Unknown error"
			};
		}
	});
};

//#endregion
//#region src/routes/directory-sync/index.ts
function getScimEndpoint(baseUrl) {
	return `${baseUrl}/scim/v2`;
}
function generateScimToken() {
	const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	let result = "";
	const array$1 = new Uint8Array(48);
	crypto.getRandomValues(array$1);
	for (let i = 0; i < array$1.length; i++) result += chars[array$1[i] % 62];
	return result;
}
function getSCIMPlugin(ctx) {
	return ctx.context.options.plugins?.find((p) => p.id === "scim");
}
const listOrganizationDirectories = (options) => {
	return createAuthEndpoint("/dash/organization/:id/directories", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		if (!getSCIMPlugin(ctx)) return [];
		const organizationId = ctx.params.id;
		try {
			return (await ctx.context.adapter.findMany({
				model: "scimProvider",
				where: [{
					field: "organizationId",
					value: organizationId
				}]
			})).map((provider) => ({
				organizationId: provider.organizationId ?? organizationId,
				providerId: provider.providerId,
				scimEndpoint: getScimEndpoint(ctx.context.baseURL)
			}));
		} catch {
			return [];
		}
	});
};
const createOrganizationDirectory = (options) => {
	return createAuthEndpoint("/dash/organization/directory/create", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({
			providerId: zod_default.string().min(1, "Provider ID is required"),
			ownerUserId: zod_default.string().min(1, "Owner user ID is required")
		})
	}, async (ctx) => {
		const { organizationId } = ctx.context.payload;
		if (!getSCIMPlugin(ctx)) throw ctx.error("BAD_REQUEST", { message: "SCIM plugin is not enabled" });
		const { providerId } = ctx.body;
		const scimToken = generateScimToken();
		await ctx.context.adapter.create({
			model: "scimProvider",
			data: {
				providerId,
				scimToken,
				organizationId
			}
		});
		return {
			organizationId,
			providerId,
			scimEndpoint: getScimEndpoint(ctx.context.baseURL),
			scimToken
		};
	});
};
const deleteOrganizationDirectory = (options) => {
	return createAuthEndpoint("/dash/organization/directory/delete", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ providerId: zod_default.string().min(1, "Provider ID is required") })
	}, async (ctx) => {
		if (!getSCIMPlugin(ctx)) throw ctx.error("BAD_REQUEST", { message: "SCIM plugin is not enabled" });
		const { organizationId } = ctx.context.payload;
		const { providerId } = ctx.body;
		if (!await ctx.context.adapter.findOne({
			model: "scimProvider",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "providerId",
				value: providerId
			}]
		})) throw ctx.error("NOT_FOUND", { message: "Directory sync connection not found" });
		await ctx.context.adapter.delete({
			model: "scimProvider",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "providerId",
				value: providerId
			}]
		});
		return { success: true };
	});
};
const regenerateDirectoryToken = (options) => {
	return createAuthEndpoint("/dash/organization/directory/regenerate-token", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ organizationId: zod_default.string() }))],
		body: zod_default.object({ providerId: zod_default.string().min(1, "Provider ID is required") })
	}, async (ctx) => {
		if (!getSCIMPlugin(ctx)) throw ctx.error("BAD_REQUEST", { message: "SCIM plugin is not enabled" });
		const { organizationId } = ctx.context.payload;
		const { providerId } = ctx.body;
		const provider = await ctx.context.adapter.findOne({
			model: "scimProvider",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "providerId",
				value: providerId
			}]
		});
		if (!provider) throw ctx.error("NOT_FOUND", { message: "Directory sync connection not found" });
		const scimToken = generateScimToken();
		await ctx.context.adapter.update({
			model: "scimProvider",
			where: [{
				field: "id",
				value: provider.id
			}],
			update: { scimToken }
		});
		return {
			success: true,
			scimToken,
			scimEndpoint: getScimEndpoint(ctx.context.baseURL)
		};
	});
};
const getDirectoryDetails = (options) => {
	return createAuthEndpoint("/dash/organization/:orgId/directory", {
		method: "GET",
		use: [jwtMiddleware(options)],
		query: zod_default.object({ providerId: zod_default.string() })
	}, async (ctx) => {
		if (!getSCIMPlugin(ctx)) throw ctx.error("BAD_REQUEST", { message: "SCIM plugin is not enabled" });
		const organizationId = ctx.params.orgId;
		const { providerId } = ctx.query;
		const provider = await ctx.context.adapter.findOne({
			model: "scimProvider",
			where: [{
				field: "organizationId",
				value: organizationId
			}, {
				field: "providerId",
				value: providerId
			}]
		});
		if (!provider) throw ctx.error("NOT_FOUND", { message: "Directory sync connection not found" });
		return {
			organizationId: provider.organizationId ?? organizationId,
			providerId: provider.providerId,
			scimEndpoint: getScimEndpoint(ctx.context.baseURL)
		};
	});
};

//#endregion
//#region src/routes/sessions.ts
const deleteSessions = (options) => {
	return createAuthEndpoint("/dash/delete-sessions", {
		method: "POST",
		use: [jwtMiddleware(options, zod_default.object({ userId: zod_default.string() }))]
	}, async (ctx) => {
		await ctx.context.internalAdapter.deleteSessions(ctx.context.payload.userId);
		return ctx.json({ message: "Sessions deleted" });
	});
};
const listAllSessions = (options) => {
	return createAuthEndpoint("/dash/list-all-sessions", {
		method: "GET",
		use: [jwtMiddleware(options)],
		query: zod_default.object({
			limit: zod_default.number().optional(),
			offset: zod_default.number().optional()
		}).optional()
	}, async (ctx) => {
		const sessionsCount = await ctx.context.adapter.count({ model: "session" });
		const sessions = await ctx.context.adapter.findMany({
			model: "session",
			limit: ctx.query?.limit || sessionsCount,
			offset: ctx.query?.offset || 0,
			sortBy: {
				field: "createdAt",
				direction: "desc"
			}
		});
		return (await ctx.context.adapter.findMany({
			model: "user",
			where: [{
				field: "id",
				value: sessions.map((s) => s.userId),
				operator: "in"
			}]
		})).map((u) => {
			return {
				...u,
				sessions: sessions.filter((s) => s.userId === u.id)
			};
		});
	});
};
const revokeSession = (options) => createAuthEndpoint("/dash/sessions/revoke", {
	method: "POST",
	use: [jwtMiddleware(options)],
	metadata: { allowedMediaTypes: ["application/json", ""] }
}, async (ctx) => {
	const { sessionId, userId } = ctx.context.payload;
	if (!sessionId || !userId) throw ctx.error("FORBIDDEN", { message: "Invalid payload" });
	const session = await ctx.context.adapter.findOne({
		model: "session",
		where: [{
			field: "id",
			value: sessionId
		}, {
			field: "userId",
			value: userId
		}]
	});
	if (!session) throw ctx.error("NOT_FOUND", { message: "Session not found" });
	await ctx.context.internalAdapter.deleteSession(session.token);
	return ctx.json({ success: true });
});
const revokeAllSessions = (options) => createAuthEndpoint("/dash/sessions/revoke-all", {
	method: "POST",
	use: [jwtMiddleware(options)],
	body: zod_default.object({ userId: zod_default.string() })
}, async (ctx) => {
	const { userId } = ctx.body;
	if (!await ctx.context.internalAdapter.findUserById(userId)) throw ctx.error("NOT_FOUND", { message: "User not found" });
	await ctx.context.internalAdapter.deleteSessions(userId);
	return ctx.json({ success: true });
});

//#endregion
//#region src/routes/events.ts
/**
* All available event types that can be returned in audit logs
*/
const USER_EVENT_TYPES = {
	...EVENT_TYPES,
	...ORGANIZATION_EVENT_TYPES
};
function transformEvent(raw) {
	const location = raw.ipAddress || raw.city || raw.country || raw.countryCode ? {
		ipAddress: raw.ipAddress,
		city: raw.city,
		country: raw.country,
		countryCode: raw.countryCode
	} : void 0;
	return {
		eventType: raw.eventType,
		eventData: raw.eventData,
		eventKey: raw.eventKey,
		projectId: raw.projectId,
		createdAt: new Date(raw.createdAt),
		updatedAt: new Date(raw.updatedAt),
		ageInMinutes: raw.ageInMinutes,
		location
	};
}
/**
* Get the current user's audit log events.
*
* This endpoint is designed for end-users to view their own activity history,
* such as sign-ins, password changes, and other account events.
*
* @example
* ```ts
* // Using the Better Auth client
* const { data, error } = await authClient.events.list({
*   query: { limit: 20, offset: 0 }
* });
*
* if (data) {
*   for (const event of data.events) {
*     console.log(`${event.eventType} at ${event.createdAt}`);
*   }
* }
* ```
*/
const getUserEvents = (options) => {
	const $fetch = createFetch({
		baseURL: options.apiUrl,
		headers: { "x-api-key": options.apiKey }
	});
	return createAuthEndpoint("/events/list", {
		method: "GET",
		use: [sessionMiddleware],
		query: zod_default.object({
			limit: zod_default.number().or(zod_default.string().transform(Number)).optional(),
			offset: zod_default.number().or(zod_default.string().transform(Number)).optional(),
			eventType: zod_default.string().optional()
		}).optional()
	}, async (ctx) => {
		const session = ctx.context.session;
		if (!session?.user?.id) throw ctx.error("UNAUTHORIZED", { message: "You must be signed in to view your events" });
		if (!options.apiKey) throw ctx.error("INTERNAL_SERVER_ERROR", { message: "Events API is not configured" });
		const requestedLimit = ctx.query?.limit ?? 50;
		const limit = Math.min(Math.max(1, requestedLimit), 100);
		const offset = Math.max(0, ctx.query?.offset ?? 0);
		const { data, error: error$47 } = await $fetch("/events/user", {
			method: "GET",
			query: {
				userId: session.user.id,
				limit: limit.toString(),
				offset: offset.toString()
			}
		});
		if (error$47 || !data) throw ctx.error("INTERNAL_SERVER_ERROR", { message: "Failed to fetch events" });
		let events = data.events.map(transformEvent);
		if (ctx.query?.eventType) events = events.filter((event) => event.eventType === ctx.query?.eventType);
		return {
			events,
			total: data.total,
			limit: data.limit,
			offset: data.offset
		};
	});
};
/**
* Get the list of available event types.
*
* This endpoint returns all the event types that can appear in the audit log,
* useful for building filters or documentation.
*/
const getEventTypes = (options) => {
	return createAuthEndpoint("/events/types", {
		method: "GET",
		use: [sessionMiddleware]
	}, async (ctx) => {
		if (!options.apiKey) throw ctx.error("INTERNAL_SERVER_ERROR", { message: "Events API is not configured" });
		return {
			user: EVENT_TYPES,
			organization: ORGANIZATION_EVENT_TYPES,
			all: USER_EVENT_TYPES
		};
	});
};

//#endregion
//#region src/routes/execute-adapter.ts
const whereClause = object({
	field: string$1(),
	value: unknown(),
	operator: _enum([
		"eq",
		"ne",
		"gt",
		"gte",
		"lt",
		"lte",
		"in",
		"contains",
		"starts_with",
		"ends_with"
	]).optional(),
	connector: _enum(["AND", "OR"]).optional()
});
const sortBySchema = object({
	field: string$1(),
	direction: _enum(["asc", "desc"])
});
const actionSchema = discriminatedUnion("action", [
	object({
		action: literal("findOne"),
		model: string$1(),
		where: array(whereClause).optional(),
		select: array(string$1()).optional(),
		join: record(string$1(), boolean$1()).optional()
	}),
	object({
		action: literal("findMany"),
		model: string$1(),
		where: array(whereClause).optional(),
		limit: number$1().optional(),
		offset: number$1().optional(),
		sortBy: sortBySchema.optional(),
		join: record(string$1(), boolean$1()).optional()
	}),
	object({
		action: literal("create"),
		model: string$1(),
		data: record(string$1(), unknown())
	}),
	object({
		action: literal("update"),
		model: string$1(),
		where: array(whereClause),
		update: record(string$1(), unknown())
	}),
	object({
		action: literal("count"),
		model: string$1(),
		where: array(whereClause).optional()
	})
]);
const executeAdapter = (options) => {
	return createAuthEndpoint("/dash/execute-adapter", {
		method: "POST",
		use: [jwtMiddleware(options)],
		body: actionSchema
	}, async (ctx) => {
		const adapter = ctx.context.adapter;
		const body = ctx.body;
		switch (body.action) {
			case "findOne": return { result: await adapter.findOne({
				model: body.model,
				where: body.where,
				select: body.select,
				join: body.join
			}) };
			case "findMany": return { result: await adapter.findMany({
				model: body.model,
				where: body.where,
				limit: body.limit,
				offset: body.offset,
				sortBy: body.sortBy,
				join: body.join
			}) };
			case "create": return { result: await adapter.create({
				model: body.model,
				data: body.data
			}) };
			case "update": return { result: await adapter.update({
				model: body.model,
				where: body.where,
				update: body.update
			}) };
			case "count": return { count: await adapter.count({
				model: body.model,
				where: body.where
			}) };
		}
	});
};

//#endregion
//#region src/routes/invitations.ts
/**
* Accept invitation endpoint
* This is called when a user clicks the invitation link.
* It creates the user in the auth database and sets up a session.
*/
const acceptInvitation = (options) => {
	const $api = createFetch({
		baseURL: options.apiUrl || INFRA_API_URL,
		headers: { "x-api-key": options.apiKey }
	});
	return createAuthEndpoint("/dash/accept-invitation", {
		method: "GET",
		query: zod_default.object({ token: zod_default.string() })
	}, async (ctx) => {
		const { token } = ctx.query;
		const { data: invitation, error: error$47 } = await $api("/api/internal/invitations/verify", {
			method: "POST",
			body: { token }
		});
		if (error$47 || !invitation) throw new APIError("BAD_REQUEST", { message: "Invalid or expired invitation." });
		if (invitation.status !== "pending") throw new APIError("BAD_REQUEST", { message: `This invitation has already been ${invitation.status}.` });
		if (invitation.expiresAt) {
			if (new Date(invitation.expiresAt) < /* @__PURE__ */ new Date()) {
				await $api("/api/internal/invitations/mark-expired", {
					method: "POST",
					body: { token }
				});
				throw new APIError("BAD_REQUEST", { message: "This invitation has expired." });
			}
		}
		const existingUser = await ctx.context.internalAdapter.findUserByEmail(invitation.email).then((user$1) => user$1?.user);
		if (existingUser) {
			await $api("/api/internal/invitations/mark-accepted", {
				method: "POST",
				body: {
					token,
					userId: existingUser.id
				}
			});
			await setSessionCookie(ctx, {
				session: await ctx.context.internalAdapter.createSession(existingUser.id),
				user: existingUser
			});
			const redirectUrl$1 = invitation.redirectUrl || ctx.context.options.baseURL || "/";
			return ctx.redirect(redirectUrl$1);
		}
		if (invitation.authMode === "auth") {
			const platformUrl = options.apiUrl || INFRA_API_URL;
			const acceptPageUrl = new URL("/invite/accept", platformUrl);
			acceptPageUrl.searchParams.set("token", token);
			const callbackUrl = `${ctx.context.options.baseURL}${ctx.context.options.basePath || "/api/auth"}/dash/complete-invitation`;
			acceptPageUrl.searchParams.set("callback", callbackUrl);
			return ctx.redirect(acceptPageUrl.toString());
		}
		const user = await ctx.context.internalAdapter.createUser({
			email: invitation.email,
			name: invitation.name || invitation.email.split("@")[0] || "",
			emailVerified: true,
			createdAt: /* @__PURE__ */ new Date(),
			updatedAt: /* @__PURE__ */ new Date()
		});
		await $api("/api/internal/invitations/mark-accepted", {
			method: "POST",
			body: {
				token,
				userId: user.id
			}
		});
		await setSessionCookie(ctx, {
			session: await ctx.context.internalAdapter.createSession(user.id),
			user
		});
		const redirectUrl = invitation.redirectUrl || ctx.context.options.baseURL || "/";
		return ctx.redirect(redirectUrl);
	});
};
/**
* Complete invitation endpoint
* Called by the platform after user completes authentication (password/social)
* This creates the user in the auth database and sets up a session
*/
const completeInvitation = (options) => {
	const $api = createFetch({
		baseURL: options.apiUrl || INFRA_API_URL,
		headers: { "x-api-key": options.apiKey }
	});
	return createAuthEndpoint("/dash/complete-invitation", {
		method: "POST",
		body: zod_default.object({
			token: zod_default.string(),
			password: zod_default.string().optional(),
			providerId: zod_default.string().optional(),
			providerAccountId: zod_default.string().optional(),
			accessToken: zod_default.string().optional(),
			refreshToken: zod_default.string().optional()
		})
	}, async (ctx) => {
		const { token, password, providerId, providerAccountId, accessToken, refreshToken } = ctx.body;
		const { data: invitation, error: error$47 } = await $api("/api/internal/invitations/verify", {
			method: "POST",
			body: { token }
		});
		if (error$47 || !invitation) throw new APIError("BAD_REQUEST", { message: "Invalid or expired invitation." });
		if (invitation.status !== "pending") throw new APIError("BAD_REQUEST", { message: `This invitation has already been ${invitation.status}.` });
		if (!ctx.context) throw new APIError("BAD_REQUEST", { message: "Context is required" });
		const existingUser = await ctx.context.internalAdapter.findUserByEmail(invitation.email).then((user$1) => user$1?.user);
		if (existingUser) {
			await $api("/api/internal/invitations/mark-accepted", {
				method: "POST",
				body: {
					token,
					userId: existingUser.id
				}
			});
			await setSessionCookie(ctx, {
				session: await ctx.context.internalAdapter.createSession(existingUser.id),
				user: existingUser
			});
			return {
				success: true,
				redirectUrl: invitation.redirectUrl || ctx.context.options.baseURL || "/"
			};
		}
		const user = await ctx.context.internalAdapter.createUser({
			email: invitation.email,
			name: invitation.name || invitation.email.split("@")[0] || "",
			emailVerified: true,
			createdAt: /* @__PURE__ */ new Date(),
			updatedAt: /* @__PURE__ */ new Date()
		});
		if (password) await ctx.context.internalAdapter.createAccount({
			userId: user.id,
			providerId: "credential",
			accountId: user.id,
			password: await ctx.context.password.hash(password)
		});
		else if (providerId && providerAccountId) await ctx.context.internalAdapter.createAccount({
			userId: user.id,
			providerId,
			accountId: providerAccountId,
			accessToken,
			refreshToken
		});
		await $api("/api/internal/invitations/mark-accepted", {
			method: "POST",
			body: {
				token,
				userId: user.id
			}
		});
		await setSessionCookie(ctx, {
			session: await ctx.context.internalAdapter.createSession(user.id),
			user
		});
		return {
			success: true,
			redirectUrl: invitation.redirectUrl || ctx.context.options.baseURL || "/"
		};
	});
};
/**
* Check if a user exists by email
* Used by the platform to verify before sending invitation
* This is different from /dash/organization/check-user-by-email which also checks membership
*/
const checkUserExists = (options) => {
	return createAuthEndpoint("/dash/check-user-exists", {
		method: "POST",
		body: zod_default.object({ email: zod_default.string().email() })
	}, async (ctx) => {
		const { email: email$2 } = ctx.body;
		if (!ctx.request?.headers.get("Authorization")) throw new APIError("UNAUTHORIZED", { message: "Authorization required" });
		const existingUser = await ctx.context.internalAdapter.findUserByEmail(email$2.toLowerCase()).then((user) => user?.user);
		return {
			exists: !!existingUser,
			userId: existingUser?.id || null
		};
	});
};

//#endregion
//#region src/validation/matchers.ts
const paths = [
	"/sign-up/email",
	"/email-otp/verify-email",
	"/sign-in/email-otp",
	"/sign-in/magic-link",
	"/forget-password/email-otp",
	"/email-otp/reset-password",
	"/email-otp/create-verification-otp",
	"/email-otp/get-verification-otp",
	"/email-otp/send-verification-otp",
	"/forget-password",
	"/send-verification-email",
	"/change-email"
];
const all = new Set(paths);
const signIn = new Set(paths.slice(1, 12));
/**
* Path is one of `[
*   '/sign-up/email',
*   '/email-otp/verify-email',
*   '/sign-in/email-otp',
*   '/sign-in/magic-link',
*   '/sign-in/email',
*   '/forget-password/email-otp',
*   '/email-otp/reset-password',
*   '/email-otp/create-verification-otp',
*   '/email-otp/get-verification-otp',
*   '/email-otp/send-verification-otp',
*   '/forget-password',
*   '/send-verification-email',
*   '/change-email'
* ]`.
* @param context Request context
* @param context.path Request path
* @returns boolean
*/
const allEmail = ({ path }) => !!path && all.has(path);
/**
* Path is one of `[
*   '/email-otp/verify-email',
*   '/sign-in/email-otp',
*   '/sign-in/magic-link',
*   '/sign-in/email',
*   '/forget-password/email-otp',
*   '/email-otp/reset-password',
*   '/email-otp/create-verification-otp',
*   '/email-otp/get-verification-otp',
*   '/email-otp/send-verification-otp',
*   '/forget-password',
*   '/send-verification-email'
* ]`.
* @param context Request context
* @param context.path Request path
* @returns boolean
*/
const allEmailSignIn = ({ path }) => !!path && signIn.has(path);

//#endregion
//#region src/validation/email.ts
/**
* Gmail-like providers that ignore dots in the local part
*/
const GMAIL_LIKE_DOMAINS = new Set(["gmail.com", "googlemail.com"]);
/**
* Providers known to support plus addressing
*/
const PLUS_ADDRESSING_DOMAINS = new Set([
	"gmail.com",
	"googlemail.com",
	"outlook.com",
	"hotmail.com",
	"live.com",
	"yahoo.com",
	"icloud.com",
	"me.com",
	"mac.com",
	"protonmail.com",
	"proton.me",
	"fastmail.com",
	"zoho.com"
]);
/**
* Normalize an email address for comparison/deduplication
* - Lowercase the entire email
* - Remove dots from Gmail-like providers (they ignore dots)
* - Remove plus addressing (user+tag@domain  user@domain)
* - Normalize googlemail.com to gmail.com
*/
function normalizeEmail(email$2) {
	if (!email$2 || typeof email$2 !== "string") return email$2;
	const trimmed = email$2.trim().toLowerCase();
	const atIndex = trimmed.lastIndexOf("@");
	if (atIndex === -1) return trimmed;
	let localPart = trimmed.slice(0, atIndex);
	let domain$1 = trimmed.slice(atIndex + 1);
	if (domain$1 === "googlemail.com") domain$1 = "gmail.com";
	if (PLUS_ADDRESSING_DOMAINS.has(domain$1)) {
		const plusIndex = localPart.indexOf("+");
		if (plusIndex !== -1) localPart = localPart.slice(0, plusIndex);
	}
	if (GMAIL_LIKE_DOMAINS.has(domain$1)) localPart = localPart.replace(/\./g, "");
	return `${localPart}@${domain$1}`;
}
function createEmailValidator(options = {}) {
	const { apiKey = "", apiUrl = INFRA_API_URL, kvUrl = INFRA_KV_URL, defaultConfig = {} } = options;
	const $api = createFetch({
		baseURL: apiUrl,
		headers: { "x-api-key": apiKey }
	});
	const $kv = createFetch({
		baseURL: kvUrl,
		headers: { "x-api-key": apiKey }
	});
	/**
	* Fetch and resolve email validity policy from API with caching
	* Sends client config to API which merges with user's dashboard settings
	*/
	async function fetchPolicy() {
		try {
			const { data } = await $api("/security/resolve-policy", {
				method: "POST",
				body: {
					policyId: "email_validity",
					config: { emailValidation: {
						enabled: defaultConfig.enabled,
						strictness: defaultConfig.strictness,
						action: defaultConfig.action
					} }
				}
			});
			if (data?.policy) return data.policy;
		} catch (error$47) {
			logger.warn("[Dash] Failed to fetch email policy, using defaults:", error$47);
		}
		return null;
	}
	return { async validate(email$2, checkMx = true) {
		const policy = await fetchPolicy();
		if (!policy?.enabled) return {
			valid: true,
			disposable: false,
			confidence: "high",
			policy
		};
		try {
			const { data } = await $kv("/email/validate", {
				method: "POST",
				body: {
					email: email$2,
					checkMx,
					strictness: policy.strictness
				}
			});
			return {
				...data || {
					valid: false,
					reason: "invalid_format"
				},
				policy
			};
		} catch (error$47) {
			logger.warn("[Dash] Email validation API error, falling back to allow:", error$47);
			return {
				valid: true,
				policy
			};
		}
	} };
}
/**
* Basic local email format validation (fallback)
*/
function isValidEmailFormatLocal(email$2) {
	if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email$2)) return false;
	if (email$2.length > 254) return false;
	const [localPart, domain$1] = email$2.split("@");
	if (!localPart || !domain$1) return false;
	if (localPart.length > 64) return false;
	if (domain$1.length > 253) return false;
	return true;
}
const getEmail = (ctx) => ({
	email: ctx.body?.email ?? ctx.query?.email,
	container: ctx.body ? "body" : "query"
});
/**
* Create email normalization hook (shared between all configurations)
*/
function createEmailNormalizationHook() {
	return {
		matcher: allEmailSignIn,
		handler: createAuthMiddleware(async (ctx) => {
			const { email: email$2, container } = getEmail(ctx);
			if (typeof email$2 !== "string") return;
			const normalizedEmail = normalizeEmail(email$2);
			if (normalizedEmail !== email$2) {
				const user = await ctx.context.adapter.findOne({
					model: "user",
					where: [{
						field: "normalizedEmail",
						value: normalizedEmail
					}]
				});
				if (!user) return;
				return container === "query" ? { context: {
					...ctx,
					query: {
						...ctx.query,
						email: user.email,
						normalizedEmail
					}
				} } : { context: {
					...ctx,
					body: {
						...ctx.body,
						email: user.email,
						normalizedEmail
					}
				} };
			}
		})
	};
}
/**
* Create email validation hook with configurable validation strategy
*/
function createEmailValidationHook(validator, onDisposableEmail) {
	return {
		matcher: allEmail,
		handler: createAuthMiddleware(async (ctx) => {
			const email$2 = ctx.path === "/change-email" ? ctx.body?.newEmail : getEmail(ctx).email;
			if (typeof email$2 !== "string") return;
			if (!isValidEmailFormatLocal(email$2)) throw new APIError$1("BAD_REQUEST", { message: "Invalid email" });
			if (validator) {
				const result = await validator.validate(email$2);
				const policy = result.policy;
				if (!policy?.enabled) return;
				const action = policy.action;
				if (!result.valid) {
					if ((result.disposable || result.reason === "no_mx_records" || result.reason === "blocklist") && onDisposableEmail) {
						const ip = ctx.request?.headers?.get("x-forwarded-for")?.split(",")[0] || ctx.request?.headers?.get("cf-connecting-ip") || void 0;
						onDisposableEmail({
							email: email$2,
							reason: result.reason || "disposable",
							confidence: result.confidence,
							ip,
							path: ctx.path,
							action
						});
					}
					if (action === "allow") return;
					throw new APIError$1("BAD_REQUEST", { message: result.reason === "no_mx_records" ? "This email domain cannot receive emails" : result.disposable || result.reason === "blocklist" ? "Disposable email addresses are not allowed" : result.reason === "fake_domain" || result.reason === "fake_pattern" ? "This email address appears to be invalid" : "Invalid email" });
				}
			}
		})
	};
}
/**
* Create email validation hooks with optional API-backed validation
*
* @param options - Configuration options
* @param options.enabled - Enable email validation (default: true)
* @param options.useApi - Use API-backed validation (requires apiKey)
* @param options.apiKey - API key for remote validation
* @param options.apiUrl - API URL for policy fetching (defaults to INFRA_API_URL)
* @param options.kvUrl - KV URL for email validation (defaults to INFRA_KV_URL)
* @param options.strictness - Default strictness level: 'low', 'medium' (default), or 'high'
* @param options.action - Default action when invalid: 'allow', 'block' (default), or 'challenge'
*
* @example
* // Local validation only
* createEmailHooks()
*
* @example
* // API-backed validation
* createEmailHooks({ useApi: true, apiKey: "your-api-key" })
*
* @example
* // API-backed validation with high strictness default
* createEmailHooks({ useApi: true, apiKey: "your-api-key", strictness: "high" })
*/
function createEmailHooks(options = {}) {
	const { useApi = false, apiKey = "", apiUrl = INFRA_API_URL, kvUrl = INFRA_KV_URL, defaultConfig, onDisposableEmail } = options;
	const emailConfig = {
		enabled: true,
		strictness: "medium",
		action: "block",
		...defaultConfig
	};
	if (!emailConfig.enabled) return { before: [] };
	return { before: [createEmailValidationHook(useApi ? createEmailValidator({
		apiUrl,
		kvUrl,
		apiKey,
		defaultConfig: emailConfig
	}) : void 0, onDisposableEmail), createEmailNormalizationHook()] };
}
/**
* Default email hooks using local validation only
* For API-backed validation, use createEmailHooks({ useApi: true, apiKey: "..." })
*/
const emailHooks = createEmailHooks();

//#endregion
//#region src/validation/phone.ts
/**
* Common fake/test phone numbers that should be blocked
* These are numbers commonly used in testing, movies, documentation, etc.
*/
const INVALID_PHONE_NUMBERS = new Set([
	"+15550000000",
	"+15550001111",
	"+15550001234",
	"+15551234567",
	"+15555555555",
	"+15551111111",
	"+15550000001",
	"+15550123456",
	"+12125551234",
	"+13105551234",
	"+14155551234",
	"+12025551234",
	"+10000000000",
	"+11111111111",
	"+12222222222",
	"+13333333333",
	"+14444444444",
	"+15555555555",
	"+16666666666",
	"+17777777777",
	"+18888888888",
	"+19999999999",
	"+11234567890",
	"+10123456789",
	"+19876543210",
	"+441632960000",
	"+447700900000",
	"+447700900001",
	"+447700900123",
	"+447700900999",
	"+442079460000",
	"+442079460123",
	"+441134960000",
	"+0000000000",
	"+1000000000",
	"+123456789",
	"+1234567890",
	"+12345678901",
	"+0123456789",
	"+9876543210",
	"+11111111111",
	"+99999999999",
	"+491234567890",
	"+491111111111",
	"+33123456789",
	"+33111111111",
	"+61123456789",
	"+61111111111",
	"+81123456789",
	"+81111111111",
	"+19001234567",
	"+19761234567",
	"+1911",
	"+1411",
	"+1611",
	"+44999",
	"+44112"
]);
/**
* Patterns that indicate fake/test phone numbers
*/
const INVALID_PHONE_PATTERNS = [
	/^\+\d(\d)\1{6,}$/,
	/^\+\d*1234567890/,
	/^\+\d*0123456789/,
	/^\+\d*9876543210/,
	/^\+\d*0987654321/,
	/^\+\d*(12){4,}/,
	/^\+\d*(21){4,}/,
	/^\+\d*(00){4,}/,
	/^\+1\d{3}555\d{4}$/,
	/^\+\d{1,3}\d{1,5}$/,
	/^\+\d+0{7,}$/,
	/^\+\d*147258369/,
	/^\+\d*258369147/,
	/^\+\d*369258147/,
	/^\+\d*789456123/,
	/^\+\d*123456789/,
	/^\+\d*1234512345/,
	/^\+\d*1111122222/,
	/^\+\d*1212121212/,
	/^\+\d*1010101010/
];
/**
* Invalid area codes / prefixes that indicate test numbers
* Key: country code, Value: set of invalid prefixes
*/
const INVALID_PREFIXES_BY_COUNTRY = {
	US: new Set([
		"555",
		"000",
		"111",
		"911",
		"411",
		"611"
	]),
	CA: new Set([
		"555",
		"000",
		"911"
	]),
	GB: new Set([
		"7700900",
		"1632960",
		"1134960"
	]),
	AU: new Set([
		"0491570",
		"0491571",
		"0491572"
	])
};
/**
* Check if a phone number is a commonly used fake/test number
* @param phone - The phone number to check (E.164 format preferred)
* @param defaultCountry - Default country code if not included in phone string
* @returns true if the phone appears to be fake/test, false if it seems legitimate
*/
const isFakePhoneNumber = (phone, defaultCountry) => {
	const parsed = parsePhoneNumberFromString(phone, defaultCountry);
	if (!parsed) return true;
	const e164$2 = parsed.number;
	const nationalNumber = parsed.nationalNumber;
	const country = parsed.country;
	if (INVALID_PHONE_NUMBERS.has(e164$2)) return true;
	for (const pattern of INVALID_PHONE_PATTERNS) if (pattern.test(e164$2)) return true;
	if (country && INVALID_PREFIXES_BY_COUNTRY[country]) {
		const prefixes = INVALID_PREFIXES_BY_COUNTRY[country];
		for (const prefix of prefixes) if (nationalNumber.startsWith(prefix)) return true;
	}
	if (/^(\d)\1+$/.test(nationalNumber)) return true;
	const digits = nationalNumber.split("").map(Number);
	let isSequential = digits.length >= 6;
	for (let i = 1; i < digits.length && isSequential; i++) {
		const current = digits[i];
		const previous = digits[i - 1];
		if (current === void 0 || previous === void 0 || current !== previous + 1 && current !== previous - 1) isSequential = false;
	}
	if (isSequential) return true;
	return false;
};
/**
* Validate a phone number format
* @param phone - The phone number to validate
* @param defaultCountry - Default country code if not included in phone string
* @returns true if the phone number is valid
*/
const isValidPhone = (phone, defaultCountry) => {
	return isValidPhoneNumber(phone, defaultCountry);
};
/**
* Comprehensive phone number validation
* @param phone - The phone number to validate
* @param options - Validation options
* @returns true if valid, false otherwise
*/
const validatePhone = (phone, options = {}) => {
	const { mobileOnly = false, allowedCountries, blockedCountries, blockFakeNumbers = true, blockPremiumRate = true, blockTollFree = false, blockVoip = false, defaultCountry } = options;
	if (!isValidPhone(phone, defaultCountry)) return false;
	const parsed = parsePhoneNumberFromString(phone, defaultCountry);
	if (!parsed) return false;
	if (blockFakeNumbers && isFakePhoneNumber(phone, defaultCountry)) return false;
	const country = parsed.country;
	if (country) {
		if (allowedCountries && !allowedCountries.includes(country)) return false;
		if (blockedCountries?.includes(country)) return false;
	}
	const phoneType = parsed.getType();
	if (mobileOnly) {
		if (phoneType !== "MOBILE" && phoneType !== "FIXED_LINE_OR_MOBILE") return false;
	}
	if (blockPremiumRate && phoneType === "PREMIUM_RATE") return false;
	if (blockTollFree && phoneType === "TOLL_FREE") return false;
	if (blockVoip && phoneType === "VOIP") return false;
	return true;
};
const allPhonePaths = new Set([
	"/phone-number/send-otp",
	"/phone-number/verify",
	"/sign-in/phone-number",
	"/phone-number/request-password-reset",
	"/phone-number/reset-password"
]);
const getPhoneNumber = (ctx) => ctx.body?.phoneNumber ?? ctx.query?.phoneNumber;
/**
* Better Auth plugin for phone number validation
* Validates phone numbers on all phone-related endpoints
*/
const phoneValidationHooks = { before: [{
	matcher: (context) => !!context.path && allPhonePaths.has(context.path),
	handler: createAuthMiddleware(async (ctx) => {
		const phoneNumber = getPhoneNumber(ctx);
		if (typeof phoneNumber !== "string") return;
		if (!validatePhone(phoneNumber)) throw new APIError$1("BAD_REQUEST", { message: "Invalid phone number" });
	})
}] };

//#endregion
//#region src/routes/config.ts
function estimateEntropy(str) {
	const unique = new Set(str).size;
	if (unique === 0) return 0;
	return Math.log2(Math.pow(unique, str.length));
}
const getConfig = (options) => {
	return createAuthEndpoint("/dash/config", {
		method: "GET",
		use: [jwtMiddleware(options)]
	}, async (ctx) => {
		const advancedOptions = ctx.context.options.advanced;
		return {
			socialProviders: Object.keys(ctx.context.options.socialProviders || {}),
			emailAndPassword: ctx.context.options.emailAndPassword,
			plugins: ctx.context.options.plugins?.map((plugin) => {
				return {
					id: plugin.id,
					schema: plugin.schema,
					options: plugin.options
				};
			}),
			organization: {
				sendInvitationEmailEnabled: !!ctx.context.options.plugins?.find((plugin) => plugin.id === "organization")?.options?.sendInvitationEmail,
				additionalFields: (() => {
					const orgAdditionalFields = (ctx.context.options.plugins?.find((plugin) => plugin.id === "organization"))?.options?.schema?.organization?.additionalFields || {};
					return Object.keys(orgAdditionalFields).map((field) => {
						const fieldType = orgAdditionalFields[field];
						return {
							name: field,
							type: fieldType?.type,
							required: fieldType?.required,
							input: fieldType?.input,
							unique: fieldType?.unique,
							hasDefaultValue: !!fieldType?.defaultValue,
							references: fieldType?.references,
							returned: fieldType?.returned,
							bigInt: fieldType?.bigint
						};
					});
				})()
			},
			user: {
				fields: Object.keys(ctx.context.options.user?.fields || {}).map((field) => {
					const fieldType = (ctx.context.options.user?.fields)?.[field];
					return {
						name: field,
						type: fieldType?.type,
						required: fieldType?.required,
						input: fieldType?.input,
						unique: fieldType?.unique,
						hasDefaultValue: !!fieldType?.defaultValue,
						references: fieldType?.references,
						returned: fieldType?.returned,
						bigInt: fieldType?.bigint
					};
				}),
				additionalFields: Object.keys(ctx.context.options.user?.additionalFields || {}).map((field) => {
					const fieldType = (ctx.context.options.user?.additionalFields)?.[field];
					return {
						name: field,
						type: fieldType?.type,
						required: fieldType?.required,
						input: fieldType?.input,
						unique: fieldType?.unique,
						hasDefaultValue: !!fieldType?.defaultValue,
						references: fieldType?.references,
						returned: fieldType?.returned,
						bigInt: fieldType?.bigint
					};
				}),
				deleteUserEnabled: !!ctx.context.options.user?.deleteUser?.enabled,
				modelName: ctx.context.options.user?.modelName
			},
			baseURL: ctx.context.options.baseURL,
			basePath: ctx.context.options.basePath || "/api/auth",
			emailVerification: { sendVerificationEmailEnabled: !!ctx.context.options.emailVerification?.sendVerificationEmail },
			insights: {
				hasDatabase: !!ctx.context.options.database,
				cookies: advancedOptions?.cookies ? Object.entries(advancedOptions.cookies).map(([key, value]) => ({
					key,
					name: value?.name,
					sameSite: value?.attributes?.sameSite
				})) : null,
				hasIpAddressHeaders: !!(advancedOptions?.ipAddress?.ipAddressHeaders && advancedOptions.ipAddress.ipAddressHeaders.length > 0),
				ipAddressHeaders: advancedOptions?.ipAddress?.ipAddressHeaders || null,
				disableIpTracking: advancedOptions?.ipAddress?.disableIpTracking || false,
				disableCSRFCheck: ctx.context.options.advanced?.disableCSRFCheck || false,
				disableOriginCheck: ctx.context.options.advanced?.disableOriginCheck || false,
				allowDifferentEmails: ctx.context.options.account?.accountLinking?.enabled && ctx.context.options.account?.accountLinking?.allowDifferentEmails || false,
				skipStateCookieCheck: ctx.context.options.account?.skipStateCookieCheck || false,
				storeStateCookieStrategy: ctx.context.options.account?.storeStateStrategy || null,
				cookieCache: {
					enabled: ctx.context.options.session?.cookieCache?.enabled || false,
					strategy: ctx.context.options.session?.cookieCache?.enabled && ctx.context.options.session?.cookieCache?.strategy || null,
					refreshCache: ctx.context.options.session?.cookieCache?.enabled && typeof ctx.context.options.session?.cookieCache?.refreshCache !== "undefined" ? ctx.context.options.session.cookieCache.refreshCache !== false : null
				},
				sessionFreshAge: ctx.context.options.session?.freshAge || null,
				disableVerificationCleanup: ctx.context.options.verification?.disableCleanup || false,
				minPasswordLength: ctx.context.options.emailAndPassword?.enabled && ctx.context.options.emailAndPassword?.minPasswordLength || null,
				maxPasswordLength: ctx.context.options.emailAndPassword?.enabled && ctx.context.options.emailAndPassword?.maxPasswordLength || null,
				hasRateLimitDisabled: ctx.context.options.rateLimit?.enabled === false,
				rateLimitStorage: ctx.context.options.rateLimit?.enabled !== false && !ctx.context.options.rateLimit?.customStorage && ctx.context.options.rateLimit?.storage || null,
				storeSessionInDatabase: ctx.context.options.session?.storeSessionInDatabase === true,
				preserveSessionInDatabase: ctx.context.options.session?.preserveSessionInDatabase === true,
				secretEntropy: ctx.context.secret === "better-auth-secret-12345678901234567890" || ctx.context.secret.length < 32 ? 0 : estimateEntropy(ctx.context.secret),
				useSecureCookies: typeof ctx.context.options.advanced?.useSecureCookies !== "undefined" ? ctx.context.options.advanced.useSecureCookies : null,
				crossSubDomainCookiesEnabled: ctx.context.options.advanced?.crossSubDomainCookies?.enabled || false,
				crossSubDomainCookiesDomain: ctx.context.options.advanced?.crossSubDomainCookies?.domain,
				defaultCookieAttributes: ctx.context.options.advanced?.defaultCookieAttributes ? {
					sameSite: ctx.context.options.advanced?.defaultCookieAttributes?.sameSite || null,
					httpOnly: typeof ctx.context.options.advanced?.defaultCookieAttributes?.httpOnly !== "undefined" ? ctx.context.options.advanced?.defaultCookieAttributes?.httpOnly : null,
					prefix: ctx.context.options.advanced?.defaultCookieAttributes?.prefix || null,
					partitioned: typeof ctx.context.options.advanced?.defaultCookieAttributes?.partitioned !== "undefined" ? ctx.context.options.advanced?.defaultCookieAttributes?.partitioned : null,
					secure: typeof ctx.context.options.advanced?.defaultCookieAttributes?.secure !== "undefined" ? ctx.context.options.advanced?.defaultCookieAttributes?.secure : null
				} : null,
				appName: ctx.context.options.appName || null,
				hasJoinsEnabled: ctx.context.options.experimental?.joins === true
			}
		};
	});
};

//#endregion
//#region src/identification.ts
/**
* Identification Service
*
* Fetches identification data from the durable-kv service
* when a request includes an X-Request-Id header.
*/
const identificationCache = /* @__PURE__ */ new Map();
const CACHE_TTL_MS = 6e4;
const CACHE_MAX_SIZE = 1e3;
let lastCleanup = Date.now();
function cleanupCache() {
	const now = Date.now();
	for (const [key, value] of identificationCache.entries()) if (now - value.timestamp > CACHE_TTL_MS) identificationCache.delete(key);
	lastCleanup = now;
}
function maybeCleanup() {
	if (Date.now() - lastCleanup > CACHE_TTL_MS || identificationCache.size > CACHE_MAX_SIZE) cleanupCache();
}
/**
* Fetch identification data from durable-kv by requestId
*/
async function getIdentification(requestId, apiKey, kvUrl) {
	maybeCleanup();
	const cached$1 = identificationCache.get(requestId);
	if (cached$1 && Date.now() - cached$1.timestamp < CACHE_TTL_MS) return cached$1.data;
	const baseUrl = kvUrl || INFRA_KV_URL;
	const maxRetries = 3;
	const retryDelays = [
		50,
		100,
		200
	];
	for (let attempt = 0; attempt <= maxRetries; attempt++) try {
		const response = await fetch(`${baseUrl}/identify/${requestId}`, {
			method: "GET",
			headers: { "x-api-key": apiKey }
		});
		if (response.ok) {
			const data = await response.json();
			identificationCache.set(requestId, {
				data,
				timestamp: Date.now()
			});
			return data;
		}
		if (response.status === 404 && attempt < maxRetries) {
			await new Promise((resolve) => setTimeout(resolve, retryDelays[attempt]));
			continue;
		}
		if (response.status !== 404) identificationCache.set(requestId, {
			data: null,
			timestamp: Date.now()
		});
		return null;
	} catch (error$47) {
		if (attempt === maxRetries) {
			logger.error("[Dash] Failed to fetch identification:", error$47);
			return null;
		}
		await new Promise((resolve) => setTimeout(resolve, retryDelays[attempt] || 50));
	}
	return null;
}
/**
* Extract identification headers from a request
*/
function extractIdentificationHeaders(request) {
	if (!request) return {
		visitorId: null,
		requestId: null
	};
	return {
		visitorId: request.headers.get("X-Visitor-Id"),
		requestId: request.headers.get("X-Request-Id")
	};
}
/**
* Check if identification indicates a bot
*/
function isBot(identification) {
	if (!identification) return false;
	return identification.bot === "detected";
}
/**
* Check if identification indicates an anonymizer service (VPN, proxy, Tor, relay, or hosting)
*/
function isAnonymous(identification) {
	if (!identification) return false;
	return identification.isAnonymous;
}
/**
* Get the visitor's location
*/
function getLocation(identification) {
	if (!identification) return null;
	return identification.location;
}
/**
* Get the visitor's country code
*/
function getCountryCode(identification) {
	return identification?.location?.country?.code || null;
}
/**
* Create an identification service bound to options
*/
function createIdentificationService(options) {
	return {
		async getIdentification(requestId) {
			return getIdentification(requestId, options.apiKey, options.kvUrl);
		},
		extractIdentificationHeaders,
		isBot,
		isAnonymous,
		getLocation,
		getCountryCode
	};
}

//#endregion
//#region src/security.ts
/**
* Security Client
*
* Thin client that forwards security checks to the Infra API
*/
async function hashForFingerprint(input) {
	const data = new TextEncoder().encode(input);
	const hashBuffer = await crypto.subtle.digest("SHA-256", data);
	return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function sha1Hash(input) {
	const data = new TextEncoder().encode(input);
	const hashBuffer = await crypto.subtle.digest("SHA-1", data);
	return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("").toUpperCase();
}
function createSecurityClient(apiUrl, apiKey, options, onSecurityEvent) {
	const resolvedApiUrl = apiUrl || INFRA_API_URL;
	const $api = createFetch({
		baseURL: resolvedApiUrl,
		headers: { "x-api-key": apiKey }
	});
	const emailSender = createEmailSender({
		apiUrl: resolvedApiUrl,
		apiKey
	});
	function logEvent(event) {
		const fullEvent = {
			...event,
			timestamp: Date.now()
		};
		if (onSecurityEvent) onSecurityEvent(fullEvent);
	}
	return {
		async checkSecurity(request) {
			try {
				const { data } = await $api("/security/check", {
					method: "POST",
					body: {
						...request,
						config: options
					}
				});
				if (data && data.action !== "allow") logEvent({
					type: this.mapReasonToEventType(data.reason),
					userId: null,
					visitorId: request.visitorId,
					ip: request.ip,
					country: null,
					details: data.details || { reason: data.reason },
					action: data.action === "block" ? "blocked" : "challenged"
				});
				return data || { action: "allow" };
			} catch (error$47) {
				logger.error("[Dash] Security check failed:", error$47);
				return { action: "allow" };
			}
		},
		mapReasonToEventType(reason) {
			switch (reason) {
				case "geo_blocked": return "geo_blocked";
				case "bot_detected": return "bot_blocked";
				case "suspicious_ip_detected": return "suspicious_ip_detected";
				case "rate_limited": return "velocity_exceeded";
				case "credential_stuffing_cooldown": return "credential_stuffing";
				default: return "credential_stuffing";
			}
		},
		async trackFailedAttempt(identifier, visitorId, password, ip) {
			try {
				const { data } = await $api("/security/track-failed-login", {
					method: "POST",
					body: {
						identifier,
						visitorId,
						passwordHash: await hashForFingerprint(password),
						ip,
						config: options
					}
				});
				if (data?.blocked || data?.challenged) logEvent({
					type: "credential_stuffing",
					userId: null,
					visitorId,
					ip,
					country: null,
					details: data.details || { reason: data.reason },
					action: data.blocked ? "blocked" : "challenged"
				});
				return data || { blocked: false };
			} catch (error$47) {
				logger.error("[Dash] Track failed attempt error:", error$47);
				return { blocked: false };
			}
		},
		async clearFailedAttempts(identifier) {
			try {
				await $api("/security/clear-failed-attempts", {
					method: "POST",
					body: { identifier }
				});
			} catch (error$47) {
				logger.error("[Dash] Clear failed attempts error:", error$47);
			}
		},
		async isBlocked(visitorId) {
			try {
				const { data } = await $api(`/security/is-blocked?visitorId=${encodeURIComponent(visitorId)}`, { method: "GET" });
				return data?.blocked ?? false;
			} catch {
				return false;
			}
		},
		async verifyPoWSolution(visitorId, solution) {
			try {
				const { data } = await $api("/security/pow/verify", {
					method: "POST",
					body: {
						visitorId,
						solution
					}
				});
				return data || {
					valid: false,
					reason: "unknown"
				};
			} catch {
				return {
					valid: false,
					reason: "error"
				};
			}
		},
		async generateChallenge(visitorId) {
			try {
				const { data } = await $api("/security/pow/generate", {
					method: "POST",
					body: {
						visitorId,
						difficulty: options.challengeDifficulty
					}
				});
				return data?.challenge || "";
			} catch {
				return "";
			}
		},
		async checkImpossibleTravel(userId, currentLocation, visitorId) {
			if (!options.impossibleTravel?.enabled || !currentLocation) return null;
			try {
				const { data } = await $api("/security/impossible-travel", {
					method: "POST",
					body: {
						userId,
						visitorId,
						location: currentLocation,
						config: options
					}
				});
				if (data?.isImpossible) {
					const actionTaken = data.action === "block" ? "blocked" : data.action === "challenge" ? "challenged" : "logged";
					logEvent({
						type: "impossible_travel",
						userId,
						visitorId: visitorId || null,
						ip: null,
						country: currentLocation.country?.code || null,
						details: {
							from: data.from,
							to: data.to,
							distance: data.distance,
							speedRequired: data.speedRequired,
							action: data.action
						},
						action: actionTaken
					});
				}
				return data || null;
			} catch {
				return null;
			}
		},
		async storeLastLocation(userId, location) {
			if (!location) return;
			try {
				await $api("/security/store-last-login", {
					method: "POST",
					body: {
						userId,
						location
					}
				});
			} catch (error$47) {
				logger.error("[Dash] Store last location error:", error$47);
			}
		},
		async checkFreeTrialAbuse(visitorId) {
			if (!options.freeTrialAbuse?.enabled) return {
				isAbuse: false,
				accountCount: 0,
				maxAccounts: 0,
				action: "log"
			};
			try {
				const { data } = await $api("/security/free-trial-abuse/check", {
					method: "POST",
					body: {
						visitorId,
						config: options
					}
				});
				if (data?.isAbuse) logEvent({
					type: "free_trial_abuse",
					userId: null,
					visitorId,
					ip: null,
					country: null,
					details: {
						accountCount: data.accountCount,
						maxAccounts: data.maxAccounts
					},
					action: data.action === "block" ? "blocked" : "logged"
				});
				return data || {
					isAbuse: false,
					accountCount: 0,
					maxAccounts: 0,
					action: "log"
				};
			} catch {
				return {
					isAbuse: false,
					accountCount: 0,
					maxAccounts: 0,
					action: "log"
				};
			}
		},
		async trackFreeTrialSignup(visitorId, userId) {
			if (!options.freeTrialAbuse?.enabled) return;
			try {
				await $api("/security/free-trial-abuse/track", {
					method: "POST",
					body: {
						visitorId,
						userId
					}
				});
			} catch (error$47) {
				logger.error("[Dash] Track free trial signup error:", error$47);
			}
		},
		async checkCompromisedPassword(password) {
			try {
				const hash$1 = await sha1Hash(password);
				const prefix = hash$1.substring(0, 5);
				const suffix = hash$1.substring(5);
				const { data } = await $api("/security/breached-passwords", {
					method: "POST",
					body: {
						passwordPrefix: prefix,
						config: options
					}
				});
				if (!data?.enabled) return { compromised: false };
				const breachCount = (data.suffixes || {})[suffix] || 0;
				const minBreachCount = data.minBreachCount ?? 1;
				const action = data.action || "block";
				const compromised = breachCount >= minBreachCount;
				if (compromised) logEvent({
					type: "compromised_password",
					userId: null,
					visitorId: null,
					ip: null,
					country: null,
					details: { breachCount },
					action: action === "block" ? "blocked" : action === "challenge" ? "challenged" : "logged"
				});
				return {
					compromised,
					breachCount: breachCount > 0 ? breachCount : void 0,
					action: compromised ? action : void 0
				};
			} catch (error$47) {
				logger.error("[Dash] Compromised password check error:", error$47);
				return { compromised: false };
			}
		},
		async checkStaleUser(userId, lastActiveAt) {
			if (!options.staleUsers?.enabled) return { isStale: false };
			try {
				const { data } = await $api("/security/stale-user", {
					method: "POST",
					body: {
						userId,
						lastActiveAt: lastActiveAt instanceof Date ? lastActiveAt.toISOString() : lastActiveAt,
						config: options
					}
				});
				if (data?.isStale) logEvent({
					type: "stale_account_reactivation",
					userId,
					visitorId: null,
					ip: null,
					country: null,
					details: {
						daysSinceLastActive: data.daysSinceLastActive,
						staleDays: data.staleDays,
						lastActiveAt: data.lastActiveAt,
						notifyUser: data.notifyUser,
						notifyAdmin: data.notifyAdmin
					},
					action: data.action === "block" ? "blocked" : data.action === "challenge" ? "challenged" : "logged"
				});
				return data || { isStale: false };
			} catch (error$47) {
				logger.error("[Dash] Stale user check error:", error$47);
				return { isStale: false };
			}
		},
		async notifyStaleAccountUser(userEmail, userName, daysSinceLastActive, identification, appName) {
			const loginTime = (/* @__PURE__ */ new Date()).toLocaleString("en-US", {
				dateStyle: "long",
				timeStyle: "short",
				timeZone: "UTC"
			}) + " UTC";
			const location = identification?.location;
			const loginLocation = location?.city && location?.country?.name ? `${location.city}, ${location.country.code}` : location?.country?.name || "Unknown";
			const browser = identification?.browser;
			const loginDevice = browser?.name && browser?.os ? `${browser.name} on ${browser.os}` : "Unknown device";
			const result = await emailSender.send({
				template: "stale-account-user",
				to: userEmail,
				variables: {
					userEmail,
					userName: userName || "User",
					appName: appName || "Your App",
					daysSinceLastActive: String(daysSinceLastActive),
					loginTime,
					loginLocation,
					loginDevice,
					loginIp: identification?.ip || "Unknown"
				}
			});
			if (result.success) logger.info(`[Dash] Stale account notification sent to user: ${userEmail}`);
			else logger.error(`[Dash] Failed to send stale account user notification: ${result.error}`);
		},
		async notifyStaleAccountAdmin(adminEmail, userId, userEmail, userName, daysSinceLastActive, identification, appName) {
			const loginTime = (/* @__PURE__ */ new Date()).toLocaleString("en-US", {
				dateStyle: "long",
				timeStyle: "short",
				timeZone: "UTC"
			}) + " UTC";
			const location = identification?.location;
			const loginLocation = location?.city && location?.country?.name ? `${location.city}, ${location.country.code}` : location?.country?.name || "Unknown";
			const browser = identification?.browser;
			const loginDevice = browser?.name && browser?.os ? `${browser.name} on ${browser.os}` : "Unknown device";
			const result = await emailSender.send({
				template: "stale-account-admin",
				to: adminEmail,
				variables: {
					userEmail,
					userName: userName || "User",
					userId,
					appName: appName || "Your App",
					daysSinceLastActive: String(daysSinceLastActive),
					loginTime,
					loginLocation,
					loginDevice,
					loginIp: identification?.ip || "Unknown",
					adminEmail
				}
			});
			if (result.success) logger.info(`[Dash] Stale account admin notification sent to: ${adminEmail}`);
			else logger.error(`[Dash] Failed to send stale account admin notification: ${result.error}`);
		},
		async checkUnknownDevice(_userId, _visitorId) {
			return false;
		},
		async notifyUnknownDevice(userId, email$2, identification) {
			logEvent({
				type: "unknown_device",
				userId,
				visitorId: identification?.visitorId || null,
				ip: identification?.ip || null,
				country: identification?.location?.country?.code || null,
				details: {
					email: email$2,
					device: identification?.browser.device,
					os: identification?.browser.os,
					browser: identification?.browser.name,
					city: identification?.location?.city,
					country: identification?.location?.country?.name
				},
				action: "logged"
			});
		}
	};
}

//#endregion
//#region src/security-hooks.ts
/**
* Security Hooks
*
* Consolidated security check logic for the dash plugin.
* This module extracts the repetitive security check patterns into reusable functions.
*/
const ERROR_MESSAGES = {
	geo_blocked: "Access from your location is not allowed.",
	bot_detected: "Automated access is not allowed.",
	suspicious_ip_detected: "Anonymous connections (VPN, proxy, Tor) are not allowed.",
	rate_limited: "Too many attempts. Please try again later.",
	compromised_password: "This password has been found in data breaches. Please choose a different password.",
	impossible_travel: "Login blocked due to suspicious location change."
};
const DISPLAY_NAMES = {
	geo_blocked: {
		challenge: "Security: geo challenge",
		block: "Security: geo blocked"
	},
	bot_detected: {
		challenge: "Security: bot challenge",
		block: "Security: bot blocked"
	},
	suspicious_ip_detected: {
		challenge: "Security: anonymous IP challenge",
		block: "Security: anonymous IP blocked"
	},
	rate_limited: {
		challenge: "Security: velocity challenge",
		block: "Security: velocity exceeded"
	},
	compromised_password: {
		challenge: "Security: breached password warning",
		block: "Security: breached password blocked"
	},
	impossible_travel: {
		challenge: "Security: impossible travel challenge",
		block: "Security: impossible travel blocked"
	}
};
/**
* Throw a challenge error with appropriate headers
*/
function throwChallengeError(challenge, reason, message = "Please complete a security check to continue.") {
	const error$47 = new APIError("LOCKED", {
		message,
		code: "POW_CHALLENGE_REQUIRED"
	});
	error$47.headers = {
		"X-PoW-Challenge": challenge,
		"X-PoW-Reason": reason
	};
	throw error$47;
}
/**
* Build common event data for security tracking
*/
function buildEventData(ctx, action, reason, confidence = 1, extraData) {
	const { visitorId, identification, path, identifier, userAgent } = ctx;
	const countryCode = identification?.location?.country?.code || void 0;
	return {
		eventKey: visitorId || identification?.ip || "unknown",
		eventType: action === "challenged" ? "security_challenged" : "security_blocked",
		eventDisplayName: DISPLAY_NAMES[reason]?.[action === "challenged" ? "challenge" : "block"] || `Security: ${reason}`,
		eventData: {
			action,
			reason,
			visitorId: visitorId || "",
			path,
			userAgent,
			identifier,
			confidence,
			...extraData
		},
		ipAddress: identification?.ip || void 0,
		city: identification?.location?.city || void 0,
		country: identification?.location?.country?.name || void 0,
		countryCode
	};
}
/**
* Handle a security check result by tracking events and throwing appropriate errors
*
* @param verdict - The security verdict from the security service
* @param ctx - Security check context with request information
* @param trackEvent - Function to track security events
* @param securityService - Security service for generating challenges
* @returns True if the request should be blocked
*/
async function handleSecurityVerdict(verdict, ctx, trackEvent, securityService) {
	if (verdict.action === "allow") return;
	const reason = verdict.reason || "unknown";
	const confidence = 1;
	if (verdict.action === "challenge" && ctx.visitorId) {
		trackEvent(buildEventData(ctx, "challenged", reason, confidence, verdict.details));
		throwChallengeError(verdict.challenge || await securityService.generateChallenge(ctx.visitorId), reason, "Please complete a security check to continue.");
	} else if (verdict.action === "block") {
		trackEvent(buildEventData(ctx, "blocked", reason, confidence, verdict.details));
		throw new APIError("FORBIDDEN", { message: ERROR_MESSAGES[reason] || "Access denied." });
	}
}
/**
* Run all security checks using the consolidated checkSecurity API
*
* This replaces the multiple individual check calls with a single API call
* that handles all security checks server-side.
*/
async function runSecurityChecks(ctx, securityService, trackEvent, powVerified) {
	if (powVerified) return;
	await handleSecurityVerdict(await securityService.checkSecurity({
		visitorId: ctx.visitorId,
		requestId: ctx.identification?.requestId || null,
		ip: ctx.identification?.ip || null,
		path: ctx.path,
		identifier: ctx.identifier
	}), ctx, trackEvent, securityService);
}

//#endregion
//#region src/pow.ts
/** Default difficulty in bits (18 = ~500ms solve time) */
const DEFAULT_DIFFICULTY = 18;
/** Challenge TTL in seconds */
const CHALLENGE_TTL = 60;
/**
* SHA-256 hash function that works in both Node.js and browser
*/
async function sha256(message) {
	const msgBuffer = new TextEncoder().encode(message);
	const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
	return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
/**
* Check if a hash has the required number of leading zero bits
*/
function hasLeadingZeroBits(hash$1, bits) {
	const fullHexChars = Math.floor(bits / 4);
	const remainingBits = bits % 4;
	for (let i = 0; i < fullHexChars; i++) if (hash$1[i] !== "0") return false;
	if (remainingBits > 0 && fullHexChars < hash$1.length) {
		if (parseInt(hash$1[fullHexChars], 16) > (1 << 4 - remainingBits) - 1) return false;
	}
	return true;
}
/**
* Solve a PoW challenge (browser-compatible)
* This function is designed to run in a browser environment
*/
async function solvePoWChallenge(challenge) {
	const { nonce, difficulty } = challenge;
	let counter = 0;
	while (true) {
		if (hasLeadingZeroBits(await sha256(`${nonce}:${counter}`), difficulty)) return {
			nonce,
			counter
		};
		counter++;
		if (counter % 1e3 === 0) await new Promise((resolve) => setTimeout(resolve, 0));
	}
}
/**
* Decode a base64-encoded challenge string (browser-compatible)
*/
function decodePoWChallenge(encoded) {
	try {
		const decoded = typeof atob !== "undefined" ? atob(encoded) : Buffer.from(encoded, "base64").toString("utf-8");
		return JSON.parse(decoded);
	} catch {
		return null;
	}
}
/**
* Encode a solution string (browser-compatible)
*/
function encodePoWSolution(solution) {
	const json$1 = JSON.stringify(solution);
	return typeof btoa !== "undefined" ? btoa(json$1) : Buffer.from(json$1).toString("base64");
}
/**
* Verify a PoW solution locally (for testing purposes)
*/
async function verifyPoWSolution(nonce, counter, difficulty) {
	return hasLeadingZeroBits(await sha256(`${nonce}:${counter}`), difficulty);
}

//#endregion
//#region src/sms.ts
/**
* SMS sending module for @better-auth/infra
*
* This module provides SMS sending functionality for OTP verification codes
* with template support similar to emails.
*/
/**
* SMS template definitions with their required variables
*/
const SMS_TEMPLATES = {
	"phone-verification": { variables: {} },
	"two-factor": { variables: {} },
	"sign-in-otp": { variables: {} }
};
/**
* Create an SMS sender instance
*/
function createSMSSender(config$1) {
	const baseUrl = config$1?.apiUrl || process.env.BETTER_AUTH_API_URL || INFRA_API_URL;
	const apiUrl = baseUrl.endsWith("/api") ? baseUrl : `${baseUrl}/api`;
	const apiKey = config$1?.apiKey || process.env.BETTER_AUTH_API_KEY || "";
	if (!apiKey) logger.warn("[Dash] No API key provided for SMS sending. Set BETTER_AUTH_API_KEY environment variable or pass apiKey in config.");
	/**
	* Send an SMS with OTP code
	*/
	async function send(options) {
		if (!apiKey) return {
			success: false,
			error: "API key not configured"
		};
		try {
			const response = await fetch(`${apiUrl}/v1/sms/send`, {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
					Authorization: `Bearer ${apiKey}`
				},
				body: JSON.stringify({
					to: options.to,
					code: options.code,
					template: options.template
				})
			});
			if (!response.ok) return {
				success: false,
				error: (await response.json().catch(() => ({ message: "Unknown error" }))).message || `HTTP ${response.status}`
			};
			return {
				success: true,
				messageId: (await response.json()).messageId
			};
		} catch (error$47) {
			return {
				success: false,
				error: error$47 instanceof Error ? error$47.message : "Failed to send SMS"
			};
		}
	}
	return { send };
}
/**
* Send an SMS with OTP code via Better Auth Infra.
*
* @example
* ```ts
* import { sendSMS } from "@better-auth/infra";
*
* // For phone verification
* await sendSMS({
*   to: "+1234567890",
*   code: "123456",
*   template: "phone-verification",
* });
*
* // For two-factor authentication
* await sendSMS({
*   to: "+1234567890",
*   code: "123456",
*   template: "two-factor",
* });
*
* // Default (no template specified - uses generic message)
* await sendSMS({
*   to: "+1234567890",
*   code: "123456",
* });
* ```
*/
async function sendSMS(options, config$1) {
	return createSMSSender(config$1).send(options);
}

//#endregion
//#region src/index.ts
const infra = (options) => {
	const processedBulkOperationContexts = /* @__PURE__ */ new WeakSet();
	const activityUpdateInterval = options?.activityTracking?.updateInterval ?? 3e5;
	const opts = {
		apiUrl: options?.apiUrl || INFRA_API_URL,
		kvUrl: options?.kvUrl || INFRA_KV_URL,
		apiKey: options?.apiKey || process.env.BETTER_AUTH_API_KEY || "",
		activityTracking: { updateInterval: activityUpdateInterval },
		...options
	};
	const { tracker } = initTrackEvents(opts);
	const identificationService = createIdentificationService(opts);
	const getClientIpFromRequest = (request, ipAddressHeaders) => {
		if (!request) return void 0;
		const headers = ipAddressHeaders?.length ? ipAddressHeaders : [
			"cf-connecting-ip",
			"x-forwarded-for",
			"x-real-ip",
			"x-vercel-forwarded-for"
		];
		for (const headerName of headers) {
			const value = request.headers.get(headerName);
			if (!value) continue;
			const ip = value.split(",")[0]?.trim();
			if (ip) return ip;
		}
	};
	const getCountryCodeFromRequest = (request) => {
		if (!request) return void 0;
		const cc = request.headers.get("cf-ipcountry") ?? request.headers.get("x-vercel-ip-country");
		return cc ? cc.toUpperCase() : void 0;
	};
	const getLocationDataFromCtx = async (request, requestId, ctxIdentification, ipConfig) => {
		if (ipConfig?.disableIpTracking === true) return void 0;
		if (requestId) {
			const identification = ctxIdentification || await identificationService.getIdentification(requestId);
			if (identification) {
				const location = identificationService.getLocation(identification);
				return {
					ipAddress: identification.ip || void 0,
					city: location?.city || void 0,
					country: location?.country?.name || void 0,
					countryCode: location?.country?.code || void 0
				};
			}
		}
		const ipAddress = getClientIpFromRequest(request, ipConfig?.ipAddressHeaders || null);
		const countryCode = getCountryCodeFromRequest(request);
		if (ipAddress || countryCode) return {
			ipAddress,
			countryCode
		};
	};
	const onSecurityEvent = (event) => {
		tracker.trackEvent({
			eventKey: event.visitorId || event.userId || "unknown",
			eventType: `security_${event.type}`,
			eventDisplayName: `Security: ${event.type.replace(/_/g, " ")}`,
			eventData: {
				type: event.type,
				userId: event.userId || void 0,
				visitorId: event.visitorId || void 0,
				action: event.action,
				...event.details
			},
			ipAddress: event.ip || void 0,
			country: event.country || void 0
		});
	};
	const securityService = createSecurityClient(opts.apiUrl, opts.apiKey, opts.security || {}, onSecurityEvent);
	const emailHooks$1 = createEmailHooks({
		useApi: !!opts.apiKey,
		apiKey: opts.apiKey,
		apiUrl: opts.apiUrl,
		kvUrl: opts.kvUrl,
		defaultConfig: opts.security?.emailValidation,
		onDisposableEmail: (data) => {
			const isNoMxRecord = data.reason === "no_mx_records";
			const reason = isNoMxRecord ? "no_mx_records" : "disposable_email";
			const label = isNoMxRecord ? "No MX Records" : "Disposable Email";
			const actionLabel = data.action === "allow" ? "allowed" : "blocked";
			const actionVerb = data.action === "allow" ? "detected" : "blocked";
			const eventType = data.action === "allow" ? "security_allowed" : "security_blocked";
			const displayName = isNoMxRecord ? `Security: invalid email domain ${actionVerb}` : `Security: disposable email ${actionVerb}`;
			const description = isNoMxRecord ? `${actionVerb.charAt(0).toUpperCase() + actionVerb.slice(1)} signup attempt with invalid email domain (no MX records): ${data.email}` : `${actionVerb.charAt(0).toUpperCase() + actionVerb.slice(1)} signup attempt with disposable email: ${data.email} (${data.reason}, ${data.confidence} confidence)`;
			logger.info(`[Infra] Tracking ${reason} event for email: ${data.email} (action: ${actionLabel})`);
			tracker.trackEvent({
				eventKey: data.email,
				eventType,
				eventDisplayName: displayName,
				eventData: {
					action: actionLabel,
					reason,
					identifier: data.email,
					detectionLabel: label,
					description,
					path: data.path
				},
				ipAddress: data.ip
			});
		}
	});
	const { trackUserSignedUp, trackUserProfileUpdated, trackUserProfileImageUpdated, trackUserEmailVerified, trackUserBanned, trackUserUnBanned, trackUserDeleted } = initUserEvents(tracker);
	const { trackEmailVerificationSent, trackEmailSignInAttempt, trackUserSignedIn, trackUserSignedOut, trackSessionCreated, trackSocialSignInAttempt, trackSocialSignInRedirectionAttempt, trackUserImpersonated, trackUserImpersonationStop, trackSessionRevoked, trackSessionRevokedAll } = initSessionEvents(tracker);
	const { trackAccountLinking, trackAccountUnlink, trackAccountPasswordChange } = initAccountEvents(tracker);
	const { trackPasswordResetRequest, trackPasswordResetRequestCompletion } = initVerificationEvents(tracker);
	const { trackEvent } = tracker;
	const { trackOrganizationCreated, trackOrganizationUpdated } = initOrganizationEvents(tracker);
	const { trackOrganizationTeamCreated, trackOrganizationTeamUpdated, trackOrganizationTeamDeleted, trackOrganizationTeamMemberAdded, trackOrganizationTeamMemberRemoved } = initTeamEvents(tracker);
	const { trackOrganizationMemberAdded, trackOrganizationMemberRemoved, trackOrganizationMemberRoleUpdated } = initMemberEvents(tracker);
	const { trackOrganizationMemberInvited, trackOrganizationMemberInviteAccepted, trackOrganizationMemberInviteCanceled, trackOrganizationMemberInviteRejected } = initInvitationEvents(tracker);
	return {
		id: "infra",
		init(ctx) {
			const organizationPlugin = ctx.options.plugins?.find((p) => p.id === "organization");
			if (organizationPlugin) {
				const instrumentOrganizationHooks = (organizationPluginOptions) => {
					const organizationHooks = organizationPluginOptions.organizationHooks = organizationPluginOptions.organizationHooks ?? {};
					const afterCreateOrganization = organizationHooks.afterCreateOrganization;
					organizationHooks.afterCreateOrganization = async (...args) => {
						const [{ organization, user }] = args;
						trackOrganizationCreated(organization, getOrganizationTriggerInfo(user));
						if (afterCreateOrganization) return afterCreateOrganization(...args);
					};
					const afterUpdateOrganization = organizationHooks.afterUpdateOrganization;
					organizationHooks.afterUpdateOrganization = async (...args) => {
						const [{ organization, user }] = args;
						if (organization) trackOrganizationUpdated(organization, getOrganizationTriggerInfo(user));
						if (afterUpdateOrganization) return afterUpdateOrganization(...args);
					};
					const afterAddMember = organizationHooks.afterAddMember;
					organizationHooks.afterAddMember = async (...args) => {
						const [{ organization, member, user }] = args;
						trackOrganizationMemberAdded(organization, member, user, getOrganizationTriggerInfo(user));
						if (afterAddMember) return afterAddMember(...args);
					};
					const afterRemoveMember = organizationHooks.afterRemoveMember;
					organizationHooks.afterRemoveMember = async (...args) => {
						const [{ organization, member, user }] = args;
						trackOrganizationMemberRemoved(organization, member, user, getOrganizationTriggerInfo(user));
						if (afterRemoveMember) return afterRemoveMember(...args);
					};
					const afterUpdateMemberRole = organizationHooks.afterUpdateMemberRole;
					organizationHooks.afterUpdateMemberRole = async (...args) => {
						const [{ organization, member, user, previousRole }] = args;
						trackOrganizationMemberRoleUpdated(organization, member, user, previousRole, getOrganizationTriggerInfo(user));
						if (afterUpdateMemberRole) return afterUpdateMemberRole(...args);
					};
					const afterCreateInvitation = organizationHooks.afterCreateInvitation;
					organizationHooks.afterCreateInvitation = async (...args) => {
						const [{ organization, invitation, inviter }] = args;
						trackOrganizationMemberInvited(organization, invitation, inviter, getOrganizationTriggerInfo(inviter));
						if (afterCreateInvitation) return afterCreateInvitation(...args);
					};
					const afterAcceptInvitation = organizationHooks.afterAcceptInvitation;
					organizationHooks.afterAcceptInvitation = async (...args) => {
						const [{ organization, invitation, member, user }] = args;
						trackOrganizationMemberInviteAccepted(organization, invitation, member, user, getOrganizationTriggerInfo(user));
						if (afterAcceptInvitation) return afterAcceptInvitation(...args);
					};
					const afterRejectInvitation = organizationHooks.afterRejectInvitation;
					organizationHooks.afterRejectInvitation = async (...args) => {
						const [{ organization, invitation, user }] = args;
						trackOrganizationMemberInviteRejected(organization, invitation, user, getOrganizationTriggerInfo(user));
						if (afterRejectInvitation) return afterRejectInvitation(...args);
					};
					const afterCancelInvitation = organizationHooks.afterCancelInvitation;
					organizationHooks.afterCancelInvitation = async (...args) => {
						const [{ organization, invitation, cancelledBy }] = args;
						trackOrganizationMemberInviteCanceled(organization, invitation, cancelledBy, getOrganizationTriggerInfo(cancelledBy));
						if (afterCancelInvitation) return afterCancelInvitation(...args);
					};
					const afterCreateTeam = organizationHooks.afterCreateTeam;
					organizationHooks.afterCreateTeam = async (...args) => {
						const [{ organization, team, user }] = args;
						trackOrganizationTeamCreated(organization, team, getOrganizationTriggerInfo(user));
						if (afterCreateTeam) return afterCreateTeam(...args);
					};
					const afterUpdateTeam = organizationHooks.afterUpdateTeam;
					organizationHooks.afterUpdateTeam = async (...args) => {
						const [{ organization, team, user }] = args;
						if (team) trackOrganizationTeamUpdated(organization, team, getOrganizationTriggerInfo(user));
						if (afterUpdateTeam) return afterUpdateTeam(...args);
					};
					const afterDeleteTeam = organizationHooks.afterDeleteTeam;
					organizationHooks.afterDeleteTeam = async (...args) => {
						const [{ organization, team, user }] = args;
						trackOrganizationTeamDeleted(organization, team, getOrganizationTriggerInfo(user));
						if (afterDeleteTeam) return afterDeleteTeam(...args);
					};
					const afterAddTeamMember = organizationHooks.afterAddTeamMember;
					organizationHooks.afterAddTeamMember = async (...args) => {
						const [{ organization, team, user, teamMember }] = args;
						trackOrganizationTeamMemberAdded(organization, team, user, teamMember, getOrganizationTriggerInfo(user));
						if (afterAddTeamMember) return afterAddTeamMember(...args);
					};
					const afterRemoveTeamMember = organizationHooks.afterRemoveTeamMember;
					organizationHooks.afterRemoveTeamMember = async (...args) => {
						const [{ organization, team, user, teamMember }] = args;
						trackOrganizationTeamMemberRemoved(organization, team, user, teamMember, getOrganizationTriggerInfo(user));
						if (afterRemoveTeamMember) return afterRemoveTeamMember(...args);
					};
				};
				instrumentOrganizationHooks(organizationPlugin.options = organizationPlugin.options ?? {});
			} else logger.debug("Organization plugin not active. Skipping instrumentation");
			return { options: {
				databaseHooks: {
					user: {
						create: {
							async before(user, ctx$1) {
								if (!ctx$1) return;
								const { visitorId } = identificationService.extractIdentificationHeaders(ctx$1.request);
								if (visitorId && opts.security?.freeTrialAbuse?.enabled) {
									const abuseCheck = await securityService.checkFreeTrialAbuse(visitorId);
									if (abuseCheck.isAbuse && abuseCheck.action === "block") throw new APIError("FORBIDDEN", { message: "Account creation is not allowed from this device." });
								}
							},
							async after(user, ctx$1) {
								if (!ctx$1) return;
								const trigger = getTriggerInfo(ctx$1, user.id);
								const { requestId, visitorId } = identificationService.extractIdentificationHeaders(ctx$1.request);
								const ipConfig = ctx$1.context.options.advanced?.ipAddress;
								const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
								if (visitorId && opts.security?.freeTrialAbuse?.enabled) await securityService.trackFreeTrialSignup(visitorId, user.id);
								trackUserSignedUp(user, trigger, locationData);
							}
						},
						update: { async after(user, ctx$1) {
							if (!ctx$1) return;
							const path = ctx$1.path;
							const trigger = getTriggerInfo(ctx$1, user.id);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
							if (matchesAnyRoute(path, [routes.UPDATE_USER, routes.DASH_UPDATE_USER])) {
								const updatedFields = Object.keys(ctx$1.body || {});
								const isOnlyImageUpdate = updatedFields.length === 1 && updatedFields[0] === "image";
								const isOnlyEmailVerifiedUpdate = updatedFields.length === 1 && updatedFields[0] === "emailVerified";
								const hasEmailVerifiedUpdate = updatedFields.includes("emailVerified");
								if (isOnlyEmailVerifiedUpdate && user.emailVerified) trackUserEmailVerified(user, trigger, locationData);
								else if (isOnlyImageUpdate && user.image) trackUserProfileImageUpdated(user, trigger, locationData);
								else if (!isOnlyImageUpdate && !isOnlyEmailVerifiedUpdate) {
									trackUserProfileUpdated(user, trigger, ctx$1, locationData);
									if (hasEmailVerifiedUpdate && user.emailVerified) trackUserEmailVerified(user, trigger, locationData);
								}
							} else if (matchesAnyRoute(path, [routes.CHANGE_EMAIL])) trackUserProfileUpdated(user, trigger, ctx$1, locationData);
							if (matchesAnyRoute(path, [routes.VERIFY_EMAIL]) && user.emailVerified) trackUserEmailVerified(user, trigger, locationData);
							if (matchesAnyRoute(path, [routes.ADMIN_BAN_USER]) && "banned" in user && user.banned) trackUserBanned(user, trigger, locationData);
							if (matchesAnyRoute(path, [routes.ADMIN_UNBAN_USER]) && "banned" in user && !user.banned) trackUserUnBanned(user, trigger, locationData);
						} },
						delete: { async after(user, ctx$1) {
							if (!ctx$1) return;
							const trigger = getTriggerInfo(ctx$1, user.id);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							trackUserDeleted(user, trigger, await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig));
						} }
					},
					session: {
						create: {
							async before(session, ctx$1) {
								if (!ctx$1) return;
								const loginMethod = getLoginMethod(ctx$1);
								const { requestId, visitorId } = identificationService.extractIdentificationHeaders(ctx$1.request);
								let identification = null;
								if (requestId) identification = ctx$1.context.identification || await identificationService.getIdentification(requestId);
								await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification);
								if (session.userId && identification?.location && visitorId) {
									const travelCheck = await securityService.checkImpossibleTravel(session.userId, identification.location, visitorId);
									if (travelCheck?.isImpossible) {
										if (travelCheck.action === "block") throw new APIError("FORBIDDEN", { message: "Login blocked due to suspicious location change." });
										if (travelCheck.action === "challenge" && travelCheck.challenge) throwChallengeError(travelCheck.challenge, "impossible_travel", "Unusual login location detected. Please complete a security check.");
									}
								}
								return { data: { loginMethod } };
							},
							async after(session, ctx$1) {
								if (!ctx$1 || !session.userId) return;
								session.loginMethod;
								const { requestId, visitorId } = identificationService.extractIdentificationHeaders(ctx$1.request);
								let identification = null;
								if (requestId) identification = ctx$1.context.identification || await identificationService.getIdentification(requestId);
								const ipConfig = ctx$1.context.options.advanced?.ipAddress;
								const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
								const enrichedSession = {
									...session,
									ipAddress: locationData?.ipAddress,
									city: locationData?.city,
									country: locationData?.country,
									countryCode: locationData?.countryCode
								};
								let user = null;
								try {
									user = await ctx$1.context.adapter.findOne({
										model: "user",
										where: [{
											field: "id",
											value: session.userId
										}]
									});
								} catch {}
								if (visitorId) {
									if (await securityService.checkUnknownDevice(session.userId, visitorId) && user?.email) await securityService.notifyUnknownDevice(session.userId, user.email, identification);
								}
								if (opts.security?.staleUsers?.enabled && user) {
									const staleCheck = await securityService.checkStaleUser(session.userId, user.lastActiveAt || null);
									if (staleCheck.isStale) {
										const staleOpts = opts.security.staleUsers;
										const notificationPromises = [];
										if (staleCheck.notifyUser && user.email) notificationPromises.push(securityService.notifyStaleAccountUser(user.email, user.name || null, staleCheck.daysSinceLastActive || 0, identification));
										if (staleCheck.notifyAdmin && staleOpts.adminEmail) notificationPromises.push(securityService.notifyStaleAccountAdmin(staleOpts.adminEmail, session.userId, user.email || "unknown", user.name || null, staleCheck.daysSinceLastActive || 0, identification));
										if (notificationPromises.length > 0) Promise.all(notificationPromises).catch((error$47) => {
											logger.error("[Infra] Failed to send stale account notifications:", error$47);
										});
										trackEvent({
											eventKey: session.userId,
											eventType: "security_stale_account",
											eventDisplayName: "Security: stale account reactivated",
											eventData: {
												action: staleCheck.action === "block" ? "blocked" : staleCheck.action === "challenge" ? "challenged" : "logged",
												reason: "stale_account_reactivation",
												userId: session.userId,
												daysSinceLastActive: staleCheck.daysSinceLastActive,
												staleDays: staleCheck.staleDays,
												lastActiveAt: staleCheck.lastActiveAt,
												notifyUser: staleCheck.notifyUser,
												notifyAdmin: staleCheck.notifyAdmin,
												detectionLabel: "Stale Account Reactivation",
												description: `Dormant account (inactive for ${staleCheck.daysSinceLastActive} days) became active`
											},
											ipAddress: identification?.ip || void 0,
											city: identification?.location?.city || void 0,
											country: identification?.location?.country?.name || void 0,
											countryCode: identification?.location?.country?.code || void 0
										});
										if (staleCheck.action === "block") throw new APIError("FORBIDDEN", {
											message: "This account has been inactive for an extended period. Please contact support to reactivate.",
											code: "STALE_ACCOUNT"
										});
									}
								}
								if (identification?.location) await securityService.storeLastLocation(session.userId, identification.location);
								let trigger;
								if (matchesAnyRoute(ctx$1.path, [
									routes.SIGN_IN,
									routes.SIGN_UP,
									routes.SIGN_IN_SOCIAL_CALLBACK,
									routes.SIGN_IN_OAUTH_CALLBACK
								])) {
									trigger = getTriggerInfo(ctx$1, session.userId, enrichedSession);
									trackUserSignedIn(enrichedSession, trigger, ctx$1, locationData);
								} else trigger = getTriggerInfo(ctx$1, session.userId);
								trackSessionCreated(enrichedSession, trigger, ctx$1, locationData);
								if ("impersonatedBy" in session && session.impersonatedBy) {
									trigger = {
										...trigger,
										triggeredBy: session.impersonatedBy
									};
									trackUserImpersonated(enrichedSession, trigger, ctx$1, locationData);
								}
								if (opts.activityTracking?.enabled) try {
									await ctx$1.context.adapter.update({
										model: "user",
										where: [{
											field: "id",
											value: session.userId
										}],
										update: { lastActiveAt: /* @__PURE__ */ new Date() }
									});
								} catch {}
							}
						},
						delete: { async after(session, ctx$1) {
							if (!ctx$1) return;
							const path = ctx$1.path;
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
							const enrichedSession = {
								...session,
								ipAddress: locationData?.ipAddress,
								city: locationData?.city,
								country: locationData?.country,
								countryCode: locationData?.countryCode
							};
							const trigger = getTriggerInfo(ctx$1, session.userId);
							if (matchesAnyRoute(ctx$1.path, [
								routes.REVOKE_ALL_SESSIONS,
								routes.ADMIN_REVOKE_USER_SESSIONS,
								routes.DASH_REVOKE_SESSIONS_ALL,
								routes.DASH_DELETE_SESSIONS,
								routes.DASH_BAN_USER
							])) {
								if (!processedBulkOperationContexts.has(ctx$1)) {
									trackSessionRevokedAll(enrichedSession, trigger, ctx$1, locationData);
									processedBulkOperationContexts.add(ctx$1);
								}
							} else if (matchesAnyRoute(path, [routes.SIGN_OUT])) trackUserSignedOut(enrichedSession, trigger, ctx$1, locationData);
							else trackSessionRevoked(enrichedSession, trigger, ctx$1, locationData);
							if ("impersonatedBy" in session && session.impersonatedBy) trackUserImpersonationStop(enrichedSession, trigger, ctx$1, locationData);
						} }
					},
					account: {
						create: { async after(account, ctx$1) {
							if (!ctx$1 || !account.userId) return;
							const trigger = getTriggerInfo(ctx$1, account.userId);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							trackAccountLinking(account, trigger, ctx$1, await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig));
						} },
						update: { async after(account, ctx$1) {
							if (!ctx$1 || !account.userId) return;
							const path = ctx$1.path;
							const trigger = getTriggerInfo(ctx$1, account.userId);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
							if (matchesAnyRoute(path, [
								routes.CHANGE_PASSWORD,
								routes.SET_PASSWORD,
								routes.RESET_PASSWORD,
								routes.ADMIN_SET_PASSWORD
							])) trackAccountPasswordChange(account, trigger, ctx$1, locationData);
						} },
						delete: { async after(account, ctx$1) {
							if (!ctx$1 || !account.userId) return;
							const trigger = getTriggerInfo(ctx$1, account.userId);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							trackAccountUnlink(account, trigger, ctx$1, await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig));
						} }
					},
					verification: {
						create: { async after(verification, ctx$1) {
							if (!ctx$1) return;
							const path = ctx$1.path;
							const trigger = getTriggerInfo(ctx$1, ctx$1.context.session?.user.id ?? UNKNOWN_USER);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
							if (matchesAnyRoute(path, [routes.REQUEST_PASSWORD_RESET])) trackPasswordResetRequest(verification, trigger, ctx$1, locationData);
						} },
						delete: { async after(verification, ctx$1) {
							if (!ctx$1) return;
							const path = ctx$1.path;
							const trigger = getTriggerInfo(ctx$1, ctx$1.context.session?.user.id ?? UNKNOWN_USER);
							const { requestId } = identificationService.extractIdentificationHeaders(ctx$1.request);
							const ipConfig = ctx$1.context.options.advanced?.ipAddress;
							const locationData = await getLocationDataFromCtx(ctx$1.request, requestId, ctx$1.context.identification, ipConfig);
							if (matchesAnyRoute(path, [routes.RESET_PASSWORD])) trackPasswordResetRequestCompletion(verification, trigger, ctx$1, locationData);
						} }
					}
				},
				session: { storeSessionInDatabase: ctx.options.session?.storeSessionInDatabase ?? true }
			} };
		},
		hooks: {
			before: [
				{
					matcher: (ctx) => ctx.request?.method !== "GET",
					handler: createAuthMiddleware(async (ctx) => {
						const { visitorId } = identificationService.extractIdentificationHeaders(ctx.request);
						const powSolution = ctx.headers?.get?.("X-PoW-Solution");
						if (visitorId && powSolution) {
							if ((await securityService.verifyPoWSolution(visitorId, powSolution)).valid) ctx.context.powVerified = true;
						}
					})
				},
				...emailHooks$1.before,
				...phoneValidationHooks.before,
				{
					matcher: (ctx) => ctx.request?.method !== "GET",
					handler: createAuthMiddleware(async (ctx) => {
						const { requestId, visitorId } = identificationService.extractIdentificationHeaders(ctx.request);
						const isSignIn = matchesAnyRoute(ctx.path, [
							routes.SIGN_IN_EMAIL,
							routes.SIGN_IN_USERNAME,
							routes.SIGN_IN_EMAIL_OTP,
							routes.SIGN_IN_SOCIAL,
							routes.SIGN_IN_PASSKEY,
							routes.SIGN_IN_MAGIC_LINK,
							routes.SIGN_IN_SSO,
							routes.SIGN_IN_ANONYMOUS
						]);
						const isSignUp = matchesAnyRoute(ctx.path, [routes.SIGN_UP_EMAIL]);
						const isPasswordReset = matchesAnyRoute(ctx.path, [routes.FORGET_PASSWORD, routes.REQUEST_PASSWORD_RESET]);
						const isTwoFactor = matchesAnyRoute(ctx.path, [
							routes.TWO_FACTOR_VERIFY_TOTP,
							routes.TWO_FACTOR_VERIFY_BACKUP,
							routes.TWO_FACTOR_VERIFY_OTP
						]);
						const isOtpSend = matchesAnyRoute(ctx.path, [routes.EMAIL_OTP_SEND, routes.PHONE_SEND_OTP]);
						const isMagicLinkVerify = matchesAnyRoute(ctx.path, [routes.MAGIC_LINK_VERIFY]);
						const isOrgCreate = matchesAnyRoute(ctx.path, [routes.ORG_CREATE]);
						const isSensitiveAction = matchesAnyRoute(ctx.path, [
							routes.CHANGE_EMAIL,
							routes.CHANGE_PASSWORD,
							routes.SET_PASSWORD,
							routes.LINK_SOCIAL,
							routes.PASSKEY_ADD
						]);
						if (!(isSignIn || isSignUp || isPasswordReset || isTwoFactor || isOtpSend || isMagicLinkVerify || isOrgCreate || isSensitiveAction)) return;
						const requestBody = ctx.body;
						const identifier = requestBody?.email || requestBody?.phone || requestBody?.username || void 0;
						let identification = null;
						if (requestId) {
							identification = await identificationService.getIdentification(requestId);
							if (identification) ctx.context.identification = identification;
						}
						const powVerified = ctx.context.powVerified === true;
						if (visitorId && powVerified) trackEvent({
							eventKey: visitorId,
							eventType: "security_allowed",
							eventDisplayName: "Security: challenge completed",
							eventData: {
								action: "allowed",
								reason: "pow_verified",
								visitorId,
								path: ctx.path,
								userAgent: ctx.headers?.get?.("user-agent") || "",
								identifier,
								detectionLabel: "Challenge Completed",
								description: identifier ? `Successfully completed security challenge for "${identifier}"` : "Successfully completed security challenge"
							},
							ipAddress: identification?.ip || void 0,
							city: identification?.location?.city || void 0,
							country: identification?.location?.country?.name || void 0,
							countryCode: identification?.location?.country?.code || void 0
						});
						if (visitorId) {
							if (await securityService.isBlocked(visitorId)) {
								trackEvent({
									eventKey: visitorId,
									eventType: "security_blocked",
									eventDisplayName: "Security: credential stuffing blocked",
									eventData: {
										action: "blocked",
										reason: "credential_stuffing",
										visitorId,
										path: ctx.path,
										userAgent: ctx.headers?.get?.("user-agent") || "",
										identifier,
										detectionType: "cooldown_active",
										detectionLabel: "Credential Stuffing",
										description: identifier ? `Visitor attempting "${identifier}" still in cooldown from prior detection` : "Visitor still in cooldown from prior detection",
										confidence: 1
									},
									ipAddress: identification?.ip || void 0,
									city: identification?.location?.city || void 0,
									country: identification?.location?.country?.name || void 0,
									countryCode: identification?.location?.country?.code || void 0
								});
								throw new APIError(403, { message: "Too many failed attempts. Please try again later." });
							}
						}
						await runSecurityChecks({
							path: ctx.path,
							identifier,
							visitorId,
							identification,
							userAgent: ctx.headers?.get?.("user-agent") || ""
						}, securityService, trackEvent, powVerified);
						if (matchesAnyRoute(ctx.path, [
							routes.SIGN_UP_EMAIL,
							routes.CHANGE_PASSWORD,
							routes.SET_PASSWORD,
							routes.RESET_PASSWORD
						])) {
							const body = ctx.body;
							const passwordToCheck = body?.newPassword || body?.password;
							if (passwordToCheck) {
								const compromisedResult = await securityService.checkCompromisedPassword(passwordToCheck);
								if (compromisedResult.compromised && compromisedResult.action) {
									const action = compromisedResult.action;
									trackEvent({
										eventKey: visitorId || identifier || "unknown",
										eventType: action === "block" ? "security_blocked" : "security_challenged",
										eventDisplayName: action === "block" ? "Security: breached password blocked" : "Security: breached password warning",
										eventData: {
											action: action === "block" ? "blocked" : "challenged",
											reason: "compromised_password",
											visitorId: visitorId || "",
											path: ctx.path,
											userAgent: ctx.headers?.get?.("user-agent") || "",
											identifier,
											breachCount: compromisedResult.breachCount,
											detectionLabel: "Breached Password",
											description: `Password has been seen in ${compromisedResult.breachCount?.toLocaleString() || "multiple"} data breaches`
										},
										ipAddress: identification?.ip || void 0,
										city: identification?.location?.city || void 0,
										country: identification?.location?.country?.name || void 0,
										countryCode: identification?.location?.country?.code || void 0
									});
									if (action === "block") throw new APIError("BAD_REQUEST", {
										message: "This password has been found in data breaches. Please choose a different password.",
										code: "COMPROMISED_PASSWORD"
									});
								}
							}
						}
					})
				}
			],
			after: [{
				matcher: (ctx) => ctx.request?.method !== "GET",
				handler: createAuthMiddleware(async (ctx) => {
					const trigger = getTriggerInfo(ctx, ctx.context.session?.user.id ?? UNKNOWN_USER);
					const { visitorId } = identificationService.extractIdentificationHeaders(ctx.request);
					const identification = ctx.context.identification;
					if (matchesAnyRoute(ctx.path, [routes.SEND_VERIFICATION_EMAIL]) && ctx.context.session && !(ctx.context.returned instanceof Error)) trackEmailVerificationSent(ctx.context.session.session, ctx.context.session.user, trigger, ctx);
					const body = ctx.body;
					if (matchesAnyRoute(ctx.path, [routes.SIGN_IN_EMAIL, routes.SIGN_IN_EMAIL_OTP]) && ctx.context.returned instanceof Error && body?.email) {
						trackEmailSignInAttempt(ctx, trigger);
						if (visitorId && body?.password) {
							const stuffingResult = await securityService.trackFailedAttempt(body.email, visitorId, body.password, identification?.ip || null);
							const details = stuffingResult.details;
							const descriptions = {
								unique_passwords: `Tried ${details?.uniquePasswords || details?.attemptCount} different passwords on account "${details?.identifier}"`,
								same_password_many_accounts: `Same password attempted across ${details?.targetedAccounts} different accounts`,
								ip_targeting: `IP targeting ${details?.targetedAccounts} different accounts`,
								distributed_attack: `${details?.relatedIps?.length || 0} IPs targeting "${details?.identifier}" with ${details?.attemptCount} attempts`
							};
							if (stuffingResult.challenged && stuffingResult.challenge && details) trackEvent({
								eventKey: visitorId,
								eventType: "security_challenged",
								eventDisplayName: "Security: credential stuffing challenge",
								eventData: {
									action: "challenged",
									reason: "credential_stuffing",
									visitorId,
									path: ctx.path,
									userAgent: ctx.headers?.get?.("user-agent") || "",
									identifier: details.identifier,
									detectionType: stuffingResult.reason,
									detectionLabel: "Credential Stuffing",
									description: descriptions[stuffingResult.reason || "unique_passwords"],
									attemptCount: details.attemptCount,
									windowSeconds: details.windowSeconds,
									attemptsPerMinute: Math.round((details.attemptsPerMinute || 0) * 100) / 100,
									uniquePasswords: details.uniquePasswords,
									targetedAccounts: details.targetedAccounts,
									relatedIps: details.relatedIps
								},
								ipAddress: identification?.ip || void 0,
								city: identification?.location?.city || void 0,
								country: identification?.location?.country?.name || void 0,
								countryCode: identification?.location?.country?.code || void 0
							});
							if (stuffingResult.blocked && details) trackEvent({
								eventKey: visitorId,
								eventType: "security_blocked",
								eventDisplayName: "Security: credential stuffing blocked",
								eventData: {
									action: "blocked",
									reason: "credential_stuffing",
									visitorId,
									path: ctx.path,
									userAgent: ctx.headers?.get?.("user-agent") || "",
									identifier: details.identifier,
									detectionType: stuffingResult.reason,
									detectionLabel: "Credential Stuffing",
									description: descriptions[stuffingResult.reason || "unique_passwords"],
									attemptCount: details.attemptCount,
									windowSeconds: details.windowSeconds,
									attemptsPerMinute: Math.round((details.attemptsPerMinute || 0) * 100) / 100,
									uniquePasswords: details.uniquePasswords,
									targetedAccounts: details.targetedAccounts,
									relatedIps: details.relatedIps
								},
								ipAddress: identification?.ip || void 0,
								city: identification?.location?.city || void 0,
								country: identification?.location?.country?.name || void 0,
								countryCode: identification?.location?.country?.code || void 0
							});
						}
					}
					if (matchesAnyRoute(ctx.path, [routes.SIGN_IN_EMAIL, routes.SIGN_IN_EMAIL_OTP]) && !(ctx.context.returned instanceof Error) && body?.email) await securityService.clearFailedAttempts(body.email);
					if (matchesAnyRoute(ctx.path, [routes.SIGN_IN_SOCIAL]) && ctx.context.returned instanceof Error && ctx.body.provider && ctx.body.idToken) trackSocialSignInAttempt(ctx, trigger);
					if (matchesAnyRoute(ctx.path, [routes.SIGN_IN_SOCIAL_CALLBACK]) && ctx.context.returned instanceof Error) trackSocialSignInRedirectionAttempt(ctx, trigger);
				})
			}, {
				handler: createAuthMiddleware(async (ctx) => {
					if (!opts.activityTracking?.enabled) return;
					if (activityUpdateInterval === 0) return;
					const session = ctx.context.session || ctx.context.newSession;
					if (!session?.user?.id) return;
					const userId = session.user.id;
					const now = Date.now();
					const lastUpdate = session.user.lastActiveAt;
					if (lastUpdate) {
						if (now - new Date(lastUpdate).getTime() < activityUpdateInterval) return;
					}
					ctx.context.adapter.update({
						model: "user",
						where: [{
							field: "id",
							value: userId
						}],
						update: { lastActiveAt: /* @__PURE__ */ new Date() }
					});
				}),
				matcher: (ctx) => ctx.request?.method !== "GET"
			}]
		},
		endpoints: {
			getDashConfig: getConfig(opts),
			getDashUsers: getUsers(opts),
			getOnlineUsersCount: getOnlineUsersCount(opts),
			createDashUser: createUser(opts),
			deleteDashUser: deleteUser(opts),
			listDashOrganizations: listOrganizations(opts),
			getDashOrganization: getOrganization(opts),
			listDashOrganizationMembers: listOrganizationMembers(opts),
			listDashOrganizationInvitations: listOrganizationInvitations(opts),
			listDashOrganizationTeams: listOrganizationTeams(opts),
			listDashOrganizationSsoProviders: listOrganizationSsoProviders(opts),
			createDashSsoProvider: createSsoProvider(opts),
			updateDashSsoProvider: updateSsoProvider(opts),
			requestDashSsoVerificationToken: requestSsoVerificationToken(opts),
			verifyDashSsoProviderDomain: verifySsoProviderDomain(opts),
			deleteDashSsoProvider: deleteSsoProvider(opts),
			markDashSsoProviderDomainVerified: markSsoProviderDomainVerified(opts),
			listDashTeamMembers: listTeamMembers(opts),
			createDashOrganization: createOrganization(opts),
			deleteDashOrganization: deleteOrganization(opts),
			getDashOrganizationOptions: getOrganizationOptions(opts),
			deleteDashSessions: deleteSessions(opts),
			getDashUser: getUserDetails(opts),
			getDashUserOrganizations: getUserOrganizations(opts),
			updateDashUser: updateUser(opts),
			setDashPassword: setPassword(opts),
			unlinkDashAccount: unlinkAccount(opts),
			listAllDashSessions: listAllSessions(opts),
			dashRevokeSession: revokeSession(opts),
			dashRevokeAllSessions: revokeAllSessions(opts),
			dashImpersonateUser: impersonateUser(opts),
			updateDashOrganization: updateOrganization(opts),
			createDashTeam: createTeam(opts),
			updateDashTeam: updateTeam(opts),
			deleteDashTeam: deleteTeam(opts),
			addDashTeamMember: addTeamMember(opts),
			removeDashTeamMember: removeTeamMember(opts),
			addDashMember: addMember(opts),
			removeDashMember: removeMember(opts),
			updateDashMemberRole: updateMemberRole(opts),
			inviteDashMember: inviteMember(opts),
			cancelDashInvitation: cancelInvitation(opts),
			resendDashInvitation: resendInvitation(opts),
			dashCheckUserByEmail: checkUserByEmail(opts),
			dashGetUserStats: getUserStats(opts),
			dashGetUserGraphData: getUserGraphData(opts),
			dashGetUserRetentionData: getUserRetentionData(opts),
			dashGetUserMapData: getUserMapData(opts),
			dashBanUser: banUser(opts),
			dashUnbanUser: unbanUser(opts),
			dashSendVerificationEmail: sendVerificationEmail(opts),
			dashSendResetPasswordEmail: sendResetPasswordEmail(opts),
			dashEnableTwoFactor: enableTwoFactor(opts),
			dashViewTwoFactorTotpUri: viewTwoFactorTotpUri(opts),
			dashViewBackupCodes: viewBackupCodes(opts),
			dashDisableTwoFactor: disableTwoFactor(opts),
			dashGenerateBackupCodes: generateBackupCodes(opts),
			getUserEvents: getUserEvents(opts),
			getEventTypes: getEventTypes(opts),
			dashAcceptInvitation: acceptInvitation(opts),
			dashCompleteInvitation: completeInvitation(opts),
			dashCheckUserExists: checkUserExists(opts),
			listDashOrganizationLogDrains: listOrganizationLogDrains(opts),
			createDashOrganizationLogDrain: createOrganizationLogDrain(opts),
			updateDashOrganizationLogDrain: updateOrganizationLogDrain(opts),
			deleteDashOrganizationLogDrain: deleteOrganizationLogDrain(opts),
			testDashOrganizationLogDrain: testOrganizationLogDrain(opts),
			listDashOrganizationDirectories: listOrganizationDirectories(opts),
			createDashOrganizationDirectory: createOrganizationDirectory(opts),
			deleteDashOrganizationDirectory: deleteOrganizationDirectory(opts),
			regenerateDashDirectoryToken: regenerateDirectoryToken(opts),
			getDashDirectoryDetails: getDirectoryDetails(opts),
			dashExecuteAdapter: executeAdapter(opts)
		},
		schema: { ...opts.activityTracking?.enabled ? { user: { fields: { lastActiveAt: { type: "date" } } } } : {} }
	};
};

//#endregion
export { CHALLENGE_TTL, DEFAULT_DIFFICULTY, EMAIL_TEMPLATES, SMS_TEMPLATES, USER_EVENT_TYPES, createEmailSender, createSMSSender, decodePoWChallenge, encodePoWSolution, infra, sendEmail, sendSMS, solvePoWChallenge, verifyPoWSolution };